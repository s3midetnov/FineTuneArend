index = 78

the query:{
  "Context": [
    "a^n=c : pow {R} a n = c",
    "R : CRing",
    "n : Nat",
    "a : E {P {\\this}}",
    "y : R.E",
    "c : R.E"
  ],
  "Expected type": "Cover {SpecPres R} (a R.* R.negative y R.+ a R.* (y R.+ pow {R} a n)) {\\Sigma (x : R.E)\n  (\\Sigma (p : Cover1 {SpecPres R} x a) (Inv {LocRing {R} (powers {R} x)} (func {Func {a} {x} p} (in~ {SType {R} (powers {R} a)}\n    {\\lam (a1 : SType {R} (powers {R} a)) (b : SType {R} (powers {R} a)) => a1.1 R.* b.2 = b.1 R.* a1.2}\n    (y, c, inP {\\Sigma (n : Nat) (pow {R} a n = c)} (n, a^n=c)))) || Inv {LocRing {R} (powers {R} x)} (func {Func {a} {x} p} (in~ {SType {R} (powers {R} a)}\n    {\\lam (a1 : SType {R} (powers {R} a)) (b : SType {R} (powers {R} a)) => a1.1 R.* b.2 = b.1 R.* a1.2}\n    (y, c, inP {\\Sigma (n : Nat) (pow {R} a n = c)} (n, a^n=c))) + ide)))}\n  (\\lam (t : \\Sigma (x : R.E)\n    (\\Sigma (p : Cover1 {SpecPres R} x a) (Inv {LocRing {R} (powers {R} x)} (func {Func {a} {x} p} (in~ {SType {R} (powers {R} a)}\n      {\\lam (a1 : SType {R} (powers {R} a)) (b : SType {R} (powers {R} a)) => a1.1 R.* b.2 = b.1 R.* a1.2}\n      (y, c, inP {\\Sigma (n : Nat) (pow {R} a n = c)} (n, a^n=c)))) || Inv {LocRing {R} (powers {R} x)} (func {Func {a} {x} p} (in~ {SType {R} (powers {R} a)}\n      {\\lam (a1 : SType {R} (powers {R} a)) (b : SType {R} (powers {R} a)) => a1.1 R.* b.2 = b.1 R.* a1.2}\n      (y, c, inP {\\Sigma (n : Nat) (pow {R} a n = c)} (n, a^n=c))) + ide)))) => t.1)",
  "Expression": "cover-trans (cover-basic $ indexing-make $ just (a * negative y, a * (y + pow a n))) (later (\\lam p0 => (\\case \\elim p0 \\with {\n  | true => cover-inj (_, (cover-proj1 idp () idp, byLeft $ transportInv Inv (functorial-lem-div (\\new LDiv {\n    | inv => negative y\n    | inv-right => idp\n  }) n a^n=c) $ lmake (inl~ (negative $ pow a (suc n), a * negative y, later $ inP (1, ide-left))) $ equals1 $ later $ rewrite pow_*-comm equation))\n    idp\n  | false => cover-inj (_, (cover-proj1 idp () idp, byRight $ transportInv (\\lam x => Inv (x + 1)) (functorial-lem-div (\\new LDiv {\n    | inv => y + pow a n\n    | inv-right => idp\n  }) n a^n=c) $ lmake (inl~ (pow a (suc n), a * (y + pow a n), later $ inP (1, ide-left))) $ equals1 $ later $ rewrite pow_*-comm equation))\n    idp\n})))",
  "Premises": [
    "true",
    "| \\infixl 6 + E E : E",
    "\\data Maybe \\Type \n  | nothing\n  | just A",
    "\\infixl 6 :+ (_ _ : RingTerm C V)",
    "\\instance LocRing \\hlevels  {R : CRing} (S : SubMonoid R) : CRing (Type {R} {S}) {\n  | zro => in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.zro, R.ide, S.contains_ide)\n  | + => ++ {R} {S}\n  | * => ** {R} {S}\n  | negative => neg {R} {S}\n  | ide => in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.ide, R.ide, S.contains_ide)\n  | natCoef => \\lam (n : Nat) => in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2}\n    (R.natCoef n, R.ide, S.contains_ide)\n} => \\new CRing {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | negative-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n  | *-comm => {?hidden}\n}",
    "just A",
    "\\lemma functorial-lem-div \\hlevels  {R : CRing} {a b : R.E} (d : LDiv {R} a b) {r : contains b} {x : SType {R} (powers {R} a)} (m : Nat)\n  (_ : pow {R} a m = x.2) : func {(functorial {R} {a} {b} r).1} (in~ {SType {R} (powers {R} a)}\n  {\\lam (a1 : SType {R} (powers {R} a)) (b : SType {R} (powers {R} a)) => a1.1 R.* b.2 = b.1 R.* a1.2} x) = in~ {SType {R} (powers {R} b)}\n  {\\lam (a : SType {R} (powers {R} b)) (b : SType {R} (powers {R} b)) => a.1 R.* b.2 = b.1 R.* a.2}\n  (x.1 R.* pow {R} d.inv m, pow {R} b m, inP {\\Sigma (n : Nat) (pow {R} b n = pow {R} b m)} (m, idp {R.E} {pow {R} b m})) ",
    "| \\infixl 7 * E E : E",
    "\\data Cover \\hlevels  {P : FramePres} P.E {J : \\Set} (J -> P.E) : \\Prop \n  | cover-basic (P.BasicCover {J} x g)\n  | cover-inj (j : J) (g j = x)\n  | cover-trans {I : \\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\Pi (i : I) -> Cover {P} (f i) {J} g)\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\n  | cover-idemp (j : J) (g j = P.conj x x)\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\Pi (j : J) -> g j = P.conj a (f j))",
    "cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)",
    "\\func SpecPres \\hlevels  (R : CRing) : FramePres R.E {\n  | conj => (R.*)\n  | BasicCover => Indexing {Maybe (\\Sigma R.E R.E)} {R.E} (\\lam (p0 : Maybe (\\Sigma R.E R.E)) => (\\case p0 \\with {\n    | just (a, b) => (Bool, a R.+ b, \\lam (p0 : Bool) => if {R.E} p0 a b)\n    | nothing => (Empty, R.zro, absurd {R.E})\n  }))\n} => \\new FramePres",
    "| negative E : E",
    "| E : \\Set",
    "\\func if {A : \\Type} (_ : Bool) (_ _ : A) : A \n  | {A}, true, then, else => then\n  | {A}, false, then, else => else",
    "\\lemma indexing-make \\hlevels  {I X : \\Set} {h : I -> \\Sigma (J : \\Set) X (J -> X)} (i : I) : Indexing {I} {X} h {(h i).1} (h i).2 (h i).3 ",
    "| contains (E {S}) : \\Prop",
    "in~ A",
    "| len : Nat",
    "| conj E E : E",
    "\\lemma terms-equality \\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ",
    "| ide-left {x : E} : ide * x = x",
    "| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)",
    "\\func normalize \\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\n  (map {\\Sigma (List (Fin (len {vars}))) Int} {\\Sigma (List (Fin (len {vars}))) Int}\n    (\\lam (p : \\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))",
    "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)",
    "| contains_ide : contains (ide {S})",
    "\\func powers \\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\lam (x : E {S {\\this}}) => TruncP (\\Sigma (n : Nat) (pow {M} a n = x))) \n=> \\new SubMonoid {\n  | contains_ide => {?hidden}\n  | contains_* => {?hidden}\n}",
    ":negative (RingTerm C V)",
    "| vars : Array (E {M})",
    "\\lemma toZero \\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ",
    "\\data \\infixr 2 || (_ _ : \\Type) : \\Prop \n  | byLeft A\n  | byRight B",
    "| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)",
    "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'",
    "\\data Int \\plevels  \\hlevels  \n  | pos Nat\n  | neg Nat  {\n    | 0 => pos 0\n  }",
    "| func (E {Dom}) : E {Cod}",
    "\\func inl~ \\hlevels  {R : CRing} {S : SubMonoid R} (x : SType {R} S) : Type {R} {S} \n  => in~ {SType {R} S} {\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} x",
    "| C : Semiring",
    "suc Nat",
    "\\data Bool \\plevels  \\hlevels  \n  | false\n  | true",
    "\\lemma lmake \\hlevels  {M : CMonoid} {x : M.E} (y : M.E) (_ : y M.* x = M.ide) : Inv {M} x y ",
    "coef C",
    "nil",
    "inP A",
    "\\func Cover1 \\hlevels  {P : FramePres} (x y : P.E) : \\Prop => Cover {P} x {\\Sigma} (\\lam (_ : \\Sigma) => y)",
    "cover-trans {I : \\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\Pi (i : I) -> Cover {P} (f i) {J} g)",
    "\\class Inv \\extends LInv, RInv \\hlevels ",
    "\\class LDiv \\extends DivBase \\hlevels  {\n  | inv-right : val * inv = elem\n}",
    "cover-basic (P.BasicCover {J} x g)",
    "\\lemma cover_ideal \\hlevels  {R : CRing} {x : R.E} {J : \\Set} {g : J -> R.E} (_ : Cover {SpecPres R} x {J} g) : contains x ",
    "\\data Quotient {A : \\Type} (A -> A -> \\Type) : \\Set \n  | in~ A\n  | ~-equiv (x y : A) (R x y) I",
    "false",
    "\\data Empty \\plevels  \\hlevels  ",
    "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y",
    ":ide",
    "\\lemma equals1 \\hlevels  {R : CRing} {S : SubMonoid R} {a b : SType {R} S} (_ : a.1 R.* b.2 = b.1 R.* a.2) : inl~ {R} {S} a = inl~ {R} {S} b ",
    "\\lemma gensZeroToIdealZero \\hlevels  {R : CRing} (gensCoeffs : List (\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\n  (map {\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\Sigma R.E R.E} (\\lam (x : \\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\n    gensCoeffs) = R.zro ",
    ":zro",
    "\\func interpretRingNF \\hlevels  {this3 : BaseData} (_ : List (\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \n  | {this}, nil => zro {R}\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l",
    "\\lemma pow_*-comm \\hlevels  {this : CMonoid} {a b : E} {n : Nat} : pow (a * b) n = pow a n * pow b n ",
    "\\func SType \\hlevels  {R : CRing} (S : SubMonoid R) : \\Set => \\Sigma (_ y : R.E) (S.contains y)",
    "\\class CRingData \\extends CAlgData, RingData \\hlevels ",
    "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p",
    "\\func functor (R : CRing) : Functor (op {framePresSite (SpecPres R)}) CRingBicat (\\lam (a : Ob {C {\\this}}) => LocRing {R} (powers {R} a)) {\n  | Func => \\lam {X Y : Ob {C {\\this}}} (c : Hom {C {\\this}} X Y) =>\n    (functorial {R} {X} {Y} (cover_ideal {R} {Y} {\\Sigma} {\\lam (_ : \\Sigma) => X} c)).1\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}",
    "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)",
    "byLeft A",
    "\\lemma functorial {R : CRing} {a b : R.E} (_ : contains b) :\n\\level (\\Sigma (f : RingHom (LocRing {R} (powers {R} a)) (LocRing {R} (powers {R} b)))\n  (f \u2218 locMap {R} {powers {R} a} = locMap {R} {powers {R} b})) (\\lam (p : \\Sigma (f : RingHom (LocRing {R} (powers {R} a)) (LocRing {R} (powers {R} b)))\n    (f \u2218 locMap {R} {powers {R} a} = locMap {R} {powers {R} b}))\n    (q : \\Sigma (f : RingHom (LocRing {R} (powers {R} a)) (LocRing {R} (powers {R} b)))\n      (f \u2218 locMap {R} {powers {R} a} = locMap {R} {powers {R} b})) => path (\\lam (i : I) => (\n    \\have arg => locMap-epi {R} {powers {R} a} {LocRing {R} (powers {R} b)} {p.1} {q.1}\n            (p.2 *> inv {RingHom R (LocRing {R} (powers {R} b))} {q.1 \u2218 locMap {R} {powers {R} a}} {locMap {R} {powers {R} b}} q.2)\n    \\in (arg @ i, prop-dpi (\\lam (i : I) => arg @ i \u2218 locMap {R} {powers {R} a} = locMap {R} {powers {R} b}) p.2 q.2 @ i)))) ",
    "| M : Monoid",
    "| ide : E",
    "\\data Nat \\plevels  \\hlevels  \n  | zero\n  | suc Nat",
    "\\lemma interpretNF_negate \\hlevels  {this : BaseRingData} (l : List (\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ",
    "\\infixl 7 :* (_ _ : RingTerm C V)",
    "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I",
    "\\func absurd {A : \\Type} (_ : Empty) : A ",
    "pos Nat",
    "byRight B",
    "| zro : E",
    "\\field mData : MonoidData {R} vars",
    "\\func interpret \\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \n  | {this}, coef c => func {alg} c\n  | {this}, var x => at {vars} x\n  | {this}, :zro => zro {R}\n  | {this}, :ide => ide {R}\n  | {this}, :negative t => pnegative (interpret t)\n  | {this}, t :+ s => interpret t + interpret s\n  | {this}, t :* s => interpret t * interpret s",
    "cover-inj (j : J) (g j = x)",
    "\\func transportInv {A : \\Type} (B : A -> \\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \n  | {A}, B, {a}, {a'}, idp, b => b",
    "var V",
    "\\lemma fromZero \\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ",
    "\\data List \\Type \n  | nil\n  | \\infixr 5 :: A (List A)",
    "\\infixr 5 :: A (List A)",
    "\\func pow \\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \n  | {this}, a, 0 => ide\n  | {this}, a, suc n => pow a n * a"
  ]
}
model output: 
= t.2 \n  (\lam (t : \Sigma (x : R.E)
    (\Sigma (p : Cover1 {SpecPres R} x a) (Inv {LocRing {R} (powers {R} x)} (func {Func {a} {x} p} (in~ {SType {R} (powers {R} a)}
      {\lam (a1 : SType {R} (powers {R} a)) (b : SType {R} (powers {R} a)) => a1.1 R.* b.2 = b.1 R.* a1.2}
      (y, c, inP {\Sigma (n : Nat) (pow {R} a n = c)} (n, a^n=c)))) || Inv {LocRing {R} (powers {R} x)} (func {Func {a} {x} p} (in~ {SType {R} (powers {R} a)}
      {\lam (a1 : SType {R} (powers {R} a)) (b : SType {R} (powers {R} a)) => a1.1 R.* b.2 = b.
