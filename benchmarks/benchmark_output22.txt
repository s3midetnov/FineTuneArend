index = 22

the query:{
  "Context": [
    "eps>0 : fromRat zro < fromRat eps",
    "eps : Rat"
  ],
  "Expected type": "zro OrderedAddGroup.< pinv {RealField} (fromRat eps) {?hidden}",
  "Expression": "pinv>0 {RealField} eps>0",
  "Premises": [
    "| zro : E",
    "\\lemma pinv>0 \\hlevels  {this : OrderedField} {x : E} (x>0 : zro < x) : zro < pinv x {?hidden} ",
    "\\instance RealField : OrderedFieldAlgebra RatField Real {\n  | zro => fromRat zro\n  | + => (RealAbGroup.+)\n  | negative => negative\n  | *c => \\lam (a : E {LModule.R {\\this}}) => (RealField.*) (fromRat a)\n  | * => (RealField.*)\n  | ide => ide\n  | natCoef => \\lam (n : Nat) => fromRat (natCoef n)\n  | coefMap => fromRat\n  | meet => meet\n  | join => RealAbGroup.join\n  | isPos => \\lam (x : E) => x.L zro\n  | #0=>eitherPosOrNeg => \\lam {x : E {\\this}} (xi : #0 {\\this} x) => (\\case U-inh {x RealField.* xi.inv} \\with {\n    | inP (u, xy<u) => \\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\n      (transport {Real} (\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\peval x RealField.* xi.inv)\n        (transportInv {Real} (\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\this}} xi.inv-right\n          (idp {Int} {signum (ratNom (ide - zro))})),\n        transport {Real} (\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\peval x RealField.* xi.inv)\n          xy<u) \\with {\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \n          \\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\n          \\in \\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\with {\n                | inl c1<0, inl d1>0 => absurd {isPos {\\this} x || isNeg {\\this} x} (<-irreflexive {zro}\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\n                | inl c1<0, inr d1<=0 =>\n                  byRight {isPos {\\this} x} {isNeg {\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\this} x} {isNeg {\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\this} x || isNeg {\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\n              }\n      }\n  })\n} => \\new OrderedFieldAlgebra {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | *c-comm-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n  | coefMap_*c => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | join-left => {?hidden}\n  | join-right => {?hidden}\n  | join-univ => {?hidden}\n  | zro/>0 => {?hidden}\n  | positive_+ => {?hidden}\n  | <_+-comparison => {?hidden}\n  | <_+-connectedness => {?hidden}\n  | ide>zro => {?hidden}\n  | positive_* => {?hidden}\n  | positive=>#0 => {?hidden}\n  | coef_< => {?hidden}\n  | coef_<-inv => {?hidden}\n  | *-comm => {?hidden}\n}",
    "\\func fromRat \\hlevels  (x : Rat) : Real (\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\new Real {\n  | L-closed => {?hidden}\n  | L-rounded => {?hidden}\n  | L-inh => {?hidden}\n  | U-closed => {?hidden}\n  | U-rounded => {?hidden}\n  | LU-disjoint => {?hidden}\n  | LU-located => {?hidden}\n  | LU-focus-bound => {?hidden}\n  | U-inh => {?hidden}\n  | LU-focus => {?hidden}\n}",
    "\\func pinv \\hlevels  {this : OrderedField} (x : E) (\\property x>0 : zro < x) : E => inv {pos#0 {x} x>0}",
    "\\type \\infix 4 < \\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\Prop => A.isPos (y - x)",
    "| \\infix 4 < E E : \\Prop"
  ]
}
model output: 
eps < pinv {RealField} (fromRat eps) {?hidden} eps <<<Expected value:>>> fromRat eps < fromRat eps <<<Value:>>> fromRat eps < fromRat eps <<<Expected type:>>> Real <<<Type:>>> Real (RealAbGroup.+) (fromRat eps) (fromRat eps) <<<Expected value:>>> fromRat eps < fromRat eps <<<Value:>>> fromRat eps < fromRat eps <<<Expected type:>>> Real <<<Type:>>> Real (RealAbGroup.+) (fromRat eps) (fromRat eps) <<<Expected value:>>> fromRat eps < fromRat eps <<<Value:>>> fromRat eps < fromRat eps <<<Expected type:>>> Real <<<Type:>>> Real (RealAbGroup.+) (fromRat eps) (fromRat eps) <<<Expected value:>>> fromRat eps < fromRat eps <<<Value:>>> fromRat eps < fromRat eps <<<Expected type:>>> Real <<<Type:>>> Real (RealAbGroup.+) (fromRat eps) (fromRat eps) <<<Expected value:>>> fromRat eps < fromRat eps
