index = 59

the query:{
  "Context": [
    "p/=0 : p /= zro",
    "s : p * x = q",
    "p : Poly K",
    "q : Poly f.Dom",
    "K : DiscreteField",
    "x : E"
  ],
  "Expected type": "LDiv {PolyRing K} (K.finv (leadCoef {K} p) *c p) q (leadCoef {K} p *c x)",
  "Expression": "make (leadCoef p *c x)\n  (inv *c-comm-left *> pmap ((*c) _) (inv *c-comm-right) *> inv *c-assoc *> pmap (\\lam _x => _x *c _) (finv-left {K} (\\lam q => p/=0 $ leadCoef=0-lem q)) *> ide_*c *> s)",
  "Premises": [
    "| ide_*c {a : E} : ide {R} *c a = a",
    "\\instance PolyRing \\hlevels  (R : Ring) : Ring (Poly R) {\n  | zro => pzero {R}\n  | + => (PolyRing.+)\n  | * => (*)\n  | negative => negative {R}\n  | ide => padd {R} (pzero {R}) R.ide\n  | natCoef => \\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\n} => \\new Ring {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | negative-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n}",
    "\\instance PolyAlgebra \\hlevels  (R1 : CRing) : CAlgebra R1 (Poly R1) {\n  | zro => pzero {R1}\n  | + => (+)\n  | negative => negative {R1}\n  | *c => (*c)\n  | * => (*)\n  | ide => padd {R1} (pzero {R1}) R.ide\n  | natCoef => \\lam (n : Nat) => padd {R1} (pzero {R1}) (R.natCoef n)\n  | coefMap => coefMap-impl\n} => \\new CAlgebra {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | *c-comm-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n  | coefMap_*c => {?hidden}\n  | *-comm => {?hidden}\n}",
    "\\func pmap {A B : \\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\lam (i : I) => f (p @ i))",
    "| ide : E",
    "\\lemma finv-left {this : DiscreteField} {x : E} (_ : x /= zro) : finv x * x = ide ",
    "\\class LDiv \\extends DivBase \\hlevels  {\n  | inv-right : val * inv = elem\n}",
    "| zro : E",
    "| \\infixl 7 * E E : E",
    "| finv E : E",
    "| *c-comm-left {r : E {R}} {a b : E} : r *c (a * b) = r *c a * b",
    "\\func * {R3 : Ring} (_ _ : Poly R3) : Poly R3 \n  | {R}, pzero, q => pzero {R}\n  | {R}, padd p e, q => padd {R} (p * q) R.zro + e *c q\n  | {R}, peq i, q =>\n    (pmap {Poly R} {Poly R} ((+) (padd {R} (pzero {R}) R.zro)) {R.zro *c q} {pzero {R}} (zro_*c {R} {q}) *> path (peq {R})) @ i",
    "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'",
    "\\func leadCoef \\hlevels  {R3 : Ring.Dec} (_ : Poly R3) : R.E \n  | {R}, pzero => R.zro\n  | {R}, padd p e => \\case decideEq p zro \\with {\n    | yes p => e\n    | no n => leadCoef {R} p\n  }\n  | {R}, peq i => idp {R.E} {\\case decideEq (pzero {R}) zro \\with {\n    | yes p => R.zro\n    | no n => R.zro\n  }} @ i",
    "\\data Poly \\hlevels  AddPointed \n  | pzero\n  | padd (Poly R) R.E\n  | peq I",
    "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}",
    "| \\infixl 7 *c (E {R}) E : E",
    "\\func make \\hlevels  {M : Monoid} {a b : M.E} (c : M.E) (p : a M.* c = b) : LDiv {M} a b c => \\new LDiv {\n  | inv-right => {?hidden}\n}",
    "| E : \\Set",
    "| *c-comm-right {r : E {R}} {a b : E} : r *c (a * b) = a * (r *c b)",
    "\\lemma leadCoef=0-lem \\hlevels  {R : Dec} {p : Poly R} (_ : leadCoef {R} p = R.zro) : p = zro ",
    "\\func \\infixr 9 *> {A : \\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \n  | {A}, {a}, {a'}, {a''}, p, idp => p",
    "| *c-assoc {r r' : E {R}} {a : E} : r * r' *c a = r *c (r' *c a)"
  ]
}
model output: 
= K.ide <<<Proof:>>> \new LDiv {
  | inv-right => {?hidden}
} (K.finv (leadCoef {K} p) *c p) q (leadCoef {K} p *c x) = K.ide <<<break>>> \new LDiv {
  | inv-right => {?hidden}
} (K.finv (leadCoef {K} p) *c p) q (leadCoef {K} p *c x) = K.ide <<<break>>> \new LDiv {
  | inv-right => {?hidden}
} (K.finv (leadCoef {K} p) *c p) q (leadCoef {K} p *c x) = K.ide <<<break>>> \new LDiv {
  | inv-right => {?hidden}
} (K.finv (leadCoef {K} p) *c p) q (leadCoef {K} p *c x) = K.ide <<<break>>> \new LDiv {
  | inv-right => {?hidden}
} (K.finv (leadCoef {K} p) *c p) q (leadCoef {K} p *c x) = K.ide <<<break
