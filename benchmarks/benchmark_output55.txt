index = 55

the query:{
  "Context": [
    "c : List A",
    "sl' : SubList {A} (nil {A}) c",
    "A : \\Set"
  ],
  "Expected type": "compose {A} {nil {A} ++ nil {A}} {nil {A} ++ nil {A}} {c ++ nil {A}}\n  (extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}})\n  (extend-right-both {A} {nil {A}} {c} sl' {nil {A}}) = extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {nil {A}} {c} (sublist-nil {A}) sl') {nil {A}}",
  "Expression": "over-right-both _ _",
  "Premises": [
    "sublist-nil",
    "\\func over-right-both \\hlevels  {A11 : \\Set} {a9 b8 c10 d8 : List A11} (sl8 : SubList {A11} a9 b8) (sl'10 : SubList {A11} b8 c10) :\ncompose {A11} {a9 ++ d8} {b8 ++ d8} {c10 ++ d8} (extend-right-both {A11} {a9} {b8} sl8 {d8})\n  (extend-right-both {A11} {b8} {c10} sl'10 {d8}) = extend-right-both {A11} {a9} {c10} (compose {A11} {a9} {b8} {c10} sl8 sl'10) {d8} \n  | {A}, {nil}, {nil}, {nil}, {d}, sublist-nil, sublist-nil => identity {A} {nil {A} ++ d}\n  | {A}, {nil}, {nil}, {y :: c}, {nil}, sublist-nil, sublist-skip sl' =>\n  pmap {SubList {A} (nil {A} ++ nil {A}) (c ++ nil {A})} {SubList {A} (nil {A} ++ nil {A}) (y :: c ++ nil {A})}\n    (sublist-skip {A} {nil {A} ++ nil {A}} {y} {c ++ nil {A}})\n    {compose {A} {nil {A} ++ nil {A}} {nil {A} ++ nil {A}} {c ++ nil {A}}\n      (extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}})\n      (extend-right-both {A} {nil {A}} {c} sl' {nil {A}})}\n    {extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {nil {A}} {c} (sublist-nil {A}) sl') {nil {A}}}\n    (over-right-both {A} {nil {A}} {nil {A}} {c} {nil {A}} (sublist-nil {A}) sl')\n  | {A}, {nil}, {nil}, {y :: c}, {a :: d}, sublist-nil, sublist-skip sl' =>\n  pmap {SubList {A} (nil {A} ++ a :: d) (c ++ a :: d)} {SubList {A} (nil {A} ++ a :: d) (y :: c ++ a :: d)}\n    (sublist-skip {A} {nil {A} ++ a :: d} {y} {c ++ a :: d})\n    {compose {A} {nil {A} ++ a :: d} {nil {A} ++ a :: d} {c ++ a :: d}\n      (extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {a :: d})\n      (extend-right-both {A} {nil {A}} {c} sl' {a :: d})}\n    {extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {nil {A}} {c} (sublist-nil {A}) sl') {a :: d}}\n    (over-right-both {A} {nil {A}} {nil {A}} {c} {a :: d} (sublist-nil {A}) sl')\n  | {A}, {x :: a}, {x1 :: b}, {y :: c}, {d}, sublist-match p sl, sublist-match p1 sl' =>\n  pmap {SubList {A} (a ++ d) (c ++ d)} {SubList {A} (x :: a ++ d) (y :: c ++ d)}\n    (sublist-match {A} {x} {a ++ d} {y} {c ++ d} (p *> p1))\n    {compose {A} {a ++ d} {b ++ d} {c ++ d} (extend-right-both {A} {a} {b} sl {d}) (extend-right-both {A} {b} {c} sl' {d})}\n    {extend-right-both {A} {a} {c} (compose {A} {a} {b} {c} sl sl') {d}} (over-right-both {A} {a} {b} {c} {d} sl sl')\n  | {A}, {x :: a}, {y :: b}, {y1 :: c}, {d}, sublist-match p sl, sublist-skip sl' =>\n  pmap {SubList {A} ((x :: a) ++ d) (c ++ d)} {SubList {A} ((x :: a) ++ d) (y1 :: c ++ d)}\n    (sublist-skip {A} {(x :: a) ++ d} {y1} {c ++ d}) {compose {A} {(x :: a) ++ d} {(y :: b) ++ d} {c ++ d}\n      (extend-right-both {A} {x :: a} {y :: b} (sublist-match {A} {x} {a} {y} {b} p sl) {d})\n      (extend-right-both {A} {y :: b} {c} sl' {d})}\n    {extend-right-both {A} {x :: a} {c} (compose {A} {x :: a} {y :: b} {c} (sublist-match {A} {x} {a} {y} {b} p sl) sl') {d}}\n    (over-right-both {A} {x :: a} {y :: b} {c} {d} (sublist-match {A} {x} {a} {y} {b} p sl) sl')\n  | {A}, {nil}, {x :: b}, {y :: c}, {nil}, sublist-skip sl, sublist-match p sl' =>\n  pmap {SubList {A} (nil {A} ++ nil {A}) (c ++ nil {A})} {SubList {A} (nil {A} ++ nil {A}) (y :: c ++ nil {A})}\n    (sublist-skip {A} {nil {A} ++ nil {A}} {y} {c ++ nil {A}})\n    {compose {A} {nil {A} ++ nil {A}} {b ++ nil {A}} {c ++ nil {A}} (extend-right-both {A} {nil {A}} {b} sl {nil {A}})\n      (extend-right-both {A} {b} {c} sl' {nil {A}})}\n    {extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {b} {c} sl sl') {nil {A}}}\n    (over-right-both {A} {nil {A}} {b} {c} {nil {A}} sl sl')\n  | {A}, {nil}, {x :: b}, {y :: c}, {a :: d}, sublist-skip sl, sublist-match p sl' =>\n  pmap {SubList {A} (nil {A} ++ a :: d) (c ++ a :: d)} {SubList {A} (nil {A} ++ a :: d) (y :: c ++ a :: d)}\n    (sublist-skip {A} {nil {A} ++ a :: d} {y} {c ++ a :: d})\n    {compose {A} {nil {A} ++ a :: d} {b ++ a :: d} {c ++ a :: d} (extend-right-both {A} {nil {A}} {b} sl {a :: d})\n      (extend-right-both {A} {b} {c} sl' {a :: d})}\n    {extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {b} {c} sl sl') {a :: d}}\n    (over-right-both {A} {nil {A}} {b} {c} {a :: d} sl sl')\n  | {A}, {a :: a1}, {x :: b}, {y :: c}, {d}, sublist-skip sl, sublist-match p sl' =>\n  pmap {SubList {A} ((a :: a1) ++ d) (c ++ d)} {SubList {A} ((a :: a1) ++ d) (y :: c ++ d)}\n    (sublist-skip {A} {(a :: a1) ++ d} {y} {c ++ d})\n    {compose {A} {(a :: a1) ++ d} {b ++ d} {c ++ d} (extend-right-both {A} {a :: a1} {b} sl {d})\n      (extend-right-both {A} {b} {c} sl' {d})}\n    {extend-right-both {A} {a :: a1} {c} (compose {A} {a :: a1} {b} {c} sl sl') {d}}\n    (over-right-both {A} {a :: a1} {b} {c} {d} sl sl')\n  | {A}, {nil}, {y :: b}, {y1 :: c}, {nil}, sublist-skip sl, sublist-skip sl' =>\n  pmap {SubList {A} (nil {A} ++ nil {A}) (c ++ nil {A} ++ nil {A})}\n    {SubList {A} (nil {A} ++ nil {A}) (y1 :: c ++ nil {A} ++ nil {A})}\n    (sublist-skip {A} {nil {A} ++ nil {A}} {y1} {c ++ nil {A} ++ nil {A}})\n    {compose {A} {nil {A} ++ nil {A}} {b ++ nil {A} ++ nil {A}} {c ++ nil {A} ++ nil {A}}\n      (extend-right-both {A} {nil {A}} {b} sl {nil {A} ++ nil {A}})\n      (shrink {A} {y} {b ++ nil {A} ++ nil {A}} {c ++ nil {A} ++ nil {A}} (extend-right-both {A} {y :: b} {c} sl' {nil {A} ++ nil {A}}))}\n    {extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {b} {c} sl (shrink {A} {y} {b} {c} sl')) {nil {A} ++ nil {A}}}\n    (transport {SubList {A} (b ++ nil {A} ++ nil {A}) (c ++ nil {A} ++ nil {A})}\n      (\\lam (slx : SubList {A} (b ++ nil {A} ++ nil {A}) (c ++ nil {A} ++ nil {A})) =>\n      compose {A} {nil {A} ++ nil {A}} {b ++ nil {A} ++ nil {A}} {c ++ nil {A} ++ nil {A}}\n        (extend-right-both {A} {nil {A}} {b} sl {nil {A} ++ nil {A}}) slx = extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {b} {c} sl (shrink {A} {y} {b} {c} sl')) {nil {A} ++ nil {A}})\n      {extend-right-both {A} {b} {c} (shrink {A} {y} {b} {c} sl') {nil {A} ++ nil {A}}}\n      {shrink {A} {y} {b ++ nil {A} ++ nil {A}} {c ++ nil {A} ++ nil {A}} (extend-right-both {A} {y :: b} {c} sl' {nil {A} ++ nil {A}})}\n      (inv {SubList {A} (b ++ nil {A} ++ nil {A}) (c ++ nil {A} ++ nil {A})}\n        {shrink {A} {y} {b ++ nil {A} ++ nil {A}} {c ++ nil {A} ++ nil {A}} (extend-right-both {A} {y :: b} {c} sl' {nil {A} ++ nil {A}})}\n        {extend-right-both {A} {b} {c} (shrink {A} {y} {b} {c} sl') {nil {A} ++ nil {A}}}\n        (shrink-over-extend-right {A} {y} {b} {c} {nil {A} ++ nil {A}} sl'))\n      (over-right-both {A} {nil {A}} {b} {c} {nil {A} ++ nil {A}} sl (shrink {A} {y} {b} {c} sl')))\n  | {A}, {nil}, {y :: b}, {y1 :: c}, {a :: d}, sublist-skip sl, sublist-skip sl' =>\n  pmap {SubList {A} (nil {A} ++ nil {A} ++ a :: d) (c ++ nil {A} ++ a :: d)}\n    {SubList {A} (nil {A} ++ a :: d) (y1 :: c ++ nil {A} ++ a :: d)}\n    (sublist-skip {A} {nil {A} ++ a :: d} {y1} {c ++ nil {A} ++ a :: d})\n    {compose {A} {nil {A} ++ nil {A} ++ a :: d} {(y :: b) ++ nil {A} ++ a :: d} {c ++ nil {A} ++ a :: d}\n      (extend-right-both {A} {nil {A}} {y :: b} (sublist-skip {A} {nil {A}} {y} {b} sl) {nil {A} ++ a :: d})\n      (extend-right-both {A} {y :: b} {c} sl' {nil {A} ++ a :: d})}\n    {extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {b} {c} sl (shrink {A} {y} {b} {c} sl')) {nil {A} ++ a :: d}}\n    (over-right-both {A} {nil {A}} {y :: b} {c} {nil {A} ++ a :: d} (sublist-skip {A} {nil {A}} {y} {b} sl) sl' *> transportInv {SubList {A} (nil {A}) c} (\\lam (x : SubList {A} (nil {A}) c) =>\n      extend-right-both {A} {nil {A}} {c} x {nil {A} ++ a :: d} = extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {b} {c} sl (shrink {A} {y} {b} {c} sl')) {nil {A} ++ a :: d})\n      {compose {A} {nil {A}} {y :: b} {c} (sublist-skip {A} {nil {A}} {y} {b} sl) sl'}\n      {compose {A} {nil {A}} {b} {c} sl (shrink {A} {y} {b} {c} sl')}\n      (trivial-sublist-contractible {A} {c} (compose {A} {nil {A}} {y :: b} {c} (sublist-skip {A} {nil {A}} {y} {b} sl) sl')\n        (compose {A} {nil {A}} {b} {c} sl (shrink {A} {y} {b} {c} sl')))\n      (idp {SubList {A} (nil {A} ++ a :: d) (c ++ nil {A} ++ a :: d)}\n        {extend-right-both {A} {nil {A}} {c} (compose {A} {nil {A}} {b} {c} sl (shrink {A} {y} {b} {c} sl')) {nil {A} ++ a :: d}}))\n  | {A}, {a :: a1}, {y :: b}, {y1 :: c}, {d}, sublist-skip sl, sublist-skip sl' =>\n  pmap {SubList {A} ((a :: a1) ++ d) (c ++ d)} {SubList {A} ((a :: a1) ++ d) (y1 :: c ++ d)}\n    (sublist-skip {A} {(a :: a1) ++ d} {y1} {c ++ d}) {compose {A} {(a :: a1) ++ d} {(y :: b) ++ d} {c ++ d}\n      (extend-right-both {A} {a :: a1} {y :: b} (sublist-skip {A} {a :: a1} {y} {b} sl) {d})\n      (extend-right-both {A} {y :: b} {c} sl' {d})}\n    {extend-right-both {A} {a :: a1} {c} (compose {A} {a :: a1} {y :: b} {c} (sublist-skip {A} {a :: a1} {y} {b} sl) sl') {d}}\n    (over-right-both {A} {a :: a1} {y :: b} {c} {d} (sublist-skip {A} {a :: a1} {y} {b} sl) sl')",
    "\\func extend-right-both {A3 : \\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})",
    "nil",
    "\\data SubList {A : \\Type} (_ _ : List A) \\with\n  | {A}, nil, nil => sublist-nil\n  | {A}, x :: xs, y :: ys => sublist-match (x = y) (SubList {A} xs ys)\n  | {A}, l, y :: ys => sublist-skip (SubList {A} l ys)",
    "\\func \\infixr 5 ++ {A1 : \\Type} (_ _ : List A1) : List A1 \n  | {A}, nil, ys => ys\n  | {A}, a :: xs, ys => a :: xs ++ ys",
    "\\func compose {A6 : \\Type} {a4 b4 c5 : List A6} (_ : SubList {A6} a4 b4) (_ : SubList {A6} b4 c5) : SubList {A6} a4 c5 \n  | {A}, {nil}, {nil}, {nil}, sublist-nil, sublist-nil => sublist-nil {A}\n  | {A}, {nil}, {nil}, {y :: c}, sublist-nil, sublist-skip sl' =>\n    sublist-skip {A} {nil {A}} {y} {c} (compose {A} {nil {A}} {nil {A}} {c} (sublist-nil {A}) sl')\n  | {A}, {x :: a}, {x1 :: b}, {y :: c}, sublist-match p sl, sublist-match p1 sl' =>\n    sublist-match {A} {x} {a} {y} {c} (p *> p1) (compose {A} {a} {b} {c} sl sl')\n  | {A}, {x :: a}, {y :: b}, {y1 :: c}, sl, sublist-skip sl' =>\n    sublist-skip {A} {x :: a} {y1} {c} (compose {A} {x :: a} {y :: b} {c} sl sl')\n  | {A}, {a}, {x :: b}, {y :: c}, sublist-skip sl, sublist-match p sl' =>\n    sublist-skip {A} {a} {y} {c} (compose {A} {a} {b} {c} sl sl')\n  | {A}, {a}, {y :: b}, {y1 :: c}, sublist-skip sl, sublist-skip sl' =>\n    sublist-skip {A} {a} {y1} {c} (compose {A} {a} {b} {c} sl (shrink {A} {y} {b} {c} sl'))"
  ]
}
model output: 
<<<break>>> extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}}<<<break>>> extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}}<<<break>>> extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}}<<<break>>> extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}}<<<break>>> extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}}<<<break>>> extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}}<<<break>>> extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}}<<<break>>> extend-right-both {A} {nil {A}} {nil {A}} (sublist-nil {A}) {nil {A}}
