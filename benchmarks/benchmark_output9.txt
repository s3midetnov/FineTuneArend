index = 9

the query:{
  "Context": [
    "M : UniformLocale",
    "h1 : func {completion {L} \u2218 completion-functor {L} {M} f} = func {f \u2218 completion {M}}",
    "f : UniformHom M L",
    "L : UniformLocale"
  ],
  "Expected type": "Path (\\lam (i : I) => \\Pi {U : E -> \\Prop} -> isUniform U -> L.isUniform (\\lam (y : L.E) => TruncP (\\Sigma (x : E) (U x) (y L.<= (@) h1 i x))))\n  (func-uniform {completion {L} \u2218 completion-functor {L} {M} f}) (func-uniform {f \u2218 completion {M}})",
  "Expression": "prop-dpi (\\lam i => ext_coe) (func-uniform {completion {L} \u2218 completion-functor {L} {M} f}) (func-uniform {f \u2218 completion {M}})",
  "Premises": [
    "| isUniform (E -> \\Prop) : \\Prop",
    "| func-uniform {U : E {Dom} -> \\Prop} (isUniform {Dom} U) : isUniform {Cod} (\\lam (y : E {Cod}) => TruncP (\\Sigma (x : E {Dom}) (U x) (y <= func x)))",
    "\\func completion {L : UniformLocale} : UniformEmbedding (Completion L) L {\n  | func => \\lam (U : E {Dom {completionLocale {L}}}) =>\n    L.Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\n} => \\new UniformEmbedding {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n  | isEmbedding => {?hidden}\n  | isUniformEmbedding => {?hidden}\n}",
    "\\lemma prop-dpi \\plevels  \\hlevels  (A : I -> \\Prop) (a : A left) (a' : A right) : Path A a a' ",
    "\\func completion-functor {L M : UniformLocale} (f : UniformHom M L) : UniformHom (Completion M) (Completion L) {\n  | func => \\lam (U : E {Dom {adjointMap {CompletionPres M} {PresentedFrame (CompletionPres L)} (presentation {L} {M} f)}}) =>\n    Join {\\Sigma (x : E) (U.1 x)} (\\lam (j : \\Sigma (x : E) (U.1 x)) => func {presentation {L} {M} f} j.1)\n} => \\new UniformHom {\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n  | func-uniform => {?hidden}\n}",
    "\\func Completion (L : UniformLocale) : UniformLocale (Opens (CompletionPres L)) {\n  | <= => (PresentedFrame.<=)\n  | meet => \\lam (U : E) (V : E) =>\n    closure {CompletionPres L} {\\Sigma (a b : E) (U.1 a) (V.1 b)} (\\lam (t : \\Sigma (a b : E) (U.1 a) (V.1 b)) => conj t.1 t.2)\n  | top => (\\lam (_ : E) => \\Sigma, \\lam (e : E) (_ : SCover {CompletionPres L} e (\\lam (_ : E) => \\Sigma)) => ())\n  | Join => \\lam {J : \\Set} (f : J -> E) =>\n    closure {CompletionPres L} {\\Sigma (j : J) (x : E) ((f j).1 x)} (\\lam (p0 : \\Sigma (j : J) (x : E) ((f j).1 x)) => p0.2)\n  | isUniform => Completion.isUniform {L}\n} => \\new UniformLocale {\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top-univ => {?hidden}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n  | isAdmissible => {?hidden}\n}",
    "| \\infix 4 <= E E : \\Prop",
    "| E : \\Set",
    "| \\infixl 8 o \\alias \\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z",
    "\\func UniformCat : Cat UniformLocale {\n  | Hom => Hom\n  | id => id\n  | o => \\lam {X Y Z : Ob} => (\u2218)\n} => subCat {PreuniformCat} {UniformLocale} (\\new Embedding {UniformLocale} {Ob} (\\lam (L : A {\\this}) => L) {\n  | isEmb => \\lam (L M : UniformLocale) =>\n  \\new Retraction {L = M} {f {\\this} L = f {\\this} M} (pmap {A {\\this}} {B {\\this}} (f {\\this}) {L} {M}) {\n    | sec => \\lam (p : B {\\this}) => path (\\lam (i : I) => \\new UniformLocale (E {p @ i}) {\n      | <= => (<=) {p @ i}\n      | <=-refl => {?hidden}\n      | <=-transitive => {?hidden}\n      | <=-antisymmetric => {?hidden}\n      | meet => (\u2227) {p @ i}\n      | meet-left => {?hidden}\n      | meet-right => {?hidden}\n      | meet-univ => {?hidden}\n      | top => top {p @ i}\n      | top-univ => {?hidden}\n      | Join => Join {p @ i}\n      | Join-cond => {?hidden}\n      | Join-univ => {?hidden}\n      | Join-ldistr>= => {?hidden}\n      | uniform-overt => {?hidden}\n      | isUniform => isUniform {p @ i}\n      | isCovering => {?hidden}\n      | isDownset => {?hidden}\n      | top-uniform => {?hidden}\n      | meet-uniform => {?hidden}\n      | <=-uniform => {?hidden}\n      | star-uniform => {?hidden}\n      | isAdmissible => {?hidden}\n    })\n    | f_sec => idpe {L = M}\n  }\n})",
    "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I"
  ]
}
model output: 
(func-uniform {completion {L} ∘ completion-functor {L} {M} f}) (func-uniform {f ∘ completion {M}}) (func-uniform {completion {L} ∘ completion-functor {L} {M} f}) (func-uniform {f ∘ completion {M}}) (func-uniform {completion {L} ∘ completion-functor {L} {M} f}) (func-uniform {f ∘ completion {M}}) (func-uniform {completion {L} ∘ completion-functor {L} {M} f}) (func-uniform {f ∘ completion {M}}) (func-uniform {completion {L} ∘ completion-functor {L} {M} f}) (func-uniform {f ∘ completion {M}}) (func-uniform {completion {L} ∘ completion-functor {L} {M} f}) (func-uniform {f ∘ completion {M}}) (func-uniform {completion {L} ∘ completion-functor {L} {M} f}) (func-uniform {f ∘ completion {M}}) (func-uniform
