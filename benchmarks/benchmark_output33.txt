index = 33

the query:{
  "Context": [
    "X : PseudoNormedRing",
    "p : L {X.norm X.ide} zro"
  ],
  "Expected type": "X.norm X.ide = ide",
  "Expression": "later (norm_ide/=0 (\\lam q => (\\case rewrite ((=-upper {norm {X} 1} {0}).2 q) p \\with {})))",
  "Premises": [
    "\\lemma norm_ide/=0 \\hlevels  {X : ExPseudoNormedRing} (_ : X.norm X.ide /= zro) : X.norm X.ide = ide ",
    "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right",
    "\\lemma =-upper \\plevels  \\hlevels  {x y : Real} : x = y <-> x = y ",
    "| ide : E",
    "\\instance RealField : OrderedFieldAlgebra RatField Real {\n  | zro => fromRat zro\n  | + => (RealAbGroup.+)\n  | negative => negative\n  | *c => \\lam (a : E {LModule.R {\\this}}) => (RealField.*) (fromRat a)\n  | * => (RealField.*)\n  | ide => ide\n  | natCoef => \\lam (n : Nat) => fromRat (natCoef n)\n  | coefMap => fromRat\n  | meet => meet\n  | join => RealAbGroup.join\n  | isPos => \\lam (x : E) => x.L zro\n  | #0=>eitherPosOrNeg => \\lam {x : E {\\this}} (xi : #0 {\\this} x) => (\\case U-inh {x RealField.* xi.inv} \\with {\n    | inP (u, xy<u) => \\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\n      (transport {Real} (\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\peval x RealField.* xi.inv)\n        (transportInv {Real} (\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\this}} xi.inv-right\n          (idp {Int} {signum (ratNom (ide - zro))})),\n        transport {Real} (\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\peval x RealField.* xi.inv)\n          xy<u) \\with {\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \n          \\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\n          \\in \\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\with {\n                | inl c1<0, inl d1>0 => absurd {isPos {\\this} x || isNeg {\\this} x} (<-irreflexive {zro}\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\n                | inl c1<0, inr d1<=0 =>\n                  byRight {isPos {\\this} x} {isNeg {\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\this} x} {isNeg {\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\this} x || isNeg {\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\n              }\n      }\n  })\n} => \\new OrderedFieldAlgebra {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | *c-comm-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n  | coefMap_*c => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | join-left => {?hidden}\n  | join-right => {?hidden}\n  | join-univ => {?hidden}\n  | zro/>0 => {?hidden}\n  | positive_+ => {?hidden}\n  | <_+-comparison => {?hidden}\n  | <_+-connectedness => {?hidden}\n  | ide>zro => {?hidden}\n  | positive_* => {?hidden}\n  | positive=>#0 => {?hidden}\n  | coef_< => {?hidden}\n  | coef_<-inv => {?hidden}\n  | *-comm => {?hidden}\n}",
    "\\instance ExUpperRealAbMonoid \\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\n  | < => (ExUpperRealAbMonoid.<)\n  | <= => (ExUpperReal.<=)\n  | meet => ExUpperReal.meet\n  | join => ExUpperReal.join\n  | zro => fromRat zro\n  | + => (ExUpperReal.+)\n} => \\new BiorderedLatticeAbMonoid {\n  | <-irreflexive => {?hidden}\n  | <-transitive => {?hidden}\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | <-transitive-right => {?hidden}\n  | <-transitive-left => {?hidden}\n  | <=-less => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | join-left => {?hidden}\n  | join-right => {?hidden}\n  | join-univ => {?hidden}\n  | <_meet-univ => {?hidden}\n  | <_join-univ => {?hidden}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | <=_+ => {?hidden}\n  | join_+-left => {?hidden}\n  | +-comm => {?hidden}\n  | meet_+-left => {?hidden}\n}",
    "| norm E : ExUpperReal",
    "| zro : E",
    "\\class Real \\extends InfReal, UpperReal \\hlevels  {\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\n}",
    "| L Rat : \\Prop",
    "\\data Empty \\plevels  \\hlevels  ",
    "\\class ExUpperReal \\plevels  \\hlevels  {\n  | U Rat : \\Prop\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\n  | U-rounded {q : Rat} (U q) : TruncP (\\Sigma (r : Rat) (U r) (r < q))\n}",
    "\\func \\infix 1 = {A : \\Type} (a a' : A) : \\Type => a = a'",
    "\\instance RatNormed \\hlevels  : NormedAbGroup Rat {\n  | isOpen => PrecoverSpace.isOpen\n  | isCauchy => PreuniformSpace.isCauchy\n  | isUniform => isUniform\n  | dist => PseudoNormedAbGroup.dist\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\n  | + => (RatField.+)\n  | negative => RatField.negative\n  | norm => \\lam (a : E {\\this}) => Real.fromRat (abs {RatField} a)\n} => \\new NormedAbGroup {\n  | cauchy-open => {?hidden}\n  | uniform-cauchy => {?hidden}\n  | dist-refl => {?hidden}\n  | dist-symm => {?hidden}\n  | dist-triang => {?hidden}\n  | dist-uniform => {?hidden}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | norm_zro => {?hidden}\n  | norm_negative => {?hidden}\n  | norm_+ => {?hidden}\n  | norm-dist => {?hidden}\n  | isHausdorff => {?hidden}\n  | isSeparatedCoverSpace => {?hidden}\n  | dist-ext => {?hidden}\n  | norm-ext => {?hidden}\n}",
    "\\instance RealNormed \\hlevels  : CompleteNormedAbGroup Real {\n  | isOpen => isOpen {RealNormedAbGroup}\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\n  | dist => dist {RealNormedAbGroup}\n  | zro => fromRat zro\n  | + => (RealAbGroup.+)\n  | negative => RealAbGroup.negative\n  | norm => abs {RealAbGroup}\n} => \\new CompleteNormedAbGroup {\n  | cauchy-open => {?hidden}\n  | uniform-cauchy => {?hidden}\n  | dist-refl => {?hidden}\n  | dist-symm => {?hidden}\n  | dist-triang => {?hidden}\n  | dist-uniform => {?hidden}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | norm_zro => {?hidden}\n  | norm_negative => {?hidden}\n  | norm_+ => {?hidden}\n  | norm-dist => {?hidden}\n  | isSeparatedCoverSpace => {?hidden}\n  | dist-ext => {?hidden}\n  | norm-ext => {?hidden}\n  | isCompleteMetric => {?hidden}\n  | isStronglyComplete => {?hidden}\n}"
  ]
}
model output: 
<<<Expected value:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value:>>> X.norm X.ide = ide <<<Actual type:>>> X.norm X.ide = ide <<<Actual value
