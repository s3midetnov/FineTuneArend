index = 41

the query:{
  "Context": [
    "v : \\Sigma (a b : L.E) (a L.\u2227 b L.<= L.bottom) (l.1.1 = func {proj1 {LocaleCat} {L} {L}} a \u2227 func {proj2 {LocaleCat} {L} {L}} b)",
    "L : Locale",
    "l : \\Sigma (j : \\Sigma (b : Opens (colimit-obj {Precat.op {DiscretePrecat (Fin 2)}}\n  (Comp {Precat.op {DiscretePrecat (Fin 2)}} {FrameBicat} {FrameUPresCat} FrameUnitalReflectiveSubcat\n    (Functor.op {functor {Fin 2} {LocaleCat} (at {L :: L :: nil})}))))\n  (b <= U || (\\Sigma (a b1 : L.E) (a L.\u2227 b1 L.<= L.bottom) (b = func {proj1 {LocaleCat} {L} {L}} a \u2227 func {proj2 {LocaleCat} {L} {L}} b1))))\n  (x : FTerm {Precat.op {DiscretePrecat (Fin 2)}}\n    (Comp {Precat.op {DiscretePrecat (Fin 2)}} {FrameBicat} {FrameUPresCat} FrameUnitalReflectiveSubcat\n      (Functor.op {functor {Fin 2} {LocaleCat} (at {L :: L :: nil})}))) (j.1.1 x)"
  ],
  "Expected type": "Cover {colimit-obj {Precat.op {DiscretePrecat (Fin 2)}}\n  (Comp {Precat.op {DiscretePrecat (Fin 2)}} {FrameBicat} {FrameUPresCat} FrameUnitalReflectiveSubcat\n    (Functor.op {functor {Fin 2} {LocaleCat} (at {L :: L :: nil})}))} l.2\n  {\\Sigma (a b : E) ((func {proj1 {LocaleCat} {L} {L}} v.1).1 a) ((func {proj2 {LocaleCat} {L} {L}} v.2).1 b)}\n  (\\lam (t : \\Sigma (a b : E) ((func {proj1 {LocaleCat} {L} {L}} v.1).1 a) ((func {proj2 {LocaleCat} {L} {L}} v.2).1 b)) =>\n    conj t.1 t.2)",
  "Expression": "transport (\\lam p0 => p0.1 l.2) v.4 l.3",
  "Premises": [
    "\\func FrameUnitalReflectiveSubcat : ReflectiveSubPrecat FrameCat FrameUPresCat FrameUnitalSubcat.F {\n  | Func => FrameUnitalSubcat.Func\n  | reflector => reflector\n  | reflectorMap => \\lam (X : Ob {D {\\this}}) => \\new FrameUPresHom X (Functor.F {\\this} (reflector {\\this} X)) {\n    | func => embed {X}\n    | func-conj => {?hidden}\n    | func-basicCover => {?hidden}\n    | func-unit => {?hidden}\n  }\n  | isReflective => \\lam {X : Ob {D {\\this}}} {Y : Ob {C {\\this}}} =>\n  \\new QEquiv {Hom {C {\\this}} (reflector {\\this} X) Y} {Hom {D {\\this}} X (Functor.F {\\this} Y)}\n    (\\lam (p0 : A {\\this}) => Functor.Func {\\this} {reflector {\\this} X} {Y} p0 \u2218 ReflectiveSubPrecat.reflectorMap {\\this} X) {\n    | ret => ret {isReflective {X} {Y}}\n    | ret_f => ret_f {isReflective {X} {Y}}\n    | f_sec => \\lam (h : B {\\this}) => path (\\lam (i : I) => (\n      \\have arg => path (\\lam (i : I) => func {f_ret {isReflective {X} {Y}} h @ i})\n      \\in \\new FrameUPresHom X (Functor.F {\\this} Y) {\n            | func => arg @ i\n            | func-conj => {?hidden}\n            | func-basicCover => {?hidden}\n            | func-unit => {?hidden}\n          }))\n  }\n} => \\new ReflectiveSubPrecat {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n  | isFullyFaithful => {?hidden}\n}",
    "\\class Locale \\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\hlevels  {\n  | Join-ldistr>= {J : \\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\lam (j : J) => e \u2227 f j)\n  | basicCover-stable => \\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\n    meet-univ {x} {Join {J} (\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\lam (j : J) => (g j).1} {x}\n  | ldistr>= => \\lam {x : E} {y : E} {z : E} => (\n    \\have t => path (\\lam (i : I) (b : Bool) => (\\case b \\with {\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\n          }) @ i)\n    \\in transportInv\n        {Bool -> E} (\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\n          {\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\lam (b : Bool) => x \u2227 if {E} b y z} t\n          (Join-ldistr>= {Bool} {\\lam (p0 : Bool) => if {E} p0 y z} {x}))\n  | Meet-cond => \\lam {J : \\Set} (j : J) {f : J -> E} =>\n  Join-univ {\\Sigma (b : E) (\\Pi (j : J) -> b <= f j)} {\\lam (t : Total {E} (\\lam (p0 : E) => \\Pi (j : J) -> p0 <= f j)) => t.1}\n    {f j} (\\lam (p0 : \\Sigma (b : E) (\\Pi (j : J) -> b <= f j)) => p0.2 j)\n  | join-left => \\lam {x : E} {y : E} => Join-cond {Bool} true {\\lam (p0 : Bool) => if {E} p0 x y}\n  | join-right => \\lam {x : E} {y : E} => Join-cond {Bool} false {\\lam (p0 : Bool) => if {E} p0 x y}\n  | Meet-univ => \\lam {J : \\Set} {f : J -> E} {e : E} (p : \\Pi (j : J) -> e <= f j) =>\n  Join-cond {\\Sigma (b : E) (\\Pi (j : J) -> b <= f j)} (e, p)\n    {\\lam (t : Total {E} (\\lam (p0 : E) => \\Pi (j : J) -> p0 <= f j)) => t.1}\n  | join-univ => \\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\n  Join-univ {Bool} {\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\lam (p0 : Bool) => (\\case p0 \\with {\n    | true => x<=z\n    | false => y<=z\n  }))\n  | join => \\lam (x : E) (y : E) => Join {Bool} (\\lam (p0 : Bool) => if {E} p0 x y)\n  | Meet => \\lam {J : \\Set} (g : J -> E) =>\n    Join {\\Sigma (b : E) (\\Pi (j : J) -> b <= g j)} (\\lam (t : Total {E} (\\lam (p0 : E) => \\Pi (j : J) -> p0 <= g j)) => t.1)\n  | isBasicCover => \\lam (x : Ob) {J : \\Set} (g : J -> Ob) => x <= Join {J} (\\lam (j : J) => (g j).1)\n}",
    "\\data Fin \\plevels  \\hlevels  Nat \\with\n  | suc n => zero\n  | suc n => suc (Fin n)",
    "| conj E E : E",
    "\\instance colimit-obj {J : Precat} (G : Functor J FrameUPresCat) : FrameUPres (FTerm {J} G) {\n  | conj => fconj {J} {G}\n  | BasicCover => \\lam {K : \\Set} (x : E {\\this}) (f : K -> E {\\this}) =>\n  (\\Sigma (j : J.Ob) (y : E {G.F j}) (g : K -> E {G.F j}) (BasicCover {G.F j} {K} y g) (x = finj {J} {G} {j} y)\n    (\\Pi (k : K) -> f k = finj {J} {G} {j} (g k))) || ((K, f) = (\\Sigma, \\lam (_ : \\Sigma) => funit {J} {G}))\n  | unit => funit {J} {G}\n} => \\new FrameUPres {\n  | isUnit => {?hidden}\n}",
    "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right",
    "\\type Opens \\hlevels  (P : FramePres) : \\Set => \\Sigma (U : P.E -> \\Prop) (\\Pi (x : P.E) -> SCover {P} x U -> U x)",
    "\\func FrameBicat : BicompleteCat Locale {\n  | Hom => FrameHom\n  | id => \\lam (L : Ob) => \\new FrameHom L L {\n    | func => \\lam (x : E {Dom {\\this}}) => x\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }\n  | o => FrameCat.o\n  | pullback => \\lam {X : Ob {\\this}} {Y : Ob {\\this}} {Z : Ob {\\this}} (f : Hom {\\this} X Z) (g1 : Hom {\\this} Y Z) =>\n  \\new Pullback {X} {Y} {Z} f g1 (pullback-obj {X} {Y} {Z} f g1) {\n    | pbProj1 => proj1 {f.Dom} {g.Dom} {f.Cod} {f} {g1}\n    | pbProj2 => proj2 {f.Dom} {g.Dom} {f.Cod} {f} {g1}\n    | pbCoh => {?hidden}\n    | pbMap => \\lam {w : Ob {Pullback.D {\\this}}} (p1 : Hom {Pullback.D {\\this}} w (x {\\this})) (p2 : Hom {Pullback.D {\\this}} w (y {\\this}))\n      (c : Pullback.f {\\this} Precat.\u2218 p1 = g {\\this} Precat.\u2218 p2) => \\new FrameHom w (Pullback.apex {\\this}) {\n      | func => \\lam (x : E {Dom {\\this}}) => (p1.func x, p2.func x, path (\\lam (i : I) => func {c @ i} x))\n      | func-<= => {?hidden}\n      | func-top => {?hidden}\n      | func-top>= => {?hidden}\n      | func-meet => {?hidden}\n      | func-meet>= => {?hidden}\n      | func-Join => {?hidden}\n      | func-Join>= => {?hidden}\n    }\n    | pbBeta1 => {?hidden}\n    | pbBeta2 => {?hidden}\n    | pbEta => {?hidden}\n  }\n  | terminal => fromLimit {Empty} (limit {\\this} {DiscretePrecat Empty} (functor {Empty} (absurd {Ob {\\this}})))\n  | Bprod => \\lam (x : Ob {\\this}) (y : Ob {\\this}) =>\n    fromLimit {Fin 2} (limit {\\this} {DiscretePrecat (Fin 2)} (functor {Fin 2} (at {x :: y :: nil})))\n  | limit => \\lam {J1 : Precat} (G1 : Functor J1 this4) => \\new Limit {J1} G1 (limit-obj {J1} G1) {\n    | coneMap => \\lam (j : Ob {J {\\this}}) => \\new FrameHom (Cone.apex {\\this}) (F {G {\\this}} j) {\n      | func => \\lam (P : E {Dom {\\this}}) => P.1 j\n      | func-<= => {?hidden}\n      | func-top => {?hidden}\n      | func-top>= => {?hidden}\n      | func-meet => {?hidden}\n      | func-meet>= => {?hidden}\n      | func-Join => {?hidden}\n      | func-Join>= => {?hidden}\n    }\n    | coneCoh => {?hidden}\n    | isLimit => {?hidden}\n    | limMap => limMap-impl\n    | limBeta => {?hidden}\n    | limUnique => {?hidden}\n  }\n  | colimit => \\lam {J : Precat} (G : Functor J this4) => reflectiveSubPrecatColimit\n    {J} FrameUnitalReflectiveSubcat G (colimit {J} (Comp {J} {FrameUPresCat} FrameUnitalReflectiveSubcat G))\n} => \\new BicompleteCat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n  | univalence => {?hidden}\n}",
    "\\func DiscretePrecat (X : \\Type) : Precat X {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Trunc0 (x = y)\n  | id => \\lam (x : Ob {\\this}) => in0 {x = x} (idp {X} {x})\n  | o => o {X}\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}",
    "\\instance LocaleCat : BicompleteCat Locale {\n  | Hom => \\lam (x : Ob) (y : Ob) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\n  | pullback => \\lam {x y z : Ob {\\this}} (f : Hom {\\this} x z) (g : Hom {\\this} y z) =>\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\n  | terminal => \\new Product {Empty} (absurd {Ob {\\this}}) (discrete (\\Sigma)) {\n    | proj => \\lam (p0 : J {\\this}) => (\\case p0 \\with {})\n    | tupleMap => \\lam {Z : Ob {D {\\this}}} (_ : \\Pi (j : J {\\this}) -> Hom {D {\\this}} Z (G {\\this} j)) => \\new FrameHom (apex {\\this}) Z {\n      | func => \\lam (P : E {Dom {\\this}}) => pHat {Z} (P ())\n      | func-<= => {?hidden}\n      | func-top => {?hidden}\n      | func-top>= => {?hidden}\n      | func-meet => {?hidden}\n      | func-meet>= => {?hidden}\n      | func-Join => {?hidden}\n      | func-Join>= => {?hidden}\n    }\n    | tupleBeta => {?hidden}\n    | tupleEq => {?hidden}\n  }\n  | Bprod => \\lam (x : Ob {\\this}) (y : Ob {\\this}) =>\n    Product.fromLimit {Fin 2} (limit {\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\n  | limit => \\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\n  | colimit => \\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\n} => \\new BicompleteCat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n  | univalence => {?hidden}\n}",
    "\\func proj2 \\plevels obj >= hom \\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 1) => proj {Bprod x y} 1",
    "\\func functor \\plevels obj >= hom {J : \\Type} {D : Precat} (G : J -> D.Ob) : Functor (DiscretePrecat J) D G {\n  | Func => map {J} {D} G\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}",
    "\\instance FrameUPresCat : Cat FrameUPres {\n  | Hom => FrameUPresHom\n  | id => \\lam (X : Ob {\\this}) => \\new FrameUPresHom X X {\n    | func => \\lam (x : X.E) => x\n    | func-conj => {?hidden}\n    | func-basicCover => {?hidden}\n    | func-unit => {?hidden}\n  }\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => \\new FrameUPresHom X Z {\n    | func => \\lam (x : X.E) => g.func (f.func x)\n    | func-conj => {?hidden}\n    | func-basicCover => {?hidden}\n    | func-unit => {?hidden}\n  }\n} => \\new Cat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n  | univalence => {?hidden}\n}",
    "\\func op \\plevels obj >= hom \\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => Func {Y} {X}\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}",
    "\\func proj1 \\plevels obj >= hom \\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 0) => proj {Bprod x y} 0",
    "\\data Cover \\hlevels  {P : FramePres} P.E {J : \\Set} (J -> P.E) : \\Prop \n  | cover-basic (P.BasicCover {J} x g)\n  | cover-inj (j : J) (g j = x)\n  | cover-trans {I : \\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\Pi (i : I) -> Cover {P} (f i) {J} g)\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\n  | cover-idemp (j : J) (g j = P.conj x x)\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\Pi (j : J) -> g j = P.conj a (f j))",
    "| at (j : Fin len) : A j",
    "| reflector (Ob {D}) : Ob {C}",
    "| func (E {Dom}) : E {Cod}",
    "| E : \\Set",
    "\\func op \\plevels obj >= hom \\hlevels  {this2 : Precat} : Precat Ob {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => Hom y x\n  | id => id\n  | o => \\lam {X Y Z : Ob {\\this}} (g : Hom {\\this} Y Z) (f : Hom {\\this} X Y) => f \u2218 g\n} => \\new Precat {\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}",
    "| meet \\alias \\infixl 7 \u2227 E E : E",
    "\\func Comp \\plevels obj >= hom \\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\lam (X : Ob {C {\\this}}) => G.F (F.F X)) {\n  | Func => \\lam {X Y : Ob {C {\\this}}} (f : Hom {C {\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\n} => \\new Functor {\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}"
  ]
}
model output: 
(l.1.1, l.1.2) (l.2.1, l.2.2) (l.3.1, l.3.2) (l.4.1, l.4.2) (l.5.1, l.5.2) (l.6.1, l.6.2) (l.7.1, l.7.2) (l.8.1, l.8.2) (l.9.1, l.9.2) (l.10.1, l.10.2) (l.11.1, l.11.2) (l.12.1, l.12.2) (l.13.1, l.13.2) (l.14.1, l.14.2) (l.15.1, l.15.2) (l.16.1, l.16.2) (l.17.1, l.17.2) (l.18.1, l.18.2) (l.1
