index = 71

the query:{
  "Context": [],
  "Expected type": "\\Pi (a : E) -> Cover {RealPres RatField} a {TruncP (\\Sigma (c : CompleteFilter (PresentedFrame (RealPres RatField)))\n  (points^* {PresentedFrame (RealPres RatField)} (embed {RealPres RatField} a) c))}\n  (\\lam (_ : TruncP (\\Sigma (c : CompleteFilter (PresentedFrame (RealPres RatField)))\n    (points^* {PresentedFrame (RealPres RatField)} (embed {RealPres RatField} a) c))) => a)",
  "Expression": "\\lam a => (\\case dec<_<= a.1 a.2 \\with {\n  | inl r => \\case isDense r \\with {\n    | inP (x, a1<x, x<a2) => cover-inj (inP (ratPoint x, inP (a, cover-inj () idp, (a1<x, x<a2)))) idp\n  }\n  | inr r => cover-empty r\n})",
  "Premises": [
    "\\data \\infixr 2 Or (_ _ : \\Type) \n  | inl A\n  | inr B",
    "\\class CompleteFilter \\extends Filter \\hlevels  {\n  | filter-Join {J : \\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\Sigma (j : J) (F (f j)))\n}",
    "\\type Interval \\hlevels  (Q : Poset) : \\Set => \\Sigma Q.E Q.E",
    "\\func idp {A : \\Type} {a : A} : a = a => path (\\lam (_ : I) => a)",
    "\\instance RatField : DiscreteOrderedField Rat {\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\n  | + => (RatField.+)\n  | * => (RatField.*)\n  | negative => RatField.negative\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\n  | natCoef => \\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\n  | decideEq => \\lam (x : E {\\this}) (y : E {\\this}) => (\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\with {\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\n    | no p, d => no {x = y} (\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\n    | d, no q => no {x = y} (\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\n  })\n  | meet => meet\n  | join => join\n  | isPos => \\lam (x : E {\\this}) => isPos (ratNom x)\n  | #0=>eitherPosOrNeg => \\lam {x : E {\\this}} (xInv : #0 {\\this} x) => (\\case x, xInv \\with {\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\n      (\\lam (n1=0 : n1 = zro) => (\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\n        (\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\n          (\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\n          {n1} {zro} n1=0 il) \\with {}))\n  })\n  | finv => RatField.finv\n  | eitherZeroOrInv => \\lam (x : E {\\this}) => (\\case decideEq {\\this} x (zro {\\this}) \\with {\n    | yes x=0 => byLeft {x = zro {\\this}} {Inv x} x=0\n    | no x/=0 => byRight {x = zro {\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\this} x) (finv-right {\\this} {x} x/=0))\n  })\n} => \\new DiscreteOrderedField {\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | negative-left => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n  | zeroProduct => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | join-left => {?hidden}\n  | join-right => {?hidden}\n  | join-univ => {?hidden}\n  | zro/>0 => {?hidden}\n  | positive_+ => {?hidden}\n  | ide>zro => {?hidden}\n  | positive_* => {?hidden}\n  | *-comm => {?hidden}\n  | finv_zro => {?hidden}\n  | finv-right => {?hidden}\n}",
    "inP A",
    "\\func ratPoint \\hlevels  (x : Rat) : CompleteFilter (PresentedFrame (RealPres RatField)) (\\lam (U : E {A {\\this}}) => TruncP (\\Sigma (x1 : E) (U.1 x1) (\n  \\let (a, b) => x1\n  \\in \\Sigma (a < x) (x < b)))) => framePres-point {RealPres RatField} (\\lam (p0 : E) => (\n  \\let (a, b) => p0\n  \\in \\Sigma (a < x) (x < b))) {?hidden} {?hidden} {?hidden}",
    "\\instance RatDenseOrder \\hlevels  : UnboundedDenseLinearOrder.Dec Rat {\n  | < => (OrderedAddGroup.<)\n  | meet => meet\n  | join => join\n  | # => \\lam (x : E) (y : E) => #0 (x - y)\n  | decideEq => \\lam (x : E) (y : E) => (\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\with {\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\n    | no p, d => no {x = y} (\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\n    | d, no q => no {x = y} (\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\n  })\n  | trichotomy => \\lam (x : E) (y : E) => (\\case +_trichotomy (x - y) \\with {\n    | less x-y<0 => less {RatField} {x} {y} (fromNeg {RatField} {x} {y} (<0_neg {RatField} {x - y} x-y<0))\n    | equals x-y=0 => equals {RatField} {x} {y} (fromZero {RatField} {x} {y} x-y=0)\n    | greater x-y>0 => greater {RatField} {x} {y} (>0_pos {RatField} {x - y} x-y>0)\n  })\n} => \\new UnboundedDenseLinearOrder.Dec {\n  | <-irreflexive => {?hidden}\n  | <-transitive => {?hidden}\n  | isDense => {?hidden}\n  | withoutUpperBound => {?hidden}\n  | withoutLowerBound => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | join-left => {?hidden}\n  | join-right => {?hidden}\n  | join-univ => {?hidden}\n  | #-irreflexive => {?hidden}\n  | #-symmetric => {?hidden}\n  | #-comparison => {?hidden}\n  | tightness => {?hidden}\n  | nonEqualApart => {?hidden}\n}",
    "\\func points^* \\hlevels  {L : Locale} (a : L.E) : Set (CompleteFilter L) => \\lam (x : CompleteFilter L) => x.F a",
    "| \\infix 4 < E E : \\Prop",
    "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I",
    "\\func embed \\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\Sigma} (\\lam (_ : \\Sigma) => x)",
    "\\data Cover \\hlevels  {P : FramePres} P.E {J : \\Set} (J -> P.E) : \\Prop \n  | cover-basic (P.BasicCover {J} x g)\n  | cover-inj (j : J) (g j = x)\n  | cover-trans {I : \\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\Pi (i : I) -> Cover {P} (f i) {J} g)\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\n  | cover-idemp (j : J) (g j = P.conj x x)\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\Pi (j : J) -> g j = P.conj a (f j))",
    "cover-inj (j : J) (g j = x)",
    "| isDense {x z : E} (x < z) : TruncP (\\Sigma (y : E) (x < y) (y < z))",
    "\\func dec<_<= \\hlevels  {A : Dec} (a a' : A.E) : Or (a A.< a') (a' <= a) => \\case A.trichotomy a a' \\with {\n  | less a<a' => inl {a A.< a'} {a' <= a} a<a'\n  | equals a=a' => inr {a A.< a'} {a' <= a} (transportInv {A.E} ((<=) a') {a} {a'} a=a' (A.<-irreflexive {a'}))\n  | greater a'<a => inr {a A.< a'} {a' <= a} (A.<=-less {a'} {a} a'<a)\n}",
    "\\instance PresentedFrame \\hlevels  (P : FramePres) : Locale (Opens P) {\n  | <= => (PresentedFrame.<=)\n  | meet => \\lam (U : E {\\this}) (V : E {\\this}) =>\n    closure {P} {\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\lam (t : \\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\n  | top => (\\lam (_ : P.E) => \\Sigma, \\lam (e : P.E) (_ : SCover {P} e (\\lam (_ : P.E) => \\Sigma)) => ())\n  | Join => \\lam {J : \\Set} (f : J -> E {\\this}) =>\n    closure {P} {\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\lam (p0 : \\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\n} => \\new Locale {\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top-univ => {?hidden}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n}",
    "| E : \\Set",
    "\\instance RealPres \\hlevels  (Q : Dec) : FramePres (Interval Q) {\n  | conj => (\u2227)\n  | BasicCover => Indexing {\\Sigma (x : Bool) (if {\\Set} x (\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\Sigma Q.E Q.E))} {Interval Q}\n    (\\lam (p0 : \\Sigma (x : Bool) (if {\\Set} x (\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\Sigma Q.E Q.E))) =>\n    (\\case p0 \\with {\n      | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\lam (p0 : Fin 2) => (\\case p0 \\with {\n        | zero => (p, q)\n        | suc zero => (r, s)\n      }))\n      | (false, (p, q)) => (\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\n        \\lam (t : \\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\n    }))\n} => \\new FramePres",
    "\\type \\infix 4 <= \\hlevels  {A : StrictPoset} (a a' : A.E) : \\Prop => Not (a' A.< a)",
    "\\lemma cover-empty \\hlevels  {Q : Dec} {x : Interval Q} (_ : x.2 Q.<= x.1) {J : \\Set} {g : J -> Interval Q} : Cover {RealPres Q} x {J} g "
  ]
}
model output: 
\n  (cover-empty {RealPres RatField} (embed {RealPres RatField} a) c) \n  (cover-inj {RealPres RatField} (embed {RealPres RatField} a) c) \n  (cover-trans {RealPres RatField} (embed {RealPres RatField} a) c) \n  (cover-proj1 {RealPres RatField} (embed {RealPres RatField} a) c) \n  (cover-idemp {RealPres RatField} (embed {RealPres RatField} a) c) \n  (cover-comm {RealPres RatField} (embed {RealPres RatField} a) c) \n  (cover-ldistr {RealPres RatField} (embed {RealPres RatField} a) c) \n  (cover-ldistr>= {RealPres RatField} (embed {RealPres RatField} a) c) \n  (cover-proj2 {RealPres RatField} (embed {RealPres RatField} a) c) \n  (cover-proj3 {RealPres RatField} (embed {RealPres RatField} a) c) \n 
