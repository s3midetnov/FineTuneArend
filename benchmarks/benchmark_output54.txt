index = 54

the query:{
  "Context": [
    "M : UniformLocale"
  ],
  "Expected type": "UniformLocale (Opens (CompletionPres M)) {\n  | <= => (<=)\n  | meet => \\lam (U : E) (V : E) =>\n    closure {CompletionPres M} {\\Sigma (a b : E) (U.1 a) (V.1 b)} (\\lam (t : \\Sigma (a b : E) (U.1 a) (V.1 b)) => conj t.1 t.2)\n  | top => (\\lam (_ : E) => \\Sigma, \\lam (e : E) (_ : SCover {CompletionPres M} e (\\lam (_ : E) => \\Sigma)) => ())\n  | Join => \\lam {J : \\Set} (f : J -> E) =>\n    closure {CompletionPres M} {\\Sigma (j : J) (x : E) ((f j).1 x)} (\\lam (p0 : \\Sigma (j : J) (x : E) ((f j).1 x)) => p0.2)\n  | isUniform => isUniform {M}\n}",
  "Expression": "Completion M",
  "Premises": [
    "\\func closure \\hlevels  {P : FramePres} {J : \\Set} (g : J -> P.E) : Opens P \n=> (\\lam (p0 : P.E) => Cover {P} p0 {J} g, \\lam (x : P.E) (c : SCover {P} x (\\lam (p0 : P.E) => Cover {P} p0 {J} g)) =>\n  cover-trans {P} {x} {J} {g} {\\Sigma (x : P.E) (Cover {P} x {J} g)} {\\lam (t : \\Sigma (x : P.E) (Cover {P} x {J} g)) => t.1} c (\\lam (p0 : \\Sigma (x : P.E) (Cover {P} x {J} g)) => p0.2))",
    "| conj E E : E",
    "\\func CompletionLocale \\hlevels  (L : UniformLocale) : Locale (Opens (CompletionPres L)) {\n  | <= => (<=)\n  | meet => \\lam (U : E {\\this}) (V : E {\\this}) =>\n    closure {CompletionPres L} {\\Sigma (a b : E) (U.1 a) (V.1 b)} (\\lam (t : \\Sigma (a b : E) (U.1 a) (V.1 b)) => conj t.1 t.2)\n  | top => (\\lam (_ : E) => \\Sigma, \\lam (e : E) (_ : SCover {CompletionPres L} e (\\lam (_ : E) => \\Sigma)) => ())\n  | Join => \\lam {J : \\Set} (f : J -> E {\\this}) =>\n    closure {CompletionPres L} {\\Sigma (j : J) (x : E) ((f j).1 x)} (\\lam (p0 : \\Sigma (j : J) (x : E) ((f j).1 x)) => p0.2)\n} => PresentedFrame (CompletionPres L)",
    "\\func SCover \\hlevels  {this : FramePres} (x : E) (U : E -> \\Prop) : \\Prop \n  => Cover x {\\Sigma (x : E) (U x)} (\\lam (t : \\Sigma (x : E) (U x)) => t.1)",
    "\\func CompletionPres \\hlevels  (L : UniformLocale) : FramePres L.E {\n  | conj => (L.\u2227)\n  | BasicCover => Indexing {\\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\Sigma (U : L.E -> \\Prop) (L.isUniform U)) :: L.E :: nil} j)} {L.E}\n    (\\lam (p0 : \\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\Sigma (U : L.E -> \\Prop) (L.isUniform U)) :: L.E :: nil} j)) =>\n    (\\case p0 \\with {\n      | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => L.top)\n      | (suc zero, a) => (IsPositive {L} a, a, \\lam (_ : IsPositive {L} a) => a)\n      | (suc (suc zero), U) => (\\Sigma (x : L.E) (U.1 x), L.top, \\lam (p0 : \\Sigma (x : L.E) (U.1 x)) => p0.1)\n      | (suc (suc (suc zero)), a) => (\\Sigma (b : L.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : L.E) (b <=u a)) => p0.1)\n    }))\n} => \\new FramePres",
    "\\func Completion (L : UniformLocale) : UniformLocale (Opens (CompletionPres L)) {\n  | <= => (PresentedFrame.<=)\n  | meet => \\lam (U : E) (V : E) =>\n    closure {CompletionPres L} {\\Sigma (a b : E) (U.1 a) (V.1 b)} (\\lam (t : \\Sigma (a b : E) (U.1 a) (V.1 b)) => conj t.1 t.2)\n  | top => (\\lam (_ : E) => \\Sigma, \\lam (e : E) (_ : SCover {CompletionPres L} e (\\lam (_ : E) => \\Sigma)) => ())\n  | Join => \\lam {J : \\Set} (f : J -> E) =>\n    closure {CompletionPres L} {\\Sigma (j : J) (x : E) ((f j).1 x)} (\\lam (p0 : \\Sigma (j : J) (x : E) ((f j).1 x)) => p0.2)\n  | isUniform => Completion.isUniform {L}\n} => \\new UniformLocale {\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top-univ => {?hidden}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n  | isAdmissible => {?hidden}\n}",
    "\\type Opens \\hlevels  (P : FramePres) : \\Set => \\Sigma (U : P.E -> \\Prop) (\\Pi (x : P.E) -> SCover {P} x U -> U x)",
    "| E : \\Set",
    "\\class UniformLocale \\extends PreuniformLocale \\hlevels  {\n  | isAdmissible (b : E) : b <= SJoin (\\lam (_x : E) => _x <=u b)\n}",
    "\\func isUniform {L : UniformLocale} (V : E -> \\Prop) : \\Prop \n=> TruncP (\\Sigma (U : L.E -> \\Prop) (L.isUniform U) (\\Pi {a : L.E} -> U a -> V (embed {CompletionPres L} a))\n  (\\Pi {x y : E} -> V y -> x <= y -> V x))",
    "\\type \\infix 4 <= \\hlevels  {P : FramePres} (U V : Opens P) : \\Prop => \\Pi {x : P.E} -> U.1 x -> V.1 x"
  ]
}
model output: 
=> \new UniformLocale {\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | top-univ => {?hidden}\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Join-ldistr>= => {?hidden}\n  | uniform-overt => {?hidden}\n  | isCovering => {?hidden}\n  | isDownset => {?hidden}\n  | top-uniform => {?hidden}\n  | meet-uniform => {?hidden}\n  | <=-uniform => {?hidden}\n  | star-uniform => {?hidden}\n  | isAdmissible => {?hidden}\n}<<<Expected type:>>> \new UniformLocale {\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-un
