index = 87

the query:{
  "Context": [
    "I : DirectedSet",
    "U0 : U Y.zro",
    "X : CoverSpace",
    "Y : TopAbGroup",
    "U : Set Y.E",
    "Uo : Y.isOpen U",
    "fc : \\Pi {U : Set Y.E} -> Y.isOpen U -> U Y.zro -> X.isCauchy (\\lam (V : Set X.E) =>\n  TruncP (\\Sigma (N : I.E) (\\Pi {x : X.E} -> V x -> \\Pi {n : I.E} -> N I.<= n -> U (func {f n} x - func {f N} x))))",
    "f : I.E -> CoverMap X Y"
  ],
  "Expected type": "X.isCauchy (\\lam (V : Set X.E) =>\n  TruncP (\\Sigma (N : I.E) (\\Pi {x : X.E} -> V x -> \\Pi {n : I.E} -> N I.<= n -> U (func {Y.negative-cont} (func {f n} x - func {f N} x)))))",
  "Expression": "fc (func-cont {negative-cont} Uo) (simplify U0)",
  "Premises": [
    "\\lemma negative_zro \\hlevels  {this : AddGroup} : negative zro = zro ",
    "\\func transport {A : \\Type} (B : A -> \\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\lam (i : I) => B (p @ i)) b right",
    "| isCauchy (Set (Set E)) : \\Prop",
    "\\func Set \\hlevels  (X : \\hType) : \\Set => X -> \\Prop",
    "| \\infix 4 <= E E : \\Prop",
    "| func-cont {U : E {Cod} -> \\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\lam (x : E {Dom}) => U (func x))",
    "\\data TruncP \\Type \n  | inP A\n  | truncP (_ _ : TruncP A) I",
    "| negative-cont : ContMap \\this \\this {\n  | func => negative\n}",
    "| zro : E",
    "\\func \\infixl 6 - \\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y",
    "\\func inv {A1 : \\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \n  | {A}, {a}, {a'}, idp => idp {A} {a}",
    "| E : \\Set",
    "| func (E {Dom}) : E {Cod}",
    "| negative E : E"
  ]
}
model output: 
<|endoftext|>\n  (\\lam (V : Set X.E) => TruncP (\Sigma (N : I.E) (\Pi {x : X.E} -> V x -> \Pi {n : I.E} -> N I.<= n -> U (func {Y.negative-cont} (func {f n} x - func {f N} x)))))')<<<Expected value:>>> X.isCauchy (\lam (V : Set X.E) =>
  TruncP (\Sigma (N : I.E) (\Pi {x : X.E} -> V x -> \Pi {n : I.E} -> N I.<= n -> U (func {Y.negative-cont} (func {f n} x - func {f N} x)))))')<<<Proof:>>> \case \infixl 6 - \hlevels  {this : AddGroup} (x y : E) : E => x E.+ E.negative y, \infixl 8 <= E E : \Prop, \infixl 7 * E E : E, \infixl 6 + E E : E, \infixl 7 mod E E : E, \infix
