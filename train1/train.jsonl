{"prompt": "['D : Inv {MatrixRing R 2}', 'null : R.zro = at {at {C.val product makeMatrix {R.E} {1} {2} ((a :: b :: nil) :: nil) product D.val} 0} 1', 'a : R.E', 'b : R.E', 'R : CRing', 'C : Inv {MatrixRing R 1}']<<<break>>>['| zro : E', '\\\\func makeMatrix {R : \\\\Type} {n m : Nat} (M : Array (Array R m) n) : Matrix R n m => M', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| val : E {M}', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', '\\\\func \\\\infixl 7 product \\\\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))']<<<break>>>R.zro - at {at {C.val product makeMatrix {R.E} {1} {2} ((a :: b :: nil) :: nil) product D.val} 0} 1 = R.zro", "completion": "toZero {R} {R.zro} {BigSum {R} (\\new Array R.E 2 (\\lam (j : Fin 2) => BigSum {R}\n  (\\new Array R.E 1 (\\lam (j1 : Fin 1) => C.val !! 0 !! j1 R.* makeMatrix {R.E} {1} {2} ((a :: b :: nil) :: nil) !! j1 !! j)) R.* D.val !! j !! 1))}\n  p"}
{"prompt": "['a : E', 'this : EuclideanSemiringData', 'e : (divMod b a).2 = zro', 'b : E']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| divMod E E : \\\\Sigma E E', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| zro-right {x : E} : x + zro = x', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| isDivMod (x y : E) : y * (divMod x y).1 + (divMod x y).2 = x']<<<break>>>LDiv a b (divMod b a).1 {\n  | inv-right => {?hidden}\n}", "completion": "\\new LDiv {\n  | inv => (divMod {this} b a).1\n  | inv-right => later (rewrite e $ inv (zro-right {this})) *> isDivMod {this} b a\n}"}
{"prompt": "['X : StronglyRegularUniformSpace', 'CU : C U', 'Cp : \\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (e : X.E) (U e))', 'U : Set X.E']<<<break>>>['\\\\lemma inhabited_weaklyProper \\\\hlevels  {this : PreuniformSpace} (_ : TruncP E) : IsWeaklyProperUniform ', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func StronglyRegularUniformTransfer \\\\hlevels  {X : \\\\Set} {Y : StronglyRegularUniformSpace} (f : X -> Y.E) : StronglyRegularUniformSpace X {\\n  | isOpen => \\\\lam (U : Set E) => TruncP (\\\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\\n  | isCauchy => \\\\lam (C : Set (Set E)) => Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set E) (C U) (f ^-1 V \u2286 U)))\\n  | isUniform => \\\\lam (C : Set (Set E)) => Y.isUniform (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set E) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new StronglyRegularUniformSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cover => {?hidden}\\n  | uniform-top => {?hidden}\\n  | uniform-refine => {?hidden}\\n  | uniform-inter => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | uniform-strongly-star => {?hidden}\\n}', '| bottom : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>\\Pi {C : Set (Set (E {StronglyRegularUniformTransfer {\\Sigma (x : X.E) (U x)} {X} (\\lam (p0 : \\Sigma (x : X.E) (U x)) => p0.1)}))} ->\nisUniform {StronglyRegularUniformTransfer {\\Sigma (x : X.E) (U x)} {X} (\\lam (p0 : \\Sigma (x : X.E) (U x)) => p0.1)}\n  (\\lam (U1 : Set (E {StronglyRegularUniformTransfer {\\Sigma (x : X.E) (U x)} {X} (\\lam (p0 : \\Sigma (x : X.E) (U x)) => p0.1)})) =>\n    (U1 = bottom) || C U1) ->\n  isUniform {StronglyRegularUniformTransfer {\\Sigma (x : X.E) (U x)} {X} (\\lam (p0 : \\Sigma (x : X.E) (U x)) => p0.1)} C", "completion": "inhabited_weaklyProper (Cp CU)"}
{"prompt": "['dec : Dec D.E {\\n  | zro => D.zro\\n  | + => (D.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (D.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => D.negative\\n  | negative-left => {?hidden}\\n  | ide => D.ide\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => D.natCoef\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | #0 => D.#0\\n  | #0-zro => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zro#ide => {?hidden}\\n  | #0-* => {?hidden}\\n  | *-comm => {?hidden}\\n}', 'x : D.E', 'D : GCDDomain', 'gcd : GCD {dec} x y', 'env : Array dec.E 5']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| res : E {M}', '\\\\func iterr {A1 : \\\\Type} (_ : A1 -> A1) (_ : Nat) (_ : A1) : A1 \\n  | {A}, f, 0, a => a\\n  | {A}, f, suc n, a => f (iterr {A} f n a)', 'nil', '| inv : E {M}', '| inv-right : val * inv = elem', '\\\\func sort \\\\hlevels  {A : Dec} (l : List A.E) : List A.E => rbTreeToList {A.E} (aux {A} l (rbLeaf {A.E})) (nil {A.E})', '\\\\infixl 7 :* (_ _ : Term n)', '| \\\\infixl 7 * E E : E', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func interpretNF \\\\hlevels  {M2 : Monoid} {V1 : \\\\Set} (_ : V1 -> M.E) (_ : List V1) : M.E \\n  | {M}, {V}, env, nil => M.ide\\n  | {M}, {V}, env, x :: nil => env x\\n  | {M}, {V}, env, x :: l => env x M.* interpretNF {M} {V} env l', '| res|val1 : LDiv {M} res val1', '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| normalize {n : Nat} (Term n) : NF n', '\\\\lemma apply-axiom \\\\hlevels  {M : CMonoid} (env : Array M.E) (t s : Term env.len)\\n  (_ : interpret {M} {env.len} env.at t = interpret {M} {env.len} env.at s) (n : Nat) (add : List (Fin env.len)) :\\n  interpretNF {M} {Fin env.len} env.at (sort {FinOrder env.len} (iterr {List (Fin env.len)} ((++) (normalize {env.len} t)) n add)) = interpretNF {M} {Fin env.len} env.at (sort {FinOrder env.len} (iterr {List (Fin env.len)} ((++) (normalize {env.len} s)) n add)) ', '| E : \\\\Set', 'var (Fin n)', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func MonoidSolverModel \\\\hlevels  (M1 : Monoid) : SubstSolverModel M.E {\\n  | Term => MonoidSolverModel.Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => \\\\lam {n : Nat} (t : SolverModel.Term {\\\\this} n) => normalize-aux {n} t (nil {Fin n})\\n  | interpret => MonoidSolverModel.interpret {M1}\\n  | interpretNF => \\\\lam {n : Nat} => MonoidSolverModel.interpretNF {M1} {Fin n}\\n  | nfVar => \\\\lam {n : Nat} (v : Fin n) => v :: nil {Fin n}\\n  | >>= => \\\\lam {m : Nat} {n : Nat} => (>>=)\\n} => \\\\new SubstSolverModel {\\n  | interpretNF-consistent => {?hidden}\\n  | >>=-consistent => {?hidden}\\n}']<<<break>>>interpretNF {dec} {Fin env.len} env.at\n  (sort {FinOrder env.len} (iterr {List (Fin env.len)} ((++) (normalize {env.len} (var {env.len} 0))) 1 (1 :: nil {Fin 5}))) = interpretNF {dec} {Fin env.len} env.at (sort {FinOrder env.len}\n  (iterr {List (Fin env.len)} ((++) (normalize {env.len} (var {env.len} 4 :* var {env.len} 2))) 1 (1 :: nil {Fin 5})))", "completion": "apply-axiom env (var 0) (var 4 :* var 2)\n  (Paths.inv {D.E} {gcd.res dec.* Monoid.DivBase.inv {gcd.res|val1}} {x} (inv-right {gcd.res|val1})) 1 (1 :: nil)"}
{"prompt": "['tc : TheoremContext', 'msubst : MetaSubstitution (tc.envs color) context (rule-mc {tc.rules color} {s} idx) mc', 'color : E {tc.Color}', \"s : tc.Sort'\", \"subst : MetaSubstitution (env {tc}) (nil {tc.Sort'}) mc (EmptyMetaContext {env {tc}})\", 'idx : rule-J {tc.rules color} s', \"context : List tc.Sort'\", \"mc : MetaContext tc.Sort'\"]<<<break>>>['| rules (c : E {Color}) : LinearRegistry (envs c)', \"| Sort' : \\\\Set\", 'nil', '\\\\func identity {A2 : \\\\Type} {list1 : List A2} : SubList {A2} list1 list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})', '\\\\func sublist-nil-free {A2 : \\\\Type} {list1 : List A2} : SubList {A2} (nil {A2}) list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-skip {A} {nil {A}} {a} {list} (sublist-nil-free {A} {list})', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| metaname Sort : \\\\Set', '| rule-container {s : Sort {env}} (rule-J s) : RewriteRule {env} s', \"\\\\lemma metacommutation \\\\hlevels  {env : FSignature} {context context' : List env.Sort} {s : env.Sort} {mc mc' mc'' : MetaContext env.Sort}\\n  (msubst : MetaSubstitution env context' mc mc') (msubst2 : MetaSubstitution env (nil {env.Sort}) mc' mc'')\\n  (t : Term env context s mc) (sublist : SubList {env.Sort} context' context) :\\napply {env} {context} {context'} {s} {mc} {mc''} t sublist (\\\\lam {s : env.Sort} (m : mc.metaname s) =>\\n  apply {env} {context' ++ mc.m-domain {s} m} {nil {env.Sort}} {s} {mc'} {mc''} (msubst {s} m)\\n    (sublist-nil-free {env.Sort} {context' ++ mc.m-domain {s} m}) msubst2) = apply {env} {context} {nil {env.Sort}} {s} {mc'} {mc''} (apply {env} {context} {context'} {s} {mc} {mc'} t sublist msubst)\\n  (sublist-nil-free {env.Sort} {context}) msubst2 \", '| E : \\\\Set', \"\\\\func rule-linear-mc \\\\hlevels  {this : TheoremContext} {s : Sort'} {c : E {Color}} (idx : rule-J {rules c} s) : MetaContext (Sort {envs c}) \\n  => LinearMetaContext {envs c} {nil {Sort'}} {s} {Empty} (get-rule-pattern {s} {c} idx)\", '| m-domain {s : Sort} (metaname s) : List Sort', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func apply \\\\hlevels  {env3 : FSignature} {context3 core-context2 : List env.Sort} {s3 : env.Sort}\\n  {old-metacontext2 new-metacontext3 : MetaContext env.Sort} (_ : Term env3 context3 s3 old-metacontext2)\\n  (_ : SubList {env.Sort} core-context2 context3)\\n  (_ : MetaSubstitution env3 core-context2 old-metacontext2 new-metacontext3) : Term env3 context3 s3 new-metacontext3 \\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, var index p, sublist, subst =>\\n    var {env} {context} {s} {new-metacontext} index p\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, metavar m arguments, sublist, subst =>\\n  Substitution.apply {env} {s} {core-context ++ old-metacontext.m-domain {s} m} {new-metacontext} (subst {s} m) {context}\\n    (extend-substitution-left {env} {core-context} {old-metacontext.m-domain {s} m} {context} {new-metacontext} sublist\\n      (\\\\lam (i : Index {env.Sort} (old-metacontext.m-domain {s} m)) => MetaSubstitution.apply\\n        {env} {context} {core-context} {old-metacontext.m-domain {s} m !! i} {old-metacontext} {new-metacontext} (arguments.at i)\\n          sublist subst))\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, func f arguments, sublist, subst =>\\n  func {env} {context} {s} {new-metacontext} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) new-metacontext)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => MetaSubstitution.apply\\n      {env} {context ++ f !!domain i} {core-context} {f !!sort i} {old-metacontext} {new-metacontext} (arguments.at i)\\n        (extend-right-single {env.Sort} {core-context} {context} sublist {f !!domain i}) subst))', \"\\\\func get-rule-pattern \\\\hlevels  {this : TheoremContext} {s : Sort'} {c : E {Color}} (idx : rule-J {rules c} s) : LinearPattern (envs c) (nil {Sort'}) s \\n  => rule-pattern {rules c} {s} idx\", '| Sort : \\\\Set', '\\\\func inject-term \\\\hlevels  {J3 Sort4 : \\\\Set} (S3 : J3 -> FSignature {\\n  | Sort => Sort4\\n}) {s3 : Sort4} {c3 : List Sort4} {mc3 : MetaContext Sort4} {j2 : J3} (_ : Term (S3 j2) c3 s3 mc3) :\\n  Term (SumFSignature {J3} {Sort4} S3) c3 s3 mc3 \\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, var index p => var {SumFSignature {J} {Sort1} S} {c} {s} {mc} index p\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, metavar m args =>\\n  metavar {SumFSignature {J} {Sort1} S} {c} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term (SumFSignature {J} {Sort1} S) c (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => inject-term {J} {Sort1} S {mc.m-domain {s} m !! i} {c} {mc} {j} (args.at i)))\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, func f args => func {SumFSignature {J} {Sort1} S} {c} {s} {mc} (j, f)\\n    (\\\\new DArray {FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f)}\\n      (\\\\lam (index : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        Term (SumFSignature {J} {Sort1} S) (c ++ (j, f) !!domain index) ((j, f) !!sort index) mc)\\n      (\\\\lam (i : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        inject-term {J} {Sort1} S {(j, f) !!sort i} {c ++ (j, f) !!domain i} {mc} {j} (args.at i)))', '\\\\func EmptyMetaContext \\\\hlevels  {env : FSignature} : MetaContext env.Sort {\\n  | metaname => \\\\lam (_ : MetaContext.Sort {\\\\this}) => Empty\\n  | m-domain => \\\\lam {s : MetaContext.Sort {\\\\this}} (e : metaname {\\\\this} s) => (\\\\case e \\\\with {})\\n} => \\\\new MetaContext', \"\\\\func weakening \\\\hlevels  {env3 : FSignature} {s'3 : env.Sort} {narrow-context3 wide-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Term env3 narrow-context3 s'3 mc3) (_ : SubList {env.Sort} narrow-context3 wide-context3) :\\n  Term env3 wide-context3 s'3 mc3 \\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, var index p, sublist =>\\n  var {env} {wide-context} {s'} {mc} (shift-index {env.Sort} {narrow-context} {wide-context} sublist index)\\n    (proof {env.Sort} {narrow-context} {wide-context} {s'} sublist index p)\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, metavar m arguments, sublist =>\\n  metavar {env} {wide-context} {s'} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s'} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s'} m)) => Term env wide-context (mc.m-domain {s'} m !! index) mc)\\n    (\\\\lam (i1 : Fin (MetaContext.arity {mc} {s'} m)) =>\\n      weakening {env} {mc.m-domain {s'} m !! i1} {narrow-context} {wide-context} {mc} (arguments.at i1) sublist))\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, func f arguments, sublist =>\\n  func {env} {wide-context} {s'} {mc} f (\\\\new DArray {FSignature.arity {env} {s'} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s'} f)) => Term env (wide-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i1 : Fin (FSignature.arity {env} {s'} f)) =>\\n    weakening {env} {f !!sort i1} {narrow-context ++ f !!domain i1} {wide-context ++ f !!domain i1} {mc} (arguments.at i1)\\n      (extend-right-both {env.Sort} {narrow-context} {wide-context} sublist {f !!domain i1})))\", '| rr-pattern : LinearPattern env (nil {Sort {env}}) s', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\func convert-to-term \\\\hlevels  {env3 : FSignature} {context3 : List env.Sort} {s3 : env.Sort} {allowVariables3 : \\\\Prop}\\n  (term : GenericLinearTerm env3 context3 s3 allowVariables3) :\\n  Term env3 context3 s3 (LinearMetaContext {env3} {context3} {s3} {allowVariables3} term) \\n  | {env}, {context}, {s}, {allowVariables}, l-func f arguments => func {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-func {env} {context} {s} {allowVariables} f arguments)} f\\n    (\\\\new DArray {FSignature.arity {env} {s} f}\\n      (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index)\\n        (LinearMetaContext {env} {context} {s} {allowVariables} (l-func {env} {context} {s} {allowVariables} f arguments)))\\n      (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => upgrade-metavariables\\n        {env} {context ++ f !!domain i} {f !!sort i} {length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f)} {i}\\n          (\\\\lam (i : Fin (length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f))) =>\\n            LinearMetaContext {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))\\n          (convert-to-term {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))))\\n  | {env}, {context}, {s}, {allowVariables}, l-var index p a => var {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-var {env} {context} {s} {allowVariables} index p a)} index p\\n  | {env}, {context}, {s}, {allowVariables}, l-full-metavar => metavar {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})}\\n    (idp {env.Sort} {s}) (\\\\new DArray {MetaContext.arity\\n      {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n        (idp {env.Sort} {s})}\\n        (\\\\lam (index : Fin (MetaContext.arity\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}))) => Term env context\\n          (m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}) !! index)\\n          (LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})))\\n        (\\\\lam (i : Fin (MetaContext.arity\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}))) => var {env} {context}\\n          {m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}) !! i}\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} i\\n          (idp {env.Sort}\\n            {m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n              (idp {env.Sort} {s}) !! i})))', '| Color : DecSet', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func LinearMetaContext \\\\hlevels  {env3 : FSignature} {context2 : List env.Sort} {s2 : env.Sort} {allowVariables1 : \\\\Prop}\\n  (_ : GenericLinearTerm env3 context2 s2 allowVariables1) : MetaContext env.Sort \\n  | {env}, {context}, {s}, {allowVariables}, l-func f arguments =>\\n  ModularMetaContext {env} {length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f)}\\n    (\\\\lam (i : Fin (length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f))) =>\\n      LinearMetaContext {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))\\n  | {env}, {context}, {s}, {allowVariables}, l-var index p a => EmptyMetaContext {env}\\n  | {env}, {context}, {s}, {allowVariables}, l-full-metavar => SingularMetaContext {env} s context', \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", \"\\\\instance env \\\\hlevels  {this1 : TheoremContext} : FSignature {\\n  | Sort => Sort'\\n  | symbol => \\\\lam (s : Sort {\\\\this}) => \\\\Sigma (j : E {Color}) (symbol {envs j} s)\\n  | domain => \\\\lam {s : Sort {\\\\this}} (symb : symbol {\\\\this} s) => domain {envs symb.1} {s} symb.2\\n} => SumFSignature {E {Color}} {Sort'} envs\"]<<<break>>>apply {env {tc}} {context} {context} {s}\n  {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)}\n  {EmptyMetaContext {env {tc}}} (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context}\n    {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {color}\n    (weakening {tc.envs color} {s} {nil {tc.Sort'}} {context}\n      {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)}\n      (convert-to-term {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (rr-pattern {rule-container {tc.rules color} {s} idx}))\n      (sublist-nil-free {tc.Sort'} {context}))) (identity {tc.Sort'} {context}) (\\lam {s1 : Sort}\n    (m : metaname {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} s1) =>\n  apply {env {tc}}\n    {context ++ m-domain {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {s1} m}\n    {nil {Sort}} {s1} {mc} {EmptyMetaContext {env {tc}}} ((\\lam {s1 : Sort}\n      (m : metaname {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} s1) =>\n    inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s1} {context ++ m-domain {rule-linear-mc {tc} {s} {color} idx} {s1} m} {mc} {color}\n      (msubst {s1} m)) {s1} m)\n    (sublist-nil-free {Sort}\n      {context ++ m-domain {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {s1} m})\n    subst) = apply {env {tc}} {context} {nil {Sort}} {s} {mc} {EmptyMetaContext {env {tc}}} (apply {env {tc}} {context} {context} {s}\n  {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {mc}\n  (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context}\n    {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {color}\n    (weakening {tc.envs color} {s} {nil {tc.Sort'}} {context}\n      {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)}\n      (convert-to-term {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (rr-pattern {rule-container {tc.rules color} {s} idx}))\n      (sublist-nil-free {tc.Sort'} {context}))) (identity {tc.Sort'} {context}) (\\lam {s1 : Sort}\n    (m : metaname {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} s1) =>\n  inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s1} {context ++ m-domain {rule-linear-mc {tc} {s} {color} idx} {s1} m} {mc} {color}\n    (msubst {s1} m))) (sublist-nil-free {Sort} {context}) subst", "completion": "metacommutation _ _ _ _"}
{"prompt": "['this : TopLModule']<<<break>>>['| ide : E', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| negative E : E', '\\\\lemma neg_ide_*c \\\\hlevels  {this : LModule} {a : E} : negative {R} (ide {R}) *c a = negative a ', '| R : Ring']<<<break>>>\\Pi (a : E) -> negative {R} (ide {R}) *c a = negative a", "completion": "\\lam a => neg_ide_*c {this}"}
{"prompt": "['h : \\\\Pi {x : E {Dom}} -> U {norm {Dom} x} delta -> U {norm {Cod} (func x)} eps', 'this : UniformNormedAbGroupMap', 'eps : Rat', 'delta : Rat']<<<break>>>[\"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| dist E E : ExUpperReal', '| norm-dist {x y : E} : dist x y = norm (x - y)', '| Cod : BaseSet', '\\\\lemma func-minus \\\\hlevels  {this : AddGroupHom} {x y : E {Dom}} : func (x - y) = func x - func y ', '| norm E : ExUpperReal', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| U Rat : \\\\Prop', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>\\Pi {x x' : E {Dom}} -> U {dist {Dom} x x'} delta -> U {dist {Cod} (func x) (func x')} eps", "completion": "unfold (\\lam d => rewrite (norm-dist {Cod {this}}, inv (func-minus {this})) $ h $ rewriteI (norm-dist {Dom {this}}) d)"}
{"prompt": "['d : D.E', 'D : BottomJoinSemilattice', 'F : Functor D MonoidCat']<<<break>>>['| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', \"\\\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D MonoidCat} (d : D.E) : MonoidHom (F.F d) (MonoidLatticeColimit {D} F1) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) =>\\n  in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\\n} => \\\\new MonoidHom {\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}\", '| Dom : BaseSet']<<<break>>>\\Pi {x y : E {Dom {inMap {D} {F} d}}} ->\n  func {inMap {D} {F} d} (x * y) = func {inMap {D} {F} d} x * func {inMap {D} {F} d} y", "completion": "func-* {inMap {D} {F} d}"}
{"prompt": "['x : E', 'this : RealPreBanachSpace']<<<break>>>['\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma *n_* \\\\plevels  \\\\hlevels  {n : Nat} {x : ExUpperReal} (_ : zro <= x) (_ : IsBounded {x}) : n *n x = fromRat (fromInt (pos n)) * x ', '\\\\lemma norm>=0 \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : zro <= X.norm x ', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '| norm-bounded (x : E) : IsBounded {norm x}', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a', 'pos Nat']<<<break>>>2 *n norm x = fromRat (fromInt (pos 2)) * norm x", "completion": "*n_* norm>=0 (norm-bounded {this} x)"}
{"prompt": "['A : RealBanachAlgebra', 'n : Nat']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\lemma pos<=pos \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n <= m) : pos n <= pos m ', 'suc Nat', '\\\\lemma finv>=0 {this : DiscreteOrderedField} {x : E} (_ : zro <= x) : zro <= finv x ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| abs>=0 {x : E} : zro <= abs x', '\\\\func fac \\\\plevels  \\\\hlevels  (_ : Nat) : Nat \\n  | 0 => 1\\n  | suc n => suc n * fac n', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', '| \\\\infixl 7 * E E : E', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '| *-comm {x y : E} : x * y = y * x', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma abs-ofPos \\\\hlevels  {this : LatticeAbGroup} {x : E} (_ : zro <= x) : abs x = x ', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\lemma finv_* {this : DiscreteField} {x y : E} : finv (x * y) = finv y * finv x ', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma natUnit \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n * m = 1) : m = 1 ', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma <=_ratNom \\\\plevels  \\\\hlevels  {x : Rat} (_ : pos 0 <= ratNom x) : fromInt (pos 0) <= x ', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', 'pos Nat', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| finv E : E', '\\\\lemma *-rat \\\\plevels  \\\\hlevels  {x y : Rat} (_ : zro <= x) (_ : zro <= y) : fromRat x ExUpperReal.* fromRat y = fromRat (x RatField.* y) ', '\\\\lemma norm_*q \\\\hlevels  {this : SeparatedPreBanachSpace} {q : Rat} {x : E} : norm (q *q x) = norm {A} q * norm x ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x']<<<break>>>A.norm (RatField.finv (rat (pos (suc n)) 1 {?hidden} {?hidden} RatField.* rat (pos (fac n)) 1 {?hidden} {?hidden}) *q A.ide) <= A.norm (RatField.finv (fromInt (pos (fac n))) *q A.ide) Semigroup.* fromRat (DiscreteField.finv (fromInt (pos (suc n))))", "completion": "=_<= (norm_*q {A} *> *-comm *> pmap ((*) _) (pmap fromRat\n  (abs-ofPos {RatField} (finv>=0 {RatField} $ <=_ratNom $ pos<=pos zero<=_) *> finv_* {RatField} {suc n} *> pmap (\\lam _x => _x * _) (inv $ abs-ofPos {RatField} $ finv>=0 {RatField} $ <=_ratNom $ pos<=pos zero<=_)) *> inv (*-rat (abs>=0 {RatField}) $ <=_ratNom $ pos<=pos zero<=_)) *> inv (pmap (\\lam _x => _x * _) (norm_*q {A} {finv (fac n)} {1} *> *-comm) *> *-assoc))"}
{"prompt": "[\"this : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (RatField.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => RatField.negative\\n  | negative-left => {?hidden}\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | zeroProduct => {?hidden}\\n  | meet => meet\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join => join\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | *-comm => {?hidden}\\n  | finv => RatField.finv\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n}\", 'denom/=0 : d1 /= 0', 'p : (\\\\case inl {n1 * pos d2 < n2 * pos d1} {n2 * pos d1 <= n1 * pos d2} _x \\\\with {\\n  | inl x<y => rat n2 d2 {?hidden} {?hidden}\\n  | inr y<=x => rat n1 d1 {?hidden} {?hidden}\\n}) < rat n2 d2 {?hidden} {?hidden}', 'denom/=0 : d2 /= 0', 'd2 : Nat', 'n1 : Int', 'd1 : Nat', 'n2 : Int', 'reduced : gcd {NatEuclidean} (iabs n1) d1 = 1', 'reduced : gcd {NatEuclidean} (iabs n2) d2 = 1', 'null : n1 * pos d2 < n2 * pos d1']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\func signum \\\\plevels  \\\\hlevels  (_ : Int) : Int \\n  | pos 0 => pos 0\\n  | pos (suc n) => pos 1\\n  | neg (suc n) => neg 1', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'inl A', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\func * (_ _ : Int) : Int \\n  | pos n, pos m => pos (n * m)\\n  | pos n, neg m => neg (n * m)\\n  | neg (suc n), pos m => neg (suc n * m)\\n  | neg (suc n), neg m => pos (suc n * m)', '\\\\func ratNom \\\\plevels  \\\\hlevels  (_ : Rat) : Int \\n  | rat n denom denom/=0 reduced => n', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>signum (ratNom (rat n2 d2 {?hidden} {?hidden} - (\\case inl {n1 * pos d2 < n2 * pos d1} {n2 * pos d1 <= n1 * pos d2} _x \\with {\n  | inl x<y => rat n2 d2 {?hidden} {?hidden}\n  | inr y<=x => rat n1 d1 {?hidden} {?hidden}\n}))) = pos 1", "completion": "unfolds p"}
{"prompt": "['M : LModule R', 'this : TopMeetSemilattice (SubLModule R1 M) {\\n  | <= => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) => \\\\Pi {a : M.E} -> U.contains a -> V.contains a\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet => SubLModuleSemilattice.meet {R1} {M}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top => topSubLModule {R1} M\\n  | top-univ => {?hidden}\\n}']<<<break>>>['| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| contains (E {S}) : \\\\Prop']<<<break>>>\\Pi {x y z : E {\\this}} -> z <= x -> z <= y -> \\Pi {a : M.E} -> z.contains a -> contains {x \u2227 y} a", "completion": "\\lam f g c => (f c, g c)"}
{"prompt": "[\"ms-a : MetaContext tc.Sort'\", \"global-context : List tc.Sort'\", \"s : tc.Sort'\", 'tc : TheoremContext', \"context : List tc.Sort'\", 'arguments : DArray {arity {ms-a} {s} m}\\n  (\\\\lam (index : Fin (arity {ms-a} {s} m)) => Term (tc.envs color) context (ms-a.m-domain {s} m !! index) ms-a)', \"sublist : SubList {tc.Sort'} global-context context\", 'm : ms-a.metaname s', 'color : E {tc.Color}', \"ms-c : MetaContext tc.Sort'\", \"ms-b : MetaContext tc.Sort'\", 'subst-a : MetaSubstitution (tc.envs color) global-context ms-a ms-b', \"subst-b : MetaSubstitution (env {tc}) (nil {tc.Sort'}) ms-b ms-c\"]<<<break>>>['\\\\func apply \\\\hlevels  {env2 : FSignature} {s2 : env.Sort} {old-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\\n  (_ : Term env2 old-context2 s2 mc2) {new-context2 : List env.Sort}\\n  (_ : Substitution {env2} old-context2 new-context2 mc2) : Term env2 new-context2 s2 mc2 \\n  | {env}, {s}, {old-context}, {mc}, var index idp, {new-context}, map => map index\\n  | {env}, {s}, {old-context}, {mc}, metavar m arguments, {new-context}, map =>\\n  metavar {env} {new-context} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term env new-context (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) =>\\n      apply {env} {mc.m-domain {s} m !! i} {old-context} {mc} (arguments.at i) {new-context} map))\\n  | {env}, {s}, {old-context}, {mc}, func f arguments, {new-context}, map =>\\n  func {env} {new-context} {s} {mc} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (new-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) =>\\n    apply {env} {f !!sort i} {old-context ++ f !!domain i} {mc} (arguments.at i) {new-context ++ f !!domain i}\\n      (append-context-right {env} {old-context} {new-context} {mc} map {f !!domain i})))', '\\\\func apply \\\\hlevels  {env3 : FSignature} {context3 core-context2 : List env.Sort} {s3 : env.Sort}\\n  {old-metacontext2 new-metacontext3 : MetaContext env.Sort} (_ : Term env3 context3 s3 old-metacontext2)\\n  (_ : SubList {env.Sort} core-context2 context3)\\n  (_ : MetaSubstitution env3 core-context2 old-metacontext2 new-metacontext3) : Term env3 context3 s3 new-metacontext3 \\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, var index p, sublist, subst =>\\n    var {env} {context} {s} {new-metacontext} index p\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, metavar m arguments, sublist, subst =>\\n  Substitution.apply {env} {s} {core-context ++ old-metacontext.m-domain {s} m} {new-metacontext} (subst {s} m) {context}\\n    (extend-substitution-left {env} {core-context} {old-metacontext.m-domain {s} m} {context} {new-metacontext} sublist\\n      (\\\\lam (i : Index {env.Sort} (old-metacontext.m-domain {s} m)) => MetaSubstitution.apply\\n        {env} {context} {core-context} {old-metacontext.m-domain {s} m !! i} {old-metacontext} {new-metacontext} (arguments.at i)\\n          sublist subst))\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, func f arguments, sublist, subst =>\\n  func {env} {context} {s} {new-metacontext} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) new-metacontext)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => MetaSubstitution.apply\\n      {env} {context ++ f !!domain i} {core-context} {f !!sort i} {old-metacontext} {new-metacontext} (arguments.at i)\\n        (extend-right-single {env.Sort} {core-context} {context} sublist {f !!domain i}) subst))', '\\\\func Index {A : \\\\Type} (list : List A) : \\\\Type => Fin (length {A} list)', '\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', '| Sort : \\\\Set', '\\\\func inject-term \\\\hlevels  {J3 Sort4 : \\\\Set} (S3 : J3 -> FSignature {\\n  | Sort => Sort4\\n}) {s3 : Sort4} {c3 : List Sort4} {mc3 : MetaContext Sort4} {j2 : J3} (_ : Term (S3 j2) c3 s3 mc3) :\\n  Term (SumFSignature {J3} {Sort4} S3) c3 s3 mc3 \\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, var index p => var {SumFSignature {J} {Sort1} S} {c} {s} {mc} index p\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, metavar m args =>\\n  metavar {SumFSignature {J} {Sort1} S} {c} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term (SumFSignature {J} {Sort1} S) c (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => inject-term {J} {Sort1} S {mc.m-domain {s} m !! i} {c} {mc} {j} (args.at i)))\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, func f args => func {SumFSignature {J} {Sort1} S} {c} {s} {mc} (j, f)\\n    (\\\\new DArray {FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f)}\\n      (\\\\lam (index : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        Term (SumFSignature {J} {Sort1} S) (c ++ (j, f) !!domain index) ((j, f) !!sort index) mc)\\n      (\\\\lam (i : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        inject-term {J} {Sort1} S {(j, f) !!sort i} {c ++ (j, f) !!domain i} {mc} {j} (args.at i)))', \"| Sort' : \\\\Set\", 'nil', '\\\\func sublist-nil-free {A2 : \\\\Type} {list1 : List A2} : SubList {A2} (nil {A2}) list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-skip {A} {nil {A}} {a} {list} (sublist-nil-free {A} {list})', \"\\\\lemma commutation \\\\hlevels  {tc : TheoremContext} {term-context context : List tc.Sort'} {s : tc.Sort'} {ms-a ms-b : MetaContext tc.Sort'}\\n  (metasubst : MetaSubstitution (env {tc}) (nil {tc.Sort'}) ms-a ms-b)\\n  (subst : Substitution {env {tc}} term-context context ms-a) (T : Term (env {tc}) term-context s ms-a) :\\nMetaSubstitution.apply {env {tc}} {context} {nil {tc.Sort'}} {s} {ms-a} {ms-b}\\n  (Substitution.apply {env {tc}} {s} {term-context} {ms-a} T {context} subst) (sublist-nil-free {tc.Sort'} {context})\\n  metasubst = Substitution.apply {env {tc}} {s} {term-context} {ms-b} (MetaSubstitution.apply\\n  {env {tc}} {term-context} {nil {tc.Sort'}} {s} {ms-a} {ms-b} T (sublist-nil-free {tc.Sort'} {term-context}) metasubst)\\n  {context} (\\\\lam (i : Index {Sort} term-context) => MetaSubstitution.apply\\n    {env {tc}} {context} {nil {tc.Sort'}} {term-context !! i} {ms-a} {ms-b} (subst i) (sublist-nil-free {tc.Sort'} {context})\\n      metasubst) \", '\\\\func extend-substitution-left \\\\hlevels  {env2 : FSignature} {left-context2 right-context2 some-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\\n  (_ : SubList {env.Sort} left-context2 some-context2) (_ : Substitution {env2} right-context2 some-context2 mc2)\\n  (j2 : Index {env.Sort} (left-context2 ++ right-context2)) :\\n  Term env2 some-context2 ((left-context2 ++ right-context2) !! j2) mc2 \\n  | {env}, {nil}, {right-context}, {some-context}, {mc}, sublist, chooser, j => chooser j\\n  | {env}, {a :: left-context}, {right-context}, {some-context}, {mc}, sublist, chooser, zero =>\\n  weakening {env} {((a :: left-context) ++ right-context) !! 0} {a :: left-context} {some-context} {mc}\\n    (var {env} {a :: left-context} {((a :: left-context) ++ right-context) !! 0} {mc} 0\\n      (idp {env.Sort} {((a :: left-context) ++ right-context) !! 0})) sublist\\n  | {env}, {a :: left-context}, {right-context}, {some-context}, {mc}, sublist, chooser, suc j => extend-substitution-left\\n    {env} {left-context} {right-context} {some-context} {mc} (shrink {env.Sort} {a} {left-context} {some-context} sublist)\\n      chooser j', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '| Color : DecSet', '| at (j : Fin len) : A j', \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", \"\\\\instance env \\\\hlevels  {this1 : TheoremContext} : FSignature {\\n  | Sort => Sort'\\n  | symbol => \\\\lam (s : Sort {\\\\this}) => \\\\Sigma (j : E {Color}) (symbol {envs j} s)\\n  | domain => \\\\lam {s : Sort {\\\\this}} (symb : symbol {\\\\this} s) => domain {envs symb.1} {s} symb.2\\n} => SumFSignature {E {Color}} {Sort'} envs\", '| E : \\\\Set', '| m-domain {s : Sort} (metaname s) : List Sort', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys']<<<break>>>MetaSubstitution.apply {env {tc}} {context} {nil {tc.Sort'}} {s} {ms-b} {ms-c}\n  (Substitution.apply {env {tc}} {s} {global-context ++ ms-a.m-domain {s} m} {ms-b}\n    (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {global-context ++ ms-a.m-domain {s} m} {ms-b} {color} (subst-a {s} m))\n    {context} (\\lam (ind : Index {Sort} (global-context ++ ms-a.m-domain {s} m)) =>\n    inject-term {E {tc.Color}} {tc.Sort'} tc.envs {(global-context ++ ms-a.m-domain {s} m) !! ind} {context} {ms-b} {color}\n      (extend-substitution-left {tc.envs color} {global-context} {ms-a.m-domain {s} m} {context} {ms-b} sublist\n        (\\lam (i : Index {Sort {tc.envs color}} (ms-a.m-domain {s} m)) => MetaSubstitution.apply\n          {tc.envs color} {context} {global-context} {ms-a.m-domain {s} m !! i} {ms-a} {ms-b} (arguments.at i) sublist subst-a)\n        ind))) (sublist-nil-free {tc.Sort'} {context}) subst-b = Substitution.apply {env {tc}} {s} {global-context ++ ms-a.m-domain {s} m} {ms-c}\n  (MetaSubstitution.apply {env {tc}} {global-context ++ ms-a.m-domain {s} m} {nil {tc.Sort'}} {s} {ms-b} {ms-c}\n    (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {global-context ++ ms-a.m-domain {s} m} {ms-b} {color} (subst-a {s} m))\n    (sublist-nil-free {tc.Sort'} {global-context ++ ms-a.m-domain {s} m}) subst-b) {context}\n  (\\lam (i : Index {Sort} (global-context ++ ms-a.m-domain {s} m)) => MetaSubstitution.apply\n    {env {tc}} {context} {nil {tc.Sort'}} {(global-context ++ ms-a.m-domain {s} m) !! i} {ms-b} {ms-c}\n      ((\\lam (ind : Index {Sort} (global-context ++ ms-a.m-domain {s} m)) =>\n      inject-term {E {tc.Color}} {tc.Sort'} tc.envs {(global-context ++ ms-a.m-domain {s} m) !! ind} {context} {ms-b} {color}\n        (extend-substitution-left {tc.envs color} {global-context} {ms-a.m-domain {s} m} {context} {ms-b} sublist\n          (\\lam (i : Index {Sort {tc.envs color}} (ms-a.m-domain {s} m)) => MetaSubstitution.apply\n            {tc.envs color} {context} {global-context} {ms-a.m-domain {s} m !! i} {ms-a} {ms-b} (arguments.at i) sublist subst-a)\n          ind)) i) (sublist-nil-free {tc.Sort'} {context}) subst-b)", "completion": "commutation subst-b\n  (\\lam ind => inject-term envs (extend-substitution-left {envs color} sublist (\\lam i => apply {envs color} (arguments i) sublist subst-a) ind))\n  (inject-term envs (subst-a m))"}
{"prompt": "['a : E {f.Cod}', 'f : AddPointedHom R E', 'E : Ring', 'l : Array (E {f.Dom})']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>Array E.E l.len (\\lam (j : Fin l.len) => f.func (l.at j) E.* pow {E1} a j)", "completion": "\\lam j => f (l j) * pow a j"}
{"prompt": "['q1<b : fromRat q1 < S.3', 'q1 : E', 'S : IntervalSubset']<<<break>>>['| \\\\infix 4 <= E E : \\\\Prop', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| <_join-univ {x y z : E} (x < z) (y < z) : x \u2228 y < z']<<<break>>>fromRat q1 \u2228 S.2 <= S.3", "completion": "<=-less (<_join-univ q1<b S.4)"}
{"prompt": "[\"subst : Substitution {env} add-context context mc'\", 'fin : Index {env.Sort} add-context', \"mc' : MetaContext env.Sort\", 'env : FSignature', \"context' : List env.Sort\", \"sublist : SubList {env.Sort} context' context\", 'add-context : List env.Sort', 'context : List env.Sort']<<<break>>>['\\\\lemma on-end \\\\hlevels  {env : FSignature} {left-context right-context some-context : List env.Sort} {mc : MetaContext env.Sort}\\n  (sublist : SubList {env.Sort} left-context some-context) (subst : Substitution {env} right-context some-context mc)\\n  (j : Index {env.Sort} right-context) :\\nextend-substitution-left {env} {left-context} {right-context} {some-context} {mc} sublist subst\\n  (expand-fin-right {env.Sort} {left-context} {right-context} j) = transport {env.Sort} (\\\\lam (p0 : env.Sort) => Term env some-context p0 mc) {right-context !! j}\\n  {(left-context ++ right-context) !! expand-fin-right {env.Sort} {left-context} {right-context} j}\\n  (inv {env.Sort} {(left-context ++ right-context) !! expand-fin-right {env.Sort} {left-context} {right-context} j}\\n    {right-context !! j} (correct {env.Sort} {left-context} {right-context} j)) (subst j) ', '\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', '\\\\func expand-fin-right {A1 : \\\\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \\n  | {A}, {nil}, {b}, i => i\\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| Sort : \\\\Set', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func extend-substitution-left \\\\hlevels  {env2 : FSignature} {left-context2 right-context2 some-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\\n  (_ : SubList {env.Sort} left-context2 some-context2) (_ : Substitution {env2} right-context2 some-context2 mc2)\\n  (j2 : Index {env.Sort} (left-context2 ++ right-context2)) :\\n  Term env2 some-context2 ((left-context2 ++ right-context2) !! j2) mc2 \\n  | {env}, {nil}, {right-context}, {some-context}, {mc}, sublist, chooser, j => chooser j\\n  | {env}, {a :: left-context}, {right-context}, {some-context}, {mc}, sublist, chooser, zero =>\\n  weakening {env} {((a :: left-context) ++ right-context) !! 0} {a :: left-context} {some-context} {mc}\\n    (var {env} {a :: left-context} {((a :: left-context) ++ right-context) !! 0} {mc} 0\\n      (idp {env.Sort} {((a :: left-context) ++ right-context) !! 0})) sublist\\n  | {env}, {a :: left-context}, {right-context}, {some-context}, {mc}, sublist, chooser, suc j => extend-substitution-left\\n    {env} {left-context} {right-context} {some-context} {mc} (shrink {env.Sort} {a} {left-context} {some-context} sublist)\\n      chooser j', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\func correct {A2 : \\\\Type} {a b2 : List A2} (i2 : Index {A2} b2) : (a ++ b2) !! expand-fin-right {A2} {a} {b2} i2 = b2 !! i2 \\n  | {A}, {nil}, {b}, i => idp {A} {(nil {A} ++ b) !! expand-fin-right {A} {nil {A}} {b} i}\\n  | {A}, {a :: a1}, {b}, i => correct {A} {a1} {b} i']<<<break>>>extend-substitution-left\n  {env} {context'} {add-context} {context} {mc'} sublist subst (expand-fin-right {env.Sort} {context'} {add-context} fin) = transport {env.Sort} (\\lam (p0 : env.Sort) => Term env context p0 mc') {add-context !! fin}\n  {(context' ++ add-context) !! expand-fin-right {env.Sort} {context'} {add-context} fin}\n  (inv {env.Sort} {(context' ++ add-context) !! expand-fin-right {env.Sort} {context'} {add-context} fin} {add-context !! fin}\n    (correct {env.Sort} {context'} {add-context} fin)) (subst fin)", "completion": "on-end _ _ _"}
{"prompt": "[\"f : LinearMap {R} E (SubLRepres.S {Maschke'sLemma.S})\", \"this : Maschke'sLemma\"]<<<break>>>['| E : LinRepres R G', '| S : LinRepres R G', '| R : CRing', '| \\\\infixl 8 ** (E {G}) E : E', '\\\\class LinearMap \\\\extends AddGroupHom \\\\hlevels  {\\n  | R : Ring\\n  | func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x\\n}', '| G : FinGroup', '\\\\func adjust {R1 : CRing} {G : FinGroup} {A B : LinRepres R1 G} (g : G.E) (f : LinearMap {R1} A B) : LinearMap {R1} A B {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => g B.** f.func (G.inverse g A.** a)\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '| inverse E : E', '| S : SubLRepres {R} {G} E']<<<break>>>\\Pi (g : BaseSet.E {G}) -> LinearMap {R} Maschke'sLemma.E (SubLRepres.S {Maschke'sLemma.S}) {\n  | func => \\lam (a : BaseSet.E {Dom {\\this}}) => g ** f.func (inverse {G} g ** a)\n}", "completion": "\\lam g => adjust g f"}
{"prompt": "['color : E {tc.Color}', \"context-a : List tc.Sort'\", \"context-c : List tc.Sort'\", \"mc : MetaContext tc.Sort'\", 'subst : Substitution {tc.envs color} context-b context-c mc', \"i1 : Index {tc.Sort'} context-a\", \"sublist : SubList {tc.Sort'} context-a context-c\", 'tc : TheoremContext', \"context-b : List tc.Sort'\"]<<<break>>>['\\\\func correct {A2 : \\\\Type} {a3 b2 : List A2} (i1 : Index {A2} a3) : (a3 ++ b2) !! expand-fin-left {A2} {a3} {b2} i1 = a3 !! i1 \\n  | {A}, {a :: a1}, {b}, zero => idp {A} {((a :: a1) ++ b) !! expand-fin-left {A} {a :: a1} {b} 0}\\n  | {A}, {a :: a1}, {b}, suc i => correct {A} {a1} {b} i', '\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| Sort : \\\\Set', \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", '\\\\func expand-fin-left {A1 : \\\\Type} {a b1 : List A1} (_ : Index {A1} a) : Index {A1} (a ++ b1) \\n  | {A}, {a :: l}, {b}, zero => 0\\n  | {A}, {a :: l}, {b}, suc i => suc (expand-fin-left {A} {l} {b} i)', \"\\\\func weakening \\\\hlevels  {env3 : FSignature} {s'3 : env.Sort} {narrow-context3 wide-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Term env3 narrow-context3 s'3 mc3) (_ : SubList {env.Sort} narrow-context3 wide-context3) :\\n  Term env3 wide-context3 s'3 mc3 \\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, var index p, sublist =>\\n  var {env} {wide-context} {s'} {mc} (shift-index {env.Sort} {narrow-context} {wide-context} sublist index)\\n    (proof {env.Sort} {narrow-context} {wide-context} {s'} sublist index p)\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, metavar m arguments, sublist =>\\n  metavar {env} {wide-context} {s'} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s'} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s'} m)) => Term env wide-context (mc.m-domain {s'} m !! index) mc)\\n    (\\\\lam (i1 : Fin (MetaContext.arity {mc} {s'} m)) =>\\n      weakening {env} {mc.m-domain {s'} m !! i1} {narrow-context} {wide-context} {mc} (arguments.at i1) sublist))\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, func f arguments, sublist =>\\n  func {env} {wide-context} {s'} {mc} f (\\\\new DArray {FSignature.arity {env} {s'} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s'} f)) => Term env (wide-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i1 : Fin (FSignature.arity {env} {s'} f)) =>\\n    weakening {env} {f !!sort i1} {narrow-context ++ f !!domain i1} {wide-context ++ f !!domain i1} {mc} (arguments.at i1)\\n      (extend-right-both {env.Sort} {narrow-context} {wide-context} sublist {f !!domain i1})))\", 'var (index : Index {env.Sort} context) (termSort = context !! index)', '\\\\lemma on-begin \\\\hlevels  {env : FSignature} {left-context right-context some-context : List env.Sort} {mc : MetaContext env.Sort}\\n  (sublist : SubList {env.Sort} left-context some-context) (subst : Substitution {env} right-context some-context mc)\\n  (j : Index {env.Sort} left-context) :\\nextend-substitution-left {env} {left-context} {right-context} {some-context} {mc} sublist subst\\n  (expand-fin-left {env.Sort} {left-context} {right-context} j) = weakening {env} {(left-context ++ right-context) !! expand-fin-left {env.Sort} {left-context} {right-context} j} {left-context}\\n  {some-context} {mc}\\n  (var {env} {left-context} {(left-context ++ right-context) !! expand-fin-left {env.Sort} {left-context} {right-context} j}\\n    {mc} j (correct {env.Sort} {left-context} {right-context} j)) sublist ', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func extend-substitution-left \\\\hlevels  {env2 : FSignature} {left-context2 right-context2 some-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\\n  (_ : SubList {env.Sort} left-context2 some-context2) (_ : Substitution {env2} right-context2 some-context2 mc2)\\n  (j2 : Index {env.Sort} (left-context2 ++ right-context2)) :\\n  Term env2 some-context2 ((left-context2 ++ right-context2) !! j2) mc2 \\n  | {env}, {nil}, {right-context}, {some-context}, {mc}, sublist, chooser, j => chooser j\\n  | {env}, {a :: left-context}, {right-context}, {some-context}, {mc}, sublist, chooser, zero =>\\n  weakening {env} {((a :: left-context) ++ right-context) !! 0} {a :: left-context} {some-context} {mc}\\n    (var {env} {a :: left-context} {((a :: left-context) ++ right-context) !! 0} {mc} 0\\n      (idp {env.Sort} {((a :: left-context) ++ right-context) !! 0})) sublist\\n  | {env}, {a :: left-context}, {right-context}, {some-context}, {mc}, sublist, chooser, suc j => extend-substitution-left\\n    {env} {left-context} {right-context} {some-context} {mc} (shrink {env.Sort} {a} {left-context} {some-context} sublist)\\n      chooser j', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))']<<<break>>>extend-substitution-left {tc.envs color} {context-a} {context-b} {context-c} {mc} sublist subst\n  (expand-fin-left {Sort {tc.envs color}} {context-a} {context-b} i1) = weakening {tc.envs color} {(context-a ++ context-b) !! expand-fin-left {Sort {tc.envs color}} {context-a} {context-b} i1}\n  {context-a} {context-c} {mc} (var {tc.envs color} {context-a}\n    {(context-a ++ context-b) !! expand-fin-left {Sort {tc.envs color}} {context-a} {context-b} i1} {mc} i1\n    (correct {Sort {tc.envs color}} {context-a} {context-b} i1)) sublist", "completion": "on-begin {envs color} _ _ _"}
{"prompt": "['R : E {A} -> E {A} -> \\\\Prop', 'q : \\\\Pi {V U : E {A}} -> R1 V U -> TruncP (\\\\Sigma (W : E {A}) (R1 V W) (R W U))', 'this : RatherBelow']<<<break>>>['| R (E {A}) (E {A}) : \\\\Prop', '| <=-refl {x : E} : x <= x', '| <=<-left {U V W : E {A}} (R U V) (V <= W) : R U W', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| E : \\\\Set', '| A : TopMeetSemilattice', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {V U : E {A}} -> TruncP (\\Sigma (U' : E {A}) (R1 V U') (U' <= U)) ->\n  TruncP (\\Sigma (W : E {A}) (TruncP (\\Sigma (U' : E {A}) (R1 V U') (U' <= W))) (R W U))", "completion": "\\lam p0 => (\\case \\elim p0 \\with {\n  | inP (U', RVU', U'<=U) => \\case q RVU' \\with {\n    | inP (W, RVW, W<=<U') => inP (W, inP (W, RVW, <=-refl), <=<-left {this} W<=<U' U'<=U)\n  }\n})"}
{"prompt": "['y : X.E', 'X : PseudoNormedAbGroup']<<<break>>>['\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', '\\\\func lnorm \\\\hlevels  {X : PseudoNormedAbGroup} (x : X.E) : Real => X.norm x', '| E : \\\\Set', '| negative E : E', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>negative (negative (lnorm {X} y)) = lnorm {X} y", "completion": "negative-isInv {_} {lnorm {X} y}"}
{"prompt": "['this : HausdorffTopPoset', 'b : E']<<<break>>>['\\\\type IsClosed \\\\hlevels  {this : TopSpace} (U : Set E) : \\\\Prop => \\\\Pi {x : E} -> IsLimitPoint x U -> U x', '\\\\lemma <=-closed-left \\\\hlevels  {this : HausdorffTopPoset} {b : E} : IsClosed (\\\\lam (_x : E) => _x <= b) ', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set']<<<break>>>IsClosed (\\lam (_x : E) => _x <= b)", "completion": "<=-closed-left {this}"}
{"prompt": "['L : Locale', 'x : L.E', 'a : L.E', 'y : L.E', 'Ut : p0.1.1 t', 'U_Up : \\\\Sigma (b : Opens (colimit-obj {Precat.op {DiscretePrecat (Fin 2)}}\\n  (Comp {Precat.op {DiscretePrecat (Fin 2)}} {FrameBicat} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n    (Functor.op {functor {Fin 2} {LocaleCat} (at {L :: L :: nil})})))) (func {diagonal {LocaleCat} L} b L.<= a)', 'q : Cover1 {colimit-obj {Precat.op {DiscretePrecat (Fin 2)}}\\n  (Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n    (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: L :: nil))}))} (fpair {L} {L} x y) t', 't : E']<<<break>>>['\\\\func fpair {L M : Locale} (a : L.E) (b : M.E) : FTerm {Precat.op {DiscretePrecat (Fin 2)}}\\n  (Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n    (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})) => fconj {Precat.op {DiscretePrecat (Fin 2)}}\\n  {Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n    (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})}\\n  (finj {Precat.op {DiscretePrecat (Fin 2)}}\\n    {Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n      (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})} {0} a)\\n  (finj {Precat.op {DiscretePrecat (Fin 2)}}\\n    {Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n      (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})} {1} b)', '\\\\instance colimit-obj {J : Precat} (G : Functor J FrameUPresCat) : FrameUPres (FTerm {J} G) {\\n  | conj => fconj {J} {G}\\n  | BasicCover => \\\\lam {K : \\\\Set} (x : E {\\\\this}) (f : K -> E {\\\\this}) =>\\n  (\\\\Sigma (j : J.Ob) (y : E {G.F j}) (g : K -> E {G.F j}) (BasicCover {G.F j} {K} y g) (x = finj {J} {G} {j} y)\\n    (\\\\Pi (k : K) -> f k = finj {J} {G} {j} (g k))) || ((K, f) = (\\\\Sigma, \\\\lam (_ : \\\\Sigma) => funit {J} {G}))\\n  | unit => funit {J} {G}\\n} => \\\\new FrameUPres {\\n  | isUnit => {?hidden}\\n}', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '\\\\lemma diagonal_func {L : Locale} (U : E {apex {Bprod L L}}) :\\n  func {diagonal {LocaleCat} L} U = SJoin {L} (\\\\lam (x : L.E) => U.1 (fpair {L} {L} x x)) ', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func functor \\\\plevels obj >= hom {J : \\\\Type} {D : Precat} (G : J -> D.Ob) : Functor (DiscretePrecat J) D G {\\n  | Func => map {J} {D} G\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func SJoin \\\\hlevels  {this : CompleteLattice} (U : E -> \\\\Prop) : E => Join {\\\\Sigma (b : E) (U b)} (\\\\lam (t : Total {E} U) => t.1)', '\\\\lemma cover-trans1 \\\\hlevels  {P : FramePres} {x : P.E} {J : \\\\Set} {g : J -> P.E} {y : P.E} (_ : Cover1 {P} x y) (_ : Cover {P} y {J} g) :\\n  Cover {P} x {J} g ', \"\\\\lemma cover-conj1 \\\\hlevels  {P : FramePres} {a a' b b' : P.E} (_ : Cover1 {P} a a') (_ : Cover1 {P} b b') : Cover1 {P} (P.conj a b) (P.conj a' b') \", '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\lemma cover-proj2 \\\\hlevels  {P : FramePres} {x : P.E} {J : \\\\Set} {g : J -> P.E} {a b : P.E} (_ : x = P.conj a b) (j : J) (_ : g j = b) :\\n  Cover {P} x {J} g ', '\\\\func Total {B : \\\\Type} (F : B -> \\\\Type) : \\\\Type => \\\\Sigma (b : B) (F b)', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', 'finj {j : J.Ob} (E {G.F j})', 'cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)', '\\\\func diagonal \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} (x : Ob) : Hom x (apex {Bprod x x}) => pair {x} {x} {x} (id x) (id x)', '| E : \\\\Set', \"\\\\data FTerm {J : Precat} (Functor J FrameUPresCat) : \\\\Set \\n  | finj {j : J.Ob} (E {G.F j})\\n  | fconj (FTerm {J} G) (FTerm {J} G)\\n  | funit\\n  | finj-eq {j j' : J.Ob} (J.Hom j j') (E {G.F j}) I\\n  | fconj-eq {j : J.Ob} (_ _ : E {G.F j}) I\\n  | funit-eq {j : J.Ob} I\", '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\func FrameUnitalReflectiveSubcat : ReflectiveSubPrecat FrameCat FrameUPresCat FrameUnitalSubcat.F {\\n  | Func => FrameUnitalSubcat.Func\\n  | reflector => reflector\\n  | reflectorMap => \\\\lam (X : Ob {D {\\\\this}}) => \\\\new FrameUPresHom X (Functor.F {\\\\this} (reflector {\\\\this} X)) {\\n    | func => embed {X}\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | isReflective => \\\\lam {X : Ob {D {\\\\this}}} {Y : Ob {C {\\\\this}}} =>\\n  \\\\new QEquiv {Hom {C {\\\\this}} (reflector {\\\\this} X) Y} {Hom {D {\\\\this}} X (Functor.F {\\\\this} Y)}\\n    (\\\\lam (p0 : A {\\\\this}) => Functor.Func {\\\\this} {reflector {\\\\this} X} {Y} p0 \u2218 ReflectiveSubPrecat.reflectorMap {\\\\this} X) {\\n    | ret => ret {isReflective {X} {Y}}\\n    | ret_f => ret_f {isReflective {X} {Y}}\\n    | f_sec => \\\\lam (h : B {\\\\this}) => path (\\\\lam (i : I) => (\\n      \\\\have arg => path (\\\\lam (i : I) => func {f_ret {isReflective {X} {Y}} h @ i})\\n      \\\\in \\\\new FrameUPresHom X (Functor.F {\\\\this} Y) {\\n            | func => arg @ i\\n            | func-conj => {?hidden}\\n            | func-basicCover => {?hidden}\\n            | func-unit => {?hidden}\\n          }))\\n  }\\n} => \\\\new ReflectiveSubPrecat {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n}', '\\\\class Locale \\\\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\\\hlevels  {\\n  | Join-ldistr>= {J : \\\\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\\\lam (j : J) => e \u2227 f j)\\n  | basicCover-stable => \\\\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\\\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\\n    meet-univ {x} {Join {J} (\\\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\\\lam (j : J) => (g j).1} {x}\\n  | ldistr>= => \\\\lam {x : E} {y : E} {z : E} => (\\n    \\\\have t => path (\\\\lam (i : I) (b : Bool) => (\\\\case b \\\\with {\\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\\n          }) @ i)\\n    \\\\in transportInv\\n        {Bool -> E} (\\\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\\n          {\\\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\\\lam (b : Bool) => x \u2227 if {E} b y z} t\\n          (Join-ldistr>= {Bool} {\\\\lam (p0 : Bool) => if {E} p0 y z} {x}))\\n  | Meet-cond => \\\\lam {J : \\\\Set} (j : J) {f : J -> E} =>\\n  Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n    {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)\\n  | join-left => \\\\lam {x : E} {y : E} => Join-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | join-right => \\\\lam {x : E} {y : E} => Join-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | Meet-univ => \\\\lam {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) =>\\n  Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n    {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  | join-univ => \\\\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\\n  Join-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n    | true => x<=z\\n    | false => y<=z\\n  }))\\n  | join => \\\\lam (x : E) (y : E) => Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)\\n  | Meet => \\\\lam {J : \\\\Set} (g : J -> E) =>\\n    Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)\\n  | isBasicCover => \\\\lam (x : Ob) {J : \\\\Set} (g : J -> Ob) => x <= Join {J} (\\\\lam (j : J) => (g j).1)\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| conj E E : E', 'fconj (FTerm {J} G) (FTerm {J} G)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Join {J : \\\\Set} (J -> E) : E', 'fconj-eq {j : J.Ob} (_ _ : E {G.F j}) I', '\\\\func FrameBicat : BicompleteCat Locale {\\n  | Hom => FrameHom\\n  | id => \\\\lam (L : Ob) => \\\\new FrameHom L L {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n  }\\n  | o => FrameCat.o\\n  | pullback => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} (f : Hom {\\\\this} X Z) (g1 : Hom {\\\\this} Y Z) =>\\n  \\\\new Pullback {X} {Y} {Z} f g1 (pullback-obj {X} {Y} {Z} f g1) {\\n    | pbProj1 => proj1 {f.Dom} {g.Dom} {f.Cod} {f} {g1}\\n    | pbProj2 => proj2 {f.Dom} {g.Dom} {f.Cod} {f} {g1}\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {Pullback.D {\\\\this}}} (p1 : Hom {Pullback.D {\\\\this}} w (x {\\\\this})) (p2 : Hom {Pullback.D {\\\\this}} w (y {\\\\this}))\\n      (c : Pullback.f {\\\\this} Precat.\u2218 p1 = g {\\\\this} Precat.\u2218 p2) => \\\\new FrameHom w (Pullback.apex {\\\\this}) {\\n      | func => \\\\lam (x : E {Dom {\\\\this}}) => (p1.func x, p2.func x, path (\\\\lam (i : I) => func {c @ i} x))\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | terminal => fromLimit {Empty} (limit {\\\\this} {DiscretePrecat Empty} (functor {Empty} (absurd {Ob {\\\\this}})))\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J1 : Precat} (G1 : Functor J1 this4) => \\\\new Limit {J1} G1 (limit-obj {J1} G1) {\\n    | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => \\\\new FrameHom (Cone.apex {\\\\this}) (F {G {\\\\this}} j) {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => P.1 j\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | coneCoh => {?hidden}\\n    | isLimit => {?hidden}\\n    | limMap => limMap-impl\\n    | limBeta => {?hidden}\\n    | limUnique => {?hidden}\\n  }\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this4) => reflectiveSubPrecatColimit\\n    {J} FrameUnitalReflectiveSubcat G (colimit {J} (Comp {J} {FrameUPresCat} FrameUnitalReflectiveSubcat G))\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func DiscretePrecat (X : \\\\Type) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Trunc0 (x = y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => in0 {x = x} (idp {X} {x})\\n  | o => o {X}\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', 'right', '\\\\instance FrameUPresCat : Cat FrameUPres {\\n  | Hom => FrameUPresHom\\n  | id => \\\\lam (X : Ob {\\\\this}) => \\\\new FrameUPresHom X X {\\n    | func => \\\\lam (x : X.E) => x\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new FrameUPresHom X Z {\\n    | func => \\\\lam (x : X.E) => g.func (f.func x)\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func SCover \\\\hlevels  {this : FramePres} (x : E) (U : E -> \\\\Prop) : \\\\Prop \\n  => Cover x {\\\\Sigma (x : E) (U x)} (\\\\lam (t : \\\\Sigma (x : E) (U x)) => t.1)', 'cover-inj (j : J) (g j = x)', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", 'left', '| func (E {Dom}) : E {Cod}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>x L.\u2227 y L.<= a", "completion": "Join-cond (later (_,\n  U.2 _ $ unfold fpair $ repeat {2} (rewrite (path (fconj-eq x y))) $ cover-trans1 (cover-conj1 (cover-proj1 idp () idp) (cover-proj2 idp () idp)) $ cover-trans1 q $ cover-inj (t, Ut) idp)) <=\u2218 =_<= (inv (diagonal_func U)) <=\u2218 Up"}
{"prompt": "['R : CRing', 'x : E.E', 'SR : \\\\Pi (x : R.E) -> S.contains (f.func x)', 'E : CRing', 'd : \\\\Sigma (c : Array (E {R}) l.len)\\n  ((E.ide, S.contains_ide) = BigSum {homLModule (corestrict {S1} {R1} f SR)} (\\\\new Array E l.len (\\\\lam (i : Fin l.len) => c.at i *c l.at i)))', 'S : SubRing E', 'l : Array E', 'f : RingHom R E']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func corestrict \\\\hlevels  {this2 : SubRing} {R : Ring} (f : RingHom R S) (p : \\\\Pi (x : R.E) -> contains (f.func x)) : RingHom R IRing {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, p x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func homLModule \\\\hlevels  (f : RingHom) : LModule f.Dom (E {f.Cod}) {\\n  | zro => zro {f.Cod}\\n  | + => (+) {f.Cod}\\n  | negative => negative {f.Cod}\\n  | *c => \\\\lam (x : E {R {\\\\this}}) => (*) (f.func x)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '| at (j : Fin len) : A j', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '\\\\lemma BigSum-ldistr \\\\hlevels  {this : Semiring} {x : E} {l : Array E} : x * BigSum l = BigSum (map {E} {E} ((*) x) l) ', '| contains (E {S}) : \\\\Prop']<<<break>>>x E.* BigSum {E1} (map {\\Sigma (x : E.E) (S.contains x)} {E.E} (\\lam (p0 : \\Sigma (x : E.E) (S.contains x)) => p0.1)\n  (\\new Array (\\Sigma (x : E.E) (S.contains x)) l.len (\\lam (i : Fin l.len) => at {d.1} i *c l.at i))) = BigSum {E1}\n  (map {E.E} {E.E} ((E.*) x) (map {\\Sigma (x : E.E) (S.contains x)} {E.E} (\\lam (p0 : \\Sigma (x : E.E) (S.contains x)) => p0.1)\n    (\\new Array (\\Sigma (x : E.E) (S.contains x)) l.len (\\lam (i : Fin l.len) => at {d.1} i *c l.at i))))", "completion": "BigSum-ldistr {E}"}
{"prompt": "['c : Limit {Precat.op {J}} {Precat.op {I.D}} (Functor.op {Comp {J} {I.C} {I.D} (\\\\new I {}) F})', 'I : ReflectiveSubPrecat', 'J : Precat', 'j : Ob {J {\\\\this}}', \"h : Hom {J {\\\\this}} j j'\", 'F : Functor J I.C', \"j' : Ob {J {\\\\this}}\"]<<<break>>>['| reflectorMap (X : Ob {D}) : Hom {D} X (F (reflector X))', '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\lemma inverse-right \\\\plevels obj >= hom \\\\hlevels  {this : FullyFaithfulFunctor} {X Y : Ob {C}} {f : Hom {D} (F X) (F Y)} : Func {X} {Y} (inverse {X} {Y} f) = f ', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '\\\\func inverse \\\\plevels obj >= hom \\\\hlevels  {this : FullyFaithfulFunctor} {X Y : Ob {C}} (f : Hom {D} (F X) (F Y)) : Hom {C} X Y => ret {isFullyFaithful {X} {Y}} f', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| D : Precat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\class ReflectiveSubPrecat \\\\extends FullyFaithfulFunctor, RightAdjointUnit \\\\plevels obj >= hom \\\\hlevels  {\\n  | reflector (Ob {D}) : Ob {Functor.C}\\n  | reflectorMap (X : Ob {D}) : Hom {D} X (F (reflector X))\\n  \\\\field isReflective {X : Ob {D}} {Y : Ob {Functor.C}} : Equiv {Hom {Functor.C} (reflector X) Y} {Hom {D} X (F Y)} (\\\\lam (p0 : A {\\\\this}) => Func {reflector X} {Y} p0 \u2218 reflectorMap X)\\n  | eta => \\\\new NatTrans {D} {D} (Id {D}) (Comp {D} {Functor.C} {D} (\\\\new this9 {}) LAdj) {\\n    | trans => reflectorMap\\n    | natural => {?hidden}\\n  }\\n  | LAdj => \\\\new Functor D Functor.C reflector {\\n    | Func => \\\\lam {X : Ob {Functor.C {\\\\this}}} {Y : Ob {Functor.C {\\\\this}}} (h : Hom {Functor.C {\\\\this}} X Y) =>\\n      ret {isReflective {X} {reflector Y}} (reflectorMap Y \u2218 h)\\n    | Func-id => {?hidden}\\n    | Func-o => {?hidden}\\n  }\\n  | eta-adjoint => isReflective\\n}', '| reflector (Ob {D}) : Ob {C}', '| C : Precat', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>I.Func {F.F j} {I.reflector c.apex} (inverse {I1} {F.F j} {I.reflector c.apex} (I.reflectorMap c.apex \u2218 c.coneMap j)) \u2218 I.Func {F.F j'} {F.F j} (Func {j} {j'} h) = I.Func {F.F j'} {I.reflector c.apex} (inverse {I1} {F.F j'} {I.reflector c.apex} (I.reflectorMap c.apex \u2218 c.coneMap j'))", "completion": "rewrite (inverse-right {I}) (rewrite (inverse-right {I}) (rewrite o-assoc (pmap ((\u2218) _) (coneCoh {c} h))))"}
{"prompt": "['y : Real', 'z : Real', 'eps : Real', 'x : Real']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func half \\\\hlevels  (x : Real) : Real => x * fromRat (ratio (pos 1) 2)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '| negative E : E', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', '\\\\lemma abs>=_- \\\\hlevels  {this : LatticeAbGroup} {x y : E} : y - x <= abs (x - y) ', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', 'inP A', '\\\\lemma abs_-_< \\\\hlevels  {this : LinearlyOrderedAbGroup} {x y z : E} (_ : x - y < z) (_ : y - x < z) : abs (x - y) < z ', 'join \\\\plevels  \\\\hlevels  (x y : Real) : Real => \\\\new Real (L {InfRealAbMonoid.join x y}) (U {InfRealAbMonoid.join x y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\class InfReal \\\\extends LowerReal, ExUpperReal \\\\hlevels  {\\n  | LU-disjoint {q : Rat} (L q) (U q) : Empty\\n  | LU-located {q r : Rat} (q < r) : L q || U r\\n  | LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', 'LessOrEquals', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\lemma real-lower-ext \\\\plevels  \\\\hlevels  {x y : Real} (_ : x = y) : x = y ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\lemma abs>=id \\\\hlevels  {this : LatticeAbGroup} {x : E} : x <= abs x ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>TruncP (\\Sigma (w' : Real) (w' = y) (abs {RealAbGroup} (z - w') < half (eps - abs {RealAbGroup} (y - x)))) ->\n(\\lam (w : InfReal) =>\n  TruncP (\\Sigma (w' : Real) (w' = w) (abs {RealAbGroup} (z - w') < half (eps - abs {RealAbGroup} (y - x))))) \u2286 (\\lam (y : InfReal) => TruncP (\\Sigma (y' : Real) (y' = y) (abs {RealAbGroup} (y' - x) < eps)))", "completion": "\\lam p0 {w} p1 => (\\case \\elim p0, \\elim w, \\elim p1 \\with {\n  | inP (y', y'=y, d), w, inP (w', w'=w, e) => inP (w', w'=w, abs_-_< {RealAbGroup}\n    (linarith (real-lower-ext y'=y, abs>=id {RealAbGroup} {y - x}, abs>=id {RealAbGroup} <\u2218r d, abs>=_- {RealAbGroup} <\u2218r e))\n    (linarith (real-lower-ext y'=y, abs>=_- {RealAbGroup} {y} {x}, abs>=_- {RealAbGroup} <\u2218r d, abs>=id {RealAbGroup} <\u2218r e)))\n})"}
{"prompt": "['X : TopAbGroup']<<<break>>>['\\\\class CompleteCoverSpace \\\\extends SeparatedCoverSpace \\\\hlevels  {\\n  | isComplete : IsCompleteCoverSpace \\\\this\\n}', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\instance Completion \\\\hlevels  (X : CoverSpace) : CompleteCoverSpace (RegularCauchyFilter X) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X}}\\n  | isCauchy => isCCauchy {X}\\n} => \\\\new CompleteCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func coverSpace \\\\hlevels  {X1 : CoverSpace} : CoverSpace (RegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => isCCauchy {X1}\\n} => \\\\new CoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n}', '\\\\func isCCauchy \\\\hlevels  {X : CoverSpace} (D : Set (Set (RegularCauchyFilter X))) : \\\\Prop => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isCauchy C)\\n  (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (RegularCauchyFilter X)) (D V) (mkSet {X} U \u2286 V))))', '| E : \\\\Set', '\\\\func isOpen \\\\hlevels  {this : PrecoverSpace} (S : Set E) : \\\\Prop => \\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S)']<<<break>>>CompleteCoverSpace (RegularCauchyFilter X) {\n  | isOpen => isOpen {coverSpace {X}}\n  | isCauchy => isCCauchy {X}\n}", "completion": "Completion X"}
{"prompt": "['a : Ob', 'k : E', 'u : R.E', 'y1 : R.E', 'R : CRing', 'v : R.E', 'y2 : R.E', 'e : R.E', 'l : Nat', 'g : Bool -> Ob', 'b : Ob']<<<break>>>['| \\\\infixl 6 + E E : E', '| x : Ob {C}', '| pullback {x y z : Ob} (f : Hom x z) (g : Hom y z) : Pullback {x} {y} {z} f g', '\\\\func matchingFamily \\\\hlevels  {C1 : SiteWithBasis} {F1 : Functor (op {C1}) SetCat} (x : C.Ob) {J1 : \\\\Set} (g : J1 -> Ob) (e : F.F x) :\\nMatchingFamily {C1} {F1} x {J1} g {\\n  | family => \\\\lam (j : J {\\\\this}) => F.Func {x} {(g j).1} (g j).2 e\\n} => \\\\new MatchingFamily {\\n  | isMatching => {?hidden}\\n}', '\\\\func forget : Functor CRingCat SetCat (\\\\lam (R : Ob {C {\\\\this}}) => R.E) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f.func\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'inP A', '| pbProj1 : Hom {D} apex x', '| F : Functor (op {C}) SetCat', '| apex : Ob {D}', '| \\\\infixl 7 * E E : E', '| C : SiteWithBasis', \"\\\\func framePresSite \\\\hlevels  (P : FramePres) : SiteWithBasis P.E {\\n  | Hom => Cover1 {P}\\n  | id => <=-refl\\n  | o => \\\\lam {X Y Z : Ob} (f : Hom Y Z) (g : Hom X Y) => g <=\u2218 f\\n  | pullback => \\\\lam {x1 y1 z1 : P.E} (f1 : Cover1 {P} x1 z1) (g1 : Cover1 {P} y1 z1) => \\\\new Pullback {x1} {y1} {z1} f1 g1 (P.conj x1 y1) {\\n    | pbProj1 => cover-proj1 {P} {apex {\\\\this}} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x {\\\\this}} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {x1})\\n    | pbProj2 => cover-proj2 {P} {P.conj x1 y1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => y1} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {y1})\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {D {\\\\this}}} (p1 : Hom {D {\\\\this}} w (x {\\\\this})) (p2 : Hom {D {\\\\this}} w (y {\\\\this}))\\n      (_ : f {\\\\this} \u2218 p1 = g {\\\\this} \u2218 p2) => cover-prod {P} {w} {x1} {y1} p1 p2\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | isBasicCover => \\\\lam (x : Ob {\\\\this}) {J : \\\\Set} (g : J -> Ob) =>\\n  TruncP (\\\\Sigma (y : P.E) (Cover1 {P} x y) (g' : J -> P.E) (P.BasicCover {J} y g')\\n    (\\\\Pi (j : J) -> \\\\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (g j).1)))\\n} => \\\\new SiteWithBasis {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | basicCover-stable => {?hidden}\\n}\", '\\\\func SpecPres \\\\hlevels  (R : CRing) : FramePres R.E {\\n  | conj => (R.*)\\n  | BasicCover => Indexing {Maybe (\\\\Sigma R.E R.E)} {R.E} (\\\\lam (p0 : Maybe (\\\\Sigma R.E R.E)) => (\\\\case p0 \\\\with {\\n    | just (a, b) => (Bool, a R.+ b, \\\\lam (p0 : Bool) => if {R.E} p0 a b)\\n    | nothing => (Empty, R.zro, absurd {R.E})\\n  }))\\n} => \\\\new FramePres', '\\\\instance CRingBicat : BicompleteCat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => Product.fromLimit {Empty} (limit {\\\\this} {DiscretePrecat Empty} (Product.functor {Empty} (absurd {Ob {\\\\this}})))\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => CompletePrecat.applyEquiv {ModelCat theory} catEquiv\\n  | colimit => CocompletePrecat.applyEquiv {ModelCat theory} catEquiv\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| E : \\\\Set', '\\\\func SType \\\\hlevels  {R : CRing} (S : SubMonoid R) : \\\\Set => \\\\Sigma (_ y : R.E) (S.contains y)', '| g J : Ob', '| contains (E {S}) : \\\\Prop', 'in~ A', '\\\\func functor (R : CRing) : Functor (op {framePresSite (SpecPres R)}) CRingBicat (\\\\lam (a : Ob {C {\\\\this}}) => LocRing {R} (powers {R} a)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (c : Hom {C {\\\\this}} X Y) =>\\n    (functorial {R} {X} {Y} (cover_ideal {R} {Y} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => X} c)).1\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func powers \\\\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (pow {M} a n = x))) \\n=> \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', '| pbProj2 : Hom {D} apex y', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}', '| family (j : J) : Functor.F {sheafOnSiteWithBasis.MatchingFamily.F} (g j).1', '| J : \\\\Set', \"| isMatching (j j' : J) : Func {sheafOnSiteWithBasis.MatchingFamily.F} {(g j).1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n  (pbProj1 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) (family j) = Func {sheafOnSiteWithBasis.MatchingFamily.F} {(g j').1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n  (pbProj2 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) (family j')\", '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>\\Pi (j j' : J {matchingFamily\n  {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n    g1 (in~ {SType {R} (powers {R} e)}\n      {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n      (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n        inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}) ->\nFunc {sheafOnSiteWithBasis.MatchingFamily.F {matchingFamily\n  {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n    g1 (in~ {SType {R} (powers {R} e)}\n      {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n      (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n        inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n  {(g {matchingFamily\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n      g1 (in~ {SType {R} (powers {R} e)}\n        {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n        (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n          inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j).1}\n  {apex {pullback {C {matchingFamily\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n      g1 (in~ {SType {R} (powers {R} e)}\n        {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n        (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n          inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n    {(g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j).1}\n    {(g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j').1}\n    {x {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n    (g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j).2\n    (g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j').2}}\n  (pbProj1 {pullback {C {matchingFamily\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n      g1 (in~ {SType {R} (powers {R} e)}\n        {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n        (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n          inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n    {(g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j).1}\n    {(g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j').1}\n    {x {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n    (g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j).2\n    (g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j').2})\n  (family {matchingFamily\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n      g1 (in~ {SType {R} (powers {R} e)}\n        {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n        (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n          inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j) = Func {sheafOnSiteWithBasis.MatchingFamily.F {matchingFamily\n  {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n    g1 (in~ {SType {R} (powers {R} e)}\n      {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n      (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n        inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n  {(g {matchingFamily\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n      g1 (in~ {SType {R} (powers {R} e)}\n        {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n        (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n          inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j').1}\n  {apex {pullback {C {matchingFamily\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n      g1 (in~ {SType {R} (powers {R} e)}\n        {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n        (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n          inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n    {(g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j).1}\n    {(g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j').1}\n    {x {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n    (g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j).2\n    (g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j').2}}\n  (pbProj2 {pullback {C {matchingFamily\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n      g1 (in~ {SType {R} (powers {R} e)}\n        {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n        (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n          inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n    {(g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j).1}\n    {(g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j').1}\n    {x {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}}\n    (g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j).2\n    (g {matchingFamily\n      {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n        g1 (in~ {SType {R} (powers {R} e)}\n          {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n          (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n            inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j').2})\n  (family {matchingFamily\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool}\n      g1 (in~ {SType {R} (powers {R} e)}\n        {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n        (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n          inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))} j')", "completion": "isMatching {matchingFamily\n  {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool} g\n    (in~ {SType {R} (powers {R} e)}\n      {\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2}\n      (u R.* y1 R.* pow {R} a k R.+ v R.* y2 R.* pow {R} b k, pow {R} e l,\n        inP {\\Sigma (n : Nat) (pow {R} e n = pow {R} e l)} (l, idp {R.E} {pow {R} e l})))}"}
{"prompt": "['cc : IsConvUpperSeries c', 'eps>0 : zro < eps', 'c : Series ExUpperReal', 'eps : Rat']<<<break>>>['\\\\func midSum \\\\hlevels  {A3 : AddMonoid} (_ : Series A.E) (_ _ : Nat) : A.E \\n  | {A}, S, 0, m => partialSum {A} S m\\n  | {A}, S, suc n, 0 => A.zro\\n  | {A}, S, suc n, suc m => midSum {A} (\\\\lam (j : Nat) => S (suc j)) n m', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| U Rat : \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (N : Nat) (\\Pi {n : Nat} -> N <= n -> U {midSum {ExUpperRealAbMonoid} c N n} eps))", "completion": "cc eps>0"}
{"prompt": "['A : Dec', 'a : A.E', \"a' : A.E\", \"r : a = a'\", \"q : a /= a'\"]<<<break>>>['| \\\\infix 4 < E E : \\\\Prop', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ']<<<break>>>a A.< a'", "completion": "absurd (q r)"}
{"prompt": "['a : E', 'x : E', 'this : Dec', 'y : E', 'b : E', 'x<=a : x <= a']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', 'byLeft A', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>x <= a || y <= b", "completion": "byLeft x<=a"}
{"prompt": "[\"b : C'.Ob\", \"C' : Precat\"]<<<break>>>['| Hom Ob Ob : \\\\Set', '| id (X : Ob) : Hom X X', '\\\\class Functor \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F (Ob {C}) : Ob {D}\\n  | Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)\\n  | Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)\\n  | Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f\\n}', '| Ob : \\\\hType', '| C : Precat', '\\\\func TrivialCat \\\\plevels  \\\\hlevels  : Cat (\\\\Sigma) {\\n  | Hom => Paths {\\\\new Graph (\\\\Sigma) (\\\\lam (_ : V {\\\\this}) (_ : V {\\\\this}) => Empty)}\\n  | id => \\\\lam (x : Ob {\\\\this}) =>\\n    empty {\\\\new Graph (\\\\Sigma) (\\\\lam (_ : V {\\\\this}) (_ : V {\\\\this}) => Empty)} {x} {x} (idp {\\\\Sigma} {x})\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (q : Hom {\\\\this} Y Z) (p : Hom {\\\\this} X Y) =>\\n    concat {\\\\new Graph (\\\\Sigma) (\\\\lam (_ : V {\\\\this}) (_ : V {\\\\this}) => Empty)} {X} {Y} {Z} p q\\n} => FreeCat {\\\\new Graph (\\\\Sigma) (\\\\lam (_ : V {\\\\this}) (_ : V {\\\\this}) => Empty)}', '\\\\func Const \\\\plevels obj >= hom \\\\hlevels  {C1 D : Precat} (d : D.Ob) : Functor C1 D (\\\\lam (_ : Ob {C {\\\\this}}) => d) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (_ : Hom {C {\\\\this}} X Y) => D.id d\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>Functor TrivialCat C' (\\lam (_ : Ob {C {\\this}}) => b) {\n  | Func => \\lam {X Y : Ob {C {\\this}}} (_ : Hom {C {\\this}} X Y) => C'.id b\n}", "completion": "Const {TrivialCat} b"}
{"prompt": "['R : CRing', 'd : CRingData {R} (pow {R} a k :: a :: f.func x :: polyEval {R} (polyMap f p) a :: f.func e :: nil) {\\n  | interpretNF_negate => {?hidden}\\n}']<<<break>>>['| len : Nat', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| R : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', 'coef C', '\\\\infixl 7 :* (_ _ : RingTerm C V)', ':negative (RingTerm C V)', '| vars : Array (E {M})', 'pos Nat', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', ':ide', 'var V', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', ':zro', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l']<<<break>>>interpret {d}\n  (var {E {d.C}} {Fin (len {d.vars})} 0 :+ :negative {E {d.C}} {Fin (len {d.vars})} (var {E {d.C}} {Fin (len {d.vars})} 0 :* var {E {d.C}} {Fin (len {d.vars})} 1 :* :negative {E {d.C}} {Fin (len {d.vars})} (var {E {d.C}} {Fin (len {d.vars})} 2 :* var {E {d.C}} {Fin (len {d.vars})} 3))) = interpret {d}\n  (coef {E {d.C}} {Fin (len {d.vars})} (pos 1) :* var {E {d.C}} {Fin (len {d.vars})} 2 :* ((var {E {d.C}} {Fin (len {d.vars})} 3 :* var {E {d.C}} {Fin (len {d.vars})} 1 :+ var {E {d.C}} {Fin (len {d.vars})} 4) :* var {E {d.C}} {Fin (len {d.vars})} 0 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:zro {Int} {Fin 5})) :+ (:negative {E {d.C}} {Fin (len {d.vars})} (coef {E {d.C}} {Fin (len {d.vars})} (pos 1)) :* var {E {d.C}} {Fin (len {d.vars})} 0 :* (var {E {d.C}} {Fin (len {d.vars})} 2 :* var {E {d.C}} {Fin (len {d.vars})} 4 :+ :negative {E {d.C}} {Fin (len {d.vars})} (:ide {Int} {Fin 5})) :+ :zro {Int} {Fin 5}))", "completion": "terms-equality {d} (var 0 :+ :negative (var 0 :* var 1 :* :negative (var 2 :* var 3)))\n  (coef 1 :* var 2 :* ((var 3 :* var 1 :+ var 4) :* var 0 :+ :negative :zro) :+ (:negative (coef 1) :* var 0 :* (var 2 :* var 4 :+ :negative :ide) :+ :zro))\n  idp"}
{"prompt": "['d : degree<= {f.Dom} p n', 'f : AddPointedHom', 'p : Poly f.Dom', 'n : Nat']<<<break>>>['\\\\lemma degree<_degree<= \\\\hlevels  {R : AddPointed} {p : Poly R} {n : Nat} (_ : degree< {R} p (suc n)) : degree<= {R} p n ', 'suc Nat', '\\\\lemma degree<_polyMap \\\\hlevels  {f : AddPointedHom} {p : Poly f.Dom} {n : Nat} (_ : degree< {f.Dom} p n) : degree< {f.Cod} (polyMap f p) n ', '\\\\func degree<= \\\\hlevels  {R3 : AddPointed} (_ : Poly R3) (_ : Nat) : \\\\Prop \\n  | {R}, pzero, n => \\\\Sigma\\n  | {R}, padd p a, 0 => p = pzero {R}\\n  | {R}, padd p a, suc n => degree<= {R} p n\\n  | {R}, peq i, 0 =>\\n    propExt {pzero {R} = pzero {R}} {\\\\Sigma} (\\\\lam (_ : pzero {R} = pzero {R}) => ()) (\\\\lam (_ : \\\\Sigma) => idp {Poly R} {pzero {R}}) @ i\\n  | {R}, peq i, suc n => idp {\\\\Prop} {\\\\Sigma} @ i', '| Cod : BaseSet', '\\\\func polyMap \\\\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \\n  | f, pzero => pzero {f.Cod}\\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\\n  | f, peq i => transportInv\\n    {E {f.Cod}} (\\\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\\n      f.func-zro (path (peq {f.Cod})) @ i', '\\\\lemma degree<=_degree< \\\\hlevels  {R : AddPointed} {p : Poly R} {n : Nat} (_ : degree<= {R} p n) : degree< {R} p (suc n) ', '| Dom : BaseSet']<<<break>>>degree<= {f.Cod} (polyMap f p) n", "completion": "degree<_degree<= (degree<_polyMap (degree<=_degree< d))"}
{"prompt": "['this : Nucleus', 'J : \\\\Set', 'j : J', 'f : J -> E {\\\\this}']<<<break>>>['| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '| \\\\infix 4 <= E E : \\\\Prop', '| L : Locale']<<<break>>>(\\lam (j : J) => (f j).1) j <= Join {L} {J} (\\lam (j : J) => (f j).1)", "completion": "Join-cond j"}
{"prompt": "[\"context : List tc.Sort'\", 'color : E {tc.Color}', \"inner-mc : MetaContext tc.Sort'\", 'tc : TheoremContext', 'arguments : DArray {arity {inner-mc} {s} m}\\n  (\\\\lam (index : Fin (arity {inner-mc} {s} m)) => Term (tc.envs color) context (inner-mc.m-domain {s} m !! index) inner-mc)', \"subst : MetaSubstitution (env {tc}) (nil {tc.Sort'}) inner-mc mc\", 'B : Term (env {tc}) context s mc', \"A~>B : TopLevelColoredReduction {tc} color {mc} {context} {s} (apply {env {tc}} {context} {nil {tc.Sort'}} {s} {inner-mc} {mc}\\n  (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {inner-mc} {color}\\n    (metavar {tc.envs color} {context} {s} {inner-mc} m arguments)) (sublist-nil-free {tc.Sort'} {context}) subst) B\", \"mc : MetaContext tc.Sort'\", \"s : tc.Sort'\", 'm : inner-mc.metaname s']<<<break>>>['\\\\func apply \\\\hlevels  {env3 : FSignature} {context3 core-context2 : List env.Sort} {s3 : env.Sort}\\n  {old-metacontext2 new-metacontext3 : MetaContext env.Sort} (_ : Term env3 context3 s3 old-metacontext2)\\n  (_ : SubList {env.Sort} core-context2 context3)\\n  (_ : MetaSubstitution env3 core-context2 old-metacontext2 new-metacontext3) : Term env3 context3 s3 new-metacontext3 \\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, var index p, sublist, subst =>\\n    var {env} {context} {s} {new-metacontext} index p\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, metavar m arguments, sublist, subst =>\\n  Substitution.apply {env} {s} {core-context ++ old-metacontext.m-domain {s} m} {new-metacontext} (subst {s} m) {context}\\n    (extend-substitution-left {env} {core-context} {old-metacontext.m-domain {s} m} {context} {new-metacontext} sublist\\n      (\\\\lam (i : Index {env.Sort} (old-metacontext.m-domain {s} m)) => MetaSubstitution.apply\\n        {env} {context} {core-context} {old-metacontext.m-domain {s} m !! i} {old-metacontext} {new-metacontext} (arguments.at i)\\n          sublist subst))\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, func f arguments, sublist, subst =>\\n  func {env} {context} {s} {new-metacontext} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) new-metacontext)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => MetaSubstitution.apply\\n      {env} {context ++ f !!domain i} {core-context} {f !!sort i} {old-metacontext} {new-metacontext} (arguments.at i)\\n        (extend-right-single {env.Sort} {core-context} {context} sublist {f !!domain i}) subst))', \"\\\\lemma extract-root-coloring \\\\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {mc : MetaContext tc.Sort'} {context : List Sort} {s : Sort}\\n  {A B : Term (env {tc}) context s mc} (_ : TopLevelColoredReduction {tc} color {mc} {context} {s} A B) :\\n  HasColoredRoot {tc} color {context} {s} {mc} A \", '| Color : DecSet', \"| Sort' : \\\\Set\", '\\\\func inject-term \\\\hlevels  {J3 Sort4 : \\\\Set} (S3 : J3 -> FSignature {\\n  | Sort => Sort4\\n}) {s3 : Sort4} {c3 : List Sort4} {mc3 : MetaContext Sort4} {j2 : J3} (_ : Term (S3 j2) c3 s3 mc3) :\\n  Term (SumFSignature {J3} {Sort4} S3) c3 s3 mc3 \\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, var index p => var {SumFSignature {J} {Sort1} S} {c} {s} {mc} index p\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, metavar m args =>\\n  metavar {SumFSignature {J} {Sort1} S} {c} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term (SumFSignature {J} {Sort1} S) c (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => inject-term {J} {Sort1} S {mc.m-domain {s} m !! i} {c} {mc} {j} (args.at i)))\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, func f args => func {SumFSignature {J} {Sort1} S} {c} {s} {mc} (j, f)\\n    (\\\\new DArray {FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f)}\\n      (\\\\lam (index : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        Term (SumFSignature {J} {Sort1} S) (c ++ (j, f) !!domain index) ((j, f) !!sort index) mc)\\n      (\\\\lam (i : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        inject-term {J} {Sort1} S {(j, f) !!sort i} {c ++ (j, f) !!domain i} {mc} {j} (args.at i)))', 'metavar (m : mc.metaname termSort) (DArray {arity {mc} {termSort} m}\\n  (\\\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))', 'nil', \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", \"\\\\data HasColoredRoot \\\\hlevels  {this : TheoremContext} (E {Color}) {context : List Sort'} {s : Sort'} {mc : MetaContext Sort'} (Term env context s mc) \\\\with\\n  | {this}, color, {context}, {s}, {mc}, func f arguments => func-root (f.1 = color)\", \"\\\\instance env \\\\hlevels  {this1 : TheoremContext} : FSignature {\\n  | Sort => Sort'\\n  | symbol => \\\\lam (s : Sort {\\\\this}) => \\\\Sigma (j : E {Color}) (symbol {envs j} s)\\n  | domain => \\\\lam {s : Sort {\\\\this}} (symb : symbol {\\\\this} s) => domain {envs symb.1} {s} symb.2\\n} => SumFSignature {E {Color}} {Sort'} envs\", '\\\\func sublist-nil-free {A2 : \\\\Type} {list1 : List A2} : SubList {A2} (nil {A2}) list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-skip {A} {nil {A}} {a} {list} (sublist-nil-free {A} {list})', '| E : \\\\Set']<<<break>>>HasColoredRoot {tc} color {context} {s} {mc} (apply {env {tc}} {context} {nil {tc.Sort'}} {s} {inner-mc} {mc}\n  (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {inner-mc} {color}\n    (metavar {tc.envs color} {context} {s} {inner-mc} m arguments)) (sublist-nil-free {tc.Sort'} {context}) subst)", "completion": "extract-root-coloring A~>B"}
{"prompt": "['Q : Dec', 'j : J', 'x : Q.E', 'x<fj : point {Q} x < f j', 'b : point {Q} x < conj a b', 'a : E', 'f : J -> E', 'b : E']<<<break>>>['| conj E E : E', '\\\\type \\\\infix 4 < \\\\hlevels  {Q : BiorderedSet} (x y : Interval Q) : \\\\Prop => \\\\Sigma (y.1 Q.< x.1) (x.2 Q.< y.2)', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '\\\\lemma meet-isMin \\\\hlevels  {this : TotalOrder} (x y : E) : (x \u2227 y = x) || (x \u2227 y = y) ', '\\\\lemma join-isMax \\\\hlevels  {this : TotalOrder} (x y : E) : (x \u2228 y = x) || (x \u2228 y = y) ', '| join-left {x y : E} : x <= x \u2228 y', '\\\\func point \\\\hlevels  {Q : Poset} (x : Q.E) : Interval Q => (x, x)', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance RealPres \\\\hlevels  (Q : Dec) : FramePres (Interval Q) {\\n  | conj => (\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))} {Interval Q}\\n    (\\\\lam (p0 : \\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))) =>\\n    (\\\\case p0 \\\\with {\\n      | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n        | zero => (p, q)\\n        | suc zero => (r, s)\\n      }))\\n      | (false, (p, q)) => (\\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\\n        \\\\lam (t : \\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\\n    }))\\n} => \\\\new FramePres', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3']<<<break>>>point {Q} x < conj a (f j)", "completion": "(\\case join-isMax a.1 (f j).1 \\with {\n  | byLeft p => transportInv (\\lam _x => _x < _) p (join-left <\u2218r b.1)\n  | byRight p => transportInv (\\lam _x => _x < _) p x<fj.1\n},\n  \\case meet-isMin a.2 (f j).2 \\with {\n    | byLeft p => transportInv ((<) _) p (b.2 <\u2218l meet-left)\n    | byRight p => transportInv ((<) _) p x<fj.2\n  })"}
{"prompt": "['n : Nat', 'm : Nat']<<<break>>>['\\\\lemma unsuc< \\\\plevels  \\\\hlevels  {n m : Nat} (_ : suc n < suc m) : n < m ', 'suc Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma conv \\\\plevels  \\\\hlevels  {n m : Nat} (_ : pos n < pos m) : n < m ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\func signum \\\\plevels  \\\\hlevels  (_ : Int) : Int \\n  | pos 0 => pos 0\\n  | pos (suc n) => pos 1\\n  | neg (suc n) => neg 1', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '\\\\lemma conv \\\\plevels  \\\\hlevels  {x y : Int} (_ : fromInt x < fromInt y) : x < y ', '| zro : E', '\\\\lemma finv_<-conv {this : DiscreteOrderedField} {x y : E} (_ : zro < x) (_ : finv x < finv y) : y < x ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\func ratNom \\\\plevels  \\\\hlevels  (_ : Rat) : Int \\n  | rat n denom denom/=0 reduced => n']<<<break>>>finv (fromInt (pos (suc m))) StrictPoset.< finv (fromInt (pos (suc n))) -> n NatOrder.< m", "completion": "\\lam p => unsuc< $ conv $ conv $ finv_<-conv {RatField} {suc m} {suc n} idp p"}
{"prompt": "['A : DecSet', 'a : A.E', \"a' : A.E\"]<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>Dec (a = a')", "completion": "decideEq a a'"}
{"prompt": "['c : Cone {J {\\\\this}} {D {\\\\this}} (G {\\\\this}) z', 'd : DArray {len {domain {T {\\\\this}} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {T {\\\\this}} {r} h})) => E {Dom {\\\\this}} (at {domain {T {\\\\this}} {r} h} j))', 'J : Precat', \"this : ModelHom {T} z (apex {\\\\this}) {\\n  | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => (\\\\lam (j : J.Ob) => funcs {c.coneMap j} {s} x,\\n    \\\\lam {j j' : J.Ob} (f : J.Hom j j') => path (\\\\lam (p0 : I) => funcs {c.coneCoh {j} {j'} f @ p0} {s} x))\\n  | func-op => {?hidden}\\n  | func-rel => {?hidden}\\n}\", 'h : Symb {T {\\\\this}} r', 'r : Sort {T {\\\\this}}', 'G : Functor J this']<<<break>>>['| E (Sort {T}) : \\\\Set', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| F (Ob {C}) : Ob {D}', '| Dom : Model T', '| T : Theory', '| operation {r : Sort {T}} (h : Symb {T} r)\\n  (DArray {len {domain {T} {r} h}} (\\\\lam (j : Fin (len {domain {T} {r} h})) => E (at {domain {T} {r} h} j))) : E r', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| func-op {r : Sort {ModelHom.T}} (h : Symb {ModelHom.T} r) (d : DArray {len {domain {ModelHom.T} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {ModelHom.T} {r} h})) => E {Dom} (at {domain {ModelHom.T} {r} h} j))) : funcs {r} (operation {Dom} {r} h d) = operation {Cod} {r} h (\\\\new DArray {len {domain {Structure.T {Cod}} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => E {Cod} (at {domain {Structure.T {Cod}} {r} h} j))\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => funcs {at {domain {ModelHom.T} {r} h} j} (d.at j)))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| domain {s : Sort} (Symb s) : Array Sort', '| Cod : Model T', '| at (j : Fin len) : A j', '| Ob : \\\\hType', '| funcs {s : Sort {T}} (E {Dom} s) : E {Cod} s', '| T : Signature']<<<break>>>funcs {\\this} {r} (operation {Dom {\\this}} {r} h d) = operation {Cod {\\this}} {r} h\n  (\\new DArray {len {domain {Structure.T {Cod {\\this}}} {r} h}} (\\lam (j : Fin (len {domain {Structure.T {Cod {\\this}}} {r} h})) =>\n    E {Cod {\\this}} (at {domain {Structure.T {Cod {\\this}}} {r} h} j))\n    (\\lam (j : Fin (len {domain {Structure.T {Cod {\\this}}} {r} h})) =>\n      funcs {\\this} {at {domain {ModelHom.T {\\this}} {r} h} j} (d.at j)))", "completion": "ext (ext (\\lam j => func-op h d))"}
{"prompt": "['A : StoneC*PseudoAlgebra', 'F : ProperFilter (E {\\\\this})']<<<break>>>['\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '| A : TopMeetSemilattice', '| F (E {A}) : \\\\Prop', '\\\\func SetFilter-map \\\\hlevels  {X1 Y : \\\\Set} (f : X1 -> Y) (F1 : SetFilter X1) : SetFilter Y (\\\\lam (V : E {A {\\\\this}}) => F.F (f ^-1 V)) \\n=> \\\\new SetFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n}', '\\\\func ProperFilter-map \\\\hlevels  {X1 Y : \\\\Set} (f : X1 -> Y) (F1 : ProperFilter X1) :\\n  ProperFilter Y (\\\\lam (V : E {A {SetFilter-map {X1} {Y} f F1}}) => F.F (f ^-1 V)) => \\\\new ProperFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isProper => {?hidden}\\n}', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| E : \\\\Set', '\\\\class ProperFilter \\\\extends WeaklyProperFilter \\\\hlevels  {\\n  | isProper {U : Set X} (F U) : TruncP (\\\\Sigma (x : X) (U x))\\n  | isWeaklyProper => \\\\lam (Fb : F bottom) => (\\\\scase isProper {bottom} Fb \\\\with {\\n    | inP (x, inP ((), a))\\n  })\\n}']<<<break>>>ProperFilter A.E (\\lam (V : E {A {SetFilter-map {\\Sigma Real A.E} {A.E} (\\lam (p0 : \\Sigma Real A.E) => p0.2) F1}}) =>\n  F.F ((\\lam (p0 : \\Sigma Real A.E) => p0.2) ^-1 V))", "completion": "ProperFilter-map (\\lam p0 => p0.2) F"}
{"prompt": "['P : FramePres', 'a : P.E', 'x : P.E', 'p : a = P.conj x y', 'y : P.E']<<<break>>>['\\\\lemma cover-proj2 \\\\hlevels  {P : FramePres} {x : P.E} {J : \\\\Set} {g : J -> P.E} {a b : P.E} (_ : x = P.conj a b) (j : J) (_ : g j = b) :\\n  Cover {P} x {J} g ', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| E : \\\\Set']<<<break>>>\\Sigma -> Cover {P} a {\\Sigma} (\\lam (_ : \\Sigma) => y)", "completion": "\\lam _ => cover-proj2 p () idp"}
{"prompt": "['this : Functor (op {L}) S.D (h1 @ i) {\\n  | Func => h2 @ i\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', 'h2 : Path (\\\\lam (i : I) => \\\\Pi {X Y : Ob} -> Hom X Y -> Hom {S.D} ((@) h1 i X) ((@) h1 i Y)) Func (Func {S.F})', 'i : I', 'L : Locale', 'S : VSheaf {\\n  | C => L\\n}', 'h1 : Functor.F {VPresheaf.F {direct_image_locale {L} {L} (id L) S}} = Functor.F {S.F}']<<<break>>>['| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| D : Cat', '| id (X : Ob) : Hom X X', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\lemma direct_image_locale \\\\hlevels  {L L' : Locale} (f : FrameHom L' L) (S : VSheaf {\\n  | C => L\\n}) : VSheaf S.D L' (Comp {Precat.op {L'}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {f}})) \", '| Ob : \\\\hType', '| C : Precat', '| E : \\\\Set', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}']<<<break>>>\\Pi {X : Ob {C {\\this}}} -> \\Pi {Y Z : L.E} ->\n  \\Pi {g : Hom Y Z} -> \\Pi {f : Hom X Y} -> (@) h2 i {X} {Z} (g \u2218 f) = (@) h2 i {Y} {Z} g \u2218 (@) h2 i {X} {Y} f", "completion": "\\lam {X} => (@) (prop-dpi (\\lam i => ext_coe) (Func-o {F {direct_image_locale {L} {L} (id L) S}}) (Func-o {S.F})) i {X}"}
{"prompt": "['fun : Q.E -> Bool', 'z : Interval Q', 'l : Array (Interval Q)', 'j : Fin l.len', 'Q : Dec', 'z1<gj+1 : point {Q} z.1 < at {z :: l} (suc j)']<<<break>>>['| len : Nat', 'true', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\field trichotomy (x y : E) : Tri x y', 'suc Nat', '\\\\type Interval \\\\hlevels  (Q : Poset) : \\\\Set => \\\\Sigma Q.E Q.E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\data Tri \\\\hlevels  {A : StrictPoset} (_ _ : A.E) \\n  | less (a A.< a')\\n  | equals (a = a')\\n  | greater (a A.> a')\", \"less (a A.< a')\", \"\\\\lemma trichotomy<_reduce \\\\hlevels  {A : Dec} {a a' : A.E} (p : a A.< a') : A.trichotomy a a' = less {A} {a} {a'} p \", '\\\\func point \\\\hlevels  {Q : Poset} (x : Q.E) : Interval Q => (x, x)', '| \\\\infix 4 < E E : \\\\Prop', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'false', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set']<<<break>>>fun (at {map {Interval Q} {Q.E} (\\lam (p0 : Interval Q) => p0.2) l} j) = true", "completion": "unfold fun (rewrite (trichotomy<_reduce z1<gj+1.2) idp)"}
{"prompt": "['R : CRing', 'A : Matrix R.E 2 2']<<<break>>>['\\\\func determinant {R : CRing} {n : Nat} (M : Matrix R.E n n) : R.E => FinSum {R} {SymFin n}\\n  (\\\\lam (e : Sym n) => sign {R} {n} e R.* BigProd {R} (\\\\new Array R.E n (\\\\lam (j : Fin n) => at {at {M} (f {e} j)} j)))', '| at (j : Fin len) : A j', '\\\\lemma determinant11 {R : CRing} (A : Matrix R.E 1 1) : determinant {R} {1} A = at {at {A} 0} 0 ', '| E : \\\\Set', '\\\\func minor {R : \\\\Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : Matrix R n m \\n  => map {Array R (suc m)} {Array R m} (\\\\lam (p0 : Array R (suc m)) => skip {R} {m} p0 j0) (skip {Array R (suc m)} {n} M i0)']<<<break>>>determinant {R} {1} (minor {R.E} {1} {1} A 1 0) = at {at {minor {R.E} {1} {1} A 1 0} 0} 0", "completion": "determinant11 (minor A 1 0)"}
{"prompt": "['eps : Rat', 'X : \\\\Set', 'h : \\\\Pi (x : X) ->\\nTruncP (\\\\Sigma (V : Set Y.E) (TruncP (\\\\Sigma (x : Y.E) (V = (\\\\lam (y : Y.E) => U {Y.dist x y} (half eps)))))\\n  (\\\\Pi {n : I.E} -> N I.<= n -> V (f n x)))', 'I : DirectedSet', 'f : I.E -> X -> Y.E', 'Y : ExPseudoMetricSpace', 'N : I.E']<<<break>>>['\\\\lemma halving1/2 \\\\hlevels  {this : ExPseudoMetricSpace} {x y z : E} {c : Rat} (_ : U {dist y x} (c * ratio (pos 1) 2))\\n  (_ : U {dist y z} (c * ratio (pos 1) 2)) : U {dist x z} c ', '| <=-refl {x : E} : x <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| U Rat : \\\\Prop', '| dist E E : ExUpperReal', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '\\\\func half \\\\plevels  \\\\hlevels  (a : Rat) : Rat => a * ratio (pos 1) 2', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (N : I.E) (\\Pi (x : X) -> \\Pi {n : I.E} -> N I.<= n -> U {Y.dist (f n x) (f N x)} eps))", "completion": "inP (N, \\lam x N<=n => (\\case h x \\with {\n  | inP (_, inP (y, idp), g) => halving1/2 {Y} (g N<=n) (g <=-refl)\n}))"}
{"prompt": "['R : CRing', 'x : R.E', 'zd : at {IsZeroDimensional {R} :: Dim<= {R} 0 :: (\\\\Pi (a : R.E) ->\\n  TruncP (\\\\Sigma (b : R.E) (k : Nat) (k /= 0) (b R.* b = b) (LDiv {R} (pow {R} a k) b) (LDiv {R} b (pow {R} a k)))) :: nil}\\n  1']<<<break>>>['| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func fold \\\\hlevels  {this2 : CRing} {k1 : Nat} (_ _ : Array E k1) (_ : Array Nat k1) : E \\n  | {this}, {0}, nil, nil, nil => ide\\n  | {this}, {suc k}, x :: xs, a :: as, m :: ms => pow x m * (fold {k} xs as ms - x * a)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (a : Array R.E 1) (m : Array Nat 1) (fold {R} {1} (x :: nil) a m = R.zro))", "completion": "zd (x :: nil)"}
{"prompt": "['this : CRing (M.E ()) {\\n  | zro => M.operation {()} 0 nil\\n  | + => \\\\lam (x : BaseSet.E {\\\\this}) (y : BaseSet.E {\\\\this}) => M.operation {()} 2 (x :: y :: nil)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => \\\\lam (x : BaseSet.E {\\\\this}) (y : BaseSet.E {\\\\this}) => M.operation {()} 3 (x :: y :: nil)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => \\\\lam (x : BaseSet.E {\\\\this}) => M.operation {()} 4 (x :: nil)\\n  | negative-left => {?hidden}\\n  | ide => M.operation {()} 1 nil\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', 'M : Model theory']<<<break>>>['apply (f : S.Symb s) (DArray {len {S.domain {s} f}} (\\\\lam (j : Fin (len {S.domain {s} f})) => Term {S} V (at {S.domain {s} f} j)))', '| E (Sort {T}) : \\\\Set', '\\\\lemma SigmaFin (S : FinSet) (Q : S.E -> FinSet) : FinSet (\\\\Sigma (i : S.E) (E {Q i})) {\\n  | finCard => FinSum {NatSemiring} {S} (\\\\lam (i : S.E) => finCard {Q i})\\n} ', 'var (V s)', '| Sort : \\\\Set', 'inP A', '\\\\data Formula \\\\hlevels  {S : Signature} (S.Sort -> \\\\Set) \\n  | equality {s : S.Sort} (Term {S} V s) (Term {S} V s)\\n  | predicate (P : S.PredSymb) (DArray {len {S.predDomain P}} (\\\\lam (j : Fin (len {S.predDomain P})) => Term {S} V (at {S.predDomain P} j)))', '\\\\func interpret \\\\hlevels  {this1 : Structure} {V1 : Sort {T} -> \\\\Set} (_ : Env V1) {s2 : Sort {T}} (_ : Term {T} V1 s2) : E s2 \\n  | {this}, {V}, rho, {s}, var v => rho {s} v\\n  | {this}, {V}, rho, {s}, apply f d =>\\n  operation {s} f (\\\\new DArray {len {domain {T} {s} f}} (\\\\lam (j : Fin (len {domain {T} {s} f})) => E (at {domain {T} {s} f} j))\\n    (\\\\lam (j : Fin (len {domain {T} {s} f})) => interpret {V} rho {at {domain {T} {s} f} j} (d.at j)))', '\\\\func Sequent {S : Signature} : \\\\1-Type \\n  => \\\\Sigma (V : S.Sort -> \\\\Set) (FinSet (\\\\Sigma (s : S.Sort) (V s))) (Array (Formula {S} V)) (Formula {S} V)', '\\\\func coe (A : I -> \\\\Type) (a : A left) (i : I) : A i ', '| isModel (S : Sequent {T}) (axioms {T} S) : isSequentTrue S', '\\\\instance theory : Theory {\\n  | Sort => \\\\Sigma\\n  | Symb => \\\\lam (_ : Sort {\\\\this}) => Fin 5\\n  | domain => \\\\lam {s : Sort {\\\\this}} (p0 : Symb {\\\\this} s) => (\\\\case p0 \\\\with {\\n    | zero => nil\\n    | suc zero => nil\\n    | suc (suc zero) => () :: () :: nil\\n    | suc (suc (suc zero)) => () :: () :: nil\\n    | suc (suc (suc (suc zero))) => () :: nil\\n  })\\n  | PredSymb => Empty\\n  | predDomain => absurd {Array (Sort {\\\\this})}\\n  | axioms => arraySubset {Sequent} ((\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n    | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n  }) (SigmaFin UnitFin (\\\\lam (_ : E) => UnitFin)) right} {}, nil,\\n    equality {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 2\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 0} 0 nil :: var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 1} () :: nil))\\n      (var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} ())) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 3, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n    }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 3)) right} {}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()}\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 2 (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 0} 2\\n        (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 2} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 2} 1} 1 :: nil) :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 1} 2 :: nil))\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 2\\n        (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 0} 0 :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 1} 2\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 2} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 2} 1} 2 :: nil) :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n    }) (SigmaFin UnitFin (\\\\lam (_ : E) => UnitFin)) right} {}, nil,\\n      equality {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 3\\n        (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 3} 0} 1 nil :: var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 3} 1} () :: nil))\\n        (var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} ())) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 3, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n      }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 3)) right} {}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()}\\n        (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 3 (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 0} 3\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 0} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 0} 3} 1} 1 :: nil) :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 1} 2 :: nil))\\n        (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 3\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 0} 0 :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 1} 3\\n            (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 3} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 3} 1} 2 :: nil) :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 2, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n      }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 2)) right} {}, nil,\\n        equality {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 2\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 1} 1 :: nil))\\n          (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 2\\n            (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 1} 0 :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 2, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n          | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n        }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 2)) right} {}, nil,\\n          equality {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 3\\n            (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 1} 1 :: nil))\\n            (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 3\\n              (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 1} 0 :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n          }) (SigmaFin UnitFin (\\\\lam (_ : E) => UnitFin)) right} {}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()}\\n            (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 2 (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 0} 4\\n              (var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 4} 0} () :: nil) :: var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 1} () :: nil))\\n            (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 0 nil)) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 3, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n          }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 3)) right} {}, nil,\\n            equality {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 3\\n              (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 0} 0 :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 1} 2\\n                (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 2} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 2} 1} 2 :: nil) :: nil))\\n              (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 2 (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 0} 3\\n                (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 3} 1} 1 :: nil) :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 1} 3\\n                (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 3} 1} 2 :: nil) :: nil))) :: nil)\\n} => \\\\new Theory', '\\\\data Term \\\\hlevels  {S : TermSig} (S.Sort -> \\\\Set) S.Sort \\n  | var (V s)\\n  | apply (f : S.Symb s) (DArray {len {S.domain {s} f}} (\\\\lam (j : Fin (len {S.domain {s} f})) => Term {S} V (at {S.domain {s} f} j)))', \"\\\\func isFormulaTrue \\\\hlevels  {this2 : Structure} {V2 : Sort {T} -> \\\\Set} (_ : Env V2) (_ : Formula {T} V2) : \\\\Prop \\n  | {this}, {V}, rho, equality {s} t t' => interpret {V} rho {s} t = interpret {V} rho {s} t'\\n  | {this}, {V}, rho, predicate P d =>\\n  relation P (\\\\new DArray {len {predDomain {T} P}} (\\\\lam (j : Fin (len {predDomain {T} P})) => E (at {predDomain {T} P} j))\\n    (\\\\lam (j : Fin (len {predDomain {T} P})) => interpret {V} rho {at {predDomain {T} P} j} (d.at j)))\", '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| domain {s : Sort} (Symb s) : Array Sort', '\\\\func finSet {A : FinSet} : FinSet => A', '| at (j : Fin len) : A j', '| E : \\\\Set', '| T : Signature', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', 'equality {s : S.Sort} (Term {S} V s) (Term {S} V s)', '\\\\instance UnitFin : FinSet (\\\\Sigma) {\\n  | finCard => 1\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case finEq {\\\\this} \\\\with {\\n    | inP e => \\\\case decideEq (e.ret x) (e.ret y) \\\\with {\\n      | yes q => yes {x = y} (isInj {symQEquiv {Fin (finCard {\\\\this})} {E {\\\\this}} (fromEquiv e)} {x} {y} q)\\n      | no q => no {x = y} (\\\\lam (p : x = y) => q (pmap {E {\\\\this}} {Fin (finCard {\\\\this})} e.ret {x} {y} p))\\n    }\\n  })\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '| finCard : Nat', 'right', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\class FinSet \\\\extends KFinSet, Choice, DecSet {\\n  | finEq : TruncP (Equiv {Fin finCard} {E})\\n  | #-comparison => \\\\lam (x : E) (y : E) (z : E) (x/=z : x # z) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => byRight {x # y} {y # z} (\\\\lam (y=z : y = z) => x/=z (x=y *> y=z))\\n    | no x/=y => byLeft {x # y} {y # z} x/=y\\n  })\\n  | #-symmetric => /=-sym {E}\\n  | # => (/=)\\n  | nonEqualApart => \\\\lam {x y : E} (p : x /= y) => p\\n  | tightness => \\\\lam {x : E} {y : E} (x//=y : Not (x # y)) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => x=y\\n    | no x/=y => absurd {x = y} (x//=y x/=y)\\n  })\\n  | finSurj => map {Equiv {Fin finCard} {E}} {\\\\Sigma (f : Fin finCard -> E) (IsSurj {Fin finCard} {E} f)} finEq\\n    (\\\\lam (e : Equiv {Fin finCard} {E}) => (e.f, isSurjMap {ESEquiv.fromEquiv e}))\\n  | #-irreflexive => \\\\lam {x : E} (p : x # x) => p (idp {E} {x})\\n  | choice => \\\\lam {B : E -> \\\\Set} => (\\\\scase finEq \\\\with {\\n    | inP e => transport {\\\\Type} (\\\\lam (x : \\\\Type) => \\\\Pi {A : x -> \\\\Set} -> (\\\\Pi (i : x) -> TruncP (A i)) -> TruncP (\\\\Pi (i : x) -> A i))\\n      {Fin finCard} {E} (Equiv-to-= {Fin finCard} {E} e) (finiteAC {finCard}) {B}\\n  })\\n}', '\\\\lemma FinSum_replicate {this : Semiring} {A : FinSet} {x : E} : FinSum {A} (\\\\lam (_ : A.E) => x) = natCoef A.finCard * x ']<<<break>>>\\Pi {x : BaseSet.E {\\this}} -> \\Pi {y : BaseSet.E {\\this}} ->\n  interpret {M} {(((\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (\\Sigma)) {\n    | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n  }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => UnitFin)) right} {}, nil,\n    equality {theory} {\\lam (_ : Sort) => \\Sigma} {()} (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 2\n      (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 0} 0 nil :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 1} () :: nil))\n      (var {theory} {\\lam (_ : Sort) => \\Sigma} {()} ())) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 3)) {\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n    }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 3)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => Fin 3} {()}\n      (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 2\n        (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 2} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 2} 1} 1 :: nil) :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 2 :: nil))\n      (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2\n        (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 2\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 2} 1} 2 :: nil) :: nil))) :: (\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (\\Sigma)) {\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n    }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => UnitFin)) right} {}, nil,\n      equality {theory} {\\lam (_ : Sort) => \\Sigma} {()} (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 3\n        (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 3} 0} 1 nil :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 3} 1} () :: nil))\n        (var {theory} {\\lam (_ : Sort) => \\Sigma} {()} ())) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 3)) {\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n      }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 3)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => Fin 3} {()}\n        (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 3\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 0} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 0} 3} 1} 1 :: nil) :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 2 :: nil))\n        (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 3\n            (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 3} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 3} 1} 2 :: nil) :: nil))) :: (\\lam (_ : Sort) => Fin 2, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 2)) {\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n      }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 2)) right} {}, nil,\n        equality {theory} {\\lam (_ : Sort) => Fin 2} {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n          (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 1 :: nil))\n          (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n            (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 0 :: nil))) :: (\\lam (_ : Sort) => Fin 2, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 2)) {\n          | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n        }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 2)) right} {}, nil,\n          equality {theory} {\\lam (_ : Sort) => Fin 2} {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 3\n            (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 1} 1 :: nil))\n            (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 3\n              (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 1} 0 :: nil))) :: (\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (\\Sigma)) {\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n          }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => UnitFin)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => \\Sigma} {()}\n            (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 2 (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 0} 4\n              (var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {at {domain {()} 2} 0} 4} 0} () :: nil) :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 1} () :: nil))\n            (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 0 nil)) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 3)) {\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n          }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 3)) right} {}, nil,\n            equality {theory} {\\lam (_ : Sort) => Fin 3} {()} (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3\n              (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 2\n                (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 2} 1} 2 :: nil) :: nil))\n              (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 3\n                (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 3} 1} 1 :: nil) :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 3\n                (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 3} 1} 2 :: nil) :: nil))) :: nil) !! 4).1}\n    (\\lam {s : Sort {M.T}} => at {x :: y :: nil}) {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n      (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 1 :: nil)) = interpret {M} {(((\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (\\Sigma)) {\n    | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n  }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => UnitFin)) right} {}, nil,\n    equality {theory} {\\lam (_ : Sort) => \\Sigma} {()} (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 2\n      (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 0} 0 nil :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 1} () :: nil))\n      (var {theory} {\\lam (_ : Sort) => \\Sigma} {()} ())) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 3)) {\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n    }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 3)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => Fin 3} {()}\n      (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 2\n        (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 2} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 2} 1} 1 :: nil) :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 2 :: nil))\n      (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2\n        (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 2\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 2} 1} 2 :: nil) :: nil))) :: (\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (\\Sigma)) {\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n    }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => UnitFin)) right} {}, nil,\n      equality {theory} {\\lam (_ : Sort) => \\Sigma} {()} (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 3\n        (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 3} 0} 1 nil :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 3} 1} () :: nil))\n        (var {theory} {\\lam (_ : Sort) => \\Sigma} {()} ())) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 3)) {\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n      }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 3)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => Fin 3} {()}\n        (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 3\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 0} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 0} 3} 1} 1 :: nil) :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 2 :: nil))\n        (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 3\n            (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 3} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 3} 1} 2 :: nil) :: nil))) :: (\\lam (_ : Sort) => Fin 2, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 2)) {\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n      }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 2)) right} {}, nil,\n        equality {theory} {\\lam (_ : Sort) => Fin 2} {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n          (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 1 :: nil))\n          (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n            (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 0 :: nil))) :: (\\lam (_ : Sort) => Fin 2, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 2)) {\n          | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n        }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 2)) right} {}, nil,\n          equality {theory} {\\lam (_ : Sort) => Fin 2} {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 3\n            (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 1} 1 :: nil))\n            (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 3\n              (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 1} 0 :: nil))) :: (\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (\\Sigma)) {\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n          }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => UnitFin)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => \\Sigma} {()}\n            (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 2 (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 0} 4\n              (var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {at {domain {()} 2} 0} 4} 0} () :: nil) :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 1} () :: nil))\n            (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 0 nil)) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 3)) {\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n          }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 3)) right} {}, nil,\n            equality {theory} {\\lam (_ : Sort) => Fin 3} {()} (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3\n              (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 2\n                (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 2} 1} 2 :: nil) :: nil))\n              (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 3\n                (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 3} 1} 1 :: nil) :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 3\n                (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 3} 1} 2 :: nil) :: nil))) :: nil) !! 4).1}\n    (\\lam {s : Sort {M.T}} => at {x :: y :: nil}) {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n      (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 0 :: nil))", "completion": "\\lam {x} {y} => isModel {M} _ (inP (4, idp)) (\\lam {_} => (::) x (y :: nil) a) (\\lam p0 => (\\case p0 \\with {}))"}
{"prompt": "['l : E', 'l<x : l < x', 'u : E', 'x<u : x < u', 'x : Rat', 'this : FramePresHom (RealPres RatField) (F (discrete Rat)) {\\n  | func => \\\\lam (p : E {Dom {\\\\this}}) (x : Rat) => \\\\Sigma (p.1 < x) (x < p.2)\\n  | func-conj => {?hidden}\\n  | func-basicCover => {?hidden}\\n  | func-image => {?hidden}\\n}']<<<break>>>[\"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>func {\\this} (l, u) x", "completion": "(l<x, x<u)"}
{"prompt": "['lw : Array W.E', 'f : LinearMap {R} U V', 'bv : IsBasis {V} lv', 'R : Ring', 'W : LModule R', 'i : Fin lu.len', 'g : LinearMap {R} V W', 'lv : Array V.E', 'lu : Array U.E', 'V : LModule R', 'bw : IsBasis {W} lw']<<<break>>>['| len : Nat', 'basis-split \\\\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', '| at (j : Fin len) : A j', '| \\\\infixl 7 *c (E {R}) E : E', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '\\\\lemma BigSum-transpose \\\\hlevels  {this : AbMonoid} {m n : Nat} (f : Fin m -> Fin n -> E) :\\n  BigSum (\\\\new Array E m (\\\\lam (i : Fin m) => BigSum (\\\\new Array E n (f i)))) = BigSum (\\\\new Array E n (\\\\lam (j : Fin n) => BigSum (\\\\new Array E m (\\\\lam (p0 : Fin m) => f p0 j)))) ', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l']<<<break>>>BigSum {W}\n  (\\new Array W.E lv.len (\\lam (i1 : Fin lv.len) => BigSum {W} (\\new Array W.E lw.len ((\\lam (p0 : Fin lv.len) (j : Fin lw.len) =>\n    at {basis-split {V} {lv} bv (f.func (lu.at i))} p0 R.* at {basis-split {W} {lw} bw (g.func (lv.at p0))} j W.*c lw.at j) i1)))) = BigSum {W} (\\new Array W.E lw.len (\\lam (j : Fin lw.len) =>\n  BigSum {W} (\\new Array W.E lv.len (\\lam (p0 : Fin lv.len) => (\\lam (p0 : Fin lv.len) (j : Fin lw.len) =>\n    at {basis-split {V} {lv} bv (f.func (lu.at i))} p0 R.* at {basis-split {W} {lw} bw (g.func (lv.at p0))} j W.*c lw.at j) p0 j))))", "completion": "BigSum-transpose {W} _"}
{"prompt": "['V : Set S.E', 'F : WeaklyCauchyFilter S', 'S : CoverSpace']<<<break>>>['\\\\data Empty \\\\plevels  \\\\hlevels  ', '| X : \\\\Set', '| bottom : E', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func Compl \\\\hlevels  {X : \\\\hType} (U : Set X) : Set X => \\\\lam (x : X) => Not (U x)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ']<<<break>>>Compl {S.E} V \u2227 V \u2286 bottom", "completion": "\\lam s => absurd $ s.1 s.2"}
{"prompt": "['P : FramePres']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '\\\\class Locale \\\\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\\\hlevels  {\\n  | Join-ldistr>= {J : \\\\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\\\lam (j : J) => e \u2227 f j)\\n  | basicCover-stable => \\\\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\\\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\\n    meet-univ {x} {Join {J} (\\\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\\\lam (j : J) => (g j).1} {x}\\n  | ldistr>= => \\\\lam {x : E} {y : E} {z : E} => (\\n    \\\\have t => path (\\\\lam (i : I) (b : Bool) => (\\\\case b \\\\with {\\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\\n          }) @ i)\\n    \\\\in transportInv\\n        {Bool -> E} (\\\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\\n          {\\\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\\\lam (b : Bool) => x \u2227 if {E} b y z} t\\n          (Join-ldistr>= {Bool} {\\\\lam (p0 : Bool) => if {E} p0 y z} {x}))\\n  | Meet-cond => \\\\lam {J : \\\\Set} (j : J) {f : J -> E} =>\\n  Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n    {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)\\n  | join-left => \\\\lam {x : E} {y : E} => Join-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | join-right => \\\\lam {x : E} {y : E} => Join-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | Meet-univ => \\\\lam {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) =>\\n  Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n    {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  | join-univ => \\\\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\\n  Join-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n    | true => x<=z\\n    | false => y<=z\\n  }))\\n  | join => \\\\lam (x : E) (y : E) => Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)\\n  | Meet => \\\\lam {J : \\\\Set} (g : J -> E) =>\\n    Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)\\n  | isBasicCover => \\\\lam (x : Ob) {J : \\\\Set} (g : J -> Ob) => x <= Join {J} (\\\\lam (j : J) => (g j).1)\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Locale (Set (CompleteFilter (PresentedFrame P))) {\n  | <= => (\u2286)\n  | meet => \\lam (U : E {\\this}) (V : E {\\this}) (a : CompleteFilter (PresentedFrame P)) => \\Sigma (U a) (V a)\n  | top => \\lam (_ : CompleteFilter (PresentedFrame P)) => \\Sigma\n  | Join => \\lam {J : \\Set} (f : J -> E {\\this}) (a : CompleteFilter (PresentedFrame P)) => TruncP (\\Sigma (j : J) (f j a))\n}", "completion": "SetLattice _"}
{"prompt": "['Rd : DecSet R.E', 'R : AbMonoid', 'M : DecSet', 'l : Array (\\\\Sigma R.E M.E)']<<<break>>>['| zro : E', '\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\func inMS \\\\hlevels  {M : \\\\Set} {R : AddMonoid} (l : Array (\\\\Sigma R.E M)) : MonoidSet M R => in~ {Array (\\\\Sigma R.E M)} {(~)} l', '\\\\func msCoef \\\\hlevels  {M : DecSet} {R : AbMonoid} (p : MonoidSet M.E R) (m : M.E) : R.E => monoidSet-coefs {M.E} {R} {(=) m} (M.decideEq m) p']<<<break>>>\\Pi (m : M.E) -> Dec (msCoef {M} {R} (inMS {M.E} {R} l) m = zro {R})", "completion": "\\lam m => decideEq (msCoef (inMS l) m) 0"}
{"prompt": "['b : Rat', 'delta : Rat', 'b<x+delta : fromRat b < x + fromRat delta', 'x : Real']<<<break>>>['true', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\lemma minus-rat \\\\plevels  \\\\hlevels  {x y : Rat} : fromRat x - fromRat y = fromRat (x - y) ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| E : \\\\Set', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '| \\\\infix 4 < E E : \\\\Prop', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)']<<<break>>>fromRat (b - delta) < x", "completion": "transport (\\lam _x => _x < _) minus-rat (linarith : b - {RealAbGroup} delta < x)"}
{"prompt": "['r : E {R {\\\\this}}', 'B : LinRepres R G', 'g : G.E', 'A : LinRepres R G', 'x : E {Dom {\\\\this}}', 'f : LinearMap {R} A B', 'G : FinGroup']<<<break>>>['| **-*c {g : E {G}} {e : E} {c : E {R}} : g ** (c *c e) = c *c g ** e', '| \\\\infixl 8 ** (E {G}) E : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| inverse E : E']<<<break>>>g B.** f.func (r A.*c G.inverse g A.** x) = r B.*c g B.** f.func (G.inverse g A.** x)", "completion": "rewrite (func-*c {f}) (rewrite (**-*c {B}) idp)"}
{"prompt": "['x : E {\\\\this}', 'A : StoneC*PseudoAlgebra', 'j : \\\\Sigma (y : A.E) (A.norm y <= ide)', 'B1 : Rat', '|x1|<B1 : U {abs {RealAbGroup} x.1} B1']<<<break>>>['\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\lemma <=_* \\\\plevels  \\\\hlevels  {x x' y y' : ExUpperReal} (_ : x <= x') (_ : y <= y') : x * y <= x' * y' \", '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| abs>=0 {x : E} : zro <= abs x', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma ide-right \\\\plevels  \\\\hlevels  {x : ExUpperReal} (_ : zro <= x) : x * fromRat ide = x ', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', 'join \\\\plevels  \\\\hlevels  (x y : Real) : Real => \\\\new Real (L {InfRealAbMonoid.join x y}) (U {InfRealAbMonoid.join x y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| zro : E', '\\\\lemma <_<= \\\\plevels  \\\\hlevels  {x : ExUpperReal} {q : Rat} (_ : x.U q) : x <= fromRat q ', '\\\\lemma <=-upper \\\\plevels  \\\\hlevels  {x y : Real} : x Preorder.<= y <-> x ExUpperReal.<= y ', '\\\\instance ExUpperRealLattice \\\\hlevels  : CompleteLattice ExUpperReal {\\n  | <= => (ExUpperReal.<=)\\n  | meet => meet\\n  | join => join\\n  | top => top-impl\\n  | Join => ExUpperRealLattice.Join\\n  | Meet => ExUpperRealLattice.Meet\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| negative E : E', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>abs {RealAbGroup} x.1 * A.norm j.1 <= fromRat B1", "completion": "<=_* (<_<= |x1|<B1) j.2 <=\u2218 =_<= (ide-right $ <=-rat.1 $ <=-less $ <=-upper.1 (abs>=0 {RealAbGroup}) |x1|<B1)"}
{"prompt": "['V : PosetQModule', \"a' : \\\\Sigma V.E B.E\", \"l' : Array (\\\\Sigma V.E B.E) l.len\", 'B : BooleanRing', 'n : Nat', 'l : Array (\\\\Sigma V.E B.E) n']<<<break>>>['| len : Nat', '| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', \"~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\"]<<<break>>>(a'.1, B.zro) :: l' ~ l'", "completion": "~-zro-right idp"}
{"prompt": "['n : Nat']<<<break>>>['\\\\func negative (_ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 xReduced => rat (negative xNom) xDenom {?hidden} {?hidden}', '| zro : E', '| \\\\infixl 6 + E E : E', '| zro-left {x : E} : zro + x = x', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| E : \\\\Set', 'rfunc \\\\hlevels  (_ : Nat) : Rat \\n  | 0 => zro\\n  | suc n => ratio (pos 1) 2 * (ide + rfunc n * rfunc n)']<<<break>>>zro + negative (rfunc n) = negative (rfunc n)", "completion": "zro-left {_} {negative (rfunc n)}"}
{"prompt": "['R : CRing', 'E : CRing', 'j : Fin l.len', 'f : RingHom R E', 'l : Array E.E']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func id \\\\hlevels  {M : Monoid} : MonoidHom M M {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new MonoidHom {\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '| Cod : BaseSet', '\\\\instance MonoidRing \\\\hlevels  (M : Monoid) (R : Ring) : Ring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | negative => negative {M.E} {R}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| E : \\\\Set', '\\\\func inPS \\\\hlevels  {A : \\\\Set} (l : Array A) : PermSet A => in~ {Array A} {EPerm {A}} l', '\\\\func mPolyEval \\\\hlevels  {J : \\\\Set} {R : CRing} (f : J -> R.E) : RingHom (MonoidRing (PermSetMonoid J) R) R {\\n  | func => \\\\lam (p0 : E {Dom {evalMSMonoidHom {E} {R} (func {permSet-univ {J} {R} f})}}) =>\\n    evalMS {E} {R} p0 (func {permSet-univ {J} {R} f})\\n} => evalMSRingHom {PermSetMonoid J} {R} (permSet-univ {J} {R} f)', '\\\\func mPoly-mapHom \\\\hlevels  {J : \\\\Set} {R S : CRing} (f : RingHom R S) :\\nRingHom (MonoidRing (Dom {id {PermSetMonoid J}}) f.Dom) (MonoidRing (Cod {id {PermSetMonoid J}}) f.Cod) {\\n  | func => monoidSet-map {E {Dom {id {PermSetMonoid J}}}} {E {Cod {id {PermSetMonoid J}}}} (func {id {PermSetMonoid J}}) f\\n} => monoidSet-ringHom (id {PermSetMonoid J}) f', '\\\\instance RingCat : Cat Ring {\\n  | Hom => RingHom\\n  | id => RingHom.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func permSet-univ \\\\hlevels  {A : \\\\Set} {B : CMonoid} (f : A -> B.E) : MonoidHom (PermSetMonoid A) B {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => permSet-sum {B} (permSet-map {A} {B.E} f x)\\n} => \\\\new MonoidHom {\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| ide-right {x : E} : x * ide = x', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| ide-left {x : E} : ide * x = x', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '| zro-right {x : E} : x + zro = x', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| func-ide : func (ide {Dom}) = ide {Cod}', '| zro : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| func (E {Dom}) : E {Cod}', '\\\\func mVar \\\\hlevels  {J : \\\\Set} {R : CRing} (j : J) : E => msMonomial {PermSet J} {R} R.ide (inPS {J} (j :: nil))']<<<break>>>func {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f} (mVar {Fin l.len} {R} j) = l.at j", "completion": "unfold (unfold $ rewrite (func-ide {f}) simplify)"}
{"prompt": "[\"U'o : X.isOpen U'\", 'Uo : X.isOpen U', \"U' : Set X.E\", 'U : Set X.E', 'X : TopSpace']<<<break>>>['| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)', '| isOpen (Set E) : \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>X.isOpen (U \u2227 U')", "completion": "open-inter Uo U'o"}
{"prompt": "['x : X.E', 'fd : IsDenseTopEmbedding {f}', 'f : TopAbGroupMap X Y', 'g : TopAbGroupMap X Z', 'Z : CompleteTopAbGroup']<<<break>>>['cauchy-lift \\\\hlevels  {X Y : CoverSpace} {Z : CompleteCoverSpace} (f : CoverMap X Y) (\\\\property fd : IsDenseEmbedding {f}) (g : CauchyMap X Z)\\n  (y : Y.E) : Z.E => filter-point {Z} (g.func-cauchy (dense-filter-lift {X} {Y} f fd (pointCF {Y} y)))', '\\\\func IsDenseEmbedding \\\\hlevels  {this : PrecoverMap} : \\\\Prop => \\\\Sigma IsDense IsEmbedding', '\\\\func IsDense \\\\hlevels  {this : ContMap} : \\\\Prop => IsDenseSet {Cod} (\\\\lam (y : E {Cod}) => TruncP (\\\\Sigma (x : E {Dom}) (func x = y)))', '\\\\func IsEmbedding \\\\hlevels  {this : PrecoverMap} : \\\\Prop => \\\\Pi {C : Set (Set (E {Dom}))} -> isCauchy {Dom} C ->\\n  isCauchy {Cod} (\\\\lam (V : Set (E {Cod})) => TruncP (\\\\Sigma (U : Set (E {Dom})) (C U) (func ^-1 V \u2286 U)))', '\\\\lemma embedding->coverEmbedding \\\\hlevels  {this : UniformMap} (_ : IsUniformEmbedding) : IsEmbedding ', '| Cod : BaseSet', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\lemma embedding->uniformEmbedding \\\\hlevels  {this : TopAbGroupMap} (_ : IsDenseTopEmbedding) : IsDenseUniformEmbedding ', '| Dom : BaseSet', '\\\\lemma dense-lift-char \\\\hlevels  {X Y : CoverSpace} {Z : CompleteCoverSpace} {f : CoverMap X Y} (fd : IsDenseEmbedding {f}) {g : CoverMap X Z} (x : X.E) :\\n  cauchy-lift {X} {Y} {Z} f {?hidden} g (f.func x) = g.func x ']<<<break>>>cauchy-lift {f.Dom} {f.Cod} {Z} f {?hidden} g (f.func x) = func {g} x", "completion": "dense-lift-char (fd.1, embedding->coverEmbedding {f} (embedding->uniformEmbedding {f} fd).2) x"}
{"prompt": "['a : R.E', 'R : CRing', 'b : R.E', 'a|b : LDiv {R} a b']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func aux-func \\\\hlevels  {R : CRing} {a b : R.E} (a|b : LDiv {R} a b) (x : E) : E => \\\\case x \\\\with {\\n  | in~ x => (aux {R} {a} {b} a|b x).1\\n  | ~-equiv x y r i => (\\\\case (aux {R} {a} {b} a|b x).2, (aux {R} {a} {b} a|b y).2 \\\\with {\\n    | inP ((n, a^n=x2), p), inP ((m, a^m=y2), q) => Paths.inv {Quotient {SType {R} (powers {R} b)}\\n      (\\\\lam (a : SType {R} (powers {R} b)) (b : SType {R} (powers {R} b)) => a.1 R.* b.2 = b.1 R.* a.2)}\\n      {in~ {SType {R} (powers {R} b)}\\n        {\\\\lam (a : SType {R} (powers {R} b)) (b : SType {R} (powers {R} b)) => a.1 R.* b.2 = b.1 R.* a.2}\\n        (x.1 R.* pow {R} a|b.inv n, pow {R} a|b.inv n R.* pow {R} a n,\\n          inP {\\\\Sigma (n1 : Nat) (pow {R} b n1 = pow {R} a|b.inv n R.* pow {R} a n)}\\n            (n, transport {R.E} (\\\\lam (x : R.E) => pow {R} x n = pow {R} a|b.inv n R.* pow {R} a n) {a R.* a|b.inv} {b} a|b.inv-right\\n              (pow_*-comm {R} {a} {a|b.inv} {n} *> R.*-comm {pow {R} a n} {pow {R} a|b.inv n})))} {(aux {R} {a} {b} a|b x).1} p *> ~-pequiv {\\\\Sigma (_ y : R.E) (contains y)} {\\\\lam (x : \\\\Sigma (_ y : R.E) (TruncP (\\\\Sigma (n : Nat) (pow {R} b n = y))))\\n      (y : \\\\Sigma (_ y : R.E) (TruncP (\\\\Sigma (n : Nat) (pow {R} b n = y)))) => x.1 R.* y.2 = y.1 R.* x.2}\\n      {(x.1 R.* pow {R} a|b.inv n, pow {R} a|b.inv n R.* pow {R} a n,\\n        inP {\\\\Sigma (n1 : Nat) (pow {R} b n1 = pow {R} a|b.inv n R.* pow {R} a n)}\\n          (n, transport {R.E} (\\\\lam (x : R.E) => pow {R} x n = pow {R} a|b.inv n R.* pow {R} a n) {a R.* a|b.inv} {b} a|b.inv-right\\n            (pow_*-comm {R} {a} {a|b.inv} {n} *> R.*-comm {pow {R} a n} {pow {R} a|b.inv n})))}\\n      {(y.1 R.* pow {R} a|b.inv m, pow {R} a|b.inv m R.* pow {R} a m,\\n        inP {\\\\Sigma (n : Nat) (pow {R} b n = pow {R} a|b.inv m R.* pow {R} a m)}\\n          (m, transport {R.E} (\\\\lam (x : R.E) => pow {R} x m = pow {R} a|b.inv m R.* pow {R} a m) {a R.* a|b.inv} {b} a|b.inv-right\\n            (pow_*-comm {R} {a} {a|b.inv} {m} *> R.*-comm {pow {R} a m} {pow {R} a|b.inv m})))}\\n      (\\n        \\\\let d => \\\\new CRingData {R} (x.1 :: pow {R} a|b.inv n :: pow {R} a|b.inv m :: pow {R} a m :: y.1 :: pow {R} a n :: y.2 :: x.2 :: nil) {\\n               | interpretNF_negate => {?hidden}\\n             }\\n        \\\\in fromZero {R} {x.1 R.* pow {R} a|b.inv n R.* (pow {R} a|b.inv m R.* pow {R} a m)}\\n              {y.1 R.* pow {R} a|b.inv m R.* (pow {R} a|b.inv n R.* pow {R} a n)} (terms-equality {d}\\n                (var {E {d.C}} {Fin (len {d.vars})} 0 :* var {E {d.C}} {Fin (len {d.vars})} 1 :* (var {E {d.C}} {Fin (len {d.vars})} 2 :* var {E {d.C}} {Fin (len {d.vars})} 3) :+ :negative {E {d.C}} {Fin (len {d.vars})} (var {E {d.C}} {Fin (len {d.vars})} 4 :* var {E {d.C}} {Fin (len {d.vars})} 2 :* (var {E {d.C}} {Fin (len {d.vars})} 1 :* var {E {d.C}} {Fin (len {d.vars})} 5)))\\n                (coef {E {d.C}} {Fin (len {d.vars})} (pos 1) :* var {E {d.C}} {Fin (len {d.vars})} 1 :* var {E {d.C}} {Fin (len {d.vars})} 2 :* (var {E {d.C}} {Fin (len {d.vars})} 0 :* var {E {d.C}} {Fin (len {d.vars})} 6 :+ :negative {E {d.C}} {Fin (len {d.vars})} (var {E {d.C}} {Fin (len {d.vars})} 4 :* var {E {d.C}} {Fin (len {d.vars})} 7)) :+ (:negative {E {d.C}} {Fin (len {d.vars})} (coef {E {d.C}} {Fin (len {d.vars})} (pos 1)) :* var {E {d.C}} {Fin (len {d.vars})} 1 :* var {E {d.C}} {Fin (len {d.vars})} 2 :* var {E {d.C}} {Fin (len {d.vars})} 4 :* (var {E {d.C}} {Fin (len {d.vars})} 5 :+ :negative {E {d.C}} {Fin (len {d.vars})} (var {E {d.C}} {Fin (len {d.vars})} 7)) :+ (coef {E {d.C}} {Fin (len {d.vars})} (pos 1) :* var {E {d.C}} {Fin (len {d.vars})} 0 :* var {E {d.C}} {Fin (len {d.vars})} 1 :* var {E {d.C}} {Fin (len {d.vars})} 2 :* (var {E {d.C}} {Fin (len {d.vars})} 3 :+ :negative {E {d.C}} {Fin (len {d.vars})} (var {E {d.C}} {Fin (len {d.vars})} 6)) :+ :zro {Int} {Fin 8})))\\n                (idp {R.E} {interpretRingNF {d} (normalize {d}\\n                  (var {Int} {Fin 8} 0 :* var {Int} {Fin 8} 1 :* (var {Int} {Fin 8} 2 :* var {Int} {Fin 8} 3) :+ :negative {Int} {Fin 8} (var {Int} {Fin 8} 4 :* var {Int} {Fin 8} 2 :* (var {Int} {Fin 8} 1 :* var {Int} {Fin 8} 5))))}) *> gensZeroToIdealZero {R} ((interpret {d}\\n                (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1) :* var {E {d.C}} {Fin (len {vars {d.mData}})} 1 :* var {E {d.C}} {Fin (len {vars {d.mData}})} 2),\\n                x.1 R.* y.2 R.+ R.negative (y.1 R.* x.2), toZero {R} {x.1 R.* y.2} {y.1 R.* x.2} r) :: (interpret {d}\\n                  (:negative {E {d.C}} {Fin (len {vars {d.mData}})} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1)) :* var {E {d.C}} {Fin (len {vars {d.mData}})} 1 :* var {E {d.C}} {Fin (len {vars {d.mData}})} 2 :* var {E {d.C}} {Fin (len {vars {d.mData}})} 4),\\n                  pow {R} a n R.+ R.negative x.2, toZero {R} {pow {R} a n} {x.2} a^n=x2) :: (interpret {d}\\n                    (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1) :* var {E {d.C}} {Fin (len {vars {d.mData}})} 0 :* var {E {d.C}} {Fin (len {vars {d.mData}})} 1 :* var {E {d.C}} {Fin (len {vars {d.mData}})} 2),\\n                    pow {R} a m R.+ R.negative y.2, toZero {R} {pow {R} a m} {y.2} a^m=y2) :: nil {\\\\Sigma R.E (gen : R.E) (gen = R.zro)}))) *> q\\n  }) @ i\\n}', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\instance LocRing \\\\hlevels  {R : CRing} (S : SubMonoid R) : CRing (Type {R} {S}) {\\n  | zro => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.zro, R.ide, S.contains_ide)\\n  | + => ++ {R} {S}\\n  | * => ** {R} {S}\\n  | negative => neg {R} {S}\\n  | ide => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.ide, R.ide, S.contains_ide)\\n  | natCoef => \\\\lam (n : Nat) => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2}\\n    (R.natCoef n, R.ide, S.contains_ide)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '| E : \\\\Set', '| negative E : E', '| contains (E {S}) : \\\\Prop', 'in~ A', '| len : Nat', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', '| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| contains_ide : contains (ide {S})', '\\\\func powers \\\\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (pow {M} a n = x))) \\n=> \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func ~-pequiv {A : \\\\Type} {R : A -> A -> \\\\Type} {x y : A} (r : R x y) : in~ {A} {R} x = in~ {A} {R} y => path (~-equiv {A} {R} x y r)', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| M : Monoid', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '| C : Semiring', '\\\\lemma aux \\\\hlevels  {R : CRing} {a b : R.E} (a|b : LDiv {R} a b) (x : SType {R} (powers {R} a)) :\\n\\\\Sigma (b1 : E) (TruncP (\\\\Sigma (a1 : \\\\Sigma (n : Nat) (pow {R} a n = x.2)) (in~ {SType {R} (powers {R} b)}\\n  {\\\\lam (a : SType {R} (powers {R} b)) (b : SType {R} (powers {R} b)) => a.1 R.* b.2 = b.1 R.* a.2}\\n  (x.1 R.* pow {R} a|b.inv a1.1, pow {R} a|b.inv a1.1 R.* pow {R} a a1.1,\\n    inP {\\\\Sigma (n : Nat) (pow {R} b n = pow {R} a|b.inv a1.1 R.* pow {R} a a1.1)} (a1.1,\\n      transport {R.E} (\\\\lam (x : E {a|b.M}) => pow {R} x a1.1 = pow {R} a|b.inv a1.1 R.* pow {R} a a1.1) {a R.* a|b.inv} {b}\\n        a|b.inv-right (pow_*-comm {R} {a} {a|b.inv} {a1.1} *> R.*-comm {pow {R} a a1.1} {pow {R} a|b.inv a1.1}))) = b1))) ', 'coef C', 'nil', 'inP A', '| Cod : BaseSet', '| inv-right : val * inv = elem', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '| *-comm {x y : E} : x * y = y * x', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', ':ide', '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', ':zro', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '\\\\lemma pow_*-comm \\\\hlevels  {this : CMonoid} {a b : E} {n : Nat} : pow (a * b) n = pow a n * pow b n ', '\\\\func SType \\\\hlevels  {R : CRing} (S : SubMonoid R) : \\\\Set => \\\\Sigma (_ y : R.E) (S.contains y)', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| inv : E {M}', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '| zro : E', 'var V', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>RingHom (LocRing {R} (powers {R} a)) (LocRing {R} (powers {R} b)) {\n  | func => aux-func {R} {a} {b} a|b\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "completion": "\\new RingHom {\n  | Dom => LocRing (powers a)\n  | Cod => LocRing (powers b)\n  | func => aux-func {R} a|b\n  | func-+ => \\lam {p0} {p1} => (\\scase \\elim p0, \\elim p1 \\with {\n    | in~ x, in~ y => \\scase (aux {R} a|b x).2, (aux {R} a|b y).2, (aux {R} a|b _).2 \\with {\n      | inP ((n, a^n=x2), p1), inP ((m, a^m=y2), p2), inP ((k, a^k=x2y2), p3) => inv p3 *> ~-pequiv equation *> pmap2 (+) p1 p2\n    }\n  })\n  | func-ide => \\scase (aux {R} a|b _).2 \\with {\n    | inP ((n, a^n=1), p) => inv p *> ~-pequiv equation\n  }\n| func-* => \\lam {p0} {p1} => (\\scase \\elim p0, \\elim p1 \\with {\n  | in~ x, in~ y => \\scase (aux {R} a|b x).2, (aux {R} a|b y).2, (aux {R} a|b _).2 \\with {\n    | inP ((n, a^n=x2), p1), inP ((m, a^m=y2), p2), inP ((k, a^k=x2y2), p3) => inv p3 *> ~-pequiv equation *> pmap2 (*) p1 p2\n  }\n})\n}"}
{"prompt": "['l : Array X.E n', 'X : PseudoNormedAbGroup', 'n : Nat', 'x : X.E']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '| <=-refl {x : E} : x <= x', 'suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\lemma lnorm_BigSum \\\\hlevels  {X : PseudoNormedAbGroup} {l : Array X.E} :\\n  lnorm {X} (BigSum {X} l) <= BigSum {RealAbGroup} (\\\\new Array Real l.len (\\\\lam (j : Fin l.len) => lnorm {X} (l.at j))) ', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '| zro : E', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func lnorm \\\\hlevels  {X : PseudoNormedAbGroup} (x : X.E) : Real => X.norm x', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\lemma lnorm_+ \\\\hlevels  {X : PseudoNormedAbGroup} {x y : X.E} : lnorm {X} (x X.+ y) <= lnorm {X} x + lnorm {X} y ', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>lnorm {X} (BigSum {X} (x :: l)) <= BigSum {RealAbGroup} (\\new Array Real (suc n) (\\lam (j : Fin (suc n)) => lnorm {X} (at {x :: l} j)))", "completion": "lnorm_+ <=\u2218 <=_+ <=-refl lnorm_BigSum"}
{"prompt": "[\"b_z1<b_y'1b<=l : \\\\Sigma (b : Q.E) (z.1 Q.< b)\\n  (\\\\Pi {x : Q.E} -> point {Q} x < (y'.1, b) -> TruncP (\\\\Sigma (j : Fin l.len) (point {Q} x < l.at j)))\", 'Q : Dec', \"b'<b : b' Q.< b\", \"b' : Q.E\", \"x' : E\"]<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', '| E : \\\\Set', '\\\\instance RealPres \\\\hlevels  (Q : Dec) : FramePres (Interval Q) {\\n  | conj => (\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))} {Interval Q}\\n    (\\\\lam (p0 : \\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))) =>\\n    (\\\\case p0 \\\\with {\\n      | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n        | zero => (p, q)\\n        | suc zero => (r, s)\\n      }))\\n      | (false, (p, q)) => (\\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\\n        \\\\lam (t : \\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\\n    }))\\n} => \\\\new FramePres', '\\\\lemma cover-pair \\\\hlevels  {Q : Dec} {x : Interval Q} {z1 z2 : Q.E} (_ : z1 Q.< z2) :\\nCover {RealPres Q} x {Fin 2} (\\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n  | zero => (x.1, z2)\\n  | suc zero => (z1, x.2)\\n})) ']<<<break>>>Cover {RealPres Q} x' {Fin 2} (\\lam (p0 : Fin 2) => (\\case p0 \\with {\n  | zero => (x'.1, b)\n  | suc zero => (b', x'.2)\n}))", "completion": "cover-pair b'<b"}
{"prompt": "['A : Set Real', 'eps>0 : zro < eps', 'eps : Real', 'Ac : \\\\Pi {eps : Real} -> zro < eps -> TruncP (\\\\Sigma (l : Array Real) (\\\\Pi (j : Fin l.len) -> A (l !! j))\\n  (\\\\Pi {x : Real} -> A x -> TruncP (\\\\Sigma (j : Fin l.len) (abs {RealField} (x - l !! j) < eps))))']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\lemma abs_negative \\\\hlevels  {this : LatticeAbGroup} {x : E} : abs (negative x) = abs x ', 'negative \\\\plevels  \\\\hlevels  (x : Real) : Real \\n=> \\\\new Real (\\\\lam (a : Rat) => x.U (RatField.negative a)) (\\\\lam (a : Rat) => x.L (RatField.negative a)) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', 'inP A', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| E : \\\\Set', '| negative E : E', '\\\\lemma negative_+ \\\\hlevels  {this : AddGroup} {x y : E} : negative (x + y) = negative y - x ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| +-comm {x y : E} : x + y = y + x']<<<break>>>TruncP (\\Sigma (l : Array Real) (\\Pi (j : Fin l.len) -> A (negative (l !! j)))\n  (\\Pi {x : Real} -> A (negative x) -> TruncP (\\Sigma (j : Fin l.len) (abs {RealField} (x - l !! j) < eps))))", "completion": "\\case Ac eps>0 \\with {\n  | inP (l, Al, lb) => inP (map negative l, \\lam j => transportInv A negative-isInv (Al j), \\lam A-x => (\\case lb A-x \\with {\n    | inP (j, p) => inP (j, transport (\\lam _x => _x < _) (pmap abs (+-comm *> simplify) *> abs_negative) p)\n  }))\n}"}
{"prompt": "['g : Hom {\\\\this} X Y', 'f : Hom {\\\\this} Y Z', 'this : InterwiningMap {G1} {R} X Z {\\n  | func => \\\\lam (a : E {Dom {f \u2218 g}}) => f.func (g.func a)\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n  | func-** => {?hidden}\\n}', 'Y : Ob {\\\\this}', 'Z : Ob {\\\\this}', 'X : Ob {\\\\this}']<<<break>>>['| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e', '| G : Group', '| \\\\infixl 8 ** (E {G}) E : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>\\Pi {e : E {Dom {\\this}}} -> \\Pi {g1 : E {G {\\this}}} -> f.func (g.func (g1 X.** e)) = g1 Z.** f.func (g.func e)", "completion": "\\lam {e} {g} => rewrite (func-** {g}, func-** {f}) idp"}
{"prompt": "['J : \\\\Set', 'j : J', 'Jf<=P : Join {J} f <= pHat P', 'f : J -> E', 'P : \\\\Prop', 'this : Locale']<<<break>>>['\\\\func pHat \\\\hlevels  {this : Locale} (P : \\\\Prop) : E => Join {P} (\\\\lam (_ : P) => top)', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '| \\\\infix 4 <= E E : \\\\Prop', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>f j <= pHat P", "completion": "Join-cond {this} j <=\u2218 {this} Jf<=P"}
{"prompt": "['p : \\\\Pi (i : Fin (suc l.len)) -> (at {a :: l} i).1 = V.zro', 'n : Nat', 'B : BottomDistributiveLattice', 'V : AddMonoid', 'a : \\\\Sigma V.E B.E', 'l : Array (\\\\Sigma V.E B.E) n']<<<break>>>['| len : Nat', '| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '| at (j : Fin len) : A j', '| E : \\\\Set']<<<break>>>\\Pi (i : Fin l.len) -> (at {a :: l} (suc i)).1 = V.zro", "completion": "\\lam i => p (suc i)"}
{"prompt": "['l2 : Array (\\\\Sigma R.E M)', 'R : AddMonoid', \"e1 : l1 ~ l1'\", 'l1 : Array (\\\\Sigma R.E M)', \"e2 : Closure {Array (\\\\Sigma R.E M)} (~) l2 l2'\", 'M : \\\\Set', \"l2' : Array (\\\\Sigma R.E M)\", \"l1' : Array (\\\\Sigma R.E M)\"]<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", 'ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', '\\\\lemma ~_++-right \\\\hlevels  {M : \\\\Set} {R : AddMonoid} {l l1 l2 : Array (\\\\Sigma R.E M)} (_ : Closure {Array (\\\\Sigma R.E M)} (~) l1 l2) :\\n  Closure {Array (\\\\Sigma R.E M)} (~) (l ++ l1) (l ++ l2) ', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\data Closure {A : \\\\Type} (A -> A -> \\\\Type) (_ _ : A) : \\\\Prop \\n  | cin (R x y)\\n  | ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', \"\\\\func ~_++-left {M4 : \\\\Set} {R4 : AddMonoid} {l12 l13 l14 : Array (\\\\Sigma R.E M4)} (_ : l12 ~ l13) : (l12 ++ l14) ~ (l13 ++ l14) \\n  | {M}, {R}, {l1}, {l2}, {l}, ~-perm e => ~-perm {M} {R} {l1 ++ l} {l2 ++ l} (eperm-++-left {\\\\Sigma R.E M} {l1} {l2} {l} e)\\n  | {M}, {R}, {l1}, {l2}, {l}, ~-sym e => ~-sym {M} {R} {l1 ++ l} {l2 ++ l} (~_++-left {M} {R} {l2} {l1} {l} e)\\n  | {M}, {R}, {l1}, {l2}, {l}, ~-zro {m} p => ~-zro {M} {R} {l1 ++ l} {l2 ++ l} {m}\\n    (pmap {Array (\\\\Sigma R.E M)} {Array (\\\\Sigma R.E M)} (\\\\lam (_x : Array (\\\\Sigma R.E M)) => _x ++ l) {l1} {(R.zro, m) :: l2} p)\\n  | {M}, {R}, {l1}, {l2}, {l}, ~-+ {l''} m {a} {b} p q => ~-+ {M} {R} {l1 ++ l} {l2 ++ l} {\\\\new l'' {} ++ l} m {a} {b}\\n    (pmap {Array (\\\\Sigma R.E M)} {Array (\\\\Sigma R.E M)} (\\\\lam (_x : Array (\\\\Sigma R.E M)) => _x ++ l) {l1} {(a R.+ b, m) :: l''} p)\\n    (pmap {Array (\\\\Sigma R.E M)} {Array (\\\\Sigma R.E M)} (\\\\lam (_x : Array (\\\\Sigma R.E M)) => _x ++ l) {l2}\\n      {(a, m) :: (b, m) :: l''} q)\", 'cin (R x y)']<<<break>>>Closure {Array (\\Sigma R.E M)} (~) (l1 ++ l2) (l1' ++ l2')", "completion": "ctrans (cin (~_++-left e1)) (~_++-right e2)"}
{"prompt": "['X : ExPseudoNormedRing', 'B_|x|<B : \\\\Sigma (r : Rat) (U {X.norm x} r)', 'x : X.E', 'eps : Rat']<<<break>>>['\\\\type \\\\infix 4 < \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => TruncP (\\\\Sigma (q : Rat) (x.U q) (fromRat q <= y))', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma <-rat \\\\plevels  \\\\hlevels  {x : ExUpperReal} {y : Rat} : x < fromRat y <-> x.U y ', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| norm E : ExUpperReal', '\\\\lemma <_+-left \\\\plevels  \\\\hlevels  {x y : ExUpperReal} (_ : x < y) {z : Rat} : x + fromRat z < y + fromRat z ']<<<break>>>X.norm x + fromRat eps < fromRat B + fromRat eps", "completion": "<_+-left (<-rat.2 |x|<B)"}
{"prompt": "['n : Nat', 'R : CRing']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\instance MonoidAlgebra \\\\hlevels  (M : CMonoid) (R1 : CRing) : CAlgebra R1 (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | negative => negative {M.E} {R1}\\n  | *c => \\\\lam (x : E {R}) => (Semigroup.*) (func {monoidRingHom {M} {R1}} x)\\n  | * => (MonoidSemiring.*)\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | coefMap => coefMap-impl\\n} => homAlgebra {R1} {\\\\new CRing (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (MonoidSemiring.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => negative {M.E} {R1}\\n  | negative-left => {?hidden}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}} (monoidRingHom {M} {R1})', 'suc Nat', '\\\\func fHom \\\\hlevels  {n : Nat} {R : CRing} : RingHom (MonoidRing (PermSetMonoid (Fin (suc n))) R) (MPoly (Fin n) (PolyAlgebra R)) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => func {mPolyEval {Fin (suc n)} {MPoly (Fin n) (PolyAlgebra R)}\\n    (at {mConst {Fin n} {PolyAlgebra R} (padd {R} ide R.zro) :: mkArray {MonoidSet (PermSet (Fin n)) (PolyAlgebra R)} {n} (mVar {Fin n} {PolyAlgebra R})})}\\n    (func {mPoly-mapHom {Fin (suc n)} {R} {MPoly (Fin n) (PolyAlgebra R)} (mPolyHom {Fin n} {PolyAlgebra R} \u2218 polyHom {R})} x)\\n} => mPolyMapEvalRingHom {Fin (suc n)} {R} {MPoly (Fin n) (PolyAlgebra R)} (mPolyHom {Fin n} {PolyAlgebra R} \u2218 polyHom {R})\\n  (at {mConst {Fin n} {PolyAlgebra R} (padd {R} ide R.zro) :: mkArray {MonoidSet (PermSet (Fin n)) (PolyAlgebra R)} {n} (mVar {Fin n} {PolyAlgebra R})})', '\\\\instance PolyAlgebra \\\\hlevels  (R1 : CRing) : CAlgebra R1 (Poly R1) {\\n  | zro => pzero {R1}\\n  | + => (+)\\n  | negative => negative {R1}\\n  | *c => (*c)\\n  | * => (*)\\n  | ide => padd {R1} (pzero {R1}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R1} (pzero {R1}) (R.natCoef n)\\n  | coefMap => coefMap-impl\\n} => \\\\new CAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\instance MonoidRing \\\\hlevels  (M : Monoid) (R : Ring) : Ring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | negative => negative {M.E} {R}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\func retHom \\\\hlevels  {n : Nat} {R : CRing} :\\nRingHom (MonoidRing (PermSetMonoid (Fin n)) (PolyAlgebra R)) (MonoidAlgebra (PermSetMonoid (Fin (suc n))) R) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) =>\\n  func {mPolyEval {Fin n} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (\\\\lam (j : Fin n) => mVar {Fin (suc n)} {R} (fsuc {n} j))}\\n    (func {mPoly-mapHom {Fin n} {PolyAlgebra R} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (polyMapEvalRingHom\\n      {R} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (mPolyHom {Fin (suc n)} {R}) (mVar {Fin (suc n)} {R} 0))} x)\\n} => mPolyMapEvalRingHom {Fin n} {PolyAlgebra R} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (polyMapEvalRingHom\\n  {R} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (mPolyHom {Fin (suc n)} {R}) (mVar {Fin (suc n)} {R} 0))\\n  (\\\\lam (j : Fin n) => mVar {Fin (suc n)} {R} (fsuc {n} j))', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ', '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func \\\\infixl 8 compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {R S T : Ring} (g : RingHom S T) (f : RingHom R S) : RingHom R T {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\func MPoly \\\\hlevels  (J : \\\\Set) (R1 : CRing) : CAlgebra R1 (MonoidSet E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E E)} {(~)} nil\\n  | + => (+)\\n  | negative => negative {E} {R1}\\n  | *c => \\\\lam (x : E {R}) => (Semigroup.*) (func {monoidRingHom {PermSetMonoid J} {R1}} x)\\n  | * => (MonoidSemiring.*)\\n  | ide => in~ {Array (\\\\Sigma R.E E)} {(~)} ((R.ide, ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring (PermSetMonoid J) R1}\\n  | coefMap => coefMap-impl\\n} => MonoidAlgebra (PermSetMonoid J) R1']<<<break>>>RingHom (MonoidRing (PermSetMonoid (Fin n)) (PolyAlgebra R)) (MPoly (Fin n) (PolyAlgebra R)) {\n  | func => \\lam (x : E {Dom {\\this}}) => func {fHom {n} {R}} (func {retHom {n} {R}} x)\n}", "completion": "fHom \u2218 retHom"}
{"prompt": "['r : Rat', 'b : Rat', 'rr<b : r * r < b']<<<break>>>[\"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)']<<<break>>>r * r <= b", "completion": "<=-less rr<b"}
{"prompt": "['z1=z : z1 = z', 'z : InfReal', 'z2=z : z2 = z', 'z1 : Real', 'z2 : Real']<<<break>>>['\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\class InfReal \\\\extends LowerReal, ExUpperReal \\\\hlevels  {\\n  | LU-disjoint {q : Rat} (L q) (U q) : Empty\\n  | LU-located {q r : Rat} (q < r) : L q || U r\\n  | LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma real-lower-ext \\\\plevels  \\\\hlevels  {x y : Real} (_ : x = y) : x = y ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>z1 = z2", "completion": "real-lower-ext (z1=z *> inv z2=z)"}
{"prompt": "['i : I', 'H : Group', 'G : Group', 'p : G = H', 'this : Group (E {p @ i}) {\\n  | ide => ide {p @ i}\\n  | * => (*) {p @ i}\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse => h1 @ i\\n  | inverse-left => {?hidden}\\n  | inverse-right => {?hidden}\\n}']<<<break>>>['| \\\\infixl 7 * E E : E', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| ide : E', '| E : \\\\Set', '| ide-right {x : E} : x * ide = x']<<<break>>>\\Pi {x : E {\\this}} -> x * ide {p @ i} = x", "completion": "\\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (ide-right {G}) (ide-right {H})) i {x}"}
{"prompt": "['A : StoneC*Algebra']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\class ContMap \\\\extends SetHom \\\\hlevels  {\\n  | func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))\\n}', '\\\\lemma TopTransfer-map \\\\hlevels  {X : \\\\Set} {Y : TopSpace} (f : X -> Y.E) : ContMap (TopTransfer {X} {Y} f) Y {\\n  | func => f\\n} ', '\\\\lemma *-locally-uniform \\\\hlevels  {X : ExPseudoNormedPseudoRing} : LocallyUniformMap (X \u2a2f X) X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 X.* s.2\\n} ', '\\\\func tuple \\\\hlevels  {X Y Z : TopSpace} (f : ContMap X Y) (g : ContMap X Z) : ContMap X (Y \u2a2f Z) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, g.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma TopTransfer-lift \\\\hlevels  {X Y : TopSpace} {U : Set Y.E} (f : ContMap X Y) (p : \\\\Pi (x : X.E) -> U (f.func x)) :\\nContMap X (TopTransfer {Total {Y.E} U} {Y} (\\\\lam (p0 : Total {Y.E} U) => p0.1)) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, p x)\\n} ', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : TopSpace} (g : ContMap Y Z) (f : ContMap X Y) : ContMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\lemma square-norm \\\\hlevels  {A : StoneC*Algebra} {w : A.E} (_ : w A.<= A.ide) (_ : A.norm (A.ide - w) <= ide) : A.norm (A.ide - w A.* w) <= ide ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '| E : \\\\Set', '\\\\func Total {X : \\\\Type} (U : Set X) : \\\\Type => \\\\Sigma (x : X) (\\\\property (U x))', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| ide : E', '\\\\instance TopSpaceHasProduct \\\\hlevels  : HasProduct TopSpace {\\n  | Product => ProductTopSpace\\n} => \\\\new HasProduct', '| norm E : ExUpperReal', '\\\\func id \\\\hlevels  {X : TopSpace} : ContMap X X {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\instance ExUpperRealLattice \\\\hlevels  : CompleteLattice ExUpperReal {\\n  | <= => (ExUpperReal.<=)\\n  | meet => meet\\n  | join => join\\n  | top => top-impl\\n  | Join => ExUpperRealLattice.Join\\n  | Meet => ExUpperRealLattice.Meet\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func zfunc-lim \\\\hlevels  {this1 : RealBanachAlgebra} : CoverMap UnitBall this1 {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => value {limit {NatBSemilattice} (\\\\lam (p0 : E) => zfunc p0 x.1)}\\n    (funcConv-pointwise {NatBSemilattice} {UnitBall} (\\\\lam (n : E) (s : E) => zfunc n s.1) zfunc-funcConv {x})\\n} => funcLimit {NatBSemilattice} {UnitBall} (\\\\lam (n : E) (s : E) => zfunc n s.1) zfunc-funcConv', '\\\\func TopTransfer \\\\hlevels  {X : \\\\Set} {Y : TopSpace} (f : X -> Y.E) : TopSpace X {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) => TruncP (\\\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}']<<<break>>>ContMap (TopTransfer {\\Sigma (x : A.E) (\\Sigma (x A.<= A.ide) (A.norm (A.ide - x) Preorder.<= ide))} {A}\n  (\\lam (p1 : \\Sigma (x : A.E) (\\Sigma (x A.<= A.ide) (A.norm (A.ide - x) Preorder.<= ide))) => p1.1)) A {\n  | func => \\lam (x : E {Dom {\\this}}) => func {zfunc-lim {A}}\n    (func {TopTransfer-lift {TopTransfer {\\Sigma (x : A.E) (\\Sigma (x A.<= A.ide) (A.norm (A.ide - x) Preorder.<= ide))} {A}\n      (\\lam (p1 : \\Sigma (x : A.E) (\\Sigma (x A.<= A.ide) (A.norm (A.ide - x) Preorder.<= ide))) => p1.1)} {A}\n      {\\lam (x : A.E) => norm {A} (ide {A} - x) ExUpperReal.<= fromRat ide}\n      (*-locally-uniform {A} \u2218 tuple {A} {A} {A} (id {A}) (id {A}) \u2218 TopTransfer-map {\\Sigma (x : A.E) (\\Sigma (x A.<= A.ide) (A.norm (A.ide - x) Preorder.<= ide))} {A}\n        (\\lam (p0 : \\Sigma (x : A.E) (\\Sigma (x A.<= A.ide) (A.norm (A.ide - x) Preorder.<= ide))) => p0.1))\n      (\\lam (s : E) => square-norm {A} {s.1} s.2.1 s.2.2)} x)\n}", "completion": "zfunc-lim \u2218 TopTransfer-lift\n  (*-locally-uniform \u2218 tuple id id \u2218 TopTransfer-map (\\lam p0 => p0.1)) (later (\\lam s => square-norm {A} s.2.1 s.2.2))"}
{"prompt": "['a : Nat', 'al : InList {Nat} a l', 'l : List Nat', 'b : Nat']<<<break>>>[\"\\\\data InList {A : \\\\Type} A (List A) : \\\\Prop \\\\with\\n  | {A}, a, a' :: l => here (a = a')\\n  | {A}, a, a' :: l => there (InList {A} a l)\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', 'there (InList {A} a l)', '\\\\infixr 5 :: A (List A)']<<<break>>>InList {Nat} a (b :: l)", "completion": "there al"}
{"prompt": "[\"this : MatchingFamily {C1} {S.D} {Comp {Precat.op {C1}} {Precat.op {C'}} {S.D} S.F (Functor.op {f})} x {J1} g z {\\n  | family => m.family\\n  | isMatching => {?hidden}\\n}\", \"f : SiteWithBasisPrehom C C'\", \"S : VSheaf {\\n  | C => C'\\n}\", \"C' : SiteWithBasis\", 'g : J -> Ob', 'z : Ob {S.D}', 'm : A {\\\\this}', 'x : C.Ob', 'C : SiteWithBasis']<<<break>>>[\"| isMatching (j j' : J) : Func {vsheafOnSiteWithBasis.MatchingFamily.F} {(g j).1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n  (pbProj1 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) \u2218 family j = Func {vsheafOnSiteWithBasis.MatchingFamily.F} {(g j').1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n  (pbProj2 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) \u2218 family j'\", '\\\\func reverse \\\\plevels obj >= hom \\\\hlevels  {this : Iso} : Iso {C} {cod} {dom} hinv {\\n  | hinv => f\\n} => \\\\new Iso {\\n  | hinv_f => {?hidden}\\n  | f_hinv => {?hidden}\\n}', '| pullback {x y z : Ob} (f : Hom x z) (g : Hom y z) : Pullback {x} {y} {z} f g', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| pbProj1 : Hom {D} apex x', '| apex : Ob {D}', '| family (j : J) : Hom {D} z (Functor.F {vsheafOnSiteWithBasis.MatchingFamily.F} (g j).1)', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '| pbCoh : f \u2218 pbProj1 = g \u2218 pbProj2', '| F : Functor (op {C}) D', '\\\\func Func-iso \\\\plevels obj >= hom \\\\hlevels  {this1 : Functor} (e : Iso {C}) : Iso {D} {F e.dom} {F e.cod} (Func {e.dom} {e.cod} e.f) {\\n  | hinv => Func {e.cod} {e.dom} e.hinv\\n} => \\\\new Iso {\\n  | hinv_f => {?hidden}\\n  | f_hinv => {?hidden}\\n}', '| J : \\\\Set', '| C : Precat', '| z : Ob {D}', '| g J : Ob', '| x : Ob {C}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', '| hinv : Hom {C} cod dom', '| F-pullback {x1 y1 z1 : Ob {C}} {f1 : Hom {C} x1 z1} {g1 : Hom {C} y1 z1} : Iso {Functor.D} {F (apex {pullback {C} {x1} {y1} {z1} f1 g1})}\\n  {apex {pullback {Functor.D} {F x1} {F y1} {F z1} (Func {x1} {z1} f1) (Func {y1} {z1} g1)}}\\n  (pbMap {pullback {Functor.D} {F x1} {F y1} {F z1} (Func {x1} {z1} f1) (Func {y1} {z1} g1)}\\n    {F (apex {pullback {C} {x1} {y1} {z1} f1 g1})}\\n    (Func {apex {pullback {C} {x1} {y1} {z1} f1 g1}} {x1} (pbProj1 {pullback {C} {x1} {y1} {z1} f1 g1}))\\n    (Func {apex {pullback {C} {x1} {y1} {z1} f1 g1}} {y1} (pbProj2 {pullback {C} {x1} {y1} {z1} f1 g1}))\\n    (inv {Hom {Functor.D} (F (apex {pullback {C} {x1} {y1} {z1} f1 g1})) (F z1)}\\n      {Func {apex {pullback {C} {x1} {y1} {z1} f1 g1}} {z1} (f1 \u2218 pbProj1 {pullback {C} {x1} {y1} {z1} f1 g1})}\\n      {Func {x1} {z1} f1 \u2218 Func {apex {pullback {C} {x1} {y1} {z1} f1 g1}} {x1} (pbProj1 {pullback {C} {x1} {y1} {z1} f1 g1})}\\n      (Func-o {apex {pullback {C} {x1} {y1} {z1} f1 g1}} {x1} {z1} {f1} {pbProj1 {pullback {C} {x1} {y1} {z1} f1 g1}}) *> pmap {Hom {C} (apex {pullback {C} {x1} {y1} {z1} f1 g1}) z1}\\n      {Hom {Functor.D} (F (apex {pullback {C} {x1} {y1} {z1} f1 g1})) (F z1)}\\n      (Func {apex {pullback {C} {x1} {y1} {z1} f1 g1}} {z1})\\n      {f {pullback {C} {x1} {y1} {z1} f1 g1} \u2218 pbProj1 {pullback {C} {x1} {y1} {z1} f1 g1}}\\n      {g {pullback {C} {x1} {y1} {z1} f1 g1} \u2218 pbProj2 {pullback {C} {x1} {y1} {z1} f1 g1}}\\n      (pbCoh {pullback {C} {x1} {y1} {z1} f1 g1}) *> Func-o {apex {pullback {C} {x1} {y1} {z1} f1 g1}} {y1} {z1} {g1} {pbProj2 {pullback {C} {x1} {y1} {z1} f1 g1}}))', '| pbProj2 : Hom {D} apex y', '| pbBeta2 {w : Ob {D}} {p1 : Hom {D} w x} {p2 : Hom {D} w y} {c : f \u2218 p1 = g \u2218 p2} : pbProj2 \u2218 pbMap {w} p1 p2 c = p2', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this : Iso} : Iso {op {C}} {cod} {dom} f {\\n  | hinv => hinv\\n} => \\\\new Iso {\\n  | hinv_f => {?hidden}\\n  | f_hinv => {?hidden}\\n}', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| D : Cat', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| isMono {x : Ob {C}} {g h : Hom {C} x dom} (f \u2218 g = f \u2218 h) : g = h', '| D : Precat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| C : SiteWithBasis', \"\\\\lemma adjointMap' \\\\plevels obj >= hom \\\\hlevels  {this : Iso} {z : Ob {C}} {g : Hom {C} cod z} {h : Hom {C} dom z} (_ : g \u2218 f = h) : g = h \u2218 hinv \", '| pbBeta1 {w : Ob {D}} {p1 : Hom {D} w x} {p2 : Hom {D} w y} {c : f \u2218 p1 = g \u2218 p2} : pbProj1 \u2218 pbMap {w} p1 p2 c = p1', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| D : Cat']<<<break>>>\\Pi (j : J {\\this}) -> \\Pi (j' : J {\\this}) -> Func {vsheafOnSiteWithBasis.MatchingFamily.F {\\this}} {(g {\\this} j).1}\n  {apex {pullback {C {\\this}} {(g {\\this} j).1} {(g {\\this} j').1} {x {\\this}} (g {\\this} j).2 (g {\\this} j').2}}\n  (pbProj1 {pullback {C {\\this}} {(g {\\this} j).1} {(g {\\this} j').1} {x {\\this}} (g {\\this} j).2 (g {\\this} j').2}) \u2218 family {\\this} j = Func {vsheafOnSiteWithBasis.MatchingFamily.F {\\this}} {(g {\\this} j').1}\n  {apex {pullback {C {\\this}} {(g {\\this} j).1} {(g {\\this} j').1} {x {\\this}} (g {\\this} j).2 (g {\\this} j').2}}\n  (pbProj2 {pullback {C {\\this}} {(g {\\this} j).1} {(g {\\this} j').1} {x {\\this}} (g {\\this} j).2 (g {\\this} j').2}) \u2218 family {\\this} j'", "completion": "\\lam j j' => (\n  \\have e : Iso => F-pullback {f}\n  \\in isMono {reverse {Func-iso {F {S}} (op {e})}} $ inv o-assoc *> pmap (\\lam _x => _x \u2218 _) (inv Func-o *> pmap Func (unfold $ inv $ adjointMap' {e} pbBeta1)) *> isMatching {m} j j' *> pmap (\\lam _x => _x \u2218 _) (pmap Func (unfold $ adjointMap' {e} pbBeta2) *> Func-o) *> o-assoc)"}
{"prompt": "['G : Group', 'H : SubGroup G']<<<break>>>['\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '\\\\func ActionBySubgroup \\\\hlevels  {G : Group} (H : SubGroup G) : GroupAction G (Cosets {H}) {\\n  | ** => (**)\\n} => \\\\new GroupAction {\\n  | **-assoc => {?hidden}\\n  | id-action => {?hidden}\\n}', '\\\\func ** {G2 : Group} {H2 : SubGroup G2} (_ : G.E) (_ : Cosets {H2}) : Cosets {H2} \\n  | {G}, {H}, g, in~ a => in~ {E {H.S}} {(~)} (g G.* a)\\n  | {G}, {H}, g, ~-equiv x y r i =>\\n  ((==<) {Quotient {G.E} (~)} (in~ {G.E} {(~)} (g G.* x)) {in~ {G.E} {(~)} (g G.* x G.* (G.inverse x G.* y))}\\n    (invariant-right-multiplication {H} {g G.* x} {G.inverse x G.* y} (equivalence-to-1 {H} {x} {y} r)) >== (==<) {Quotient {G.E} (~)} (in~ {G.E} {(~)} (g G.* x G.* (G.inverse x G.* y))) {in~ {G.E} {(~)} (g G.* y)}\\n    (pmap {G.E} {Quotient {G.E} (~)} (in~ {G.E} {(~)}) {g G.* x G.* (G.inverse x G.* y)} {g G.* y} (trivialRelation {G} g x y)) >== qed {Quotient {G.E} (~)} (in~ {G.E} {(~)} (g G.* y))) @ i', \"\\\\lemma isTransAction {G : Group} {H : SubGroup G} (v v' : Cosets {H}) : TruncP (\\\\Sigma (g : G.E) (g ** v = v')) \", \"\\\\class TransitiveGroupAction \\\\extends GroupAction \\\\hlevels  {\\n  | isTransAction (v v' : E) : TruncP (\\\\Sigma (g : E {G}) (g ** v = v'))\\n}\", '| id-action {e : E} : ide {G} ** e = e', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '| S : BaseSet', '| **-assoc {m n : E {G}} {e : E} : m ** (n ** e) = (m * n) ** e', '\\\\func equivalence \\\\hlevels  {this4 : SubGroup} : Equivalence (E {S}) {\\n  | ~ => \\\\lam (x : A {\\\\this}) (y : A {\\\\this}) => contains (inverse {S} x * y)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', '\\\\func Cosets \\\\hlevels  {this : SubGroup} : \\\\Set => Quotient {E {S}} (~)']<<<break>>>TransitiveGroupAction G (Quotient {E {H.S}} (~)) {\n  | ** => (**)\n  | **-assoc => {?hidden}\n  | id-action => {?hidden}\n  | isTransAction => {?hidden}\n}", "completion": "\\new TransitiveGroupAction {\n  | G => G\n  | GroupAction => ActionBySubgroup H\n  | isTransAction => isTransAction {G} {H}\n}"}
{"prompt": "['R : CRing', 'A : Matrix R.E 1 1', 'p : 0 /= 0']<<<break>>>['| zro : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| at (j : Fin len) : A j', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| E : \\\\Set', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ']<<<break>>>at {at {A} 0} 0 = R.zro", "completion": "absurd (p idp)"}
{"prompt": "[\"y' : E\", 'y : E', \"y~y' : y ~ y'\", 'this : Preorder', 'x : E']<<<break>>>['\\\\lemma propExt \\\\hlevels  {A B : \\\\Prop} (_ : A -> B) (_ : B -> A) : A = B ', '| \\\\infix 4 <= E E : \\\\Prop', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>x <= y = x <= y'", "completion": "propExt (\\lam p0 => p0 <=\u2218 {this} y~y'.1) (\\lam p0 => p0 <=\u2218 {_} {x} y~y'.2)"}
{"prompt": "['this : LModule R (InterwiningMap {G} {R} A B) {\\n  | zro => zeroInterwining {R} {G} {A} {B}\\n  | + => addInterwining {R} {G} {A} {B}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => negativeInterwining {R} {G} {A} {B}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c => mulconstInterwining {R} {G} {A} {B}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>\\Pi {x y : E {Dom {zro {\\this}}}} -> func {zro {\\this}} (x + y) = func {zro {\\this}} x + func {zro {\\this}} y", "completion": "func-+ {zeroInterwining {R} {G} {A} {B}}"}
{"prompt": "['y>=0 : zro <= y', 'y : Real', 'a : Rat', 'x<a : x.U a', 'x : Real']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\lemma real_<_U \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : x < fromRat a <-> x.U a ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| <=_*_positive-left {x y z : E} (x <= y) (zro <= z) : x * z <= y * z', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>x * y <= fromRat a * y", "completion": "<=_*_positive-left {RealField} (<=-less $ real_<_U.2 x<a) y>=0"}
{"prompt": "['r<q : r.U q', 'r : ExUpperReal', 'q : Rat', 'j : Nat']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\lemma <_<= \\\\plevels  \\\\hlevels  {x : ExUpperReal} {q : Rat} (_ : x.U q) : x <= fromRat q ', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\func pow \\\\plevels  \\\\hlevels  (_ : ExUpperReal) (_ : Nat) : ExUpperReal \\n  | x, 0 => ide\\n  | x, suc n => pow x n * x', '\\\\lemma pow_<= \\\\plevels  \\\\hlevels  {x y : ExUpperReal} (_ : x <= y) {n : Nat} : pow x n <= pow y n ']<<<break>>>pow r j <= pow (fromRat q) j", "completion": "pow_<= (<_<= r<q)"}
{"prompt": "['this : NatData', 'l : GroupTerm V', 'r : GroupTerm V', 'p : (remove-pair (l :* r) (count-leaves (l :* r))).2 = true']<<<break>>>['true', '| V : \\\\Set', \"\\\\func rp-returns-true-lemma''' \\\\hlevels  {this : NatData} (l r : GroupTerm V) (fstLeafToRemoveInd : Nat) : (remove-pair (l :* r) fstLeafToRemoveInd).2 = true ->\\n  \\\\Sigma ((remove-pair l fstLeafToRemoveInd).2 = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l) \\n=> \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n  | greater _x => \\\\case (remove-pair r (fstLeafToRemoveInd -' count-leaves l)).2 \\\\with {\\n    | true => absurd {\\\\Sigma ((remove-pair l fstLeafToRemoveInd).2 = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n    | false => absurd {\\\\Sigma ((remove-pair l fstLeafToRemoveInd).2 = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n  }\\n  | less _x => \\\\case (remove-pair l fstLeafToRemoveInd).2 \\\\with {\\n    | true => absurd {\\\\Sigma (true = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n    | false => absurd {\\\\Sigma (false = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n  }\\n  | equals p => \\\\case (remove-pair l fstLeafToRemoveInd).2, idp {Bool} {(remove-pair l fstLeafToRemoveInd).2}, (remove-pair r 0).2,\\n    idp {Bool} {(remove-pair r 0).2} \\\\with {\\n      | true, p1, true, q => \\\\lam (_ : (\\\\case true, true \\\\with {\\n        | true, true => (:ide {Nat}, true)\\n        | true, false => remove-pair r 0\\n        | false, true => remove-pair l fstLeafToRemoveInd\\n        | false, false => ((remove-pair l fstLeafToRemoveInd).1 :* (remove-pair r 0).1, false)\\n      }).2 = true) => (idp {Bool} {true}, idp {Bool} {true}, p)\\n      | true, p, false, q => \\\\lam (p : (\\\\case true, false \\\\with {\\n        | true, true => (:ide {Nat}, true)\\n        | true, false => remove-pair r 0\\n        | false, true => remove-pair l fstLeafToRemoveInd\\n        | false, false => ((remove-pair l fstLeafToRemoveInd).1 :* (remove-pair r 0).1, false)\\n      }).2 = true) => absurd {\\\\Sigma (true = true) (false = true) (fstLeafToRemoveInd = count-leaves l)}\\n        (true/=false (inv {Bool} {(remove-pair r 0).2} {true} p *> q))\\n      | false, q, true, p => \\\\lam (p : (\\\\case false, true \\\\with {\\n        | true, true => (:ide {Nat}, true)\\n        | true, false => remove-pair r 0\\n        | false, true => remove-pair l fstLeafToRemoveInd\\n        | false, false => ((remove-pair l fstLeafToRemoveInd).1 :* (remove-pair r 0).1, false)\\n      }).2 = true) => absurd {\\\\Sigma (false = true) (true = true) (fstLeafToRemoveInd = count-leaves l)}\\n        (true/=false (inv {Bool} {(remove-pair l fstLeafToRemoveInd).2} {true} p *> q))\\n      | false, p, false, p =>\\n        absurd {\\\\Sigma (false = true) (false = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n    }\\n}\", '\\\\func count-leaves \\\\hlevels  {this1 : NatData} (_ : GroupTerm V) : Nat \\n  | {this}, l :* r => count-leaves l + count-leaves r\\n  | {this}, :inv (var x) => 1\\n  | {this}, :inv g => 0\\n  | {this}, var x => 1\\n  | {this}, t => 0', '\\\\infixl 6 :* (_ _ : GroupTerm V)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\func remove-pair \\\\hlevels  {this5 : NatData} (_ : GroupTerm V) (_ : Nat) : \\\\Sigma (GroupTerm V) Bool \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | less _x => \\n      \\\\let res-l => remove-pair l fstLeafToRemoveInd\\n      \\\\in \\\\case res-l.2 \\\\with {\\n            | true => (r, false)\\n            | false => (res-l.1 :* r, false)\\n          }\\n    | equals p => \\n      \\\\let | res-l => remove-pair l fstLeafToRemoveInd\\n           | res-r => remove-pair r 0\\n      \\\\in \\\\case res-l.2, res-r.2 \\\\with {\\n            | true, true => (:ide {Nat}, true)\\n            | true, false => res-r\\n            | false, true => res-l\\n            | false, false => (res-l.1 :* res-r.1, false)\\n          }\\n    | greater _x => \\n      \\\\let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l)\\n      \\\\in \\\\case res-r.2 \\\\with {\\n            | true => (l, false)\\n            | false => (l :* res-r.1, false)\\n          }\\n  }\\n  | {this}, :inv (var x), fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :inv g, fstLeafToRemoveInd => (:inv {V} g, false)\\n  | {this}, var x, fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :ide, fstLeafToRemoveInd => (:ide {Nat}, false)\"]<<<break>>>(remove-pair r 0).2 = true", "completion": "(rp-returns-true-lemma''' {this} l r (count-leaves {this} t) p).2"}
{"prompt": "['y : E {Dom {\\\\this}}', 'h1 : (U.*c) (x + y) = (\\\\lam (e : U.E) => x U.*c e U.+ y U.*c e)', 'U : LModule R', 'R : CRing', 'x : E {Dom {\\\\this}}', 'this : RingHom R1 (LinearMapRing {R1} U) {\\n  | func => LinearMapRing.*c-hom.func {R1} {U}\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Cod : BaseSet', '| Dom : BaseSet']<<<break>>>Path (\\lam (i : I) => \\Pi {r : R.E} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r U.*c (@) h1 i x)\n  (func-*c {func {\\this} (x + y)}) (func-*c {func {\\this} x + func {\\this} y})", "completion": "prop-dpi (\\lam i => ext_coe) (func-*c {func {R} {U} (x R.+ y)}) (func-*c {func {R} {U} x + func {R} {U} y})"}
{"prompt": "['l : Array A.E n', 'j : Fin (len {nub {A} l})', 'A : DecSet']<<<break>>>['| at (j : Fin len) : A j', '\\\\func nub-preimage \\\\hlevels  {A2 : DecSet} {l2 : Array A.E} (j1 : Fin (len {nub {A2} l2})) : \\\\Sigma (i : Fin l.len) (at {nub {A2} l2} j1 = l.at i) \\n  | {A}, {:: {n} a l}, zero => (0, idp {A.E} {at {nub {A} (a :: l)} 0})\\n  | {A}, {:: {n} a l}, suc j => \\n    \\\\have | (k, p) => preimage {A.E} {(=) a} {A.decideEq a} {nub {A} l} j\\n          | (i, q) => nub-preimage {A} {l} k\\n    \\\\in (suc i, p *> q)', '| E : \\\\Set', '\\\\func nub \\\\hlevels  {A2 : DecSet} (_ : Array A.E) : Array A.E \\n  | {A}, nil => nil\\n  | {A}, :: {n} a l => a :: removeElem {A} a (nub {A} l)']<<<break>>>at {nub {A} l} j = at {l} (nub-preimage {A} {l} j).1", "completion": "(nub-preimage j).2"}
{"prompt": "['a^n=u12 : pow {R} a.1 n = u.1.2', 'm : Nat', 'n : Nat', 'a : Ob {C {\\\\this}}', 't : \\\\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b.1 n = a.1 R.* c) (suc b.2 * n = suc a.2 + cd)', 's : \\\\Sigma (y : R.E) (k : Nat) (yh : R.isHomogen y (suc a.2 * k)) ((x,\\n  inP {\\\\Sigma (y : SType {R} (powers {R} a.1)) (x = inl~ {R} {powers {R} a.1} y) (n : Nat) (R.isHomogen y.1 n) (R.isHomogen y.2 n)}\\n    u) = fromSType {R} {powers {R} a.1}\\n    (y, pow {R} a.1 k, inP {\\\\Sigma (n : Nat) (pow {R} a.1 n = pow {R} a.1 k)} (k, idp {R.E} {pow {R} a.1 k})) {suc a.2 * k}\\n    {?hidden} {?hidden})', 'u : \\\\Sigma (y : SType {R} (powers {R} a.1)) (x = inl~ {R} {powers {R} a.1} y) (n : Nat) (R.isHomogen y.1 n) (R.isHomogen y.2 n)', 'd : CRingData {R}\\n  (s.1 :: pow {R} t.2 s.2 :: pow {R} a.1 n :: pow {R} t.2 n :: pow {R} a.1 m :: pow {R} t.2 m :: u.1.1 :: pow {R} a.1 s.2 :: u.1.2 :: nil) {\\n  | interpretNF_negate => {?hidden}\\n}', 'd : u.1.1 R.* pow {R} a.1 s.2 R.* pow {R} a.1 m = s.1 R.* u.1.2 R.* pow {R} a.1 m', 'R : GradedCRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| C : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', 'coef C', 'nil', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', ':zro', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '| negative E : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\infixl 7 :* (_ _ : RingTerm C V)', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', 'pos Nat', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '| zro : E', '\\\\field mData : MonoidData {R} vars', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ', '\\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>s.1 R.* pow {R} t.2 s.2 R.* (pow {R} a.1 n R.* pow {R} t.2 n) R.* (pow {R} a.1 m R.* pow {R} t.2 m) = u.1.1 R.* pow {R} t.2 n R.* (pow {R} a.1 s.2 R.* pow {R} t.2 s.2) R.* (pow {R} a.1 m R.* pow {R} t.2 m)", "completion": "fromZero {R} {s.1 R.* pow {R} t.2 s.2 R.* (pow {R} a.1 n R.* pow {R} t.2 n) R.* (pow {R} a.1 m R.* pow {R} t.2 m)}\n  {u.1.1 R.* pow {R} t.2 n R.* (pow {R} a.1 s.2 R.* pow {R} t.2 s.2) R.* (pow {R} a.1 m R.* pow {R} t.2 m)}\n  (terms-equality {d}\n    (var 0 :* var 1 :* (var 2 :* var 3) :* (var 4 :* var 5) :+ :negative (var 6 :* var 3 :* (var 7 :* var 1) :* (var 4 :* var 5)))\n    (coef 1 :* var 0 :* var 1 :* var 3 :* var 4 :* var 5 :* (var 2 :+ :negative (var 8)) :+ (:negative (coef 1) :* var 1 :* var 3 :* var 5 :* (var 6 :* var 7 :* var 4 :+ :negative (var 0 :* var 8 :* var 4)) :+ :zro))\n    idp *> gensZeroToIdealZero\n  ((interpret {d} (coef 1 :* var 0 :* var 1 :* var 3 :* var 4 :* var 5), pow {R} a.1 n + negative u.1.2,\n    toZero {R} {pow {R} a.1 n} {u.1.2} a^n=u12) :: (interpret {d} (:negative (coef 1) :* var 1 :* var 3 :* var 5),\n      u.1.1 R.* pow {R} a.1 s.2 R.* pow {R} a.1 m + negative (s.1 R.* u.1.2 R.* pow {R} a.1 m),\n      toZero {R} {u.1.1 R.* pow {R} a.1 s.2 R.* pow {R} a.1 m} {s.1 R.* u.1.2 R.* pow {R} a.1 m} d) :: nil))"}
{"prompt": "['I : Ideal R', 'J : Ideal R', 'R : CRing']<<<break>>>['| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', '\\\\lemma product-right \\\\hlevels  {R : CRing} {I J : Ideal R} : product {R} I J <= J ', '\\\\lemma product-left \\\\hlevels  {R : CRing} {I J : Ideal R} : product {R} I J <= I ', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func product \\\\hlevels  {R : CRing} (I J : Ideal R) :\\nIdeal R (\\\\lam (e : E {S {\\\\this}}) => TruncP (\\\\Sigma (l : Array (\\\\Sigma R.E (\\\\Sigma (a b : R.E) (I.contains a) (J.contains b))))\\n  (e = BigSum {R} (map {\\\\Sigma R.E (\\\\Sigma (a b : R.E) (I.contains a) (J.contains b))} {R.E}\\n    (\\\\lam (p : \\\\Sigma R.E (\\\\Sigma (a b : R.E) (I.contains a) (J.contains b))) => p.1 R.* func {R} I J p.2) l)))) \\n  => closure {R} {\\\\Sigma (a b : R.E) (I.contains a) (J.contains b)} (func {R} I J)', '| S : BaseSet', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance IdealLattice \\\\hlevels  {R : CRing} : BoundedLattice (Ideal R) {\\n  | <= => \\\\lam (I : E {\\\\this}) (J : E {\\\\this}) => \\\\Pi {a : R.E} -> I.contains a -> J.contains a\\n  | meet => IdealLattice.meet {R}\\n  | join => \\\\lam (I : E {\\\\this}) (J : E {\\\\this}) => closure {R} {Or (\\\\Sigma (a : R.E) (I.contains a)) (\\\\Sigma (a : R.E) (J.contains a))}\\n    (rec {\\\\Sigma (a : R.E) (I.contains a)} {\\\\Sigma (a : R.E) (J.contains a)} {R.E}\\n      (\\\\lam (p0 : \\\\Sigma (a : R.E) (I.contains a)) => p0.1) (\\\\lam (p0 : \\\\Sigma (a : R.E) (J.contains a)) => p0.1))\\n  | top => top {R}\\n  | bottom => IdealLattice.bottom {R}\\n} => \\\\new BoundedLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | bottom-univ => {?hidden}\\n}']<<<break>>>product {R} I J <= I \u2227 J", "completion": "meet-univ product-left product-right"}
{"prompt": "['y : E', 'x : E', 'this : LatticeAbGroup']<<<break>>>['\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', '| negative E : E', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>negative (negative (negative x \u2227 negative y)) = negative x \u2227 negative y", "completion": "negative-isInv {this}"}
{"prompt": "[\"B's : IsSmith {R} {n} {m} B'\", 'A : Matrix R.E n m', 'B : Matrix R.E n m', \"A~A' : A M~ A'\", 'j : Fin (n \u2227 m)', 'n : Nat', \"B~B' : B M~ B'\", 'A~B : A M~ B', \"B' : Matrix R.E n m\", 'm : Nat', 'R : SmithDomain', \"A's : IsSmith {R} {n} {m} A'\", \"A' : Matrix R.E n m\"]<<<break>>>['| \\\\infix 4 > E E : \\\\Prop', '\\\\func toFin \\\\plevels  \\\\hlevels  (k1 : Nat) {n1 : Nat} (\\\\property _ : k1 < n1) : Fin n1 \\n  | 0, {suc n}, p => 0\\n  | suc k, {suc n}, p => suc (toFin k {n} {?hidden})', '\\\\field trichotomy (x y : E) : Tri x y', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', \"\\\\data Tri \\\\hlevels  {A : StrictPoset} (_ _ : A.E) \\n  | less (a A.< a')\\n  | equals (a = a')\\n  | greater (a A.> a')\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\lemma smith-div-equiv \\\\hlevels  {R : ReducedCRing} {n m : Nat} {A B : Matrix R.E n m} (_ : IsSmith {R} {n} {m} A) (_ : IsSmith {R} {n} {m} B)\\n  (_ : A M~ B) (i : Fin n) (j : Fin m) :\\n  \\\\Sigma (TruncP (LDiv {R} (at {at {A} i} j) (at {at {B} i} j))) (TruncP (LDiv {R} (at {at {B} i} j) (at {at {A} i} j))) ', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\instance M~-equiv \\\\hlevels  {R : Ring} {n m : Nat} : Equivalence (Matrix R.E n m) {\\n  | ~ => (M~)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', '| ~-symmetric {x y : A} (x ~ y) : y ~ x', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| at (j : Fin len) : A j', '| ~-transitive {x y z : A} (x ~ y) (y ~ z) : x ~ z', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>\\Sigma (TruncP (LDiv {R} (at {at {B'} (toFin j {n} {?hidden})} (toFin j {m} {?hidden}))\n  (at {at {A'} (toFin j {n} {?hidden})} (toFin j {m} {?hidden}))))\n  (TruncP (LDiv {R} (at {at {A'} (toFin j {n} {?hidden})} (toFin j {m} {?hidden}))\n    (at {at {B'} (toFin j {n} {?hidden})} (toFin j {m} {?hidden}))))", "completion": "smith-div-equiv B's A's (~-transitive (~-symmetric B~B') (~-transitive (~-symmetric A~B) A~A')) _ _"}
{"prompt": "['x : E {\\\\this}', 'y : E {\\\\this}']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '\\\\lemma <=-upper \\\\plevels  \\\\hlevels  {x y : Real} : x Preorder.<= y <-> x ExUpperReal.<= y ', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\lemma abs_+ \\\\hlevels  {this : LatticeAbGroup} {x y : E} : abs (x + y) <= abs x + abs y ', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>abs {RealAbGroup} (x + y) <= abs {RealAbGroup} x + abs {RealAbGroup} y", "completion": "<=-upper.1 abs_+"}
{"prompt": "['l : Array (\\\\Sigma V.E B.E) n', 'B : BooleanRing', 'a : \\\\Sigma V.E B.E', 'V : PosetQModule', 'n : Nat']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma BigJoin-ldistr \\\\hlevels  {this : BottomDistributiveLattice} {l : Array E} {x : E} :\\n  x \u2227 BigJoin l = BigJoin (\\\\new Array E l.len (\\\\lam (j : Fin l.len) => x \u2227 l.at j)) ', 'suc Nat', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\type \\\\infix 4 <= \\\\hlevels  {R : Semigroup} (x y : R.E) : \\\\Prop => x R.* y = x', '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>(at {a :: l} 0).2 B.\u2227 BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l) <= BigJoin {B} (\\new Array B.E (len {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l})\n  (\\lam (j : Fin (len {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l})) =>\n    (at {a :: l} 0).2 B.\u2227 at {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l} j))", "completion": "=_<= (BigJoin-ldistr {B})"}
{"prompt": "['this : FinSet']<<<break>>>[\"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", \"\\\\lemma /=-sym {A : \\\\Type} {a a' : A} (_ : a /= a') : a' /= a \", '| E : \\\\Set']<<<break>>>\\Pi {x : E} -> \\Pi {y : E} -> x /= y -> y /= x", "completion": "\\lam {x} {y} => /=-sym"}
{"prompt": "['q : Rat', 'r : Rat']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '| len : Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma nat_gcd-comm \\\\plevels  \\\\hlevels  {a b : Nat} : gcd {NatEuclidean} a b = gcd {NatEuclidean} b a ', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatData (zro :: r :: q :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}}\n  ((var {E} {Fin 3} 1 :+ :negative {E} {Fin 3} (var {E} {Fin 3} 2 :+ (var {E} {Fin 3} 1 :+ :negative {E} {Fin 3} (var {E} {Fin 3} 2)) :* coef {E} {Fin 3} (rat (pos 1) 3 {?hidden} {?hidden}))) :* coef {E} {Fin 3} (rat (pos 3) 2 {?hidden} {?hidden})) <= interpret {\\new LinearRatData (zro :: r :: q :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 3} 1 :+ :negative {E} {Fin 3} (var {E} {Fin 3} 2))", "completion": "solve<=Problem {\\new LinearRatData {\n  | R => RatField\n  | vars => zro :: r :: q :: nil\n}} nil\n  ((var 1 :+ :negative (var 2 :+ (var 1 :+ :negative (var 2)) :* coef (rat (pos 1) 3 {?hidden} {?hidden}))) :* coef (rat (pos 3) 2 {?hidden} {?hidden}))\n  (var 1 :+ :negative (var 2)) (1 :: nil, 0, idp, idp {Bool} {true}) nil"}
{"prompt": "['x : E', 'y : E', 'this : HeytingAlebra']<<<break>>>['| <=-refl {x : E} : x <= x', '| \\\\infix 4 <= E E : \\\\Prop', '| implies \\\\alias \\\\infixr 5 --> E E : E']<<<break>>>x --> y <= x --> y", "completion": "<=-refl {this}"}
{"prompt": "['mon : \\\\Pi (k : Fin n) -> f k < f (suc k)', 'k : Fin n', 'n : Nat', 'f : Fin (suc n) -> Fin (suc n)']<<<break>>>['\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', 'suc Nat', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma monotone-diagonal-fin \\\\plevels  \\\\hlevels  {n : Nat} (f : Fin (suc n) -> Fin (suc n)) (_ : \\\\Pi (k : Fin n) -> f k < f (suc k)) {k : Fin (suc n)} : k <= f k ']<<<break>>>k <= f k", "completion": "monotone-diagonal-fin {n} f mon {k}"}
{"prompt": "['a : Real', 'b : Real', '/b-a : E', 'x : Real', 'n : Nat', 'j : Nat']<<<break>>>['\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma abs_* \\\\hlevels  {this : OrderedRing} {x y : E} : abs (x * y) = abs x * abs y ', '\\\\func RealNormedAbGroup \\\\hlevels  : NormedAbGroup Real {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| E : \\\\Set', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', 'pos Nat', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>abs {RealField}\n  ((fromRat (fromInt (pos j)) - (x - a) * fromRat (fromInt (pos n)) * /b-a) * ((b - a) * fromRat (finv (fromInt (pos n))))) = abs {RealField} (fromRat (fromInt (pos j)) - (x - a) * fromRat (fromInt (pos n)) * /b-a) * abs {RealField} ((b - a) * fromRat (finv (fromInt (pos n))))", "completion": "abs_* {RealField}"}
{"prompt": "['l : PFunc {V} {B}', 'V : RieszSpace', 'B : BooleanRing']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\lemma ~_+ \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} (f g : V.E -> V.E) {l : Array (\\\\Sigma V.E B.E)} :\\n  map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (f s.1, s.2)) l ++ map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (g s.1, s.2)) l ~ map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (f s.1 V.+ g s.1, s.2)) l ', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', \"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '| E : \\\\Set', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| negative E : E', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>map {\\Sigma V.E (E {B})} {\\Sigma V.E (E {B})} (\\lam (s : \\Sigma V.E (E {B})) => (abs {V} s.1, s.2)) l ++ map {\\Sigma V.E (E {B})} {\\Sigma V.E (E {B})} (\\lam (s : \\Sigma V.E (E {B})) => (V.negative s.1, s.2)) l ~ map {\\Sigma V.E (E {B})} {\\Sigma V.E (E {B})} (\\lam (s : \\Sigma V.E (E {B})) => (abs {V} s.1 V.+ V.negative s.1, s.2)) l", "completion": "~_+ (abs {V}) negative"}
{"prompt": "['x : E {Dom {\\\\this}}', 'b : Rat', 'x1y1<a : U {dist x.1 y.1} a', 'y : E {Dom {\\\\this}}', 'a : Rat', 'x2y2<b : U {dist x.2 y.2} b']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma dist-right \\\\plevels  \\\\hlevels  {x y : ExUpperReal} {a : Rat} (_ : U {dist x y} a) : y <= x + fromRat a ', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>y.1 + y.2 <= x.1 + fromRat a + (x.2 + fromRat b)", "completion": "<=_+ {ExUpperRealAbMonoid} (dist-right x1y1<a) (dist-right x2y2<b)"}
{"prompt": "['this : PID']<<<break>>>['| isBezout : IsBezout', '\\\\func IsBezout \\\\hlevels  {this : CRing} : \\\\Prop => \\\\Pi (a b : E) -> TruncP (\\\\Sigma (s t : E) (LDiv (s * a + t * b) a) (LDiv (s * a + t * b) b))']<<<break>>>IsBezout", "completion": "isBezout {this}"}
{"prompt": "['Y : TopSpace', 'X : TopSpace', 'g : Y.E -> X.E', 'b : X.E', 'h : \\\\Pi (y : Y.E) -> f.func (g y) = y', 'f : ContMap X Y', 'p : g a = b', 'a : Y.E', 'd : E']<<<break>>>[\"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>d.1 (f.func b)", "completion": "transportInv d.1 (pmap f (inv p) *> h a) d.3"}
{"prompt": "['this : Functor (op {SetCat}) (LModuleCat R1) (\\\\lam (I : Ob {C {\\\\this}}) => PowerLModule {R1} I (RingLModule R1)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => \\\\new LinearMap {R1} (F {\\\\this} X) (F {\\\\this} Y) {\\n    | func => \\\\lam (r : E {Dom {\\\\this}}) (j : Y) => r (f j)\\n    | func-+ => {?hidden}\\n    | func-*c => {?hidden}\\n  }\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', 'R : Ring']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '\\\\instance PowerLModule \\\\hlevels  {R1 : Ring} (J : \\\\Set) (M : LModule R1) : LModule R1 (J -> M.E) {\\n  | zro => \\\\lam (_ : J) => M.zro\\n  | + => \\\\lam (f : E {\\\\this}) (g : E {\\\\this}) (j : J) => f j M.+ g j\\n  | negative => \\\\lam (f : E {\\\\this}) (j : J) => M.negative (f j)\\n  | *c => \\\\lam (r : E {R {\\\\this}}) (f : E {\\\\this}) (j : J) => r M.*c f j\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', \"\\\\class LModule \\\\extends AbGroup \\\\hlevels  {\\n  | R : Ring\\n  | \\\\infixl 7 *c (E {R}) E : E\\n  | *c-assoc {r r' : E {R}} {a : E} : r * r' *c a = r *c (r' *c a)\\n  | *c-ldistr {r : E {R}} {a b : E} : r *c (a + b) = r *c a + r *c b\\n  | *c-rdistr {r s : E {R}} {a : E} : (r + s) *c a = r *c a + s *c a\\n  | ide_*c {a : E} : ide {R} *c a = a\\n}\", '| Ob : \\\\hType', '| C : Precat', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| negative E : E', '\\\\func RingLModule \\\\hlevels  (R1 : Ring) : LModule R1 R.E {\\n  | zro => R.zro\\n  | + => (R.+)\\n  | negative => R.negative\\n  | *c => (R.*)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '| R : Ring']<<<break>>>\\Pi (I : Ob {C {\\this}}) -> LModule R1 (I -> E) {\n  | zro => \\lam (_ : I) => zro\n  | + => \\lam (f : E {\\this}) (g : E {\\this}) (j : I) => f j + g j\n  | negative => \\lam (f : E {\\this}) (j : I) => negative (f j)\n  | *c => \\lam (r : E {R {\\this}}) (f : E {\\this}) (j : I) => r *c f j\n}", "completion": "\\lam I => PowerLModule I (RingLModule R)"}
{"prompt": "['y : E {Dom {\\\\this}}', 'x : E {Dom {\\\\this}}', 'g : LinearMap {R} A B']<<<break>>>['| \\\\infixl 6 + E E : E', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>g.func (x + y) = g.func x + g.func y", "completion": "func-+ {g}"}
{"prompt": "['this : Cat Ring {\\n  | Hom => RingHom\\n  | id => RingHom.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}']<<<break>>>['| Ob : \\\\hType', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func \\\\infixl 8 compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {R S T : Ring} (g : RingHom S T) (f : RingHom R S) : RingHom R T {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ']<<<break>>>\\Pi {X : Ob {\\this}} ->\n\\Pi {Y : Ob {\\this}} -> \\Pi {Z : Ob {\\this}} -> \\Pi (g : RingHom Y Z) -> \\Pi (f : RingHom X Y) -> RingHom X Z {\n  | func => \\lam (x : E {Dom {\\this}}) => g.func (f.func x)\n}", "completion": "\\lam {X} {Y} {Z} => (\u2218)"}
{"prompt": "['n1 : Nat', 'l1 : Array E n', 'this : GradedCRing', 'n : Nat', 'c1 : E', 'l1h : \\\\Pi (j : Fin (suc l1.len)) -> isHomogen (at {c1 :: l1} j) (n1 + j)']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '| at (j : Fin len) : A j', '| isHomogen E Nat : \\\\Prop', '| E : \\\\Set', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)']<<<break>>>\\Pi (j : Fin l1.len) -> isHomogen (at {c1 :: l1} (suc j)) (n1 + suc j)", "completion": "\\lam j => l1h (suc j)"}
{"prompt": "['n : Nat', 'c : Sym n', 'supp-f : Or (Fin center.1) (\\\\Sigma (i : Fin n) (Support {n}\\n  (inverse (cycle {n} {center.1} (\\\\new Array (Fin n) center.1 (\\\\lam (j : Fin center.1) => f {pow {SymmetricGroup n} e j} d.1)) inj) * e)\\n  i)) -> \\\\Sigma (i : Fin n) (Support {n} e i)', 'p : \\\\Sigma (i : Fin n) (Support {n} (inverse c * e) i)', 's : supp-f (inr {Fin t.1} {\\\\Sigma (i : Fin n) (Support {n} (inverse c * e) i)} p) = supp-f (inl {Fin t.1} {\\\\Sigma (i : Fin n) (Support {n} (inverse c * e) i)} j)', 'j : Fin t.1', 'r-supp : \\\\Pi {k : Fin t.1} -> Support {n} (inverse c * e) (f {pow {SymmetricGroup n} e k} d.1) -> Empty', 't : A', 'e : Sym n', 'd : \\\\Sigma (j0 : Fin n) (f {e} j0 /= j0) (\\\\Pi (j : Fin n) -> f {e} j /= j -> j0 <= j)']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func Support \\\\plevels  \\\\hlevels  {n : Nat} (e : Sym n) (i : Fin n) : \\\\Prop => f {e} i /= i', '\\\\instance SymmetricGroup \\\\hlevels  (n : Nat) : Group (Sym n) {\\n  | ide => idEquiv {Fin n}\\n  | * => transEquiv {Fin n} {Fin n} {Fin n}\\n  | inverse => \\\\lam (e : E {\\\\this}) => symQEquiv {Fin n} {Fin n} (fromEquiv e)\\n} => \\\\new Group {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | inverse-right => {?hidden}\\n}', '| inverse E : E', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '| \\\\infixl 7 * E E : E', 'inl A', '| f A : B', 'inr B', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>inr {Fin t.1} {\\Sigma (i : Fin n) (Support {n} (inverse c * e) i)} p = inl {Fin t.1} {\\Sigma (i : Fin n) (Support {n} (inverse c * e) i)} j", "completion": "absurd (r-supp $ rewriteI (pmap (\\lam p0 => p0.1) s) p.2)"}
{"prompt": "['y : E {\\\\this}', 'f : X -> Y.E', 'p : dist {\\\\this} x y = zro', 'x : E {\\\\this}', 'Y : ExMetricSpace']<<<break>>>['| dist-ext {x y : E} (dist x y = zro) : x = y', '| E : \\\\Set']<<<break>>>f x = f y", "completion": "dist-ext p"}
{"prompt": "['R : CRing', 'u : R.E', 's : R.E', 'B : Matrix R.E 2 2', 't : R.E', 'v : R.E']<<<break>>>['| len : Nat', '\\\\field mData : MonoidData {R} vars', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| M : Monoid', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '| E : \\\\Set', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', '| vars : Array (E {M})', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>CRingData {R} (t :: v :: u :: s :: at {B} 0 !! 0 :: at {B} 1 !! 1 :: nil) {\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new CRingData {\n  | R => R\n  | vars => t :: v :: u :: s :: B !! 0 !! 0 :: B !! 1 !! 1 :: nil\n}"}
{"prompt": "['this : Model', 'rho : Env V', 'V : Sort {T} -> \\\\Set', 'tau : \\\\Pi {s : Sort {T}} -> S.1 s -> Term {T} V s', 'S : Sequent {T}']<<<break>>>[\"\\\\func isFormulaTrue \\\\hlevels  {this2 : Structure} {V2 : Sort {T} -> \\\\Set} (_ : Env V2) (_ : Formula {T} V2) : \\\\Prop \\n  | {this}, {V}, rho, equality {s} t t' => interpret {V} rho {s} t = interpret {V} rho {s} t'\\n  | {this}, {V}, rho, predicate P d =>\\n  relation P (\\\\new DArray {len {predDomain {T} P}} (\\\\lam (j : Fin (len {predDomain {T} P})) => E (at {predDomain {T} P} j))\\n    (\\\\lam (j : Fin (len {predDomain {T} P})) => interpret {V} rho {at {predDomain {T} P} j} (d.at j)))\", '| Sort : \\\\Set', '\\\\func substF \\\\hlevels  {S2 : Signature} {U2 V2 : S.Sort -> \\\\Set} (_ : Formula {S2} U2) (_ : \\\\Pi {s : S.Sort} -> U2 s -> Term {S2} V2 s) :\\n  Formula {S2} V2 \\n  | {S}, {U}, {V}, equality {s} t1 t2, rho =>\\n    equality {S} {V} {s} (subst {S} {U} {V} {s} t1 rho) (subst {S} {U} {V} {s} t2 rho)\\n  | {S}, {U}, {V}, predicate P ts, rho => predicate {S} {V} P\\n    (\\\\new DArray {len {S.predDomain P}} (\\\\lam (j : Fin (len {S.predDomain P})) => Term {S} V (at {S.predDomain P} j))\\n      (\\\\lam (j : Fin (len {S.predDomain P})) => subst {S} {U} {V} {at {S.predDomain P} j} (ts.at j) rho))', '\\\\func interpret \\\\hlevels  {this1 : Structure} {V1 : Sort {T} -> \\\\Set} (_ : Env V1) {s2 : Sort {T}} (_ : Term {T} V1 s2) : E s2 \\n  | {this}, {V}, rho, {s}, var v => rho {s} v\\n  | {this}, {V}, rho, {s}, apply f d =>\\n  operation {s} f (\\\\new DArray {len {domain {T} {s} f}} (\\\\lam (j : Fin (len {domain {T} {s} f})) => E (at {domain {T} {s} f} j))\\n    (\\\\lam (j : Fin (len {domain {T} {s} f})) => interpret {V} rho {at {domain {T} {s} f} j} (d.at j)))', '\\\\lemma subst_isFormulaTrue \\\\hlevels  {this : Structure} {U V : Sort {T} -> \\\\Set} {rho : Env V} {tau : \\\\Pi {s : Sort {T}} -> U s -> Term {T} V s}\\n  {phi : Formula {T} U} :\\n  isFormulaTrue {V} rho (substF {T} {U} {V} phi tau) = isFormulaTrue {U} (\\\\lam {s : Sort {T}} (u : U s) => interpret {V} rho {s} (tau {s} u)) phi ', '| T : Signature']<<<break>>>isFormulaTrue {V} rho (substF {T} {S.1} {V} S.4 tau) = isFormulaTrue {S.1} (\\lam {s : Sort {T}} (u : S.1 s) => interpret {V} rho {s} (tau {s} u)) S.4", "completion": "subst_isFormulaTrue {this}"}
{"prompt": "[]<<<break>>>['\\\\type Sym \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => Equiv {Fin n} {Fin n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| A : \\\\Type', '\\\\lemma equals \\\\plevels  \\\\hlevels  {n : Nat} {x y : Sym n} (_ : \\\\Pi (j : Fin n) -> f {x} j = f {y} j) : x = y ', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', '\\\\func idEquiv {A1 : \\\\Type} : QEquiv {A1} {A1} (\\\\lam (x : A {\\\\this}) => x) {\\n  | ret => \\\\lam (x : B {\\\\this}) => x\\n  | ret_f => \\\\lam (a : A {\\\\this}) => idp {A1} {ret {\\\\this} a}\\n  | f_sec => \\\\lam (b : B {\\\\this}) => idp {A1} {sec {\\\\this} b}\\n} => \\\\new QEquiv', '| B : \\\\Type', '\\\\func fac \\\\plevels  \\\\hlevels  (_ : Nat) : Nat \\n  | 0 => 1\\n  | suc n => suc n * fac n']<<<break>>>QEquiv {Fin (fac 0)} {Sym 0} (\\lam (_ : A {\\this}) => idEquiv {Fin 0}) {\n  | ret => \\lam (_ : B {\\this}) => 0\n  | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n    | zero => idp {Fin (fac 0)} {0}\n  })\n  | f_sec => \\lam (e : B {\\this}) => equals {0} {idEquiv {Fin 0}} {e} (\\lam (p0 : Fin 0) => (\\case p0 \\with {}))\n}", "completion": "\\new QEquiv {\n  | f => \\lam _ => idEquiv\n  | ret => \\lam _ => 0\n  | ret_f => \\lam p0 => (\\case \\elim p0 \\with {\n    | 0 => idp\n  })\n  | f_sec => \\lam e => equals (\\lam p0 => (\\case p0 \\with {}))\n}"}
{"prompt": "['x : E {Dom}', 'this : GroupHom']<<<break>>>['\\\\lemma func-inverse \\\\hlevels  {this : GroupHom} {a : E {Dom}} : func (inverse {Dom} a) = inverse {Cod} (func a) ', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| inverse E : E', '| Dom : BaseSet']<<<break>>>func (inverse {Dom} x) = inverse {Cod} (func x)", "completion": "func-inverse {this}"}
{"prompt": "['a : E {\\\\this}', 'm : Nat', 'n : Nat', \"r' : E {R {\\\\this}}\", 'R : Ring', 'r : E {R {\\\\this}}']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', '| at (j : Fin len) : A j', '| E : \\\\Set', '| *-assoc {x y z : E} : x * y * z = x * (y * z)']<<<break>>>\\Pi (i : Fin n) -> \\Pi (j : Fin m) -> r * r' * at {at {a} i} j = r * (r' * at {at {a} i} j)", "completion": "\\lam i j => *-assoc"}
{"prompt": "['J : \\\\Set', 'd : Array (\\\\Sigma (E {R}) J)', 'this : LModule', 'c : Array (\\\\Sigma (E {R}) J)', 'g : J -> E']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| R : Ring', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', \"\\\\lemma BigSum_++ \\\\hlevels  {this : AddMonoid} {l l' : Array E} : BigSum (l ++ l') = BigSum l + BigSum l' \", '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>BigSum (map {\\Sigma (E {R}) J} {E} (\\lam (s1 : \\Sigma (E {R}) J) => s1.1 *c g s1.2) c ++ map {\\Sigma (E {R}) J} {E} (\\lam (s1 : \\Sigma (E {R}) J) => s1.1 *c g s1.2) d) = BigSum (map {\\Sigma (E {R}) J} {E} (\\lam (s1 : \\Sigma (E {R}) J) => s1.1 *c g s1.2) c) + BigSum (map {\\Sigma (E {R}) J} {E} (\\lam (s1 : \\Sigma (E {R}) J) => s1.1 *c g s1.2) d)", "completion": "BigSum_++ {this}"}
{"prompt": "['x : Fin (suc n)', 'x0 : Fin (suc n)', 'p : x0 < x']<<<break>>>['\\\\lemma <_/= \\\\hlevels  {this : StrictPoset} {x y : E} (_ : x < y) : x /= y ', '\\\\lemma suc_pred \\\\plevels  \\\\hlevels  {n : Nat} (_ : n /= 0) : suc (pred n) = n ', '\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func pred \\\\plevels  \\\\hlevels  (_ : Nat) : Nat \\n  | 0 => 0\\n  | suc x' => x'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\lemma /=-sym {A : \\\\Type} {a a' : A} (_ : a /= a') : a' /= a \", '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3']<<<break>>>suc (pred x) = x", "completion": "suc_pred (/=-sym $ <_/= {NatSemiring} $ zero<=_ <\u2218r p)"}
{"prompt": "['x : E', 'this : ExPseudoNormedAbGroup']<<<break>>>['| zro : E', '| norm E : ExUpperReal', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '| dist E E : ExUpperReal', '| norm-dist {x y : E} : dist x y = norm (x - y)']<<<break>>>dist x zro = norm (x - zro)", "completion": "norm-dist {this}"}
{"prompt": "['b : Rat', 'this : NormedAbGroupMap (toBanach {Dom}) (toBanach {Cod}) {\\n  | func => func\\n  | func-+ => {?hidden}\\n  | func-norm => {?hidden}\\n}', 'this : OrderedC*AlgebraHom', 'x : E {Dom {\\\\this}}', 'p0 : U {norm {Dom {\\\\this}} x} b']<<<break>>>['\\\\lemma func-negative \\\\hlevels  {this : AddGroupHom} {x : E {Dom}} : func (negative {Dom} x) = negative {Cod} (func x) ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| Cod : BaseSet', '\\\\lemma func-*q \\\\hlevels  {A B : QModule} {f : AddGroupHom A B} {q : Rat} {a : A.E} : f.func (q *q a) = q *q f.func a ', '| func-<= {x y : E {Dom}} (x <= y) : func x <= func y', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| negative E : E', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", \"\\\\func transport2 {A B : \\\\Type} (C : A -> B -> \\\\Type) {a a' : A} {b b' : B} (_ : a = a') (_ : b = b') (_ : C a b) : C a' b' \\n  | {A}, {B}, C, {a}, {a'}, {b}, {b'}, idp, idp, c => c\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', '| func-ide : func (ide {Dom}) = ide {Cod}', '| norm E : ExUpperReal', '\\\\class OrderedC*AlgebraHom \\\\extends RingHom, PosetHom \\\\hlevels ', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| U Rat : \\\\Prop', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func toBanach \\\\hlevels  {this107 : OrderedC*Algebra} : RealPreBanachAlgebra E {\\n  | isOpen => isOpen\\n  | isCauchy => isCauchy\\n  | isUniform => isUniform\\n  | dist => ExPseudoNormedAbGroup.dist\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | negative => negative\\n  | norm => OrderedC*Algebra.toBanach.norm\\n  | * => (Semigroup.*)\\n  | ide => ide\\n  | natCoef => natCoef\\n} => \\\\new RealPreBanachAlgebra {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | norm-double => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | norm_*_<= => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_ide_<= => {?hidden}\\n}']<<<break>>>U {norm {Cod {\\this}} (func {\\this} x)} b", "completion": "\\scase \\elim p0 \\with {\n  | inP (a, a<b, a>0, x<=a, -x<=a) =>\n  inP (a, a<b, a>0, transport ((<=) _) (func-*q *> pmap ((*q) a) (func-ide {this})) (func-<= {this} x<=a),\n    transport2 (<=) (func-negative {this}) (func-*q *> pmap ((*q) a) (func-ide {this})) (func-<= {this} -x<=a))\n}"}
{"prompt": "['A : Matrix R.E lv.len lw.len', 'bv : IsBasis {V} lv', 'this : LinearMap {R1} U W {\\n  | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', 'i : I', 'R : Ring', 'lw : Array W.E', 'f : Iso {LModuleCat R} {U} {V}', 'V : LModule R', 'W : LModule R', 'h1 : (\\\\lam (e : U.E) => BigSum {W} (\\\\new Array W.E lv.len (\\\\lam (j : Fin lv.len) =>\\n  at {basis-split {V} {lv} bv (func {f.f} e)} j W.*c BigSum {W} (\\\\new Array W.E lw.len (\\\\lam (j1 : Fin lw.len) => at {at {A} j} j1 W.*c lw.at j1))))) = (\\\\lam (e : U.E) => BigSum {W} (\\\\new Array W.E lv.len (\\\\lam (j : Fin lv.len) =>\\n  at {basis-split {U} {map {V.E} {U.E} (func {f.hinv}) lv} (iso-basis {R} {V} {U} (reverse {f1}) {lv} bv) e} j W.*c BigSum {W} (\\\\new Array W.E lw.len (\\\\lam (j1 : Fin lw.len) => at {at {A} j} j1 W.*c lw.at j1)))))', 'U : LModule R', 'lv : Array V.E']<<<break>>>['| hinv : Hom {C} cod dom', '\\\\func reverse \\\\plevels obj >= hom \\\\hlevels  {this : Iso} : Iso {C} {cod} {dom} hinv {\\n  | hinv => f\\n} => \\\\new Iso {\\n  | hinv_f => {?hidden}\\n  | f_hinv => {?hidden}\\n}', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| f : Hom {C} dom cod', '\\\\func \\\\infixl 8 compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {R1 : Ring} {U V W : LModule R1} (g : LinearMap {R1} V W) (f : LinearMap {R1} U V) : LinearMap {R1} U W {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => g.func (f.func a)\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '\\\\lemma iso-basis {R : Ring} {U V : LModule R} (f1 : Iso {LModuleCat R} {U} {V}) {l : Array U.E} (_ : IsBasis {U} l) :\\n  IsBasis {V} (map {U.E} {V.E} (func {f.f}) l) ', '| R : Ring', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func toLinearMap \\\\hlevels  {R : Ring} {U V : LModule R} {lu : Array U.E} (bu : IsBasis {U} lu) (lv : Array V.E) (A : Matrix R.E lu.len lv.len) :\\nLinearMap {R} U V {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => BigSum {V} (\\\\new Array V.E lu.len (\\\\lam (j : Fin lu.len) =>\\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\\n} => extend {R} {U} {V} {lu} bu\\n  (\\\\new Array V.E lu.len (\\\\lam (j : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))']<<<break>>>\\Pi {r : E {R {\\this}}} -> \\Pi {x : U.E} -> (@) h1 i (r U.*c x) = r W.*c (@) h1 i x", "completion": "\\lam {r} => (@) (prop-dpi (\\lam i => ext_coe) (func-*c {toLinearMap {R} {V} {W} {lv} bv lw A \u2218 f.f})\n  (func-*c {toLinearMap {R} {U} {W} {map {V.E} {U.E} (func {f.hinv}) lv} (iso-basis {R} {V} {U} (reverse {f}) {lv} bv) lw A}))\n  i {r}"}
{"prompt": "['f : IsometricMap X Y', 'Y : PseudoMetricSpace', \"x' : X.E\", 'X : PseudoMetricSpace', 'x : X.E']<<<break>>>['\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '| func-isometry {x y : E {Dom}} : dist {Cod} (func x) (func y) = dist {Dom} x y', '\\\\lemma =-upper \\\\plevels  \\\\hlevels  {x y : Real} : x = y <-> x = y ', '| dist E E : ExUpperReal', '| func (E {Dom}) : E {Cod}']<<<break>>>Y.dist (f.func x) (f.func x') = X.dist x x'", "completion": "=-upper.2 (func-isometry {f})"}
{"prompt": "['q : Rat', 'f : AddGroupHom A B', 'a : A.E', 'B : QModule']<<<break>>>['| center : A', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\func \\\\infixl 7 *i \\\\hlevels  {this2 : AddGroup} (_ : Int) (_ : E) : E \\n  | {this}, pos n, a => n *n a\\n  | {this}, neg n, a => n *n negative a', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '\\\\lemma ratDenom/=0 \\\\plevels  \\\\hlevels  {x : Rat} : ratDenom x /= 0 ', '\\\\func ratDenom \\\\plevels  \\\\hlevels  (_ : Rat) : Nat \\n  | rat nom d denom/=0 reduced => d', '\\\\func ratNom \\\\plevels  \\\\hlevels  (_ : Rat) : Int \\n  | rat n denom denom/=0 reduced => n', '\\\\lemma uniquelyDivisible \\\\hlevels  {this : QModule} (a : E) {n : Nat} (_ : n /= 0) : Contr (\\\\Sigma (b : E) (n *n b = a)) ']<<<break>>>q *q f.func a = ratNom q *i center.1", "completion": "\\peval _ *q {B} _"}
{"prompt": "['t : E', 's : E', \"b' : E\", \"p : (s * a + t * b) * a' = a\", 'b : E', 'this : PPRing', 'a : E', \"a' : E\", 'w : E', 'f : \\\\Pi {x : E} -> g * x = zro -> w * x = zro', \"q : (s * a + t * b) * b' = b\"]<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', ':zro', '\\\\data Term \\\\hlevels  \\\\Set Nat \\n  | var (Fin n)\\n  | coef C\\n  | :zro\\n  | :ide\\n  | :negative (Term C n)\\n  | \\\\infixl 6 :+ (_ _ : Term C n)\\n  | \\\\infixl 7 :* (_ _ : Term C n)', '\\\\lemma terms-equality \\\\hlevels  {R : CRing} (env : Array R.E) (t s : Term Int env.len)\\n  (_ : ringInterpretNF {R} env (sortMonomials {env.len} {Int} (normalize {env.len} {IntRing} (t :+ :negative {E} {env.len} s))) = R.zro) :\\n  interpret {R} env t = interpret {R} env s ', 'nil', 'neg Nat  {\\n  | 0 => pos 0\\n}', 'pos Nat', ':negative (Term C n)', '\\\\func NF \\\\hlevels  (C : \\\\Set) (n : Nat) : \\\\Set => List (\\\\Sigma (List (Fin n)) C)', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func interpret \\\\hlevels  {R6 : Ring} (env4 : Array R.E) (_ : Term Int env.len) : R.E \\n  | {R}, env, coef c => intCoef {R} c\\n  | {R}, env, var c => env.at c\\n  | {R}, env, :zro => R.zro\\n  | {R}, env, :ide => R.ide\\n  | {R}, env, :negative t => R.negative (interpret {R} env t)\\n  | {R}, env, t :+ s => interpret {R} env t R.+ interpret {R} env s\\n  | {R}, env, t :* s => interpret {R} env t R.* interpret {R} env s', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', \"\\\\lemma apply-axioms \\\\hlevels  {R : CRing} (env : Array R.E)\\n  (l : Array (\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)))\\n  (add : NF Int env.len) : ringInterpretNF {R} env (sortMonomials\\n  {env.len} {Int} (Big {List (\\\\Sigma (List (Fin env.len)) Int)} {List (\\\\Sigma (List (Fin env.len)) Int)} (++) add\\n    (map {\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)}\\n      {List (\\\\Sigma (List (Fin env.len)) Int)}\\n      (\\\\lam (s : \\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)) =>\\n        multiply {env.len} {IntRing} s.1 (normalize {env.len} {IntRing} (s.2 :+ :negative {E} {env.len} s.3))) l))) = ringInterpretNF' {R} {env} add \", '| E : \\\\Set', '\\\\infixl 6 :+ (_ _ : Term C n)', '\\\\infixl 7 :* (_ _ : Term C n)', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', 'var (Fin n)']<<<break>>>w * (b' * a - a' * b) = zro", "completion": "f {b' * {this} a - a' * {this} b} (cRing {(p, q)})"}
{"prompt": "['n : Nat', 'A : LModule R']<<<break>>>['| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set']<<<break>>>Array A.E (suc (suc n)) (\\lam (_ : Fin (suc (suc n))) => A.zro)", "completion": "\\new Array A.E (suc (suc n)) (\\lam (_ : Fin (suc (suc n))) => A.zro)"}
{"prompt": "['GV : G.F V', 'X : ExPseudoMetricSpace', 'r : Rat', 'b : Rat', 'G : RegularCauchyFilter X', 'r<b : r < b', 'FU : F.F U', 'F : RegularCauchyFilter X', 'h : \\\\Pi {x : G.X} -> V x -> \\\\Pi {y : F.X} -> U1 y -> U {X.dist x y} r', 'V : E {G.A}', 'U : E {F.A}']<<<break>>>['| A : TopMeetSemilattice', '| F (E {A}) : \\\\Prop', '| X : \\\\Set', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| dist E E : ExUpperReal', 'inP A', '| dist-symm {x y : E} : dist x y = dist y x', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| U Rat : \\\\Prop', '| E : \\\\Set']<<<break>>>TruncP (\\Sigma (r : Rat) (r < b) (U1 : E {F.A}) (F.F U1) (V : E {G.A}) (G.F V)\n  (\\Pi {x : F.X} -> U1 x -> \\Pi {y : G.X} -> V y -> U {X.dist x y} r))", "completion": "inP (r, r<b, U, FU, V, GV, \\lam Ux Vy => rewrite dist-symm (h Vy Ux))"}
{"prompt": "['I : DirectedSet', 'X : CoverSpace', 'h : \\\\Pi (x : Y.E) -> TruncP (\\\\Sigma (V : Set Y.E) (E1 V) (\\\\Pi {y : Y.E} -> U (x - y) -> V y))', 'Y : TopAbGroup', 'g : \\\\Pi {x : X.E} -> V x -> \\\\Pi {n : I.E} -> N I.<= n -> U (func {Y.negative-cont} (func {f n} x - func {f N} x))', 'V : Set X.E', 'U : Set Y.E', 'N : I.E', 'f : I.E -> CoverMap X Y', 'E : Set (Set Y.E)']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| negative E : E', '\\\\lemma negative_+ \\\\hlevels  {this : AddGroup} {x y : E} : negative (x + y) = negative y - x ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>\\Pi {x : X.E} -> V x -> TruncP (\\Sigma (W : Set Y.E) (E1 W) (\\Pi {n : I.E} -> N I.<= n -> W (func {f n} x)))", "completion": "\\lam {x} Vx => (\\case h (f N x) \\with {\n  | inP (W, EW, dW) => inP (W, EW, \\lam p => dW $ simplify in g Vx p)\n})"}
{"prompt": "['q : Rat', 'q>0 : U {zro} q', 'z>0 : zro < z', 'z : Rat']<<<break>>>['| zro : E', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma *-rat \\\\plevels  \\\\hlevels  {x y : Rat} (_ : zro <= x) (_ : zro <= y) : fromRat x ExUpperReal.* fromRat y = fromRat (x RatField.* y) ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)']<<<break>>>fromRat q ExUpperReal.* fromRat z = fromRat (q RatField.* z)", "completion": "*-rat (<=-less q>0) (<=-less z>0)"}
{"prompt": "['a : L.E', 'L : UniformLocale']<<<break>>>['\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '| <=-refl {x : E} : x <= x', '\\\\func CompletionPres \\\\hlevels  (L : UniformLocale) : FramePres L.E {\\n  | conj => (L.\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U)) :: L.E :: nil} j)} {L.E}\\n    (\\\\lam (p0 : \\\\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U)) :: L.E :: nil} j)) =>\\n    (\\\\case p0 \\\\with {\\n      | (zero, a) => (\\\\Sigma, a, \\\\lam (_ : \\\\Sigma) => L.top)\\n      | (suc zero, a) => (IsPositive {L} a, a, \\\\lam (_ : IsPositive {L} a) => a)\\n      | (suc (suc zero), U) => (\\\\Sigma (x : L.E) (U.1 x), L.top, \\\\lam (p0 : \\\\Sigma (x : L.E) (U.1 x)) => p0.1)\\n      | (suc (suc (suc zero)), a) => (\\\\Sigma (b : L.E) (b <=u a), a, \\\\lam (p0 : \\\\Sigma (b : L.E) (b <=u a)) => p0.1)\\n    }))\\n} => \\\\new FramePres', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x']<<<break>>>embed {CompletionPres L} a <= embed {CompletionPres L} a", "completion": "<=-refl {_} {embed a}"}
{"prompt": "['q : pow {MonoidSemiring (PermSetMonoid (Fin (suc n))) K} (mVar {Fin (suc n)} {K} zro) m - pow {MonoidSemiring (PermSetMonoid (Fin (suc n))) K} (mVar {Fin (suc n)} {K} zro) (suc m) * p = zro', 'm : Nat', 'p : E', 'n : Nat', 'K : DiscreteField']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func msMonomial \\\\hlevels  {M : \\\\Set} {R : AddMonoid} (r : R.E) (m : M) : MonoidSet M R => inMS {M} {R} ((r, m) :: nil)', '\\\\instance MonoidAbGroup \\\\hlevels  (M : \\\\Set) (R : AddGroup) : AbGroup (MonoidSet M R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M)} {(~)} nil\\n  | + => (+)\\n  | negative => negative {M} {R}\\n} => \\\\new AbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n}', 'suc Nat', '| ide : E', '\\\\type PermSet \\\\hlevels  (A : \\\\Set) : \\\\Set => Quotient {Array A} (EPerm {A})', '\\\\instance MonoidSemiring \\\\hlevels  (M : Monoid) (R : Semiring) : Semiring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl\\n} => \\\\new Semiring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| zro : E', '\\\\instance FinRing \\\\hlevels  {n : Nat} : CRing.Dec (Fin (suc n)) {\\n  | zro => 0\\n  | + => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => fromNat {n} (x AddMonoid.+ y)\\n  | negative => \\\\lam (x : E {\\\\this}) => fromNat {n} (iabs (suc n - x))\\n  | #0 => #0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq x y \\\\with {\\n    | yes x=y => yes {x = y} (fin_nat-inj {suc n} {x} {y} x=y)\\n    | no x/=y => no {x = y} x/=y\\n  })\\n  | * => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => fromNat {n} (x Semigroup.* y)\\n  | ide => fromNat {n} 1\\n  | natCoef => fromNat {n}\\n} => \\\\new CRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | #0-zro => {?hidden}\\n  | nonZeroApart => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', \"\\\\func * {M3 : Monoid} {R3 : Semiring} (_ _ : MonoidSet M.E R3) : MonoidSet M.E R3 \\n  | {M}, {R}, in~ l, in~ l' =>\\n    in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l')\\n  | {M}, {R}, in~ l, ~-equiv l1 l2 r i => monoidSet-ext {M.E} {R}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l1)}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l2)}\\n    (toEquality {Array (\\\\Sigma R.E M.E)} {Quotient {Array (\\\\Sigma R.E M.E)} (~)} (inMS~ {M.E} {R}) {(~)}\\n      (~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)}) {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l1}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l2} (*-coh-right {M} {R} {l} {l1} {l2} r)) @ i\\n  | {M}, {R}, ~-equiv l1 l2 r i, in~ l => monoidSet-ext {M.E} {R}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l1 l)}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l2 l)}\\n    (~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)} {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l1 l}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (\\\\lam (b : \\\\Sigma R.E M.E) (a : \\\\Sigma R.E M.E) => func {M} {R} a b) l\\n        l1}\\n      (~-perm {M.E} {R} {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l1 l}\\n        {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (\\\\lam (b : \\\\Sigma R.E M.E) (a : \\\\Sigma R.E M.E) => func {M} {R} a b) l\\n          l1} (pairs-flip {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {func {M} {R}} {l1} {l})) *> toEquality {Array (\\\\Sigma R.E M.E)} {Quotient {Array (\\\\Sigma R.E M.E)} (~)} (inMS~ {M.E} {R}) {(~)}\\n      (~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)})\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l1}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l2}\\n      (*-coh-right {Monoid.op {M}} {Semiring.op {R}} {l} {l1} {l2} r) *> ~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l2}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l2 l}\\n      (~-perm {M.E} {R} {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l2}\\n        {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l2 l}\\n        (pairs-flip {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {func {Monoid.op {M}} {Semiring.op {R}}} {l} {l2}))) @ i\", '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| E : \\\\Set', '\\\\func inPS \\\\hlevels  {A : \\\\Set} (l : Array A) : PermSet A => in~ {Array A} {EPerm {A}} l', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ', '\\\\func mVar \\\\hlevels  {J : \\\\Set} {R : CRing} (j : J) : E => msMonomial {PermSet J} {R} R.ide (inPS {J} (j :: nil))', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>pow {MonoidSemiring (PermSetMonoid (Fin (suc n))) K} (msMonomial {E} {K} K.ide (inPS {Fin (suc n)} (zro :: nil))) m = pow {MonoidSemiring (PermSetMonoid (Fin (suc n))) K} (mVar {Fin (suc n)} {K} zro) m * mVar {Fin (suc n)} {K} zro * p", "completion": "fromZero q"}
{"prompt": "['Vo : isOpen {Cod {\\\\this}} V', 'f : X.E -> Y.E', 'fc : \\\\Pi (x : X.E) -> IsContAt {X} {Y} f x', 'V : E {Cod {\\\\this}} -> \\\\Prop', 'X : TopSpace']<<<break>>>['| isOpen (Set E) : \\\\Prop', '| E : \\\\Set', '\\\\lemma cover-open \\\\hlevels  {this : TopSpace} {U : Set E} (_ : \\\\Pi {x : E} -> U x -> TruncP (\\\\Sigma (V : Set E) (isOpen V) (V x) (V \u2286 U))) : isOpen U ']<<<break>>>X.isOpen (\\lam (a : X.E) => V (f a))", "completion": "cover-open {X} (\\lam Vfx => fc _ Vo Vfx)"}
{"prompt": "['n : Nat', 'l : Array A.E', 'f : Array A.E (suc n) -> B.E', 'B : LModule R', 'j : Fin l.len', 'c : Array (Fin l.len) n', 'A : LModule R', 'p : \\\\Pi (c : Array (Fin l.len) (suc n)) -> f (map {Fin l.len} {A.E} l.at c) = B.zro']<<<break>>>['| len : Nat', '| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>f (map {Fin l.len} {A.E} l.at (j :: c)) = B.zro", "completion": "p (j :: c)"}
{"prompt": "['this : DiscreteField', 'x : E', 'x+1i : x + ide /= zro', 'xi : x /= zro']<<<break>>>['| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '| finv-right {x : E} (x /= zro) : x * finv x = ide', '\\\\lemma nonZero_* \\\\hlevels  {this : Domain} {x y : E} (_ : x /= zro) (_ : y /= zro) : x * y /= zro ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| finv E : E', '| ide : E', '| E : \\\\Set']<<<break>>>x * (x + ide) * finv (x * (x + ide)) = ide", "completion": "finv-right {this} (nonZero_* {this} xi x+1i)"}
{"prompt": "['x : E {Dom {\\\\this}}', 'this : AAlgebra', 'y : E {Dom {\\\\this}}']<<<break>>>['| \\\\infixl 7 * E E : E', '| *c-comm-left {r : E {R}} {a b : E} : r *c (a * b) = r *c a * b', '| ide : E', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set']<<<break>>>x *c (ide * (y *c ide)) = x *c ide * (y *c ide)", "completion": "*c-comm-left {this}"}
{"prompt": "['c1 : Rat', 'd1 : Rat', 'c1>=0 : zro <= c1', 'c1<d1 : c1 < d1']<<<break>>>['| zro : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\instance RatNormed \\\\hlevels  : NormedAbGroup Rat {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | negative => RatField.negative\\n  | norm => \\\\lam (a : E {\\\\this}) => Real.fromRat (abs {RatField} a)\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)']<<<break>>>zro < d1", "completion": "c1>=0 <\u2218r c1<d1"}
{"prompt": "['W2 : E {A}', \"R' : E {A} -> E {A} -> \\\\Prop\", 'W1 : E {A}', 'RV1W1 : R V1 W1', 'this : RatherBelow', 'V : E {A}', 'V2 : E {A}', 'R : E {A} -> E {A} -> \\\\Prop', 'V1 : E {A}', \"R'V2W2 : R' V2 W2\", 'Vp : V = V1 \u2227 V2']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', 'inP A', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| A : TopMeetSemilattice', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (V1 V2 U1 U2 : E {A}) (R V1 U1) (R' V2 U2) (V = V1 \u2227 V2) (W1 \u2227 W2 = U1 \u2227 U2))", "completion": "inP (V1, V2, W1, W2, RV1W1, R'V2W2, Vp, idp)"}
{"prompt": "['p : \\\\Sigma (\\\\Sigma (x : X.E) (U.1 x)) (\\\\Sigma (x : X.E) (V.1 x))', 'f : FramePresHom X (F Y)', 'V : E {Dom {\\\\this}}', 'U : E {Dom {\\\\this}}', 'X : FramePres', 'Y : Locale']<<<break>>>['| conj E E : E', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', 'cover-inj (j : J) (g j = x)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Join {J : \\\\Set} (J -> E) : E', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>(\\lam (j : \\Sigma (x : X.E) ((U \u2227 V).1 x)) => f.func j.1)\n(conj {X} p.1.1 p.2.1, cover-inj {X} {X.conj p.1.1 p.2.1} {\\Sigma (a b : X.E) (U.1 a) (V.1 b)}\n  {\\lam (t : \\Sigma (a b : X.E) (U.1 a) (V.1 b)) => X.conj t.1 t.2} (p.1.1, p.2.1, p.1.2, p.2.2)\n  (idp {X.E} {X.conj p.1.1 p.2.1})) Y.<= Y.Join {\\Sigma (x : X.E) ((U \u2227 V).1 x)} (\\lam (j : \\Sigma (x : X.E) ((U \u2227 V).1 x)) => f.func j.1)", "completion": "Join-cond {Y} (later (conj p.1.1 p.2.1, cover-inj (later (p.1.1, p.2.1, p.1.2, p.2.2)) idp))"}
{"prompt": "['g : SemiringHom R S', 'M : \\\\Set', 'l : Array (\\\\Sigma R.E M)', 'R : Semiring', 'f : M -> R.E']<<<break>>>['| len : Nat', '| \\\\infixl 7 * E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '\\\\lemma func-BigSum \\\\hlevels  {this : AddMonoidHom} {l : Array (E {Dom})} :\\n  func (BigSum {Dom} l) = BigSum {Cod} (\\\\new Array (E {Cod}) l.len (\\\\lam (j : Fin l.len) => func (l.at j))) ', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '| Dom : BaseSet', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>g.func (BigSum {g.Dom} (map {\\Sigma R.E M} {R.E} (\\lam (s : \\Sigma R.E M) => s.1 R.* f s.2) l)) = BigSum {g.Cod} (\\new Array (E {g.Cod}) (len {map {\\Sigma R.E M} {R.E} (\\lam (s : \\Sigma R.E M) => s.1 R.* f s.2) l})\n  (\\lam (j : Fin (len {map {\\Sigma R.E M} {R.E} (\\lam (s : \\Sigma R.E M) => s.1 R.* f s.2) l})) =>\n    g.func (at {map {\\Sigma R.E M} {R.E} (\\lam (s : \\Sigma R.E M) => s.1 R.* f s.2) l} j)))", "completion": "func-BigSum {g}"}
{"prompt": "['eps : Rat', \"eps' : Rat\"]<<<break>>>['true', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatData (eps' :: eps :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 2} 0 :+ (var {E} {Fin 2} 1 :+ :negative {E} {Fin 2} (var {E} {Fin 2} 0))) <= interpret {\\new LinearRatData (eps' :: eps :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 2} 1)", "completion": "solve<=Problem {\\new LinearRatData {\n  | R => RatField\n  | vars => eps' :: eps :: nil\n}} nil (var 0 :+ (var 1 :+ :negative (var 0))) (var 1) (1 :: nil, 0, idp, idp {Bool} {true}) nil"}
{"prompt": "['R : CRing']<<<break>>>['| zro : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| natCoef Nat : E', '| E : \\\\Set', '| natCoefZero : natCoef 0 = zro']<<<break>>>R.natCoef 0 = R.zro", "completion": "natCoefZero {R}"}
{"prompt": "['j : Fin (suc n)', 'n : Nat']<<<break>>>['suc Nat', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ']<<<break>>>j < suc n", "completion": "fin_< j"}
{"prompt": "['this : PrecatWithBprod', 'x : Ob', 'y : Ob']<<<break>>>['| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '| apex : Ob {D}', '| Hom Ob Ob : \\\\Set', '| id (X : Ob) : Hom X X', '\\\\func proj1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 0) => proj {Bprod x y} 0', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| Bprod (x y : Ob) : Product {Fin 2} (at {x :: y :: nil})']<<<break>>>proj1 {x} {y} = proj1 {x} {y} \u2218 id (apex {Bprod x y})", "completion": "rewrite (id-right {this}) idp"}
{"prompt": "['n : Nat']<<<break>>>['\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| E : \\\\Set', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '| \\\\infix 4 < E E : \\\\Prop', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)', 'pos Nat']<<<break>>>Real (\\lam (_x : Rat) => _x StrictPoset.< finv (fromInt (pos n))) ((OrderedAddGroup.<) (finv (fromInt (pos n))))", "completion": "finv n"}
{"prompt": "[\"y' : Ob\", \"f' : Hom x' y'\", 'z : Ob', \"x' : Ob\", 'f : Hom x y', 'g : Hom y z', 'y : Ob', 'x : Ob', 'this : PrecatWithBprod']<<<break>>>['| apex : Ob {D}', '| Hom Ob Ob : \\\\Set', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '\\\\func proj1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 0) => proj {Bprod x y} 0', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma beta1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : proj1 {x} {y} \u2218 pair {x} {y} {z} f g = f ', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\func proj2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 1) => proj {Bprod x y} 1', '| Bprod (x y : Ob) : Product {Fin 2} (at {x :: y :: nil})', '\\\\func pair \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : Hom z (apex {Bprod x y}) \\n=> tupleMap {Bprod x y} {z} (\\\\lam (p0 : J {Bprod x y}) => (\\\\case p0 \\\\with {\\n  | zero => f\\n  | suc zero => g\\n}))']<<<break>>>g \u2218 f \u2218 proj1 {x} {x'} = g \u2218 (proj1 {y} {y'} \u2218 pair {y} {y'} {apex {Bprod x x'}} (f \u2218 proj1 {x} {x'}) (f' \u2218 proj2 {x} {x'}))", "completion": "rewrite (beta1 {this} _ _) (o-assoc {this})"}
{"prompt": "['G : Sheaf C']<<<break>>>['| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| D : Precat', '| Ob : \\\\hType', '| C : Precat', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f']<<<break>>>\\Pi {X Y Z : Ob {C {G.F}}} -> \\Pi {g : Hom {C {G.F}} Y Z} ->\n  \\Pi {f : Hom {C {G.F}} X Y} -> Func {G.F} {X} {Z} (g \u2218 f) = Func {G.F} {Y} {Z} g \u2218 Func {G.F} {X} {Y} f", "completion": "Func-o {F {G}}"}
{"prompt": "['p : \\\\Pi (x y : X.E) -> f.func (pointCF {X} x, pointCF {X} y) = g.func (pointCF {X} x, pointCF {X} y)', 'f : ContMap (Completion X \u2a2f Completion X) (Completion X)', 'X : CoverSpace', 'g : ContMap (Completion X \u2a2f Completion X) (Completion X)']<<<break>>>['| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\instance Completion \\\\hlevels  (X : CoverSpace) : CompleteCoverSpace (RegularCauchyFilter X) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X}}\\n  | isCauchy => isCCauchy {X}\\n} => \\\\new CompleteCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}']<<<break>>>\\Pi (s : E {X \u2a2f X}) -> f.func (pointCF {X} s.1, pointCF {X} s.2) = g.func (pointCF {X} s.1, pointCF {X} s.2)", "completion": "\\lam s => p s.1 s.2"}
{"prompt": "['h : R.E', 'Y : HausdorffTopLModule R']<<<break>>>['| zro : E', '\\\\lemma *c_zro-right \\\\hlevels  {this : LModule} {r : E {R}} : r *c zro = zro ', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set']<<<break>>>h Y.*c Y.zro = Y.zro", "completion": "*c_zro-right {Y}"}
{"prompt": "['n : Nat', 'xy : Nat -> R.E', 'R : CRing']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', 'suc Nat', '| natCoef Nat : E', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func binom \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | n, 0 => 1\\n  | 0, i => 0\\n  | suc n, suc i => binom n i + binom n (suc i)']<<<break>>>Array R.E (suc n) (\\lam (i : Fin (suc n)) => R.natCoef (binom n i) R.* xy i)", "completion": "\\new DArray {suc n} (\\lam _ => R) (\\lam i => natCoef (binom n i) * xy i)"}
{"prompt": "['l : List (Array Bool n)', 'env : Array B.E n', 'B : BooleanRing', \"l' : NF n\"]<<<break>>>['| len : Nat', \"\\\\lemma interpretNF_++ {B : BooleanRing} {n : Nat} {env : Array B.E n} {l l' : NF n} :\\n  interpretNF' {B} {n} env (l ++ l') = interpretNF' {B} {n} env l B.+ interpretNF' {B} {n} env l' \", '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\func interpretNF' \\\\hlevels  {B3 : BooleanRing} {n2 : Nat} (_ : Array B.E n2) (_ : NF n2) : B.E \\n  | {B}, {n}, env, nil => B.zro\\n  | {B}, {n}, env, x :: nil => interpretMonomial {B} {n} env x\\n  | {B}, {n}, env, x :: l => interpretMonomial {B} {n} env x B.+ interpretNF' {B} {n} env l\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys']<<<break>>>interpretNF' {B} {len {env}} env (l ++ l') = interpretNF' {B} {len {env}} env l B.+ interpretNF' {B} {len {env}} env l'", "completion": "interpretNF_++ {B}"}
{"prompt": "['R : CRing', 'x : R.E', 'p : R.zro /= R.ide']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '| ide : E', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '| inv : E {M}', '| inv-right : val * inv = elem', \"\\\\func levelProp \\\\plevels  \\\\hlevels  {A4 B4 : \\\\Prop} (_ : A4 -> B4 -> Empty) (x y : Or A4 B4) : x = y \\n  | {A}, {B}, e, inl a, inl a' => pmap {A} {Or A B} (inl {A} {B}) {a} {a'} (prop-pi {A} {a} {a'})\\n  | {A}, {B}, e, inl a, inr b => absurd {inl {A} {B} a = inr {A} {B} b} (e a b)\\n  | {A}, {B}, e, inr b, inl a => absurd {inr {A} {B} b = inl {A} {B} a} (e a b)\\n  | {A}, {B}, e, inr b, inr b' => pmap {B} {Or A B} (inr {A} {B}) {b} {b'} (prop-pi {B} {b} {b'})\", '| zro : E', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| zro_*-left {x : E} : zro * x = zro', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>\\Pi (x1 y : Or (x = R.zro) (Inv {R} x)) -> x1 = y", "completion": "levelProp (\\lam x=0 (j : Inv x) => p $ inv (zro_*-left {R}) *> pmap (\\lam _x => _x * _) (inv x=0) *> inv-right {j})"}
{"prompt": "['M : UniformLocale']<<<break>>>['\\\\func closure \\\\hlevels  {P : FramePres} {J : \\\\Set} (g : J -> P.E) : Opens P \\n=> (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g, \\\\lam (x : P.E) (c : SCover {P} x (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g)) =>\\n  cover-trans {P} {x} {J} {g} {\\\\Sigma (x : P.E) (Cover {P} x {J} g)} {\\\\lam (t : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => t.1} c (\\\\lam (p0 : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => p0.2))', '| conj E E : E', '\\\\func CompletionLocale \\\\hlevels  (L : UniformLocale) : Locale (Opens (CompletionPres L)) {\\n  | <= => (<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {CompletionPres L} {\\\\Sigma (a b : E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : E) (U.1 a) (V.1 b)) => conj t.1 t.2)\\n  | top => (\\\\lam (_ : E) => \\\\Sigma, \\\\lam (e : E) (_ : SCover {CompletionPres L} e (\\\\lam (_ : E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {CompletionPres L} {\\\\Sigma (j : J) (x : E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : E) ((f j).1 x)) => p0.2)\\n} => PresentedFrame (CompletionPres L)', '\\\\func SCover \\\\hlevels  {this : FramePres} (x : E) (U : E -> \\\\Prop) : \\\\Prop \\n  => Cover x {\\\\Sigma (x : E) (U x)} (\\\\lam (t : \\\\Sigma (x : E) (U x)) => t.1)', '\\\\func CompletionPres \\\\hlevels  (L : UniformLocale) : FramePres L.E {\\n  | conj => (L.\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U)) :: L.E :: nil} j)} {L.E}\\n    (\\\\lam (p0 : \\\\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U)) :: L.E :: nil} j)) =>\\n    (\\\\case p0 \\\\with {\\n      | (zero, a) => (\\\\Sigma, a, \\\\lam (_ : \\\\Sigma) => L.top)\\n      | (suc zero, a) => (IsPositive {L} a, a, \\\\lam (_ : IsPositive {L} a) => a)\\n      | (suc (suc zero), U) => (\\\\Sigma (x : L.E) (U.1 x), L.top, \\\\lam (p0 : \\\\Sigma (x : L.E) (U.1 x)) => p0.1)\\n      | (suc (suc (suc zero)), a) => (\\\\Sigma (b : L.E) (b <=u a), a, \\\\lam (p0 : \\\\Sigma (b : L.E) (b <=u a)) => p0.1)\\n    }))\\n} => \\\\new FramePres', '\\\\func Completion (L : UniformLocale) : UniformLocale (Opens (CompletionPres L)) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E) (V : E) =>\\n    closure {CompletionPres L} {\\\\Sigma (a b : E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : E) (U.1 a) (V.1 b)) => conj t.1 t.2)\\n  | top => (\\\\lam (_ : E) => \\\\Sigma, \\\\lam (e : E) (_ : SCover {CompletionPres L} e (\\\\lam (_ : E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E) =>\\n    closure {CompletionPres L} {\\\\Sigma (j : J) (x : E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : E) ((f j).1 x)) => p0.2)\\n  | isUniform => Completion.isUniform {L}\\n} => \\\\new UniformLocale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n  | uniform-overt => {?hidden}\\n  | isCovering => {?hidden}\\n  | isDownset => {?hidden}\\n  | top-uniform => {?hidden}\\n  | meet-uniform => {?hidden}\\n  | <=-uniform => {?hidden}\\n  | star-uniform => {?hidden}\\n  | isAdmissible => {?hidden}\\n}', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', '| E : \\\\Set', '\\\\class UniformLocale \\\\extends PreuniformLocale \\\\hlevels  {\\n  | isAdmissible (b : E) : b <= SJoin (\\\\lam (_x : E) => _x <=u b)\\n}', '\\\\func isUniform {L : UniformLocale} (V : E -> \\\\Prop) : \\\\Prop \\n=> TruncP (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U) (\\\\Pi {a : L.E} -> U a -> V (embed {CompletionPres L} a))\\n  (\\\\Pi {x y : E} -> V y -> x <= y -> V x))', '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x']<<<break>>>UniformLocale (Opens (CompletionPres M)) {\n  | <= => (<=)\n  | meet => \\lam (U : E) (V : E) =>\n    closure {CompletionPres M} {\\Sigma (a b : E) (U.1 a) (V.1 b)} (\\lam (t : \\Sigma (a b : E) (U.1 a) (V.1 b)) => conj t.1 t.2)\n  | top => (\\lam (_ : E) => \\Sigma, \\lam (e : E) (_ : SCover {CompletionPres M} e (\\lam (_ : E) => \\Sigma)) => ())\n  | Join => \\lam {J : \\Set} (f : J -> E) =>\n    closure {CompletionPres M} {\\Sigma (j : J) (x : E) ((f j).1 x)} (\\lam (p0 : \\Sigma (j : J) (x : E) ((f j).1 x)) => p0.2)\n  | isUniform => isUniform {M}\n}", "completion": "Completion M"}
{"prompt": "['Q : Dec', 'a : Interval Q', 'n : Nat', 'z : Interval Q', 'c_c<z2_ca2<=l+1 : \\\\Sigma (c : Q.E) (c Q.< z.2) (\\\\Pi {x : Q.E} -> point {Q} x < (c, a.2) -> TruncP (\\\\Sigma (j : Fin l.len) (point {Q} x < l.at j)))', 'l : Array (Interval Q) n']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '\\\\type Interval \\\\hlevels  (Q : Poset) : \\\\Set => \\\\Sigma Q.E Q.E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', '\\\\lemma cover-pair \\\\hlevels  {Q : Dec} {x : Interval Q} {z1 z2 : Q.E} (_ : z1 Q.< z2) :\\nCover {RealPres Q} x {Fin 2} (\\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n  | zero => (x.1, z2)\\n  | suc zero => (z1, x.2)\\n})) ', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', 'cover-inj (j : J) (g j = x)', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\instance RealPres \\\\hlevels  (Q : Dec) : FramePres (Interval Q) {\\n  | conj => (\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))} {Interval Q}\\n    (\\\\lam (p0 : \\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))) =>\\n    (\\\\case p0 \\\\with {\\n      | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n        | zero => (p, q)\\n        | suc zero => (r, s)\\n      }))\\n      | (false, (p, q)) => (\\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\\n        \\\\lam (t : \\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\\n    }))\\n} => \\\\new FramePres', '\\\\lemma fromPointwiseCover \\\\hlevels  {Q : Dec} {a : Interval Q} {l : Array (Interval Q)}\\n  (_ : \\\\Pi {x : Q.E} -> point {Q} x < a -> TruncP (\\\\Sigma (j : Fin l.len) (point {Q} x < l.at j))) :\\n  Cover {RealPres Q} a {Fin l.len} l.at ']<<<break>>>\\Sigma -> Cover {RealPres Q} (z.1, a.2) {Fin (suc l.len)} (at {z :: l})", "completion": "\\lam _ => cover-trans (cover-pair c<z2) (\\lam p0 => (\\case \\elim p0 \\with {\n  | 0 => cover-inj 0 idp\n  | 1 => cover-trans (fromPointwiseCover ca2<=l+1) (\\lam i => cover-inj (suc i) idp)\n}))"}
{"prompt": "['n : Nat', 'a : K.E', 'ac : IsAlgebraicallyClosed K', 'pa : polyEval {K} p a = K.zro', 'pc : polyCoef {K} p (suc n) = K.ide', 'K : CRing', 'p : Poly K', \"pd' : degree<= {K} (degree1PolyDivision {K} p a).1 n\"]<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func rootDiv \\\\hlevels  {R : CRing} (f : Poly R) (a : R.E) : Poly R => (degree1PolyDivision {R} f a).1', '\\\\func BigProd \\\\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l', 'suc Nat', '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', 'padd (Poly R) R.E', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'pzero', '| \\\\infixl 7 * E E : E', '\\\\lemma aux \\\\hlevels  {K : CRing} (_ : IsAlgebraicallyClosed K) {p : Poly K} {n : Nat} (_ : degree<= {K} p n) (_ : polyCoef {K} p n = K.ide) :\\n  TruncP (\\\\Sigma (l : Array K.E n) (p = BigProd {PolyRing K} (map {K.E} {Poly K} (\\\\lam (a : K.E) => padd {K} ide (K.negative a)) l))) ', '| E : \\\\Set', '| negative E : E', '\\\\lemma rootDiv_* \\\\hlevels  {R : CRing} {f : Poly R} {a : R.E} (_ : polyEval {R} f a = R.zro) : f = rootDiv {R} f a * padd {R} ide (R.negative a) ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| ide-right {x : E} : x * ide = x', '\\\\lemma leadCoef-product \\\\hlevels  {R : Ring} {p q : Poly R} {n m : Nat} (_ : degree<= {R} p n) (_ : degree<= {R} q m) :\\n  polyCoef {R} (p * q) (n + m) = polyCoef {R} p n R.* polyCoef {R} q m ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '\\\\func polyCoef \\\\hlevels  {R4 : AddPointed} (_ : Poly R4) (_ : Nat) : R.E \\n  | {R}, pzero, n => R.zro\\n  | {R}, padd p e, 0 => e\\n  | {R}, padd p e, suc n => polyCoef {R} p n\\n  | {R}, peq i, 0 => idp {R.E} {R.zro} @ i\\n  | {R}, peq i, suc n => idp {R.E} {R.zro} @ i', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma degree1PolyDivision \\\\hlevels  {R : CRing} (f : Poly R) (a : R.E) :\\n\\\\level (\\\\Sigma (q : Poly R) (f = q * padd {R} ide (R.negative a) + padd {R} (pzero {R}) (polyEval {R} f a))) (\\\\lam (s1 : \\\\Sigma (q : Poly R) (f = q * padd {R} ide (R.negative a) + padd {R} (pzero {R}) (polyEval {R} f a)))\\n  (s2 : \\\\Sigma (q : Poly R) (f = q * padd {R} ide (R.negative a) + padd {R} (pzero {R}) (polyEval {R} f a))) =>\\npath (\\\\lam (i : I) => (\\n  \\\\have arg => degree1PolyDivision-unique {R} f a {s1.1} {s2.1} s1.2 s2.2\\n  \\\\in (arg @ i,\\n        prop-dpi (\\\\lam (i : I) => f = arg @ i * padd {R} ide (R.negative a) + padd {R} (pzero {R}) (polyEval {R} f a)) s1.2 s2.2 @ i)))) ']<<<break>>>TruncP (\\Sigma (l : Array K.E n)\n  ((degree1PolyDivision {K} p a).1 = BigProd {PolyRing K} (map {K.E} {Poly K} (\\lam (a : K.E) => padd {K} ide (K.negative a)) l)))", "completion": "aux ac pd' (inv ide-right *> inv (leadCoef-product {_} {_} {_} {n} {1} pd' idp) *> (rewrite (rootDiv_* pa) in pc))"}
{"prompt": "['U : Set E', 'x : E', 'this : PrecoverSpace']<<<break>>>['\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set']<<<break>>>U x -> U \u2286 (\\lam (_ : E) => \\Sigma)", "completion": "\\lam _ _ => ()"}
{"prompt": "['J : FinSet', 'this : With#', 'i : J.E', 'r : #0 (BigSum (\\\\new Array E J.finCard (\\\\lam (j : Fin J.finCard) => x (e.f j))))', 'x : J.E -> E', 'p : FinSum {J} x = BigSum (\\\\new Array E J.finCard (\\\\lam (j : Fin J.finCard) => x (e.f j)))', 'e : Equiv {Fin J.finCard} {J.E}']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'byLeft A', '| \\\\infix 8 #0 E : \\\\Prop', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '| f A : B', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", 'FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| finCard : Nat', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l']<<<break>>>#0 (FinSum {J} x) || (\\Sigma (j : J.E) (j /= i) (#0 (x j)))", "completion": "byLeft (transportInv (#0 {this}) p r)"}
{"prompt": "['X : FramePres', 'f : FramePresHom X (F Y)', 'x : X.E', 'Y : Locale']<<<break>>>['\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '| <=-refl {x : E} : x <= x', '| Join {J : \\\\Set} (J -> E) : E', '\\\\lemma locale_cover {L : Locale} {x : L.E} {J : \\\\Set} {g : J -> L.E} (_ : Cover {F L} x {J} g) : x L.<= L.Join {J} g ', '\\\\lemma map \\\\hlevels  {F : FramePresPrehom} {x : E {F.Dom}} {J : \\\\Set} {g : J -> E {F.Dom}} (_ : Cover {F.Dom} x {J} g) :\\n  Cover {F.Cod} (F.func x) {J} (\\\\lam (j : J) => F.func (g j)) ', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>\\Pi (j : \\Sigma (x1 : X.E) ((embed {X} x).1 x1)) -> f.func j.1 Y.<= f.func x", "completion": "\\lam j => locale_cover (map j.2) <=\u2218 Join-univ (\\lam _ => <=-refl)"}
{"prompt": "['X : ExPseudoNormedAbGroup']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma negative_+ \\\\hlevels  {this : AddGroup} {x y : E} : negative (x + y) = negative y - x ', '| E : \\\\Set', '| negative E : E']<<<break>>>X.negative (X.zro X.+ (zro {X} + zro {X})) = X.negative (zro {X} + zro {X}) - X.zro", "completion": "negative_+ {_} {X.zro} {X.zro X.+ X.zro}"}
{"prompt": "['R : Ring', 'm : Nat', 'this : Equivalence (Matrix R.E n m) {\\n  | ~ => (M~)\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', 'n : Nat']<<<break>>>['\\\\lemma ide-isInv \\\\hlevels  {M : Monoid} : Inv {M} M.ide ', '\\\\lemma product_ide-right \\\\hlevels  {R : Ring} {n m : Nat} {M : Matrix R.E n m} : M product ide {R} {m} = M ', '| ide : E', 'inP A', '| A : \\\\Set', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\instance MatrixRing \\\\hlevels  (R : Ring) (n : Nat) : Ring (Matrix R.E n n) {\\n  | zro => \\\\new Array (Array R.E n) n (\\\\lam (_ : Fin n) => \\\\new Array R.E n (\\\\lam (_ : Fin n) => R.zro))\\n  | + => \\\\lam (M : E) (N : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => at {at {M} i} j R.+ at {at {N} i} j)\\n  | * => (product)\\n  | negative => \\\\lam (M : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => R.negative (at {at {M} i} j))\\n  | ide => ide {R} {n}\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| val : E {M}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func ide {R : Ring} {n : Nat} : Matrix R.E n n => diagonal {R} (replicate {R.E} n R.ide)', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '\\\\lemma product_ide-left \\\\hlevels  {R : Ring} {n m : Nat} {A : Matrix R.E n m} : ide {R} {n} product A = A ', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func \\\\infixl 7 product \\\\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))', '\\\\type \\\\infix 4 M~ \\\\hlevels  {R : Ring} {n m : Nat} (A B : Matrix R.E n m) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (B = C.val product A product D.val))']<<<break>>>\\Pi {A : A {\\this}} -> A M~ A", "completion": "\\lam {A} => inP (ide-isInv, ide-isInv, inv $ product_ide-right *> product_ide-left)"}
{"prompt": "['x : X.E', \"x' : X.E\", 'X : PseudoMetricSpace', 'eps : Real', \"xx'<delta : X.dist x x' < fromRat delta\", \"eps'<esp : eps.L eps'\", 'Y : PseudoMetricSpace', \"eps' : Rat\", 'f : X.E -> Y.E', \"h : \\\\Pi {x' : X.E} -> U {X.dist x x'} delta -> U {Y.dist (f x) (f x')} eps'\", 'delta : Rat']<<<break>>>['\\\\lemma real_<_U \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : x < fromRat a <-> x.U a ', '| dist E E : ExUpperReal', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| <-transitive \\\\alias \\\\infixr 9 <\u2218 {x y z : E} (x < y) (y < z) : x < z', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\lemma real_<_L \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : fromRat a < x <-> x.L a ', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>Y.dist (f x) (f x') < eps", "completion": "real_<_U.2 (h $ real_<_U.1 xx'<delta) <\u2218 real_<_L.2 eps'<esp"}
{"prompt": "['a : E {A {\\\\this}}', 'V : Set Y.E', 'GV : G.F V', \"V' : Set Y.E\", 'f : \\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> a (x, y)', 'F : CauchyFilter X', \"FU' : F.F U'\", 'G : CauchyFilter Y', \"GV' : G.F V'\", 'U : Set X.E', 'b : E {A {\\\\this}}', \"U' : Set X.E\", \"f' : \\\\Pi {x : X.E} -> U' x -> \\\\Pi {y : Y.E} -> V' y -> b (x, y)\", 'Y : CoverSpace', 'X : CoverSpace', 'FU : F.F U']<<<break>>>['| F (E {A}) : \\\\Prop', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U : Set X.E) (F.F U) (V : Set Y.E) (G.F V) (\\Pi {x : X.E} -> U x -> \\Pi {y : Y.E} -> V y -> (\u2227) a b (x, y)))", "completion": "inP (U \u2227 U', filter-meet FU FU', V \u2227 V', filter-meet GV GV', \\lam p0 p1 => (\n  \\let | (Ux, U'x) => p0\n       | (Vy, V'y) => p1\n  \\in (f Ux Vy, f' U'x V'y)))"}
{"prompt": "['L : Locale', 'f : PrecoverMap (LocalePrecoverSpace L) (LocalePrecoverSpace M)', 'y : E {Dom {\\\\this}}', 'M : Locale', 'b_b<=<x : \\\\Sigma (b : M.E) (b <=< x)', 'p : x <= y', 'x : E {Dom {\\\\this}}', 'this : FrameHom M L {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) =>\\n    L.Join {\\\\Sigma (b : M.E) (b <=< a)} (\\\\lam (s : \\\\Sigma (b : M.E) (b <=< a)) => points_* {L} (f.func ^-1 points^* {M} s.1))\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| <=<-left {U V W : E {A}} (R U V) (V <= W) : R U W', '| Join {J : \\\\Set} (J -> E) : E', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func points^* \\\\hlevels  {L : Locale} (a : L.E) : Set (CompleteFilter L) => \\\\lam (x : CompleteFilter L) => x.F a', '\\\\type \\\\infix 4 <=< \\\\hlevels  {this : Locale} (x y : E) : \\\\Prop => top <= neg x \u2228 y', '\\\\instance LocaleRatherBelow \\\\hlevels  {L : Locale} : RatherBelow {L} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)']<<<break>>>L.Join {\\Sigma (b : M.E) (b <=< x)} (\\lam (s : \\Sigma (b : M.E) (b <=< x)) => points_* {L} (f.func ^-1 points^* {M} s.1)) L.<= func {\\this} y", "completion": "Join-univ (\\lam p0 => (\n  \\let (b, b<=<x) => p0\n  \\in Join-cond $ later (b, <=<-left b<=<x p)))"}
{"prompt": "['n : Nat']<<<break>>>['\\\\type Sym \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => Equiv {Fin n} {Fin n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\type isCycle \\\\plevels  \\\\hlevels  {n : Nat} (e : Sym n) : \\\\Prop => TruncP (\\\\Sigma (i : Fin n) (Support {n} e i)\\n  (\\\\Pi (j : Fin n) -> Support {n} e j -> TruncP (\\\\Sigma (k : Nat) (f {pow {SymmetricGroup n} e k} i = j))))']<<<break>>>\\Pi (p0 : Fin 0) -> isCycle {n} (nil !! p0)", "completion": "\\lam p0 => (\\case p0 \\with {})"}
{"prompt": "['L : BottomJoinSemilattice', 'this : AbMonoid L.E {\\n  | zro => L.bottom\\n  | + => (L.\u2228)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n}']<<<break>>>['\\\\lemma join-assoc \\\\hlevels  {this : JoinSemilattice} {x y z : E} : x \u2228 y \u2228 z = x \u2228 (y \u2228 z) ', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E']<<<break>>>\\Pi {x : E {\\this}} -> \\Pi {y : E {\\this}} -> \\Pi {z : E {\\this}} -> x L.\u2228 y L.\u2228 z = x L.\u2228 (y L.\u2228 z)", "completion": "\\lam {x} {y} {z} => join-assoc {L}"}
{"prompt": "['X : RealBanachAlgebra', 'b : Rat', 'ab_<= : a \u2228 b \u2228 ide <= ab', '|x|<a : U {X.norm x} a', 'ab : E', 'x : X.E', \"ab'>=0 : zro <= finv (RatField.join (RatField.join a b) ide * (a JoinSemilattice.\u2228 b JoinSemilattice.\u2228 ide))\", 'a : Rat']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma norm>=0 \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : zro <= X.norm x ', '| \\\\infix 4 <= E E : \\\\Prop', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| <=_*_positive-left {x y z : E} (x <= y) (zro <= z) : x * z <= y * z', '| join-left {x y : E} : x <= x \u2228 y', '\\\\lemma <_<= \\\\plevels  \\\\hlevels  {x : ExUpperReal} {q : Rat} (_ : x.U q) : x <= fromRat q ', '| \\\\infixl 7 * E E : E', '\\\\func join (_ _ : Rat) : Rat \\n  | rat n1 d1 denom/=0 reduced, rat n2 d2 denom/=0 reduced => \\\\case dec<_<= {IntRing} (n1 * pos d2) (n2 * pos d1) \\\\with {\\n    | inl x<y => rat n2 d2 {?hidden} {?hidden}\\n    | inr y<=x => rat n1 d1 {?hidden} {?hidden}\\n  }', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\lemma finv_<= {this : DiscreteOrderedField} {x y : E} (_ : zro < x) (_ : x <= y) : finv y <= finv x ', '\\\\lemma >_/= \\\\hlevels  {this : StrictPoset} {x y : E} (_ : x > y) : x /= y ', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\lemma <=_* \\\\plevels  \\\\hlevels  {x x' y y' : ExUpperReal} (_ : x <= x') (_ : y <= y') : x * y <= x' * y' \", '| ide : E', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\lemma finv-left {this : DiscreteField} {x : E} (_ : x /= zro) : finv x * x = ide ', '| norm E : ExUpperReal', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '| zro : E', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\lemma *-rat \\\\plevels  \\\\hlevels  {x y : Rat} (_ : zro <= x) (_ : zro <= y) : fromRat x ExUpperReal.* fromRat y = fromRat (x RatField.* y) ', '| finv E : E', '\\\\instance ExUpperRealLattice \\\\hlevels  : CompleteLattice ExUpperReal {\\n  | <= => (ExUpperReal.<=)\\n  | meet => meet\\n  | join => join\\n  | top => top-impl\\n  | Join => ExUpperRealLattice.Join\\n  | Meet => ExUpperRealLattice.Meet\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '| join \\\\alias \\\\infixl 6 \u2228 E E : E']<<<break>>>fromRat (finv (RatField.join (RatField.join a b) ide RatField.* (a JoinSemilattice.\u2228 b JoinSemilattice.\u2228 ide))) ExUpperReal.* X.norm x <= ide", "completion": "<=_* <=-refl (<_<= |x|<a) <=\u2218 transportInv (\\lam _x => _x <= _) (*-rat ab'>=0 $ <=-less $ norm>=0 |x|<a) (<=-rat.1 $ <=_*_positive-left\n  {RatField} (finv_<= {RatField} (norm>=0 |x|<a) $ join-left <=\u2218 join-left <=\u2218 ab_<=) (<=-less $ norm>=0 |x|<a) <=\u2218 =_<= (finv-left {RatField} $ >_/= {RatField} $ norm>=0 |x|<a))"}
{"prompt": "['id : IsDenseEmbedding {i}', 'ph : IsRelativelyHausdorff {Z} {T} p', 'g : ContMap Y T', 'pc : IsRelativelyComplete {Z} {T} p', 'p : Z.E -> T.E', 'sq : \\\\Pi (x : X.E) -> g.func (i.func x) = p (f.func x)', 'Z : CoverSpace', 'f : CoverMap X Z', 'Y : CoverSpace', 'D : Set (Set (E {Cod {\\\\this}}))', 'i : CoverMap X Y', 'X : CoverSpace', 'T : CoverSpace', 'this : CoverMap Y Z {\\n  | func => \\\\lam (y : E {Dom {\\\\this}}) => (lift-contr {i.Dom} {i.Cod} {Z} {T} {p} pc ph {i} {f} {g} id sq y).1\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}']<<<break>>>['| <=<-right {U V W : E {A}} (U <= V) (R V W) : R U W', 'inP A', '| Cod : BaseSet', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\lemma <=<-inter \\\\hlevels  {X : CoverSpace} {x : X.E} {U : Set X.E} (_ : single {X.E} x <=< U) :\\n  TruncP (\\\\Sigma (V : Set X.E) (single {X.E} x <=< V) (V <=< U)) ', '\\\\lemma <=<_<= \\\\hlevels  {X : PrecoverSpace} {V U : Set X.E} (_ : V <=< U) : V <= U ', '\\\\lemma <=<-cont \\\\hlevels  {X : PrecoverSpace} {Y : CoverSpace} {f : ContMap X Y} {x : X.E} {U : Set Y.E} (_ : single {Y.E} (f.func x) <=< U) :\\n  single {X.E} x <=< f.func ^-1 U ', '\\\\lemma relativelyCompleteAndSeparated \\\\hlevels  {X Y : CoverSpace} (p : X.E -> Y.E) (_ : IsRelativelyComplete {X} {Y} p) (_ : IsRelativelyHausdorff {X} {Y} p)\\n  (F1 : CauchyFilter X) {y : Y.E} (_ : F {pointCF {Y} y} \u2286 F {SetFilter-map {X.E} {Y.E} p F1}) :\\n  Contr (\\\\Sigma (x : X.E) (p x = y) (F {pointCF {X} x} \u2286 F.F)) ', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '\\\\lemma neighborhood \\\\hlevels  {X Y : CoverSpace} {p : X.E -> Y.E} {pc : IsRelativelyComplete {X} {Y} p} {ph : IsRelativelyHausdorff {X} {Y} p}\\n  {y : Y.E} (F1 : CauchyFilter X) {ys : F {pointCF {Y} y} \u2286 F {SetFilter-map {X.E} {Y.E} p F1}} {V U : Set X.E}\\n  (_ : V <=< U) (_ : F.F V) : single {X.E} center.1 <=< U ', '\\\\lemma single_<= \\\\hlevels  {X : \\\\Set} {a : X} {U : Set X} (_ : U a) : single {X} a \u2286 U ', '| center : A', '| F (E {A}) : \\\\Prop', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma filter-lift \\\\hlevels  {X Y Z : CoverSpace} {i : CoverMap X Y} {f : CauchyMap X Z} (id : IsDenseEmbedding {i}) {y : Y.E} : CauchyFilter f.Cod\\n  (\\\\lam (V : E {A {SetFilter-map {E {f.Dom}} {E {f.Cod}} f.func (dense-filter-lift {X} {Y} i id (pointCF {Y} y))}}) =>\\n    F {dense-filter-lift {X} {Y} i id (pointCF {Y} y)} (f.func ^-1 V)) ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func (E {Dom}) : E {Cod}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\func lift-contr \\\\hlevels  {X Y Z T : CoverSpace} {p : Z.E -> T.E} (pc : IsRelativelyComplete {Z} {T} p) (ph : IsRelativelyHausdorff {Z} {T} p)\\n  {i : CoverMap X Y} {f : CauchyMap X Z} {g : ContMap Y T} (id : IsDenseEmbedding {i})\\n  (sq : \\\\Pi (x : X.E) -> g.func (i.func x) = p (f.func x)) (y : Y.E) :\\n  \\\\Sigma (z : Z.E) (p z = g.func y) (F {pointCF {Z} z} \u2286 F {filter-lift {i.Dom} {i.Cod} {f.Cod} {i} {f} id {y}}) => center', '| Dom : BaseSet', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}']<<<break>>>\\Pi {V' : Set Y.E} -> TruncP (\\Sigma (U : Set Y.E)\n  (TruncP (\\Sigma (U1 : Set X.E) (TruncP (\\Sigma (V : Set Z.E) (TruncP (\\Sigma (U : Set Z.E) (D U) (V <=< U))) (U1 = f.func ^-1 V)))\n    (i.func ^-1 U \u2286 U1))) (V' <=< U)) ->\n  TruncP (\\Sigma (V : Set Y.E) (TruncP (\\Sigma (V1 : Set Z.E) (D V1) (V = func {\\this} ^-1 V1))) (V' \u2286 V))", "completion": "\\lam {V'} p0 => (\\case \\elim p0 \\with {\n  | inP (V, inP (U, inP (W', inP (W, DW, W'<=<W), p), q), V'<=<V) => inP (_, inP (W, DW, idp),\n    \\lam {y} V'y => <=<_<= (neighborhood (filter-lift id) W'<=<W (\\case <=<-inter (<=<-right (single_<= V'y) V'<=<V) \\with {\n      | inP (V'', y<=<V'', V''<=<V) => inP $ later (V'', V, rewrite p in q, V''<=<V, y<=<V'')\n    })) idp)\n})"}
{"prompt": "[]<<<break>>>['apply (f : S.Symb s) (DArray {len {S.domain {s} f}} (\\\\lam (j : Fin (len {S.domain {s} f})) => Term {S} V (at {S.domain {s} f} j)))', '\\\\lemma SigmaFin (S : FinSet) (Q : S.E -> FinSet) : FinSet (\\\\Sigma (i : S.E) (E {Q i})) {\\n  | finCard => FinSum {NatSemiring} {S} (\\\\lam (i : S.E) => finCard {Q i})\\n} ', 'var (V s)', '| Sort : \\\\Set', 'inP A', '\\\\data Formula \\\\hlevels  {S : Signature} (S.Sort -> \\\\Set) \\n  | equality {s : S.Sort} (Term {S} V s) (Term {S} V s)\\n  | predicate (P : S.PredSymb) (DArray {len {S.predDomain P}} (\\\\lam (j : Fin (len {S.predDomain P})) => Term {S} V (at {S.predDomain P} j)))', '\\\\func Sequent {S : Signature} : \\\\1-Type \\n  => \\\\Sigma (V : S.Sort -> \\\\Set) (FinSet (\\\\Sigma (s : S.Sort) (V s))) (Array (Formula {S} V)) (Formula {S} V)', '\\\\func coe (A : I -> \\\\Type) (a : A left) (i : I) : A i ', '\\\\instance theory : Theory {\\n  | Sort => \\\\Sigma\\n  | Symb => \\\\lam (_ : Sort {\\\\this}) => Fin 5\\n  | domain => \\\\lam {s : Sort {\\\\this}} (p0 : Symb {\\\\this} s) => (\\\\case p0 \\\\with {\\n    | zero => nil\\n    | suc zero => nil\\n    | suc (suc zero) => () :: () :: nil\\n    | suc (suc (suc zero)) => () :: () :: nil\\n    | suc (suc (suc (suc zero))) => () :: nil\\n  })\\n  | PredSymb => Empty\\n  | predDomain => absurd {Array (Sort {\\\\this})}\\n  | axioms => arraySubset {Sequent} ((\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n    | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n  }) (SigmaFin UnitFin (\\\\lam (_ : E) => UnitFin)) right} {}, nil,\\n    equality {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 2\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 0} 0 nil :: var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 1} () :: nil))\\n      (var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} ())) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 3, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n    }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 3)) right} {}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()}\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 2 (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 0} 2\\n        (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 2} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 2} 1} 1 :: nil) :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 1} 2 :: nil))\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 2\\n        (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 0} 0 :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 1} 2\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 2} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 2} 1} 2 :: nil) :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n    }) (SigmaFin UnitFin (\\\\lam (_ : E) => UnitFin)) right} {}, nil,\\n      equality {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 3\\n        (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 3} 0} 1 nil :: var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 3} 1} () :: nil))\\n        (var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} ())) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 3, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n      }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 3)) right} {}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()}\\n        (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 3 (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 0} 3\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 0} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 0} 3} 1} 1 :: nil) :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 1} 2 :: nil))\\n        (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 3\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 0} 0 :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 1} 3\\n            (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 3} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 3} 1} 2 :: nil) :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 2, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n      }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 2)) right} {}, nil,\\n        equality {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 2\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 1} 1 :: nil))\\n          (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 2\\n            (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 1} 0 :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 2, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n          | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n        }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 2)) right} {}, nil,\\n          equality {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 3\\n            (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 1} 1 :: nil))\\n            (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 3\\n              (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 1} 0 :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n          }) (SigmaFin UnitFin (\\\\lam (_ : E) => UnitFin)) right} {}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()}\\n            (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 2 (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 0} 4\\n              (var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 4} 0} () :: nil) :: var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 1} () :: nil))\\n            (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 0 nil)) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 3, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n          }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 3)) right} {}, nil,\\n            equality {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 3\\n              (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 0} 0 :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 1} 2\\n                (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 2} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 2} 1} 2 :: nil) :: nil))\\n              (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 2 (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 0} 3\\n                (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 3} 1} 1 :: nil) :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 1} 3\\n                (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 3} 1} 2 :: nil) :: nil))) :: nil)\\n} => \\\\new Theory', '\\\\data Term \\\\hlevels  {S : TermSig} (S.Sort -> \\\\Set) S.Sort \\n  | var (V s)\\n  | apply (f : S.Symb s) (DArray {len {S.domain {s} f}} (\\\\lam (j : Fin (len {S.domain {s} f})) => Term {S} V (at {S.domain {s} f} j)))', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '| domain {s : Sort} (Symb s) : Array Sort', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\func finSet {A : FinSet} : FinSet => A', '| at (j : Fin len) : A j', '| E : \\\\Set', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', 'equality {s : S.Sort} (Term {S} V s) (Term {S} V s)', '\\\\instance UnitFin : FinSet (\\\\Sigma) {\\n  | finCard => 1\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case finEq {\\\\this} \\\\with {\\n    | inP e => \\\\case decideEq (e.ret x) (e.ret y) \\\\with {\\n      | yes q => yes {x = y} (isInj {symQEquiv {Fin (finCard {\\\\this})} {E {\\\\this}} (fromEquiv e)} {x} {y} q)\\n      | no q => no {x = y} (\\\\lam (p : x = y) => q (pmap {E {\\\\this}} {Fin (finCard {\\\\this})} e.ret {x} {y} p))\\n    }\\n  })\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '| finCard : Nat', 'right', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\type arraySubset {X : \\\\Type} (l : Array X) (x : X) : \\\\Prop => TruncP (\\\\Sigma (j : Fin l.len) (l !! j = x))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\class FinSet \\\\extends KFinSet, Choice, DecSet {\\n  | finEq : TruncP (Equiv {Fin finCard} {E})\\n  | #-comparison => \\\\lam (x : E) (y : E) (z : E) (x/=z : x # z) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => byRight {x # y} {y # z} (\\\\lam (y=z : y = z) => x/=z (x=y *> y=z))\\n    | no x/=y => byLeft {x # y} {y # z} x/=y\\n  })\\n  | #-symmetric => /=-sym {E}\\n  | # => (/=)\\n  | nonEqualApart => \\\\lam {x y : E} (p : x /= y) => p\\n  | tightness => \\\\lam {x : E} {y : E} (x//=y : Not (x # y)) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => x=y\\n    | no x/=y => absurd {x = y} (x//=y x/=y)\\n  })\\n  | finSurj => map {Equiv {Fin finCard} {E}} {\\\\Sigma (f : Fin finCard -> E) (IsSurj {Fin finCard} {E} f)} finEq\\n    (\\\\lam (e : Equiv {Fin finCard} {E}) => (e.f, isSurjMap {ESEquiv.fromEquiv e}))\\n  | #-irreflexive => \\\\lam {x : E} (p : x # x) => p (idp {E} {x})\\n  | choice => \\\\lam {B : E -> \\\\Set} => (\\\\scase finEq \\\\with {\\n    | inP e => transport {\\\\Type} (\\\\lam (x : \\\\Type) => \\\\Pi {A : x -> \\\\Set} -> (\\\\Pi (i : x) -> TruncP (A i)) -> TruncP (\\\\Pi (i : x) -> A i))\\n      {Fin finCard} {E} (Equiv-to-= {Fin finCard} {E} e) (finiteAC {finCard}) {B}\\n  })\\n}', '\\\\lemma FinSum_replicate {this : Semiring} {A : FinSet} {x : E} : FinSum {A} (\\\\lam (_ : A.E) => x) = natCoef A.finCard * x ']<<<break>>>arraySubset {Sequent {theory}} ((\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n  | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n}) (SigmaFin UnitFin (\\lam (_ : E) => UnitFin)) right} {}, nil,\n  equality {theory} {\\lam (_ : Sort) => \\Sigma} {()} (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 2\n    (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 0} 0 nil :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 1} () :: nil))\n    (var {theory} {\\lam (_ : Sort) => \\Sigma} {()} ())) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n    | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n  }) (SigmaFin UnitFin (\\lam (_ : E) => FinFin 3)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => Fin 3} {()}\n    (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 2\n      (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 2} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 2} 1} 1 :: nil) :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 2 :: nil))\n    (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2\n      (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 2\n        (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 2} 1} 2 :: nil) :: nil))) :: (\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n    | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n  }) (SigmaFin UnitFin (\\lam (_ : E) => UnitFin)) right} {}, nil,\n    equality {theory} {\\lam (_ : Sort) => \\Sigma} {()} (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 3\n      (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 3} 0} 1 nil :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 3} 1} () :: nil))\n      (var {theory} {\\lam (_ : Sort) => \\Sigma} {()} ())) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n    }) (SigmaFin UnitFin (\\lam (_ : E) => FinFin 3)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => Fin 3} {()}\n      (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 3\n        (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 0} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 0} 3} 1} 1 :: nil) :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 2 :: nil))\n      (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3\n        (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 3\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 3} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 3} 1} 2 :: nil) :: nil))) :: (\\lam (_ : Sort) => Fin 2, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n    }) (SigmaFin UnitFin (\\lam (_ : E) => FinFin 2)) right} {}, nil,\n      equality {theory} {\\lam (_ : Sort) => Fin 2} {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n        (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 1 :: nil))\n        (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n          (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 0 :: nil))) :: (\\lam (_ : Sort) => Fin 2, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n      }) (SigmaFin UnitFin (\\lam (_ : E) => FinFin 2)) right} {}, nil,\n        equality {theory} {\\lam (_ : Sort) => Fin 2} {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 3\n          (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 1} 1 :: nil))\n          (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 3\n            (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 1} 0 :: nil))) :: (\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n          | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n        }) (SigmaFin UnitFin (\\lam (_ : E) => UnitFin)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => \\Sigma} {()}\n          (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 2 (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 0} 4\n            (var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {at {domain {()} 2} 0} 4} 0} () :: nil) :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 1} () :: nil))\n          (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 0 nil)) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n          | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n        }) (SigmaFin UnitFin (\\lam (_ : E) => FinFin 3)) right} {}, nil,\n          equality {theory} {\\lam (_ : Sort) => Fin 3} {()} (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3\n            (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 2\n              (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 2} 1} 2 :: nil) :: nil))\n            (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 3\n              (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 3} 1} 1 :: nil) :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 3\n              (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 3} 1} 2 :: nil) :: nil))) :: nil)\n  (((\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (\\Sigma)) {\n    | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n  }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => UnitFin)) right} {}, nil,\n    equality {theory} {\\lam (_ : Sort) => \\Sigma} {()} (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 2\n      (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 0} 0 nil :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 1} () :: nil))\n      (var {theory} {\\lam (_ : Sort) => \\Sigma} {()} ())) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 3)) {\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n    }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 3)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => Fin 3} {()}\n      (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 2\n        (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 2} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 2} 1} 1 :: nil) :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 2 :: nil))\n      (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2\n        (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 2\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 2} 1} 2 :: nil) :: nil))) :: (\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (\\Sigma)) {\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n    }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => UnitFin)) right} {}, nil,\n      equality {theory} {\\lam (_ : Sort) => \\Sigma} {()} (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 3\n        (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 3} 0} 1 nil :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 3} 1} () :: nil))\n        (var {theory} {\\lam (_ : Sort) => \\Sigma} {()} ())) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 3)) {\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n      }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 3)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => Fin 3} {()}\n        (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 3\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 0} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 0} 3} 1} 1 :: nil) :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 2 :: nil))\n        (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3\n          (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 3\n            (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 3} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 3} 1} 2 :: nil) :: nil))) :: (\\lam (_ : Sort) => Fin 2, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 2)) {\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n      }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 2)) right} {}, nil,\n        equality {theory} {\\lam (_ : Sort) => Fin 2} {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n          (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 1 :: nil))\n          (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 2\n            (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 2} 1} 0 :: nil))) :: (\\lam (_ : Sort) => Fin 2, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 2)) {\n          | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n        }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 2)) right} {}, nil,\n          equality {theory} {\\lam (_ : Sort) => Fin 2} {()} (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 3\n            (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 1} 1 :: nil))\n            (apply {theory} {\\lam (_ : Sort) => Fin 2} {()} 3\n              (var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 2} {at {domain {()} 3} 1} 0 :: nil))) :: (\\lam (_ : Sort) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (\\Sigma)) {\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n          }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => UnitFin)) right} {}, nil, equality {theory} {\\lam (_ : Sort) => \\Sigma} {()}\n            (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 2 (apply {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 0} 4\n              (var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {at {domain {()} 2} 0} 4} 0} () :: nil) :: var {theory} {\\lam (_ : Sort) => \\Sigma} {at {domain {()} 2} 1} () :: nil))\n            (apply {theory} {\\lam (_ : Sort) => \\Sigma} {()} 0 nil)) :: (\\lam (_ : Sort) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma (\\Sigma) (Fin 3)) {\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n          }) (SigmaFin UnitFin (\\lam (_ : \\Sigma) => FinFin 3)) right} {}, nil,\n            equality {theory} {\\lam (_ : Sort) => Fin 3} {()} (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 3\n              (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 0} 0 :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 3} 1} 2\n                (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 2} 0} 1 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 3} 1} 2} 1} 2 :: nil) :: nil))\n              (apply {theory} {\\lam (_ : Sort) => Fin 3} {()} 2 (apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 0} 3\n                (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 0} 3} 1} 1 :: nil) :: apply {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {()} 2} 1} 3\n                (var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 3} 0} 0 :: var {theory} {\\lam (_ : Sort) => Fin 3} {at {domain {at {domain {()} 2} 1} 3} 1} 2 :: nil) :: nil))) :: nil) !! 0)", "completion": "inP (0, idp)"}
{"prompt": "[\"z|z' : LDiv {M} z z'\", 'M : CMonoid', \"z' : M.E\", \"this : GCD {M1} x y z' (trans {M1} {z'} {z} {x} z'|z g.res|val1) (trans {M1} {z'} {z} {y} z'|z g.res|val2)\\n  (\\\\lam (d : E {M {\\\\this}}) (d|x : LDiv {M {\\\\this}} d (val1 {\\\\this})) (d|y : LDiv {M {\\\\this}} d (val2 {\\\\this})) =>\\n    trans {M1} {d} {z} {z'} (g.res-univ d d|x d|y) z|z')\", 'g : GCD {M} x y z', 'z : M.E']<<<break>>>['| val1 : E {M}', '| res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res', '| \\\\infixl 7 * E E : E', '| val2 : E {M}', '| E : \\\\Set', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '| inv : E {M}', '| M : CMonoid', '\\\\lemma trans \\\\hlevels  {M : Monoid} {x y z : M.E} (x|y : LDiv {M} x y) (y|z : LDiv {M} y z) : LDiv {M} x z (x|y.inv M.* y|z.inv) ']<<<break>>>\\Pi (d : E {M {\\this}}) -> \\Pi (d|x : LDiv {M {\\this}} d (val1 {\\this})) ->\n  \\Pi (d|y : LDiv {M {\\this}} d (val2 {\\this})) -> LDiv {M1} d z' (inv {g.res-univ d d|x d|y} M.* z|z'.inv)", "completion": "\\lam d d|x d|y => trans (res-univ {g} d d|x d|y) z|z'"}
{"prompt": "['fi : at {isIntegralExt f :: (\\\\Pi (j : Fin l.len) -> isIntegral f (l !! j)) :: IsFinitelyGenerated {homLModule f} :: nil} 0', 'l : Array E.E', 'j : Fin l.len', 'f : RingHom R E']<<<break>>>['| zro : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '| at (j : Fin len) : A j', '\\\\func isMonic \\\\hlevels  {R : Ring} (p : Poly R) : \\\\Prop => TruncP (\\\\Sigma (n : Nat) (degree<= {R} p n) (polyCoef {R} p n = R.ide))', '| E : \\\\Set', '| Cod : BaseSet', '\\\\func polyEval \\\\hlevels  {R3 : Ring} (_ : Poly R3) (_ : R.E) : R.E \\n  | {R}, pzero, a => R.zro\\n  | {R}, padd p e, a => polyEval {R} p a R.* a R.+ e\\n  | {R}, peq i, a => (R.zro-right {R.zro R.* a} *> R.zro_*-left {a}) @ i', '\\\\func polyMap \\\\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \\n  | f, pzero => pzero {f.Cod}\\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\\n  | f, peq i => transportInv\\n    {E {f.Cod}} (\\\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\\n      f.func-zro (path (peq {f.Cod})) @ i', '| Dom : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (p : Poly f.Dom) (isMonic {f.Dom} p) (polyEval {f.Cod} (polyMap f p) (l.at j) = zro {f.Cod}))", "completion": "fi (l j)"}
{"prompt": "['l : Array (\\\\Sigma R.E E)', 'J : \\\\Set', \"r : l ~ l'\", \"l' : Array (\\\\Sigma R.E E)\", 'R : CRing', 'd : Nat', \"p0 : TruncP (\\\\Sigma (l'1 : Array (\\\\Sigma R.E E)) (inMS~ {PermSet J} {R} l' = inMS~ {PermSet J} {R} l'1)\\n  (\\\\Pi (j : Fin l'.len) -> permSet-length {J} (l'1 !! j).2 < d))\"]<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\type PermSet \\\\hlevels  (A : \\\\Set) : \\\\Set => Quotient {Array A} (EPerm {A})', '\\\\func inMS~ \\\\hlevels  {M : \\\\Set} {R : AddMonoid} (l : Array (\\\\Sigma R.E M)) : Quotient {Array (\\\\Sigma R.E M)} (~) \\n  => in~ {Array (\\\\Sigma R.E M)} {(~)} l', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', \"\\\\func permSet-length \\\\hlevels  {A1 : \\\\Set} (_ : PermSet A1) : Nat \\n  | {A}, in~ l => l.len\\n  | {A}, ~-equiv l l' e i => EPerm_len {A} {l} {l'} e @ i\", '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func ~-pequiv {A : \\\\Type} {R : A -> A -> \\\\Type} {x y : A} (r : R x y) : in~ {A} {R} x = in~ {A} {R} y => path (~-equiv {A} {R} x y r)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", 'in~ A']<<<break>>>TruncP (\\Sigma (l' : Array (\\Sigma R.E (PermSet J))) (inMS~ {PermSet J} {R} l = inMS~ {PermSet J} {R} l')\n  (\\Pi (j : Fin l'.len) -> permSet-length {J} (l' !! j).2 < d))", "completion": "map p0 (\\lam s => (s.1, ~-pequiv r *> s.2, s.3))"}
{"prompt": "['D : Set (Set X.E)', 'RB : RatherBelow {SetLattice X.E}', 'E : Set X.E -> Set (Set X.E)', \"DU' : D U'\", 'A : Set (Set X.E) -> \\\\Prop', 'CE : \\\\Pi {U : Set X.E} -> D U -> Closure {X.E} A (E1 U)', 'U : Set X.E', \"RUU' : RB.R U U'\", \"U' : Set X.E\", 'AS : \\\\Pi {C : Set (Set X.E)} -> A C -> Closure {X.E} A (\\\\lam (V : Set X.E) => TruncP (\\\\Sigma (U : Set X.E) (C U) (RB.R V U)))', 'X : PrecoverSpace']<<<break>>>['\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', '| R (E {A}) (E {A}) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| E : \\\\Set', '\\\\lemma closure-regular \\\\hlevels  {X : PrecoverSpace} (RB : RatherBelow {SetLattice X.E}) {A : Set (Set X.E) -> \\\\Prop}\\n  (_ : \\\\Pi {C : Set (Set X.E)} -> A C -> Closure {X.E} A (\\\\lam (V : Set X.E) => TruncP (\\\\Sigma (U : Set X.E) (C U) (RB.R V U))))\\n  {C : Set (Set X.E)} (_ : Closure {X.E} A C) :\\n  Closure {X.E} A (\\\\lam (V : Set X.E) => TruncP (\\\\Sigma (U : Set X.E) (C U) (RB.R V U))) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma closure-subset \\\\hlevels  {X : \\\\Set} {A : Set (Set X) -> \\\\Prop} {C D : Set (Set X)} (_ : Closure {X} A D) (_ : D \u2286 C) : Closure {X} A C ']<<<break>>>Closure {X.E} A (\\lam (V : Set X.E) => TruncP (\\Sigma (U' : Set X.E) (D U') (RB.R U U') (V' : Set X.E) (E1 U' V') (RB.R V V')))", "completion": "closure-subset (closure-regular RB AS (CE DU')) (\\lam p0 => (\\case \\elim p0 \\with {\n  | inP (V', EV', RVV') => inP (U', DU', RUU', V', EV', RVV')\n}))"}
{"prompt": "['this : SplittingFieldData', 'rfd : RootFieldData P k p', 'k : DiscreteField', 'p : Poly k', 'Sp : S {k} p']<<<break>>>[\"| S-hom {K K' : DiscreteField} (f : RingHom K K') {p : Poly K} (S {K} p) : S {K'} (polyMap f p)\", '| RootField : DiscreteField', '\\\\func polyMap \\\\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \\n  | f, pzero => pzero {f.Cod}\\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\\n  | f, peq i => transportInv\\n    {E {f.Cod}} (\\\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\\n      f.func-zro (path (peq {f.Cod})) @ i', '| S {K : DiscreteField} (Poly K) : \\\\Prop', '| rootFieldHom : RingHom k RootField']<<<break>>>S {rfd.RootField} (polyMap rfd.rootFieldHom p)", "completion": "S-hom {this} (rootFieldHom {rfd}) Sp"}
{"prompt": "['z-y-sq : y <= z', 'this : StoneC*Algebra', 'z : E', 'x : E', 'y-x-sq : x <= y', 'y : E']<<<break>>>['| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| c*-sum {a b : E} : norm (a * a) <= norm (a * a + b * b)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma square-sum \\\\hlevels  {X : RealBanachAlgebra} (_ : \\\\Pi {a b : X.E} -> X.norm (a X.* a) <= X.norm (a X.* a X.+ b X.* b)) {x y : X.E}\\n  (_ : IsSquare {X} x) (_ : IsSquare {X} y) : IsSquare {X} (x X.+ y) ', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (y1 : E) (y1 * y1 = z - y + (y - x)))", "completion": "square-sum (c*-sum {this}) z-y-sq y-x-sq"}
{"prompt": "['X : FramePres']<<<break>>>['\\\\class Locale \\\\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\\\hlevels  {\\n  | Join-ldistr>= {J : \\\\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\\\lam (j : J) => e \u2227 f j)\\n  | basicCover-stable => \\\\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\\\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\\n    meet-univ {x} {Join {J} (\\\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\\\lam (j : J) => (g j).1} {x}\\n  | ldistr>= => \\\\lam {x : E} {y : E} {z : E} => (\\n    \\\\have t => path (\\\\lam (i : I) (b : Bool) => (\\\\case b \\\\with {\\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\\n          }) @ i)\\n    \\\\in transportInv\\n        {Bool -> E} (\\\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\\n          {\\\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\\\lam (b : Bool) => x \u2227 if {E} b y z} t\\n          (Join-ldistr>= {Bool} {\\\\lam (p0 : Bool) => if {E} p0 y z} {x}))\\n  | Meet-cond => \\\\lam {J : \\\\Set} (j : J) {f : J -> E} =>\\n  Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n    {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)\\n  | join-left => \\\\lam {x : E} {y : E} => Join-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | join-right => \\\\lam {x : E} {y : E} => Join-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | Meet-univ => \\\\lam {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) =>\\n  Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n    {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  | join-univ => \\\\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\\n  Join-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n    | true => x<=z\\n    | false => y<=z\\n  }))\\n  | join => \\\\lam (x : E) (y : E) => Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)\\n  | Meet => \\\\lam {J : \\\\Set} (g : J -> E) =>\\n    Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)\\n  | isBasicCover => \\\\lam (x : Ob) {J : \\\\Set} (g : J -> Ob) => x <= Join {J} (\\\\lam (j : J) => (g j).1)\\n}', '\\\\func closure \\\\hlevels  {P : FramePres} {J : \\\\Set} (g : J -> P.E) : Opens P \\n=> (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g, \\\\lam (x : P.E) (c : SCover {P} x (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g)) =>\\n  cover-trans {P} {x} {J} {g} {\\\\Sigma (x : P.E) (Cover {P} x {J} g)} {\\\\lam (t : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => t.1} c (\\\\lam (p0 : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => p0.2))', '| conj E E : E', '\\\\func SCover \\\\hlevels  {this : FramePres} (x : E) (U : E -> \\\\Prop) : \\\\Prop \\n  => Cover x {\\\\Sigma (x : E) (U x)} (\\\\lam (t : \\\\Sigma (x : E) (U x)) => t.1)', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| E : \\\\Set', '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x']<<<break>>>Locale (Opens X) {\n  | <= => (<=)\n  | meet => \\lam (U : E {\\this}) (V : E {\\this}) =>\n    closure {X} {\\Sigma (a b : X.E) (U.1 a) (V.1 b)} (\\lam (t : \\Sigma (a b : X.E) (U.1 a) (V.1 b)) => X.conj t.1 t.2)\n  | top => (\\lam (_ : X.E) => \\Sigma, \\lam (e : X.E) (_ : SCover {X} e (\\lam (_ : X.E) => \\Sigma)) => ())\n  | Join => \\lam {J : \\Set} (f : J -> E {\\this}) =>\n    closure {X} {\\Sigma (j : J) (x : X.E) ((f j).1 x)} (\\lam (p0 : \\Sigma (j : J) (x : X.E) ((f j).1 x)) => p0.2)\n}", "completion": "PresentedFrame X"}
{"prompt": "['R : Ring', 'l : Nat', 'C : Matrix R.E k l', 'm : Nat', 'n : Nat', 'k : Nat', 'B : Matrix R.E m k', 'A : Matrix R.E n m']<<<break>>>['\\\\func product-gen \\\\hlevels  {R : Ring} {L : LModule R} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix L.E m k) : Matrix L.E n k \\n=> mkMatrix {L.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {L} (\\\\new Array L.E m (\\\\lam (j : Fin m) => at {at {M} i} j L.*c at {at {N} j} k)))', '\\\\lemma product-gen-assoc \\\\hlevels  {R : Ring} {M : LModule R} {n m k l : Nat} {A : Matrix R.E n m} {B : Matrix R.E m k} {C : Matrix M.E k l} :\\n  product-gen {R} {M} {n} {k} {l} (A product B) C = product-gen {R} {M} {n} {m} {l} A (product-gen {R} {M} {m} {k} {l} B C) ', '| E : \\\\Set', '\\\\func RingLModule \\\\hlevels  (R1 : Ring) : LModule R1 R.E {\\n  | zro => R.zro\\n  | + => (R.+)\\n  | negative => R.negative\\n  | *c => (R.*)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '\\\\func \\\\infixl 7 product \\\\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))']<<<break>>>product-gen {R} {RingLModule R} {n} {k} {l} (A product B) C = product-gen {R} {RingLModule R} {n} {m} {l} A (product-gen {R} {RingLModule R} {m} {k} {l} B C)", "completion": "product-gen-assoc {_} {RingLModule R}"}
{"prompt": "['R : ImpotentCRing', 'x : R.E', 'k : Nat', 'u : R.E', 'u=0 : u = R.zro', 'u|x^k : LDiv {R} u (pow {R} x k)']<<<break>>>['| zro : E', '\\\\lemma noNilpotent \\\\hlevels  {this : ReducedRing} {a : E} {n : Nat} (_ : pow a n = zro) : a = zro ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma ldiv=0 \\\\hlevels  {this : Semiring} {x y : E} (_ : LDiv x y) (_ : x = zro) : y = zro ', '| E : \\\\Set', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>x = R.zro", "completion": "noNilpotent {R} (ldiv=0 {R} u|x^k u=0)"}
{"prompt": "['this : AddGroup', 'y : Int', 'a : E', 'x : Int']<<<break>>>['\\\\lemma *i_ipow \\\\hlevels  {this : AddGroup} {x : Int} {a : E} : x *i a = ipow {toGroup this} a x ', '\\\\func toGroup \\\\hlevels  (G : AddGroup) : Group G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new Group {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | inverse-right => {?hidden}\\n}', '\\\\func ipow \\\\hlevels  {this2 : Group} (_ : E) (_ : Int) : E \\n  | {this}, a, pos n => pow a n\\n  | {this}, a, neg n => pow (inverse a) n', '\\\\func \\\\infixl 7 *i \\\\hlevels  {this2 : AddGroup} (_ : Int) (_ : E) : E \\n  | {this}, pos n, a => n *n a\\n  | {this}, neg n, a => n *n negative a', '| E : \\\\Set']<<<break>>>x *i ipow {toGroup this} a y = ipow {toGroup this} (ipow {toGroup this} a y) x", "completion": "*i_ipow {this}"}
{"prompt": "['X : \\\\Set', 'V : Set Y.E', 'U : Set X', 'f : X -> Y.E', 'p : U = f ^-1 V', 'SU : S U', 'Y : TopSpace', 'S : Set (Set (E {\\\\this}))', 'Vo : Y.isOpen V']<<<break>>>[\"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma Union-cond \\\\hlevels  {X : \\\\hType} {S : Set X -> \\\\hType} {U : Set X} (_ : S U) : U \u2286 Union {X} S ', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| isOpen (Set E) : \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func Union \\\\hlevels  {X : \\\\hType} (S : Set X -> \\\\hType) : Set X => \\\\lam (a : X) => TruncP (\\\\Sigma (U : Set X) (S U) (U a))', '| E : \\\\Set']<<<break>>>\\Sigma (Y.isOpen V) (f ^-1 V \u2286 Union {X} S)", "completion": "(Vo, rewriteI p $ Union-cond SU)"}
{"prompt": "['this : PrecoverMap']<<<break>>>['\\\\func PrecoverTransfer \\\\hlevels  {X : \\\\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', 'suc Nat', \"\\\\lemma cycle' \\\\plevels  \\\\hlevels  {n : Nat} {l : Array \\\\Prop (suc n)} (_ : DArray {suc n} (\\\\lam (i : Fin (suc n)) => l.at i -> l.at (suc i mod suc n))) : TFAE l \", '| isCauchy (Set (Set E)) : \\\\Prop', 'inP A', '| Cod : BaseSet', '| cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D', '| func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))', '\\\\lemma PrecoverTransfer-map \\\\hlevels  {X : \\\\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverMap (PrecoverTransfer {X} {Y} f) Y {\\n  | func => f\\n} ', '\\\\type TFAE \\\\plevels  \\\\hlevels  (l : Array \\\\Prop) : \\\\Prop => \\\\Pi (i j : Fin l.len) -> l.at i -> l.at j', '\\\\lemma PrecoverTransfer-char \\\\hlevels  {X Y : PrecoverSpace} {f : PrecoverMap X Y} {C : Set (Set X.E)} (_ : isCauchy C) : X.isCauchy C ', '| at (j : Fin len) : A j', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\class PrecoverSpace \\\\extends TopSpace \\\\hlevels  {\\n  | isCauchy (Set (Set E)) : \\\\Prop\\n  | cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))\\n  | cauchy-top : isCauchy (single {E -> \\\\Prop} top)\\n  | cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D\\n  | cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))\\n  | cauchy-open {S : Set E} : TopSpace.isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))\\n}', '| E : \\\\Set', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class PrecoverMap \\\\extends ContMap \\\\hlevels  {\\n  | func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))\\n}', '\\\\func IsEmbedding \\\\hlevels  {this : PrecoverMap} : \\\\Prop => \\\\Pi {C : Set (Set (E {Dom}))} -> isCauchy {Dom} C ->\\n  isCauchy {Cod} (\\\\lam (V : Set (E {Cod})) => TruncP (\\\\Sigma (U : Set (E {Dom})) (C U) (func ^-1 V \u2286 U)))', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma PrecoverSpace-ext \\\\hlevels  {X : \\\\Set} {S T : PrecoverSpace X} (_ : \\\\Pi {C : Set (Set X)} -> S.isCauchy C <-> T.isCauchy C) : S = T ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func \\\\infixl 8 mod \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n mod m', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>TFAE (IsEmbedding :: (\\Pi {X : PrecoverSpace (E {Dom})} -> PrecoverMap X Cod {\n  | func => func\n} -> \\Pi {C : Set (Set (E {Dom}))} -> isCauchy {Dom} C -> X.isCauchy C) :: (\\Pi {C : Set (Set (E {Dom}))} -> isCauchy {Dom} C -> isCauchy C) :: (\\new Dom {} = PrecoverTransfer {E {Dom}} {Cod} func) :: nil)", "completion": "cycle' (later (\\lam p f Cc => cauchy-refine (func-cover {f} $ p Cc) (\\lam p0 => (\\case \\elim p0 \\with {\n  | inP (V, inP (U', CU', p), q) => inP (U', CU', rewrite q p)\n})), \\lam f => f (PrecoverTransfer-map _),\n  \\lam f => PrecoverSpace-ext {_} {Dom {this}} {PrecoverTransfer (func {this})} (\\lam {C} => (f, PrecoverTransfer-char)),\n  \\lam p => unfolds $ rewrite p (\\lam Dc => Dc)))"}
{"prompt": "['this : Monoid', 'b : E', 'solver : SubstSolverModel E {\\n  | Term => MonoidSolverModel.Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => \\\\lam {n : Nat} (t : SolverModel.Term {\\\\this} n) => normalize-aux {n} t (nil {Fin n})\\n  | interpret => interpret\\n  | interpretNF => \\\\lam {n : Nat} => interpretNF {Fin n}\\n  | nfVar => \\\\lam {n : Nat} (v : Fin n) => v :: nil {Fin n}\\n  | >>= => \\\\lam {m : Nat} {n : Nat} => (>>=)\\n}', 'env : Array E 5', 'p : a * b = b * a', 'n : Nat', 'a : E']<<<break>>>['| len : Nat', '| M : \\\\Set', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma pow-comm1 \\\\hlevels  {this : Monoid} {a b : E} (_ : a * b = b * a) {n : Nat} : pow a n * b = b * pow a n ', 'suc Nat', '| interpretNF {n : Nat} (Fin n -> M) (NF n) : M', '\\\\func fcase {A : \\\\Type} {n : Nat} (_ : A) (_ : Fin n -> A) (_ : Fin (suc n)) : A \\n  | {A}, {n}, a, f, zero => a\\n  | {A}, {n}, a, f, suc j => f j', 'nil', '| \\\\infixl 2 >>= {m n : Nat} (NF m) (Fin m -> NF n) : NF n', '| NF Nat : \\\\Set', '\\\\infixl 7 :* (_ _ : Term n)', '| \\\\infixl 7 * E E : E', '| nfVar {n : Nat} (Fin n) : NF n', '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma apply-axiom \\\\hlevels  {this : SubstSolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpret {env.len} env.at t = interpret {env.len} env.at s) (pattern : NF (suc env.len)) :\\n  interpretNF {env.len} env.at (pattern >>= fcase {NF env.len} {env.len} (normalize {env.len} t) (nfVar {env.len})) = interpretNF {env.len} env.at (pattern >>= fcase {NF env.len} {env.len} (normalize {env.len} s) (nfVar {env.len})) ', '| normalize {n : Nat} (Term n) : NF n', '| E : \\\\Set', 'var (Fin n)', '\\\\infixr 5 :: A (List A)']<<<break>>>solver.interpretNF {env.len} env.at\n  (4 :: 0 :: 3 :: nil {Fin 6} solver.>>= fcase {solver.NF env.len} {env.len} (solver.normalize {env.len} (var {env.len} 4 :* var {env.len} 1)) (solver.nfVar {env.len})) = solver.interpretNF {env.len} env.at\n  (4 :: 0 :: 3 :: nil {Fin 6} solver.>>= fcase {solver.NF env.len} {env.len} (solver.normalize {env.len} (var {env.len} 1 :* var {env.len} 4)) (solver.nfVar {env.len}))", "completion": "apply-axiom {solver} env (var 4 :* var 1) (var 1 :* var 4) (pow-comm1 {b} {a} (inv {E} {a * b} {b * a} p) {n}) (4 :: 0 :: 3 :: nil)"}
{"prompt": "['x : Ob', 'z : Ob', 'this : PrecatWithBprod', 'y : Ob']<<<break>>>['| Hom Ob Ob : \\\\Set', '\\\\lemma pair-comp \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z w : Ob} {f : Hom x y} {g : Hom y z} {h : Hom y w} :\\n  pair {z} {w} {y} g h \u2218 f = pair {z} {w} {x} (g \u2218 f) (h \u2218 f) ', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\func proj2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 1) => proj {Bprod x y} 1', '| Bprod (x y : Ob) : Product {Fin 2} (at {x :: y :: nil})', '| apex : Ob {D}', '| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| id (X : Ob) : Hom X X', '\\\\func proj1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 0) => proj {Bprod x y} 0', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma pair-proj \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} :\\n  pair {x} {y} {apex {Bprod x y}} (proj1 {x} {y}) (proj2 {x} {y}) = id (apex {Bprod x y}) ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func pair \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : Hom z (apex {Bprod x y}) \\n=> tupleMap {Bprod x y} {z} (\\\\lam (p0 : J {Bprod x y}) => (\\\\case p0 \\\\with {\\n  | zero => f\\n  | suc zero => g\\n}))']<<<break>>>pair {x} {apex {Bprod y z}} {apex {Bprod x (apex {Bprod y z})}} (proj1 {x} {apex {Bprod y z}})\n  (pair {y} {z} {apex {Bprod x (apex {Bprod y z})}} (proj1 {y} {z} \u2218 proj2 {x} {apex {Bprod y z}})\n    (proj2 {y} {z} \u2218 proj2 {x} {apex {Bprod y z}})) = id (apex {Bprod x (apex {Bprod y z})})", "completion": "rewrite (inv (pair-comp {this})) (rewrite (pair-proj {this}) (rewrite (id-left {this}) (pair-proj {this})))"}
{"prompt": "['e : Equiv {Fin J.finCard} {J.E}', 'g : J.E -> E', 'this : LModule', 'J : FinSet', 'gb : IsBasisSet {J.E} g']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\type IsBasis \\\\hlevels  {this : LModule} (l : Array E) : \\\\Prop => \\\\Sigma (IsIndependent l) (IsGenerated l)', '| f A : B', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| finCard : Nat', '\\\\lemma IsBasis<->IsBasisSet \\\\hlevels  {this : LModule} {l : Array E} : IsBasis l <-> IsBasisSet {Fin l.len} l.at ', '\\\\lemma IsBasisSet-equiv \\\\hlevels  {this : LModule} {J K : \\\\Set} (e : Equiv {J} {K}) {g : K -> E} (_ : IsBasisSet {K} g) :\\n  IsBasisSet {J} (\\\\lam (j : J) => g (e.f j)) ']<<<break>>>IsBasis (\\new Array E J.finCard (\\lam (j : Fin J.finCard) => g (e.f j)))", "completion": "(IsBasis<->IsBasisSet {this}).2 (IsBasisSet-equiv {this} e gb)"}
{"prompt": "['A : StoneC*PseudoAlgebra', 'this : StoneC*Algebra (\\\\Sigma Real A.E) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | cauchy-open => {?hidden}\\n  | isUniform => isUniform\\n  | uniform-cauchy => {?hidden}\\n  | dist => ExPseudoNormedAbGroup.dist\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro => (zro, zro)\\n  | + => \\\\lam (s : E) (t : E) => (s.1 AddMonoid.+ t.1, s.2 AddMonoid.+ t.2)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => \\\\lam (p0 : E) => (negative p0.1, negative p0.2)\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm => UnitC*Algebra.norm {A}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | norm-double => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isComplete => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | * => \\\\lam (p0 : E) (p1 : E) => (p0.1 Semigroup.* p1.1, p0.1 *c p1.2 AddMonoid.+ p1.1 *c p0.2 AddMonoid.+ p0.2 Semigroup.* p1.2)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | norm_*_<= => {?hidden}\\n  | ide => (ide, zro)\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl {UnitAlgebra RealField (toRealAlgebra {A})}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | c*-sum => {?hidden}\\n  | c*-square => {?hidden}\\n  | norm_ide_<= => {?hidden}\\n}']<<<break>>>['\\\\lemma *-comm {x y : Real} : x * y = y * x ', '\\\\func interpret {G3 : Group} {n2 : Nat} (_ : Fin n2 -> G.E) (_ : Term n2) : G.E \\n  | {G}, {n}, env, var x => env x\\n  | {G}, {n}, env, :ide => G.ide\\n  | {G}, {n}, env, :inverse t => G.inverse (interpret {G} {n} env t)\\n  | {G}, {n}, env, t :* s => interpret {G} {n} env t G.* interpret {G} {n} env s', ':inverse (Term n)', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func normalize \\\\plevels  \\\\hlevels  {n4 : Nat} (_ : Term n4) : Array Int n4 \\n  | {n}, var v => singleAt {Int} {n} v (pos 1) (pos 0)\\n  | {n}, :ide => replicate {Int} n (pos 0)\\n  | {n}, :inverse t => map {Int} {Int} negative (normalize {n} t)\\n  | {n}, t :* s => mkArray {Int} {n} (\\\\lam (j : Fin n) => at {normalize {n} t} j + at {normalize {n} s} j)', '| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', '\\\\lemma apply-axioms \\\\hlevels  {A : AbGroup} {n : Nat} (env : Array A.E n)\\n  (l : Array (\\\\Sigma Int (t s : Term env.len) (interpret {toCGroup A} {n} env.at t = interpret {toCGroup A} {n} env.at s)))\\n  (right : Array Int env.len) :\\ninterpretNF {toCGroup A} {n} env.at (mkArray {Int} {n} (\\\\lam (j : Fin n) => BigSum {IntRing}\\n  (\\\\new Array Int l.len (\\\\lam (i : Fin l.len) => (l.at i).1 * (at {normalize {n} (l.at i).2} j - at {normalize {n} (l.at i).3} j))) + right.at j)) = interpretNF {toCGroup A} {n} env.at right ', '| at (j : Fin len) : A j', '| E : \\\\Set', 'var (Fin n)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\infixl 7 :* (_ _ : Term n)', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'neg Nat  {\\n  | 0 => pos 0\\n}', '\\\\infixl 7 *r \\\\hlevels  {this : RealBanachSpace} (r : Real) (a : E) : E => func {lift} (r, a)', '\\\\lemma terms-equality \\\\hlevels  {A : AbGroup} (env : Array A.E) (t s : Term env.len)\\n  (_ : interpretNF {toCGroup A} {env.len} env.at (normalize {env.len} (t :* :inverse {env.len} s)) = A.zro) :\\n  interpret {toCGroup A} {env.len} env.at t = interpret {toCGroup A} {env.len} env.at s ', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', 'pos Nat', '| zro : E', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data Term \\\\plevels  \\\\hlevels  Nat \\n  | var (Fin n)\\n  | :ide\\n  | :inverse (Term n)\\n  | \\\\infixl 7 :* (_ _ : Term n)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\func interpretNF \\\\hlevels  {G : CGroup} {n : Nat} (env : Fin n -> G.E) (l : Array Int n) : G.E \\n  => sBigProd {G} (toArray {G} l (\\\\new Array G.E l.len env))']<<<break>>>\\Pi {x : E {\\this}} -> \\Pi {y : E {\\this}} -> x * y = y * x", "completion": "\\lam {x} {y} => ext (*-comm, abGroup $ toZero {A} (*-comm {A}))"}
{"prompt": "['Y : TopSpace', 'f : ContMap X Y', \"X' : TopSpace\", 'X : TopSpace']<<<break>>>['\\\\class ContMap \\\\extends SetHom \\\\hlevels  {\\n  | func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\func proj1 \\\\hlevels  {X Y : TopSpace} : ContMap (X \u2a2f Y) X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\instance TopSpaceHasProduct \\\\hlevels  : HasProduct TopSpace {\\n  | Product => ProductTopSpace\\n} => \\\\new HasProduct', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : TopSpace} (g : ContMap Y Z) (f : ContMap X Y) : ContMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}']<<<break>>>ContMap (X \u2a2f X') Y {\n  | func => \\lam (x : E {Dom {\\this}}) => func {f} (func {proj1 {X} {X'}} x)\n}", "completion": "f \u2218 proj1"}
{"prompt": "['a : E {Dom {\\\\this}}', 'U : Set X.E', 'u : (\u2227) (\\\\lam (x1 : R.E) =>\\n  U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} (a X.+ b)))} x1))\\n  (\\\\lam (x1 : R.E) =>\\n    U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1))\\n  h', 'u3 : \\\\Pi {h : R.E} -> U (x.1 X.+ h X.*c (a X.+ b)) -> U (x.1 X.+ h X.*c a X.+ h X.*c b)', 'X : TopLModule R', 'x : Total {X.E} U', 'f : Total {X.E} U -> Y.E', 'h : R.E', 'Y : HausdorffTopLModule R', 'b : E {Dom {\\\\this}}']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| \\\\infixl 7 *c (E {R}) E : E', '| zro-right {x : E} : x + zro = x', '| E : \\\\Set']<<<break>>>f (x.1 X.+ h X.*c a X.+ h X.*c b, u3 {h} u.1) Y.+ Y.zro = f (x.1 X.+ h X.*c a X.+ h X.*c b, u3 {h} u.1)", "completion": "zro-right {_} {f (x.1 X.+ h X.*c a X.+ h X.*c b, u3 {h} u.1)}"}
{"prompt": "['null : fromRat (fromInt (pos j)) - (x - a) * fromRat (fromInt (pos n)) * /b-a < ide', 'p : (x + negative a) * fromRat (fromInt (pos n)) * pinv {RealField} (b - a) {?hidden} <= fromRat (fromInt (pos n))', 'a : Real', '/b-a : E', 'x : Real', 'n : Nat', 'j : Nat']<<<break>>>['true', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', 'LessOrEquals', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', '\\\\infixl 6 + \\\\hlevels  (x y : Real) : Real => \\\\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>fromRat (fromInt (pos j)) < fromRat (fromInt (pos n)) + fromRat ide", "completion": "linarith (abs>=id {RealAbGroup} <\u2218r d)"}
{"prompt": "['e>=0 : zro <= e', 'e : Rat']<<<break>>>['\\\\lemma <=_*_positive_positive \\\\hlevels  {this : PosetSemiring} {x y : E} (_ : zro <= x) (_ : zro <= y) : zro <= x * y ', '| zro : E', '| \\\\infixl 7 * E E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop']<<<break>>>zro <= e * e", "completion": "<=_*_positive_positive {RatField} e>=0 e>=0"}
{"prompt": "[\"F : Functor NatSemiring CRingCat (\\\\lam (n : Nat) => (S n).1) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (p : Hom {C {\\\\this}} X Y) =>\\n    natHom {CRingCat} {\\\\lam (n : Nat) => (S n).1} {\\\\lam {n : Nat} => (sf n).3} {X} {Y} (Y -' X, <=_exists {X} {Y} p)\\n}\", 'S : Nat -> \\\\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k K) (isIntegralExt g)', 'c : Countable k.E', 'k : DiscreteField', 'ps : Nat -> Poly k', 'n : Ob']<<<break>>>['| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', \"\\\\instance RingLatticeColimit {D : BottomJoinSemilattice} (F1 : Functor D RingCat) :\\nRing (SetColimit {D} (Comp {D} {RingCat} {SetCat} RingCat.forget F1)) {\\n  | zro => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, zro {F D.bottom})\\n  | + => (AddMonoidLatticeColimit.+)\\n  | * => (MonoidLatticeColimit.*)\\n  | negative => negative {D} {Comp {D} {AbGroupCat} {AddGroupCat} forgetToAddGroup (Comp {D} {RingCat} {AbGroupCat} forgetToAbGroup F1)}\\n  | ide => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, ide {F D.bottom})\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}\", '| Cod : BaseSet', '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| \\\\infixl 7 * E E : E', '\\\\instance NatBSemilattice \\\\hlevels  : BottomJoinSemilattice Nat {\\n  | <= => (<=)\\n  | join => join {NatSemiring}\\n  | bottom => 0\\n} => \\\\new BottomJoinSemilattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | bottom-univ => {?hidden}\\n}', \"\\\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D RingCat} (d : D.E) : RingHom (F.F d) (RingLatticeColimit {D} F1) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) =>\\n  in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func sequence {k2 : DiscreteField} (_ : Countable k.E) (_ : Nat -> Poly k2) (_ : Nat) :\\n  \\\\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k2 K) (isIntegralExt g) \\n  | {k}, kc, f, 0 => (k, kc, id k, integralExt_id {Dom {id k}})\\n  | {k}, kc, f, suc n => \\n    \\\\let | (K, Kc, g, gi) => sequence {k} kc f n\\n         | t => countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}\\n    \\\\in (t.1, t.2, t.3 \u2218 g, integralExt-comp\\n        {k} {(sequence {k} kc f n).1} {(countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).1} g\\n          (countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).3 gi (splitting-integral\\n          {(sequence {k} kc f n).1} {(countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).1} {polyMap g (f n)}\\n            {(countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).3}\\n            (countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).4))', '| Dom : BaseSet', '\\\\instance RingCat : Cat Ring {\\n  | Hom => RingHom\\n  | id => RingHom.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}']<<<break>>>\\Pi {x y : E {Dom {inMap {NatBSemilattice} {F} n \u2218 (S n).3}}} ->\n  func {inMap {NatBSemilattice} {F} n \u2218 (S n).3} (x * y) = func {inMap {NatBSemilattice} {F} n \u2218 (S n).3} x * func {inMap {NatBSemilattice} {F} n \u2218 (S n).3} y", "completion": "func-* {inMap {NatBSemilattice} {F} n \u2218 (S n).3}"}
{"prompt": "['Y : UniformSpace', 'X : \\\\Set', 'f : X -> Y.E']<<<break>>>['\\\\func PrecoverTransfer \\\\hlevels  {X : \\\\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func RegularPreuniformTransfer {X : \\\\Set} {Y : RegularPreuniformSpace} (f : X -> Y.E) : RegularPreuniformSpace X {\\n  | isOpen => \\\\lam (U : Set E) => TruncP (\\\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\\n  | isCauchy => \\\\lam (C : Set (Set E)) => Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set E) (C U) (f ^-1 V \u2286 U)))\\n  | isUniform => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    Y.isUniform (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new RegularPreuniformSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cover => {?hidden}\\n  | uniform-top => {?hidden}\\n  | uniform-refine => {?hidden}\\n  | uniform-inter => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | uniform-regular => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\class RegularPreuniformSpace \\\\extends PreuniformSpace, CoverSpace \\\\hlevels  {\\n  | uniform-regular {C : Set (Set E)} (isUniform C) : PrecoverSpace.isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=* U)))\\n  | isRegular => \\\\lam {C : Set (Set E)} (Cc : PrecoverSpace.isCauchy C) =>\\n    (uniform-cauchy {\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U))}).2\\n    (closure-regular RegularRatherBelow {isUniform} (\\\\lam {C : Set (Set E)} (Cu : isUniform C) =>\\n      (uniform-cauchy {\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U))}).1\\n      (cauchy-subset {\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=* U))}\\n        {\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U))} (uniform-regular {C} Cu)\\n        (\\\\lam {V : Set E} (p0 : TruncP (\\\\Sigma (U : Set E) (C U) (V <=* U))) => (\\\\case p0 \\\\with {\\n          | inP (U, CU, V<=*U) => inP {\\\\Sigma (U : Set E) (C U) (V <=< U)} (U, CU, <=*_<=< {V} {U} V<=*U)\\n        })))) {C} ((uniform-cauchy {C}).1 Cc))\\n}', '| isOpen (Set E) : \\\\Prop', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '\\\\func TopTransfer \\\\hlevels  {X : \\\\Set} {Y : TopSpace} (f : X -> Y.E) : TopSpace X {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) => TruncP (\\\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}']<<<break>>>RegularPreuniformSpace X {\n  | isOpen => \\lam (U : Set E) => TruncP (\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\n  | isCauchy => \\lam (C : Set (Set E)) => Y.isCauchy (\\lam (V : Set Y.E) => TruncP (\\Sigma (U : Set E) (C U) (f ^-1 V \u2286 U)))\n  | isUniform => \\lam (C : Set (Set (E {\\this}))) =>\n    Y.isUniform (\\lam (V : Set Y.E) => TruncP (\\Sigma (U : Set (E {\\this})) (C U) (f ^-1 V \u2286 U)))\n}", "completion": "RegularPreuniformTransfer f"}
{"prompt": "['x : Total {X.E} S', 'h : Inv {R}', 'g : Total {X.E} S -> Y.E', 'Y : TopLModule R', 'f : Total {X.E} S -> Y.E']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| inv : E {M}', '| *c-ldistr {r : E {R}} {a b : E} : r *c (a + b) = r *c a + r *c b']<<<break>>>h.inv Y.*c (f x Y.+ g x) = h.inv Y.*c f x Y.+ h.inv Y.*c g x", "completion": "*c-ldistr {Y}"}
{"prompt": "['r : GroupTerm V', 'q : 0 < count-leaves l', 'l : GroupTerm V', 'res-l : \\\\Sigma (GroupTerm V) Bool', 'this : NatData']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', \"\\\\func get-leaf \\\\hlevels  {this3 : NatData} (_ : GroupTerm V) (_ : Nat) : GroupTerm V \\n  | {this}, l :* r, ind => \\\\case dec<_<= {NatSemiring} ind (suc (count-leaves l)) \\\\with {\\n    | inl _x => get-leaf l ind\\n    | o => get-leaf r (ind -' count-leaves l)\\n  }\\n  | {this}, :inv (var x), ind => \\\\case ind \\\\with {\\n    | suc 0 => :inv {V} (var {V} x)\\n    | n => :ide {Nat}\\n  }\\n  | {this}, :inv g, ind => :ide {Nat}\\n  | {this}, var x, ind => \\\\case ind \\\\with {\\n    | suc 0 => var {V} x\\n    | n => :ide {Nat}\\n  }\\n  | {this}, :ide, ind => :ide {Nat}\", 'suc Nat', '\\\\data GroupTerm \\\\Type \\n  | var V\\n  | :ide\\n  | :inv (GroupTerm V)\\n  | \\\\infixl 6 :* (_ _ : GroupTerm V)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", \"\\\\lemma dec<_reduce \\\\hlevels  {A : Dec} {a a' : A.E} (p : a A.< a') : dec<_<= {A} a a' = inl {a A.< a'} {a' <= a} p \", \"\\\\func remove-pair \\\\hlevels  {this5 : NatData} (_ : GroupTerm V) (_ : Nat) : \\\\Sigma (GroupTerm V) Bool \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | less _x => \\n      \\\\let res-l => remove-pair l fstLeafToRemoveInd\\n      \\\\in \\\\case res-l.2 \\\\with {\\n            | true => (r, false)\\n            | false => (res-l.1 :* r, false)\\n          }\\n    | equals p => \\n      \\\\let | res-l => remove-pair l fstLeafToRemoveInd\\n           | res-r => remove-pair r 0\\n      \\\\in \\\\case res-l.2, res-r.2 \\\\with {\\n            | true, true => (:ide {Nat}, true)\\n            | true, false => res-r\\n            | false, true => res-l\\n            | false, false => (res-l.1 :* res-r.1, false)\\n          }\\n    | greater _x => \\n      \\\\let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l)\\n      \\\\in \\\\case res-r.2 \\\\with {\\n            | true => (l, false)\\n            | false => (l :* res-r.1, false)\\n          }\\n  }\\n  | {this}, :inv (var x), fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :inv g, fstLeafToRemoveInd => (:inv {V} g, false)\\n  | {this}, var x, fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :ide, fstLeafToRemoveInd => (:ide {Nat}, false)\", '| \\\\infix 4 < E E : \\\\Prop', '| \\\\infixl 7 * E E : E', '| V : \\\\Set', 'inl A', '| G : Group', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func count-leaves \\\\hlevels  {this1 : NatData} (_ : GroupTerm V) : Nat \\n  | {this}, l :* r => count-leaves l + count-leaves r\\n  | {this}, :inv (var x) => 1\\n  | {this}, :inv g => 0\\n  | {this}, var x => 1\\n  | {this}, t => 0', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', 'suc<suc (n < m)', \"\\\\func dec<_<= \\\\hlevels  {A : Dec} (a a' : A.E) : Or (a A.< a') (a' <= a) => \\\\case A.trichotomy a a' \\\\with {\\n  | less a<a' => inl {a A.< a'} {a' <= a} a<a'\\n  | equals a=a' => inr {a A.< a'} {a' <= a} (transportInv {A.E} ((<=) a') {a} {a'} a=a' (A.<-irreflexive {a'}))\\n  | greater a'<a => inr {a A.< a'} {a' <= a} (A.<=-less {a'} {a} a'<a)\\n}\", '| E : \\\\Set', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', '\\\\func interpret \\\\hlevels  {this4 : GroupData} (_ : GroupTerm V) : E {G} \\n  | {this}, var x => f x\\n  | {this}, :ide => ide {G}\\n  | {this}, :inv t => inverse {G} (interpret t)\\n  | {this}, t :* s => interpret t * interpret s', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>interpret (get-leaf l 1) * interpret (remove-pair l 0).1 * interpret r = interpret (\\case dec<_<= {NatSemiring} 1 (suc (count-leaves l)) \\with {\n  | inl _x => get-leaf l 1\n  | o => get-leaf r (1 -' count-leaves l)\n}) * (interpret res-l.1 * interpret r)", "completion": "rewrite (dec<_reduce (suc<suc q)) (rewrite *-assoc idp)"}
{"prompt": "['l : B {\\\\this}']<<<break>>>['| \\\\infixl 6 + E E : E', '| natCoefSuc (n : Nat) : natCoef (suc n) = natCoef n + ide', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| natCoef Nat : E', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| E : \\\\Set']<<<break>>>\\Pi (n : Nat) -> l.natCoef (suc n) = l.natCoef n l.+ l.ide", "completion": "natCoefSuc {l}"}
{"prompt": "['this : StoneC*Algebra', 'z : E', 'x : E', 'y : E']<<<break>>>['| V : \\\\Set', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class CGroupData \\\\extends NatData \\\\hlevels ', '| at (j : Fin len) : A j', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '| E : \\\\Set', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}']<<<break>>>CGroupData {toCGroup this1} (\\lam (a : V {\\this}) => at {z :: y :: x :: nil} (fromNat {2} a))", "completion": "\\new CGroupData {toCGroup this} ((::) z (y :: x :: nil) a)"}
{"prompt": "['S : SubMonoid R', 'R : CRing', 'a : R.E', 'd : degree<= {R} p n', 'p : Poly R', 'Sb : S.contains b', 'n : Nat', 'b : R.E']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func inl~ \\\\hlevels  {R : CRing} {S : SubMonoid R} (x : SType {R} S) : Type {R} {S} \\n  => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} x', 'suc Nat', '\\\\func locMap \\\\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) =>\\n    in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\lemma degree<=_polyMap \\\\hlevels  {f : AddPointedHom} {p : Poly f.Dom} {n : Nat} (_ : degree<= {f.Dom} p n) : degree<= {f.Cod} (polyMap f p) n ', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\lemma polyEval_polyCoef \\\\hlevels  {R : Ring} {p : Poly R} {a : R.E} {n : Nat} (_ : degree< {R} p n) :\\n  polyEval {R} p a = BigSum {R} (\\\\new Array R.E n (\\\\lam (i : Fin n) => polyCoef {R} p i R.* pow {R} a i)) ', '| Cod : BaseSet', '\\\\func polyEval \\\\hlevels  {R3 : Ring} (_ : Poly R3) (_ : R.E) : R.E \\n  | {R}, pzero, a => R.zro\\n  | {R}, padd p e, a => polyEval {R} p a R.* a R.+ e\\n  | {R}, peq i, a => (R.zro-right {R.zro R.* a} *> R.zro_*-left {a}) @ i', '\\\\lemma degree<=_degree< \\\\hlevels  {R : AddPointed} {p : Poly R} {n : Nat} (_ : degree<= {R} p n) : degree< {R} p (suc n) ', '\\\\instance LocRing \\\\hlevels  {R : CRing} (S : SubMonoid R) : CRing (Type {R} {S}) {\\n  | zro => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.zro, R.ide, S.contains_ide)\\n  | + => ++ {R} {S}\\n  | * => ** {R} {S}\\n  | negative => neg {R} {S}\\n  | ide => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.ide, R.ide, S.contains_ide)\\n  | natCoef => \\\\lam (n : Nat) => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2}\\n    (R.natCoef n, R.ide, S.contains_ide)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '| \\\\infixl 7 * E E : E', '\\\\func polyCoef \\\\hlevels  {R4 : AddPointed} (_ : Poly R4) (_ : Nat) : R.E \\n  | {R}, pzero, n => R.zro\\n  | {R}, padd p e, 0 => e\\n  | {R}, padd p e, suc n => polyCoef {R} p n\\n  | {R}, peq i, 0 => idp {R.E} {R.zro} @ i\\n  | {R}, peq i, suc n => idp {R.E} {R.zro} @ i', '\\\\func polyMap \\\\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \\n  | f, pzero => pzero {f.Cod}\\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\\n  | f, peq i => transportInv\\n    {E {f.Cod}} (\\\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\\n      f.func-zro (path (peq {f.Cod})) @ i', '| E : \\\\Set', '| contains (E {S}) : \\\\Prop', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>polyEval {LocRing {R} S} (polyMap (locMap {R} {S}) p) (inl~ {R} {S} (a, b, Sb)) = BigSum {LocRing {R} S} (\\new Array (E {LocRing {R} S}) (suc n) (\\lam (i : Fin (suc n)) =>\n  polyCoef {LocRing {R} S} (polyMap (locMap {R} {S}) p) i * pow {LocRing {R} S} (inl~ {R} {S} (a, b, Sb)) i))", "completion": "polyEval_polyCoef (degree<=_degree< $ degree<=_polyMap d)"}
{"prompt": "['U_CU_s : \\\\Sigma (U : Set InfReal) (C U) (\\\\Sigma (U x) (U y))', 'a : Rat', 'x : E {\\\\this}', 'aux : \\\\Pi {x y : InfReal} ->\\n  (\\\\Pi {C : Set (Set E)} -> isCauchy C -> TruncP (\\\\Sigma (U : Set E) (C U) (\\\\Sigma (U x) (U y)))) -> x.L \u2286 y.L', 'Sc : \\\\Pi {C : Set (Set (E {\\\\this}))} -> isCauchy {\\\\this} C -> TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (\\\\Sigma (U x) (U y)))', 'y : E {\\\\this}']<<<break>>>['| L Rat : \\\\Prop', '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', '\\\\class InfReal \\\\extends LowerReal, ExUpperReal \\\\hlevels  {\\n  | LU-disjoint {q : Rat} (L q) (U q) : Empty\\n  | LU-located {q r : Rat} (q < r) : L q || U r\\n  | LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func InfRealUniformSpace : StronglyRegularUniformSpace InfReal {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => InfRealUniformSpace.InfRealUniformSpace.isUniform\\n} => \\\\new StronglyRegularUniformSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cover => {?hidden}\\n  | uniform-top => {?hidden}\\n  | uniform-refine => {?hidden}\\n  | uniform-inter => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | uniform-strongly-star => {?hidden}\\n}', '| E : \\\\Set']<<<break>>>x.L a <-> y.L a", "completion": "(aux Sc, aux (\\lam Cc => map (Sc Cc) (\\lam p0 => (\n  \\let (U, CU, s) => p0\n  \\in (U, CU, (s.2, s.1))))))"}
{"prompt": "['n : I.E', 'x : X.E', 'X : TopAbGroup', 'f : I.E -> X.E']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma negative_+ \\\\hlevels  {this : AddGroup} {x y : E} : negative (x + y) = negative y - x ', '| negative E : E', '| E : \\\\Set']<<<break>>>X.negative (x X.+ X.negative (f n)) = X.negative (X.negative (f n)) - x", "completion": "negative_+ {_} {x} {X.negative (f n)}"}
{"prompt": "['B : BottomDistributiveLattice', 'q : Rat', 'm : Array (\\\\Sigma V.E B.E)', \"p' : m ~ l'\", 'V : QModule', \"l' : Array (\\\\Sigma V.E B.E)\"]<<<break>>>['\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', \"\\\\lemma ~_*q \\\\hlevels  {V : QModule} {B : BottomDistributiveLattice} {q : Rat} {l l' : Array (\\\\Sigma V.E B.E)} (_ : l ~ l') :\\n  map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (q *q s.1, s.2)) l ~ map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (q *q s.1, s.2)) l' \", \"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '| E : \\\\Set', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (q *q s.1, s.2)) m ~ map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (q *q s.1, s.2)) l'", "completion": "~_*q {V} {B} p'"}
{"prompt": "['z : E', 'y : E', 'this : DiscreteOrderedField']<<<break>>>['| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', '| finv E : E', '| E : \\\\Set']<<<break>>>z * finv y = finv y * z", "completion": "*-comm {this}"}
{"prompt": "[\"h : \\\\Pi (n : Nat) -> RingHom (F.F n) (RingLatticeColimit {NatBSemilattice} F1) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => in~ {\\\\Sigma (j : Ob) (F j)}\\n    {\\\\lam (s : \\\\Sigma (j : Ob) (F j)) (s' : \\\\Sigma (j : Ob) (F j)) => \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n    (n, a)\\n}\", 'sf : \\\\Pi (n : Nat) -> \\\\Sigma (K : DiscreteField) (Countable K.E) (f : RingHom (sequence {k} c ps n).1 K)\\n  (IsSplittingField {(sequence {k} c ps n).1} {K} (polyMap (S n).3 (ps n)) f)', \"F : Functor NatSemiring CRingCat (\\\\lam (n : Nat) => (S n).1) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (p : Hom {C {\\\\this}} X Y) =>\\n    natHom {CRingCat} {\\\\lam (n : Nat) => (S n).1} {\\\\lam {n : Nat} => (sf n).3} {X} {Y} (Y -' X, <=_exists {X} {Y} p)\\n}\", 'S : Nat -> \\\\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k K) (isIntegralExt g)', \"E : DiscreteField (SetColimit {NatBSemilattice} (Comp {NatBSemilattice} {CRingCat} {SetCat} CRingCat.forget F1)) {\\n  | zro => in~ {\\\\Sigma (j : Ob) (F j)}\\n    {\\\\lam (s : \\\\Sigma (j : Ob) (F j)) (s' : \\\\Sigma (j : Ob) (F j)) => \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n    (bottom, zro {F bottom})\\n  | + => (+)\\n  | * => (MonoidLatticeColimit.*)\\n  | negative => negative {NatBSemilattice} {Comp {NatBSemilattice} {AbGroupCat} {AddGroupCat} forgetToAddGroup\\n    (Comp {NatBSemilattice} {RingCat} {AbGroupCat} forgetToAbGroup (Comp {NatBSemilattice} {CRingCat} {RingCat} forgetToRing F1))}\\n  | ide => in~ {\\\\Sigma (j : Ob) (F j)}\\n    {\\\\lam (s : \\\\Sigma (j : Ob) (F j)) (s' : \\\\Sigma (j : Ob) (F j)) => \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n    (bottom, ide {F bottom})\\n  | natCoef => natCoefImpl {RingLatticeColimit {NatBSemilattice} (Comp {NatBSemilattice} {CRingCat} {RingCat} forgetToRing F1)}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case eitherZeroOrInv {\\\\this} (x - y) \\\\with {\\n    | byLeft x-y=0 => yes {x = y} (fromZero {x} {y} x-y=0)\\n    | byRight x-y-isInv => no {x = y} (\\\\lam (x=y : x = y) =>\\n      #-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (x : E {\\\\this}) => Inv (x - y)) {x} {y} x=y x-y-isInv))\\n  })\\n  | finv => finv-impl\\n  | eitherZeroOrInv => \\\\lam (p0 : E {\\\\this}) => (\\\\case p0 \\\\with {\\n    | in~ x => \\\\case eitherZeroOrInv {(S x.1).1} x.2 \\\\with {\\n      | byLeft r => byLeft {in~ {\\\\Sigma (j : Ob) (F j)}\\n        {\\\\lam (s : \\\\Sigma (j : Ob) (F j)) (s' : \\\\Sigma (j : Ob) (F j)) => \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n        x = in~ {\\\\Sigma (j : Ob) (F j)}\\n        {\\\\lam (s : \\\\Sigma (j : Ob) (F j)) (s' : \\\\Sigma (j : Ob) (F j)) => \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n        (bottom, zro {F bottom})}\\n        {Inv (in~ {\\\\Sigma (j : Ob) (F j)}\\n          {\\\\lam (s : \\\\Sigma (j : Ob) (F j)) (s' : \\\\Sigma (j : Ob) (F j)) => \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n          x)}\\n        (Paths.inv {SetColimit {NatBSemilattice} (Comp {NatBSemilattice} {CRingCat} {SetCat} CRingCat.forget F1)}\\n          {in~ {\\\\Sigma (j : E) (E {F.F j})} {\\\\lam (s : \\\\Sigma (j : E) (E {F.F j})) (s' : \\\\Sigma (j : E) (E {F.F j})) =>\\n            \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (bottom, zro {F.F bottom})}\\n          {in~ {\\\\Sigma (j : E) (E {F.F j})} {\\\\lam (s : \\\\Sigma (j : E) (E {F.F j})) (s' : \\\\Sigma (j : E) (E {F.F j})) =>\\n            \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x}\\n          (~-cequiv {NatBSemilattice} {Comp {NatBSemilattice} {CRingCat} {SetCat} CRingCat.forget F1} {(bottom, zro {F.F bottom})} {x}\\n            (bottom-univ {x.1})\\n            (func-zro {F.Func {bottom} {x.1} (bottom-univ {x.1})} *> Paths.inv {E {F.F x.1}} {x.2} {zro {F.F x.1}} r)))\\n      | byRight r => byRight {in~ {\\\\Sigma (j : Ob) (F j)}\\n        {\\\\lam (s : \\\\Sigma (j : Ob) (F j)) (s' : \\\\Sigma (j : Ob) (F j)) => \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n        x = in~ {\\\\Sigma (j : Ob) (F j)}\\n        {\\\\lam (s : \\\\Sigma (j : Ob) (F j)) (s' : \\\\Sigma (j : Ob) (F j)) => \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n        (bottom, zro {F bottom})}\\n        {Inv (in~ {\\\\Sigma (j : Ob) (F j)}\\n          {\\\\lam (s : \\\\Sigma (j : Ob) (F j)) (s' : \\\\Sigma (j : Ob) (F j)) => \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n          x)}\\n        (lmake {in~ {\\\\Sigma (j : E) (E {F.F j})} {\\\\lam (s : \\\\Sigma (j : E) (E {F.F j})) (s' : \\\\Sigma (j : E) (E {F.F j})) =>\\n          \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x}\\n          (inC {NatBSemilattice} {Comp {NatBSemilattice} {CRingCat} {SetCat} CRingCat.forget F1} (x.1, r.inv))\\n          (Paths.inv {SetColimit {NatBSemilattice} (Comp {NatBSemilattice} {CRingCat} {SetCat} CRingCat.forget F1)} {ide {\\\\this}}\\n            {inC {NatBSemilattice} {Comp {NatBSemilattice} {CRingCat} {SetCat} CRingCat.forget F1} (x.1, r.inv) Semigroup.* in~ {\\\\Sigma (j : E) (E {F.F j})} {\\\\lam (s : \\\\Sigma (j : E) (E {F.F j})) (s' : \\\\Sigma (j : E) (E {F.F j})) =>\\n              \\\\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x}\\n            (~-cequiv {NatBSemilattice} {Comp {NatBSemilattice} {CRingCat} {SetCat} CRingCat.forget F1} {(bottom, ide {F.F bottom})}\\n              {(x.1 \u2228 x.1,\\n                func {Func {x.1} {x.1 \u2228 x.1} (join-left {x.1} {x.1})} r.inv Semigroup.* func {Func {x.1} {x.1 \u2228 x.1} (join-right {x.1} {x.1})} x.2)}\\n              (bottom-univ {x.1 \u2228 x.1})\\n              (func-ide {F.Func {bottom} {x.1 \u2228 x.1} (bottom-univ {x.1 \u2228 x.1})} *> Paths.inv {E {F.F (x.1 \u2228 x.1)}} {func {F.Func {x.1} {x.1 \u2228 x.1} (join-left {x.1} {x.1})} (r.inv Semigroup.* x.2)}\\n                {ide {F.F (x.1 \u2228 x.1)}}\\n                (pmap {E {F.F x.1}} {E {F.F (x.1 \u2228 x.1)}} (func {F.Func {x.1} {x.1 \u2228 x.1} (join-left {x.1} {x.1})}) {r.inv Semigroup.* x.2}\\n                  {ide {(S x.1).1}} r.inv-left *> func-ide {F.Func {x.1} {x.1 \u2228 x.1} (join-left {x.1} {x.1})}) *> func-* {F.Func {x.1} {x.1 \u2228 x.1} (join-left {x.1} {x.1})} {r.inv} {x.2}))))\\n    }\\n  })\\n}\", 'c : Countable k.E', 'k : DiscreteField', 'ps : Nat -> Poly k']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\type SetColimit \\\\hlevels  {J : Precat} (F1 : Functor J SetCat) : \\\\Set \\n=> Quotient {\\\\Sigma (j : J.Ob) (F.F j)} (\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2))\", \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| Cod : BaseSet', '\\\\lemma sequence3 {k : DiscreteField} {kc : Countable k.E} {f : Nat -> Poly k} {n : Nat} {a : k.E} :\\nfunc {natHom {CRingCat} {\\\\lam (n : Nat) => (sequence {k} kc f n).1}\\n  {\\\\lam {n : Nat} => (countableSplittingField {(sequence {k} kc f n).1} (sequence {k} kc f n).2 {polyMap (sequence {k} kc f n).3 (f n)}).3}\\n  {0} {0 + n} (n, idp {Nat} {0 + n})} a = func {(sequence {k} kc f n).3} a ', '| \\\\infixl 7 * E E : E', '\\\\instance CRingCat : Cat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {RingCat} {CRing} (\\\\new Embedding {CRing} {Ob} (\\\\lam (R : A {\\\\this}) => R) {\\n  | isEmb => \\\\lam (R S : A {\\\\this}) =>\\n  \\\\new Retraction {R = S} {f {\\\\this} R = f {\\\\this} S} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {R} {S}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new CRing (E {p @ i}) {\\n      | zro => zro {p @ i}\\n      | + => (+) {p @ i}\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*) {p @ i}\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | negative => negative {p @ i}\\n      | negative-left => {?hidden}\\n      | ide => ide {p @ i}\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef {p @ i}\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n    })\\n    | f_sec => idpe {R = S}\\n  }\\n})', '\\\\instance NatBSemilattice \\\\hlevels  : BottomJoinSemilattice Nat {\\n  | <= => (<=)\\n  | join => join {NatSemiring}\\n  | bottom => 0\\n} => \\\\new BottomJoinSemilattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | bottom-univ => {?hidden}\\n}', '\\\\lemma integral_image-comp {R S E1 : Ring} {f : RingHom R S} (g : RingHom S E1) {a : S.E} (_ : isIntegral f a) : isIntegral (g \u2218 f) (g.func a) ', '\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', '\\\\lemma sigma-isProp \\\\plevels  \\\\hlevels  {n m : Nat} : isProp (\\\\Sigma (k : Nat) (n + k = m)) ', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '\\\\func isIntegral \\\\hlevels  (f : RingHom) (x : E {f.Cod}) : \\\\Prop \\n  => TruncP (\\\\Sigma (p : Poly f.Dom) (isMonic {f.Dom} p) (polyEval {f.Cod} (polyMap f p) x = zro {f.Cod}))', '\\\\func natHom \\\\plevels obj >= hom \\\\hlevels  {C2 : Precat} {F2 : Nat -> C.Ob} {f1 : \\\\Pi {n : Nat} -> C.Hom (F2 n) (F2 (suc n))} {n2 m1 : Nat}\\n  (_ : \\\\Sigma (k : Nat) (n2 + k = m1)) : C.Hom (F2 n2) (F2 m1) \\n  | {C}, {F}, {f}, {n}, {m}, (0, idp) => C.id (F n)\\n  | {C}, {F}, {f}, {n}, {0}, (suc k, ())\\n  | {C}, {F}, {f}, {n}, {suc m}, (suc k, q) =>\\n    f {m} C.\u2218 natHom {C} {F} {f} {n} {pred (suc m)} (k, pmap {Nat} {Nat} pred {n + suc k} {suc m} q)', '\\\\instance RingCat : Cat Ring {\\n  | Hom => RingHom\\n  | id => RingHom.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", \"\\\\lemma ~-cequiv \\\\hlevels  {J : Precat} {F1 : Functor J SetCat} {s s' : \\\\Sigma (j : J.Ob) (F.F j)} (f : J.Hom s.1 s'.1)\\n  (_ : F.Func {s.1} {s'.1} f s.2 = s'.2) :\\nin~ {\\\\Sigma (j : J.Ob) (F.F j)} {\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2)} s = in~ {\\\\Sigma (j : J.Ob) (F.F j)} {\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2)} s' \", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", \"\\\\instance RingLatticeColimit {D : BottomJoinSemilattice} (F1 : Functor D RingCat) :\\nRing (SetColimit {D} (Comp {D} {RingCat} {SetCat} RingCat.forget F1)) {\\n  | zro => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, zro {F D.bottom})\\n  | + => (AddMonoidLatticeColimit.+)\\n  | * => (MonoidLatticeColimit.*)\\n  | negative => negative {D} {Comp {D} {AbGroupCat} {AddGroupCat} forgetToAddGroup (Comp {D} {RingCat} {AbGroupCat} forgetToAbGroup F1)}\\n  | ide => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, ide {F D.bottom})\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| func-ide : func (ide {Dom}) = ide {Cod}', '\\\\func forget : Functor RingCat SetCat (\\\\lam (R : Ob {C {\\\\this}}) => R.E) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f.func\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ', '\\\\func isIntegralExt \\\\hlevels  (f : RingHom) : \\\\Prop => \\\\Pi (a : E {f.Cod}) -> isIntegral f a', '| zro : E', '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D RingCat} (d : D.E) : RingHom (F.F d) (RingLatticeColimit {D} F1) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) =>\\n  in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\lemma <=_exists \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n <= m) : n + (m -' n) = m \", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| Ob : \\\\hType', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func sequence {k2 : DiscreteField} (_ : Countable k.E) (_ : Nat -> Poly k2) (_ : Nat) :\\n  \\\\Sigma (K : DiscreteField) (Countable K.E) (g : RingHom k2 K) (isIntegralExt g) \\n  | {k}, kc, f, 0 => (k, kc, id k, integralExt_id {Dom {id k}})\\n  | {k}, kc, f, suc n => \\n    \\\\let | (K, Kc, g, gi) => sequence {k} kc f n\\n         | t => countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}\\n    \\\\in (t.1, t.2, t.3 \u2218 g, integralExt-comp\\n        {k} {(sequence {k} kc f n).1} {(countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).1} g\\n          (countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).3 gi (splitting-integral\\n          {(sequence {k} kc f n).1} {(countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).1} {polyMap g (f n)}\\n            {(countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).3}\\n            (countableSplittingField {(sequence {k} kc f n).1} Kc {polyMap g (f n)}).4))', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>isIntegralExt (h zro)", "completion": "later (\\lam p0 => (\\case \\elim p0 \\with {\n  | in~ (n, a) => \n    \\let t => integral_image-comp (inMap {_} {F} n) ((S n).4 a)\n    \\in transportInv {RingHom k E} (\\lam p0 => isIntegral p0 _)\n          (later $ exts (\\lam a => ~-cequiv zero<=_ $ pmap (\\lam p0 => natHom {CRingCat} p0 _) (sigma-isProp _ _) *> sequence3)) t\n}))"}
{"prompt": "['X : RegularPreuniformSpace', 'this : UniformMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n  | func-cont => {?hidden}\\n  | func-uniform => {?hidden}\\n}', 'g : UniformMap Y Z', 'Y : RegularPreuniformSpace', 'f : UniformMap X Y', 'Z : RegularPreuniformSpace']<<<break>>>['\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma uniform-subset \\\\hlevels  {X : PreuniformSpace} {C D : Set (Set X.E)} (_ : X.isUniform C) (_ : \\\\Pi {U : Set X.E} -> C U -> D U) : X.isUniform D ', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '| Cod : BaseSet', '| func-uniform {E1 : Set (Set (E {Cod}))} (isUniform {Cod} E1) : isUniform {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (E1 V) (U = func ^-1 V)))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '| func (E {Dom}) : E {Cod}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>\\Pi {E1 : Set (Set (E {Cod {\\this}}))} -> isUniform {Cod {\\this}} E1 ->\n  X.isUniform (\\lam (U1 : Set X.E) => TruncP (\\Sigma (Set Z.E) (E1 \\this) (U1 = func {\\this} ^-1 \\this)))", "completion": "\\lam Du => uniform-subset (func-uniform {f} $ func-uniform {g} Du) (\\lam p0 => (\\case \\elim p0 \\with {\n  | inP (V, inP (W, DW, q), p) => inP $ later (W, DW, p *> rewrite q idp)\n}))"}
{"prompt": "['Y : UniformSpace', 'C : Set (Set X.E)', 'D : Set (Set Y.E)', 'X : UniformSpace']<<<break>>>['\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\instance UniformSpaceHasProduct \\\\hlevels  : HasProduct UniformSpace {\\n  | Product => ProductUniformSpace\\n} => \\\\new HasProduct', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func proj1 \\\\hlevels  {X Y : UniformSpace} : UniformMap (X \u2a2f Y) X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1\\n} => \\\\new UniformMap {\\n  | func-cont => {?hidden}\\n  | func-uniform => {?hidden}\\n}', '\\\\func proj2 \\\\hlevels  {X Y : UniformSpace} : UniformMap (X \u2a2f Y) Y {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.2\\n} => \\\\new UniformMap {\\n  | func-cont => {?hidden}\\n  | func-uniform => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>\\Pi {p0 : Set (E {X \u2a2f Y})} ->\nTruncP (\\Sigma (U : Set (\\Sigma X.E Y.E)) (TruncP (\\Sigma (V : Set X.E) (C V) (U = func {proj1 {X} {Y}} ^-1 V)))\n  (V : Set (\\Sigma X.E Y.E)) (TruncP (\\Sigma (V1 : Set Y.E) (D V1) (V = func {proj2 {X} {Y}} ^-1 V1))) (p0 = U \u2227 V)) ->\n(\\lam (V : Set (\\Sigma X.E Y.E)) =>\n  TruncP (\\Sigma (U : Set X.E) (C U) (V1 : Set Y.E) (D V1) (V = (\\lam (s : \\Sigma X.E Y.E) => \\Sigma (U s.1) (V1 s.2))))) p0", "completion": "\\lam {p0} p1 => (\\case \\elim p0, \\elim p1 \\with {\n  | _, inP (_, inP (U, CU, idp), _, inP (V, DV, idp), idp) => inP $ later (U, CU, V, DV, idp)\n})"}
{"prompt": "['n : Nat', 'null : \\\\Pi {n : Nat} -> zro <= rfunc n', 'p : rfunc (suc n) <= ide - eps', 'eps : Rat']<<<break>>>['true', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', 'rfunc \\\\hlevels  (_ : Nat) : Rat \\n  | 0 => zro\\n  | suc n => ratio (pos 1) 2 * (ide + rfunc n * rfunc n)', '| len : Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', 'coef C', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', 'LessOrEquals', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '| zro : E', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>zro <= ide - ratio (pos 1) 2 * eps", "completion": "linarith rfunc>=0"}
{"prompt": "[\"r' : E {R {\\\\this}}\", 'a : E {\\\\this}', 'this : LModule R (InterwiningMap {G} {R} A B) {\\n  | zro => zeroInterwining {R} {G} {A} {B}\\n  | + => addInterwining {R} {G} {A} {B}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => negativeInterwining {R} {G} {A} {B}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c => mulconstInterwining {R} {G} {A} {B}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', 'r : E {R {\\\\this}}']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '| R : Ring']<<<break>>>\\Pi {r1 : E {R {r *c (r' *c a)}}} ->\n  \\Pi {x : E {Dom {r *c (r' *c a)}}} -> func {r *c (r' *c a)} (r1 *c x) = r1 *c func {r *c (r' *c a)} x", "completion": "func-*c {mulconstInterwining {R} {G} {A} {B} r (mulconstInterwining {R} {G} {A} {B} r' a)}"}
{"prompt": "['x : Fin (suc k)', 'k : Nat', 'p : x /= k']<<<break>>>['suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'suc<suc (n < m)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func \\\\infixl 8 mod \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n mod m', '\\\\lemma mod_< \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < m) : n mod m = n ', '\\\\lemma conv \\\\plevels  \\\\hlevels  {x y : Nat} (_ : suc x <= suc y) : x <= y ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma suc_<_<= \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < m) : suc n <= m ', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', \"\\\\lemma <=_/= \\\\hlevels  {A : Dec} {a a' : A.E} (_ : a <= a') (_ : a /= a') : a A.< a' \"]<<<break>>>suc x mod suc k = suc x", "completion": "mod_< (suc<suc $ <=_/= (conv $ suc_<_<= $ fin_< x) p)"}
{"prompt": "['n : Nat', 'R : CRing', 'e : E', 'a : E', 'p : Poly (MPoly (Fin n) R)']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| C : Semiring', 'suc Nat', '\\\\func permSet-map \\\\hlevels  {A2 B2 : \\\\Set} (_ : A2 -> B2) (_ : PermSet A2) : PermSet B2 \\n  | {A}, {B}, f, in~ l => in~ {Array B} {EPerm {B}} (map {A} {B} f l)\\n  | {A}, {B}, f, ~-equiv x y r i => ~-psequiv {B} {map {A} {B} f x} {map {A} {B} f y} (EPerm_map {A} {B} f {x} {y} r) @ i', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '\\\\func permSet-hom \\\\hlevels  {A B : \\\\Set} (f : A -> B) : MonoidHom (PermSetMonoid A) (PermSetMonoid B) {\\n  | func => permSet-map {A} {B} f\\n} => \\\\new MonoidHom {\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\func id \\\\hlevels  {R : Ring} : RingHom R R {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '| Cod : BaseSet', '\\\\type PermSet \\\\hlevels  (A : \\\\Set) : \\\\Set => Quotient {Array A} (EPerm {A})', '\\\\func fzero \\\\plevels  \\\\hlevels  {n : Nat} : Fin (suc n) => 0', '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| E : \\\\Set', '\\\\func inPS \\\\hlevels  {A : \\\\Set} (l : Array A) : PermSet A => in~ {Array A} {EPerm {A}} l', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', 'in~ A', '| len : Nat', '\\\\instance MonoidAlgebra \\\\hlevels  (M : CMonoid) (R1 : CRing) : CAlgebra R1 (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | negative => negative {M.E} {R1}\\n  | *c => \\\\lam (x : E {R}) => (Semigroup.*) (func {monoidRingHom {M} {R1}} x)\\n  | * => (MonoidSemiring.*)\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | coefMap => coefMap-impl\\n} => homAlgebra {R1} {\\\\new CRing (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (MonoidSemiring.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => negative {M.E} {R1}\\n  | negative-left => {?hidden}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}} (monoidRingHom {M} {R1})', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\func ret {n3 : Nat} {R3 : CRing} (_ : Poly (MPoly (Fin n3) R3)) : E \\n  | {n}, {R}, pzero => zro\\n  | {n}, {R}, padd p e =>\\n    ret {n} {R} p * mVar {Fin (suc n)} {R} (fzero {n}) + monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R}) e\\n  | {n}, {R}, peq i =>\\n    (zro-right {zro * mVar {Fin (suc n)} {R} (fzero {n})} *> zro_*-left {mVar {Fin (suc n)} {R} (fzero {n})}) @ i', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', \"\\\\func monoidSet-map \\\\hlevels  {M2 N2 : \\\\Set} (_ : M2 -> N2) (g2 : AddMonoidHom) (_ : MonoidSet M2 g.Dom) : MonoidSet N2 g.Cod \\n  | {M}, {N}, f, g, in~ l => inMS~ {N} {g.Cod}\\n    (map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l)\\n  | {M}, {N}, f, g, ~-equiv l l' r i => monoidSet-ext {N} {g.Cod} {inMS~ {N} {g.Cod}\\n    (map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l)}\\n    {inMS~ {N} {g.Cod}\\n      (map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l')}\\n    (~-pequiv {Array (\\\\Sigma (E {g.Cod}) N)} {(~)}\\n      {map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l}\\n      {map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l'}\\n      (~_map {M} {N} g f {l} {l'} r)) @ i\", '| vars : Array (E {M})', '\\\\func fsuc \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : Fin (suc n) => suc x', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\type MonoidSet \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : \\\\Set => Quotient {Array (\\\\Sigma R.E M)} (~)', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new CRingData {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R}\n  (monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R}) e :: ret {n} {R} p :: in~ {Array (\\Sigma R.E (PermSet (Fin (suc n))))} {(~)} ((R.ide, inPS {Fin (suc n)} (fzero {n} :: nil)) :: nil) :: monoidSet-map\n  {E {Dom {permSet-hom {Fin n} {Fin (suc n)} (fsuc {n})}}} {E {Cod {permSet-hom {Fin n} {Fin (suc n)} (fsuc {n})}}}\n    (func {permSet-hom {Fin n} {Fin (suc n)} (fsuc {n})}) (id {R}) a :: nil) {\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 4} 0 :* var {E} {Fin 4} 1 :* var {E} {Fin 4} 2 :+ var {E} {Fin 4} 0 :* var {E} {Fin 4} 3) = interpret {\\new CRingData {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R}\n  (monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R}) e :: ret {n} {R} p :: in~ {Array (\\Sigma R.E (PermSet (Fin (suc n))))} {(~)} ((R.ide, inPS {Fin (suc n)} (fzero {n} :: nil)) :: nil) :: monoidSet-map\n  {E {Dom {permSet-hom {Fin n} {Fin (suc n)} (fsuc {n})}}} {E {Cod {permSet-hom {Fin n} {Fin (suc n)} (fsuc {n})}}}\n    (func {permSet-hom {Fin n} {Fin (suc n)} (fsuc {n})}) (id {R}) a :: nil) {\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 4} 0 :* (var {E} {Fin 4} 1 :* var {E} {Fin 4} 2 :+ var {E} {Fin 4} 3))", "completion": "\n  \\let d => \\new CRingData {\n         | R => MonoidAlgebra (PermSetMonoid (Fin (suc n))) R\n         | vars => monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R}) e :: ret {n} {R} p :: in~ {Array (\\Sigma R.E (PermSet (Fin (suc n))))} {(~)} ((R.ide, inPS {Fin (suc n)} (fzero {n} :: nil)) :: nil) :: monoidSet-map\n         {E {Dom {permSet-hom {Fin n} {Fin (suc n)} (fsuc {n})}}} {E {Cod {permSet-hom {Fin n} {Fin (suc n)} (fsuc {n})}}}\n           (func {permSet-hom {Fin n} {Fin (suc n)} (fsuc {n})}) (id {R}) a :: nil\n       }\n  \\in terms-equality {d} (var 0 :* var 1 :* var 2 :+ var 0 :* var 3) (var 0 :* (var 1 :* var 2 :+ var 3)) idp"}
{"prompt": "['this : CAlgData', 't : RingTerm (E {C}) (Fin (len {vars {mData}}))']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| R : Semiring', \"\\\\func normalize' \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) :\\n  List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n  | {this}, coef c => (nil {Fin (len {vars})}, c) :: nil {\\\\Sigma (List (Fin (len {vars}))) (E {C})}\\n  | {this}, var v => (v :: nil {Fin (len {vars})}, ide {C}) :: nil {\\\\Sigma (List (Fin (len {vars}))) (E {C})}\\n  | {this}, :zro => nil {\\\\Sigma (List (Fin (len {vars}))) (E {C})}\\n  | {this}, :ide => (nil {Fin (len {vars})}, ide {C}) :: nil {\\\\Sigma (List (Fin (len {vars}))) (E {C})}\\n  | {this}, :negative t => negate (normalize' t)\\n  | {this}, t :+ s => normalize' t ++ normalize' s\\n  | {this}, t :* s => remove0 (collapse (multiply' {Fin (len {vars})} {C} (normalize' t) (normalize' s)))\", '\\\\func map {A1 B2 : \\\\Type} (_ : A1 -> B2) (_ : List A1) : List B2 \\n  | {A}, {B}, f, nil => nil {B}\\n  | {A}, {B}, f, a :: l => f a :: map {A} {B} f l', '\\\\func sort \\\\hlevels  {A : Dec} (l : List A.E) : List A.E => rbTreeToList {A.E} (aux {A} l (rbLeaf {A.E})) (nil {A.E})', '| vars : Array (E {M})', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '\\\\lemma map_sort-consistent \\\\hlevels  {this : CAlgData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\ninterpretRingNF l = interpretRingNF (map {\\\\Sigma (List (Fin (len {vars}))) (E {C})} {\\\\Sigma (List (Fin (len {vars}))) (E {C})}\\n  (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) (E {C})) => (sort {FinOrder (len {vars})} p.1, p.2)) l) ', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpretRingNF (normalize' t) = interpretRingNF (map {\\Sigma (List (Fin (len {vars}))) (E {C})} {\\Sigma (List (Fin (len {vars}))) (E {C})}\n  (\\lam (p : \\Sigma (List (Fin (len {vars}))) (E {C})) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))", "completion": "map_sort-consistent {this} _"}
{"prompt": "['X : \\\\Set']<<<break>>>['true', '| cauchy-top : isCauchy (single {E -> \\\\Prop} top)', '| isCauchy (Set (Set E)) : \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma meet-left-impl \\\\hlevels  {this : CompleteLattice} {x : E} {y : E} : meet-impl x y <= x \\n  => Meet-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}', '| cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D', '| open-top : isOpen top', '\\\\class CoverSpace \\\\extends PrecoverSpace \\\\hlevels  {\\n  | isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\lemma Meet-univ-impl \\\\hlevels  {this : CompleteLattice} {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) : e <= Meet-impl {J} f \\n=> Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n  {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}', '| E : \\\\Set', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '\\\\class PrecoverSpace \\\\extends TopSpace \\\\hlevels  {\\n  | isCauchy (Set (Set E)) : \\\\Prop\\n  | cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))\\n  | cauchy-top : isCauchy (single {E -> \\\\Prop} top)\\n  | cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D\\n  | cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))\\n  | cauchy-open {S : Set E} : TopSpace.isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))\\n}', '\\\\lemma meet-right-impl \\\\hlevels  {this : CompleteLattice} {x : E} {y : E} : meet-impl x y <= y \\n  => Meet-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| join-right {x y : E} : y <= x \u2228 y', '| cauchy-open {S : Set E} : isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))', '| R (E {A}) (E {A}) : \\\\Prop', '| Join {J : \\\\Set} (J -> E) : E', '\\\\lemma meet-univ-impl \\\\hlevels  {this : CompleteLattice} {x : E} {y : E} {z : E} (z<=x : z <= x) (z<=y : z <= y) : z <= meet-impl x y \\n=> Meet-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n  | true => z<=x\\n  | false => z<=y\\n}))', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '\\\\lemma CoverSpace-ext \\\\hlevels  {X : \\\\Set} {S T : CoverSpace X} (_ : \\\\Pi {C : Set (Set X)} -> S.isCauchy C <-> T.isCauchy C) : S = T ', '\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', '| isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))', '| open-Union {S : Set (Set E)} (\\\\Pi {U : Set E} -> S U -> isOpen U) : isOpen (Union {E} S)', '| join-univ {x y z : E} (x <= z) (y <= z) : x \u2228 y <= z', '\\\\func DiscreteCover \\\\hlevels  (X : \\\\Set) : CompletelyRegularCoverSpace X {\\n  | isOpen => \\\\lam (_ : Set E) => \\\\Sigma\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) => \\\\Pi (x : X) -> TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (U x))\\n} => \\\\new CompletelyRegularCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isCompletelyRegular => {?hidden}\\n}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\func meet-impl \\\\hlevels  {this : CompleteLattice} (x : E) (y : E) : E => Meet {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'inP A', '\\\\func Meet-impl \\\\hlevels  {this : CompleteLattice} {J : \\\\Set} (g : J -> E) : E \\n  => Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)', '\\\\func isOpen \\\\hlevels  {this : PrecoverSpace} (S : Set E) : \\\\Prop => \\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S)', '| join-left {x y : E} : x <= x \u2228 y', '\\\\lemma Meet-cond-impl \\\\hlevels  {this : CompleteLattice} {J : \\\\Set} (j : J) {f : J -> E} : Meet-impl {J} f <= f j \\n=> Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)', 'false', '| cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))', '| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)', '| cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\instance PrecoverLattice \\\\hlevels  (X : \\\\Set) : CompleteLattice (PrecoverSpace X) {\\n  | <= => \\\\lam (A : E {\\\\this}) (B : E {\\\\this}) => \\\\Pi {C : Set (Set X)} -> A.isCauchy C -> B.isCauchy C\\n  | meet => meet-impl\\n  | join => join-impl\\n  | top => DiscreteCover X\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n  ClosurePrecoverSpace {X} (\\\\lam (C : Set (Set X)) => TruncP (\\\\Sigma (j : J) (isCauchy {f j} C)))\\n    (\\\\lam {C : Set (Set X)} (e : TruncP (\\\\Sigma (j : J) (isCauchy {f j} C))) (x : X) => (\\\\case e \\\\with {\\n      | inP (j, Cc) => cauchy-cover {f j} {C} Cc x\\n    }))\\n  | Meet => Meet-impl\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '\\\\func ClosurePrecoverSpace \\\\hlevels  {X : \\\\Set} (A : Set (Set X) -> \\\\Prop)\\n  (CA : \\\\Pi {C : Set (Set X)} -> A C -> \\\\Pi (x : X) -> TruncP (\\\\Sigma (U : Set X) (C U) (U x))) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => Closure {X} A\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma closure-regular \\\\hlevels  {X : PrecoverSpace} (RB : RatherBelow {SetLattice X.E}) {A : Set (Set X.E) -> \\\\Prop}\\n  (_ : \\\\Pi {C : Set (Set X.E)} -> A C -> Closure {X.E} A (\\\\lam (V : Set X.E) => TruncP (\\\\Sigma (U : Set X.E) (C U) (RB.R V U))))\\n  {C : Set (Set X.E)} (_ : Closure {X.E} A C) :\\n  Closure {X.E} A (\\\\lam (V : Set X.E) => TruncP (\\\\Sigma (U : Set X.E) (C U) (RB.R V U))) ', 'closure (A C)', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\lemma cauchy-subset \\\\hlevels  {X : PrecoverSpace} {C D : Set (Set X.E)} (_ : X.isCauchy C) (_ : \\\\Pi {U : Set X.E} -> C U -> D U) : X.isCauchy D ', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '\\\\class CompleteLattice \\\\extends BoundedLattice, CompleteCat \\\\hlevels  {\\n  | Join {J : \\\\Set} (J -> E) : E\\n  | Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f\\n  | Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e\\n  | Meet {J : \\\\Set} (J -> E) : E\\n  | Meet-cond {J : \\\\Set} (j : J) {f : J -> E} : Meet {J} f <= f j\\n  | Meet-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> e <= f j) : e <= Meet {J} f\\n  | pullback => \\\\lam {x1 : Ob} {y1 : Ob} {z1 : Ob} (f : Hom x1 z1) (g1 : Hom y1 z1) => \\\\new Pullback {x1} {y1} {z1} f g1 (x1 \u2227 y1) {\\n    | pbProj1 => meet-left {x1} {y1}\\n    | pbProj2 => meet-right {x1} {y1}\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {Pullback.D {\\\\this}}} (p1 : Hom {Pullback.D {\\\\this}} w (x {\\\\this})) (p2 : Hom {Pullback.D {\\\\this}} w (y {\\\\this}))\\n      (_ : Pullback.f {\\\\this} \u2218 p1 = g {\\\\this} \u2218 p2) => meet-univ {x1} {y1} {w} p1 p2\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | bottom => Join {Empty} (absurd {E})\\n  | limit => \\\\lam {J : Precat} (G : Functor J this18) => \\\\new Limit {J} G (Meet {\\\\Sigma (b : E) (TruncP (\\\\Sigma (j : J.Ob) (G.F j = b)))}\\n    (Total.proj {E} (\\\\lam (x : E) => TruncP (\\\\Sigma (j : J.Ob) (G.F j = x))))) {\\n    | coneMap => \\\\lam (j : Ob {Cone.J {\\\\this}}) => Meet-cond {\\\\Sigma (b : E) (TruncP (\\\\Sigma (j : J.Ob) (G.F j = b)))}\\n      (G.F j, inP {\\\\Sigma (j1 : J.Ob) (G.F j1 = G.F j)} (j, idp {E} {G.F j}))\\n      {Total.proj {E} (\\\\lam (x : E) => TruncP (\\\\Sigma (j : J.Ob) (G.F j = x)))}\\n    | coneCoh => {?hidden}\\n    | isLimit => {?hidden}\\n    | limMap => limMap-impl\\n    | limBeta => {?hidden}\\n    | limUnique => {?hidden}\\n  }\\n  | bottom-univ => \\\\lam {x : E} => Join-univ {Empty} {absurd {E}} {x} (\\\\lam (p0 : Empty) => (\\\\case p0 \\\\with {}))\\n}']<<<break>>>CompleteLattice (CoverSpace X) {\n  | <= => \\lam (A : E {\\this}) (B : E {\\this}) => \\Pi {C : Set (Set X)} -> A.isCauchy C -> B.isCauchy C\n  | <=-refl => {?hidden}\n  | <=-transitive => {?hidden}\n  | <=-antisymmetric => {?hidden}\n  | meet => meet-impl\n  | meet-left => {?hidden}\n  | meet-right => {?hidden}\n  | meet-univ => {?hidden}\n  | join => \\lam (A : E {\\this}) (B : E {\\this}) => \\new CoverSpace X {\n    | isOpen => isOpen {ClosurePrecoverSpace {X} (\\lam (C : Set (Set X)) => TruncP (\\Sigma (j : Bool) (isCauchy C)))\n      (\\lam {C : Set (Set X)} (e : TruncP (\\Sigma (j : Bool) (isCauchy C))) (x : X) => (\\case e \\with {\n        | inP (j, Cc) => cauchy-cover {C} Cc x\n      }))}\n    | open-top => {?hidden}\n    | open-inter => {?hidden}\n    | open-Union => {?hidden}\n    | isCauchy => Closure {X} (\\lam (C : Set (Set X)) => TruncP (\\Sigma (j : Bool) (isCauchy C)))\n    | cauchy-cover => {?hidden}\n    | cauchy-top => {?hidden}\n    | cauchy-refine => {?hidden}\n    | cauchy-glue => {?hidden}\n    | cauchy-open => {?hidden}\n    | isRegular => {?hidden}\n  }\n  | join-left => {?hidden}\n  | join-right => {?hidden}\n  | join-univ => {?hidden}\n  | top => DiscreteCover X\n  | top-univ => {?hidden}\n  | Join => \\lam {J : \\Set} (f : J -> E {\\this}) => \\new CoverSpace X {\n    | isOpen => isOpen {ClosurePrecoverSpace {X} (\\lam (C : Set (Set X)) => TruncP (\\Sigma (j : J) (isCauchy {f j} C)))\n      (\\lam {C : Set (Set X)} (e : TruncP (\\Sigma (j : J) (isCauchy {f j} C))) (x : X) => (\\case e \\with {\n        | inP (j, Cc) => cauchy-cover {f j} {C} Cc x\n      }))}\n    | open-top => {?hidden}\n    | open-inter => {?hidden}\n    | open-Union => {?hidden}\n    | isCauchy => Closure {X} (\\lam (C : Set (Set X)) => TruncP (\\Sigma (j : J) (isCauchy {f j} C)))\n    | cauchy-cover => {?hidden}\n    | cauchy-top => {?hidden}\n    | cauchy-refine => {?hidden}\n    | cauchy-glue => {?hidden}\n    | cauchy-open => {?hidden}\n    | isRegular => {?hidden}\n  }\n  | Join-cond => {?hidden}\n  | Join-univ => {?hidden}\n  | Meet => Meet-impl\n  | Meet-cond => {?hidden}\n  | Meet-univ => {?hidden}\n}", "completion": "\\new CompleteLattice {\n  | E => CoverSpace X\n  | <= => \\lam A B => \\Pi {C : Set (Set X)} -> isCauchy {A} C -> isCauchy {B} C\n  | <=-refl => \\lam c => c\n  | <=-transitive => \\lam f g c => g (f c)\n  | <=-antisymmetric => \\lam f g => CoverSpace-ext (\\lam {C} => (f, g))\n  | top => DiscreteCover X\n  | top-univ => \\lam {A} c => cauchy-cover {A} c\n  | Join => \\lam f => \\new CoverSpace {\n    | PrecoverSpace => Join {PrecoverLattice X} f\n    | isRegular => closure-regular {Join f} RegularRatherBelow $ later (\\lam p0 => (\\case p0 \\with {\n      | inP (j, Cc) => closure $ inP (j, cauchy-subset (isRegular {f j} Cc) $ later (\\lam {U} p0 => (\\case \\elim p0 \\with {\n        | inP (V, CV, U<=<V) => inP (V, CV, Join-cond {PrecoverLattice X} j {f} U<=<V)\n      })))\n    }))\n  }\n  | Join-cond => \\lam j {f} => Join-cond {PrecoverLattice X} j\n  | Join-univ => Join-univ {PrecoverLattice X}\n  | join => \\lam A B => \\new CoverSpace {\n    | PrecoverSpace => A \u2228 {PrecoverLattice X} B\n    | isRegular => closure-regular {A \u2228 B} RegularRatherBelow $ later (\\lam p0 => (\\case p0 \\with {\n      | inP (true, Cc) => closure $ inP (true, cauchy-subset (isRegular Cc) $ later (\\lam {U} p0 => (\\case \\elim p0 \\with {\n        | inP (V, CV, U<=<V) => inP (V, CV, join-left {PrecoverLattice X} {A} {B} U<=<V)\n      })))\n      | inP (false, Cc) => closure $ inP (false, cauchy-subset (isRegular Cc) $ later (\\lam {U} p0 => (\\case \\elim p0 \\with {\n        | inP (V, CV, U<=<V) => inP (V, CV, join-right {PrecoverLattice X} {A} {B} U<=<V)\n      })))\n    }))\n  }\n  | join-left => join-left {PrecoverLattice X}\n  | join-right => join-right {PrecoverLattice X}\n  | join-univ => join-univ {PrecoverLattice X}\n}"}
{"prompt": "['p : R.E', 'R : CRing']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func inF \\\\hlevels  {I : Ideal} (a : E {I.S}) : Type I => in~ {E {I.S}} {\\\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b)} a', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func NF \\\\hlevels  (C : \\\\Set) (n : Nat) : \\\\Set => List (\\\\Sigma (List (Fin n)) C)', '| \\\\infixl 7 * E E : E', '\\\\func interpret \\\\hlevels  {R6 : Ring} (env4 : Array R.E) (_ : Term Int env.len) : R.E \\n  | {R}, env, coef c => intCoef {R} c\\n  | {R}, env, var c => env.at c\\n  | {R}, env, :zro => R.zro\\n  | {R}, env, :ide => R.ide\\n  | {R}, env, :negative t => R.negative (interpret {R} env t)\\n  | {R}, env, t :+ s => interpret {R} env t R.+ interpret {R} env s\\n  | {R}, env, t :* s => interpret {R} env t R.* interpret {R} env s', '\\\\func closure1 \\\\hlevels  {R : CRing} (a : R.E) : Ideal R (\\\\lam (e : E {S {\\\\this}}) => TruncP (\\\\Sigma (l : Array (\\\\Sigma R.E (\\\\Sigma)))\\n  (e = BigSum {R} (map {\\\\Sigma R.E (\\\\Sigma)} {R.E} (\\\\lam (p : \\\\Sigma R.E (\\\\Sigma)) => p.1 R.* a) l)))) \\n  => closure {R} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => a)', '| E : \\\\Set', '| negative E : E', ':ide', '| contains (E {S}) : \\\\Prop', 'in~ A', 'var (Fin n)', '| len : Nat', '\\\\lemma negative_zro \\\\hlevels  {this : AddGroup} : negative zro = zro ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| zro-right {x : E} : x + zro = x', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', ':negative (Term C n)', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma closure1-lem \\\\hlevels  {R : CRing} {a b : R.E} : contains b <-> TruncP (\\\\Sigma (c : R.E) (b = a R.* c)) ', '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\infixl 6 :+ (_ _ : Term C n)', '\\\\lemma lmake \\\\hlevels  {M : CMonoid} {x : M.E} (y : M.E) (_ : y M.* x = M.ide) : Inv {M} x y ', 'nil', 'inP A', '\\\\lemma unfequiv \\\\hlevels  {I : Ideal} {a b : E {I.S}} (_ : inF {I} a = inF {I} b) : I.contains (a - b) ', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '| inv-right : val * inv = elem', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\type Type \\\\hlevels  (I : Ideal) : \\\\Set => Quotient {E {I.S}} (\\\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b))', '\\\\infixl 7 :* (_ _ : Term C n)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func map {A B C2 D2 : \\\\Type} (_ : A -> C2) (_ : B -> D2) (_ : A || B) : C2 || D2 \\n  | {A}, {B}, {C}, {D}, f, g, byLeft a => byLeft {C} {D} (f a)\\n  | {A}, {B}, {C}, {D}, f, g, byRight b => byRight {C} {D} (g b)', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'byLeft A', '\\\\data Term \\\\hlevels  \\\\Set Nat \\n  | var (Fin n)\\n  | coef C\\n  | :zro\\n  | :ide\\n  | :negative (Term C n)\\n  | \\\\infixl 6 :+ (_ _ : Term C n)\\n  | \\\\infixl 7 :* (_ _ : Term C n)', '\\\\lemma fequiv \\\\hlevels  {I : Ideal} {a b : E {I.S}} (_ : I.contains (a - b)) : inF {I} a = inF {I} b ', '| ide : E', '\\\\lemma terms-equality \\\\hlevels  {R : CRing} (env : Array R.E) (t s : Term Int env.len)\\n  (_ : ringInterpretNF {R} env (sortMonomials {env.len} {Int} (normalize {env.len} {IntRing} (t :+ :negative {E} {env.len} s))) = R.zro) :\\n  interpret {R} env t = interpret {R} env s ', '| inv : E {M}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'byRight B', 'pos Nat', '| zro : E', '\\\\instance FactorRing \\\\hlevels  (I1 : Ideal) : CRing (Type I1) {\\n  | zro => inF {I1} (zro {I.S})\\n  | + => (FactorRing.+)\\n  | * => (FactorRing.*)\\n  | negative => FactorRing.negative {I1}\\n  | ide => inF {I1} (ide {I.S})\\n  | natCoef => \\\\lam (n : Nat) => inF {I1} (natCoef {I.S} n)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', \"\\\\lemma apply-axioms \\\\hlevels  {R : CRing} (env : Array R.E)\\n  (l : Array (\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)))\\n  (add : NF Int env.len) : ringInterpretNF {R} env (sortMonomials\\n  {env.len} {Int} (Big {List (\\\\Sigma (List (Fin env.len)) Int)} {List (\\\\Sigma (List (Fin env.len)) Int)} (++) add\\n    (map {\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)}\\n      {List (\\\\Sigma (List (Fin env.len)) Int)}\\n      (\\\\lam (s : \\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)) =>\\n        multiply {env.len} {IntRing} s.1 (normalize {env.len} {IntRing} (s.2 :+ :negative {E} {env.len} s.3))) l))) = ringInterpretNF' {R} {env} add \", '| S : BaseSet', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>(\\Pi (a : E) -> (a = zro) || Inv {FactorRing (closure1 {R} p)} a) <-> (\\Pi (a : R.E) -> LDiv {R} p a || (\\Sigma (s t : R.E) (s R.* a R.+ t R.* p = R.ide)))", "completion": "(\\lam f a => (\\case f (in~ a) \\with {\n  | byLeft a~0 => \\case closure1-lem.1 (unfequiv a~0) \\with {\n    | inP s => byLeft (\\new LDiv {\n      | inv => s.1\n      | inv-right => inv s.2 *> simplify\n    })\n  }\n  | byRight (in~ b, q, _) => \\case closure1-lem.1 (unfequiv q) \\with {\n    | inP (c, u) => byRight (b, negative c, cRing {u})\n  }\n}),\n  \\lam f => \\lam p0 => (\\case \\elim p0 \\with {\n    | in~ a => map (\\lam (p|a : LDiv p a) => fequiv $ closure1-lem.2 $ inP (inv {p|a}, simplify $ inv (inv-right {p|a}))) (\\lam p0 => (\n      \\let (s, t, q) => p0\n      \\in lmake {_} {inF a} (inF s) $ fequiv $ (closure1-lem {R} {p} {s * a - 1}).2 $ inP (negative t, cRing {q}))) (f a)\n  }))"}
{"prompt": "['b<c : a2 < a3', 'a<=b : a1 <= a2', 'a1 : E {\\\\this}', 'a3 : E {\\\\this}', 'Q : BiorderedSet', 'a2 : E {\\\\this}']<<<break>>>['| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>a3.1 Q.< a1.1", "completion": "b<c.1 <\u2218l a<=b.1"}
{"prompt": "['x : E', 'this : OrderedRing', 'x<xy : x < x * y', 'y : E']<<<break>>>['| \\\\infixl 6 + E E : E', '| ide : E', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '\\\\lemma negative_*-right \\\\hlevels  {this : PseudoRing} {x y : E} : x * negative y = negative (x * y) ', '\\\\lemma toNeg \\\\hlevels  {this : OrderedAddGroup} {x y : E} (_ : x < y) : isNeg (x - y) ', '| \\\\infixl 7 * E E : E', '| ldistr {x y z : E} : x * (y + z) = x * y + x * z', '| isPos E : \\\\Prop', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| isNeg E : \\\\Prop', '| E : \\\\Set', '| negative E : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| ide-right {x : E} : x * ide = x']<<<break>>>isPos (negative (x * (ide + negative y)))", "completion": "transportInv\n  (isNeg {this}) (ldistr {this} *> pmap2 ((+) {this}) (ide-right {this}) (negative_*-right {this})) (toNeg {this} x<xy)"}
{"prompt": "['x : R.E', 'p : pow {R} x n = R.zro', 'this : Contr E\\n  (in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.zro, R.ide, S.contains_ide))\\n  (\\\\lam (p0 : A {\\\\this}) => (\\\\case p0 \\\\with {\\n    | in~ a => equals-lem {R} {S} {(R.zro, R.ide, S.contains_ide)} {a} R.zro\\n      (transport {R.E} S.contains {pow {R} x n} {R.zro} p (contains_pow {S} {x} s {n}))\\n      (transport {R.E} ((=) (R.zro R.* a.2 R.* R.zro)) {R.zro} {a.1 R.* R.ide R.* R.zro}\\n        (inv {R.E} {a.1 R.* R.ide R.* R.zro} {R.zro} (path ((@) (R.zro_*-right {a.1 R.* R.ide}))))\\n        (transport {R.E} (\\\\lam (x0 : R.E) => x0 = R.zro) {R.zro} {R.zro R.* a.2 R.* R.zro}\\n          (inv {R.E} {R.zro R.* a.2 R.* R.zro} {R.zro} (path ((@) (R.zro_*-right {R.zro R.* a.2})))) (idp {R.E} {R.zro})))\\n  }))', 'R : CRing', 'n : Nat', 'S : SubMonoid R', 's : S.contains x']<<<break>>>['| center : A', '| contains_ide : contains (ide {S})', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\instance LocRing \\\\hlevels  {R : CRing} (S : SubMonoid R) : CRing (Type {R} {S}) {\\n  | zro => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.zro, R.ide, S.contains_ide)\\n  | + => ++ {R} {S}\\n  | * => ** {R} {S}\\n  | negative => neg {R} {S}\\n  | ide => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.ide, R.ide, S.contains_ide)\\n  | natCoef => \\\\lam (n : Nat) => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2}\\n    (R.natCoef n, R.ide, S.contains_ide)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\lemma contains_pow \\\\hlevels  {this : SubMonoid} {x : E {S}} (_ : contains x) {n : Nat} : contains (pow {S} x n) ', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\lemma equals-lem \\\\hlevels  {R : CRing} {S : SubMonoid R} {a b : SType {R} S} (c : R.E) (_ : S.contains c)\\n  (_ : a.1 R.* b.2 R.* c = b.1 R.* a.2 R.* c) : inl~ {R} {S} a = inl~ {R} {S} b ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| A : \\\\Type', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro_*-right {x : E} : x * zro = zro', '| E : \\\\Set', '\\\\func SType \\\\hlevels  {R : CRing} (S : SubMonoid R) : \\\\Set => \\\\Sigma (_ y : R.E) (S.contains y)', '| contains (E {S}) : \\\\Prop', 'in~ A', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>\\Pi (p0 : A {\\this}) -> center {\\this} = p0", "completion": "\\lam p0 => (\\case \\elim p0 \\with {\n  | in~ a => equals-lem {R} {S} 0 (transport S p $ contains_pow {S} s) simplify\n})"}
{"prompt": "[\"x' : E\", 'y : E', \"xx'<gamma : \\\\Sigma (a : Rat) (a < gamma \u2227 fromInt (pos 1)) (zro <= a) (x <= x' + fromRat a) (x' <= x + fromRat a)\", 'x : E']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\lemma <=_* \\\\plevels  \\\\hlevels  {x x' y y' : ExUpperReal} (_ : x <= x') (_ : y <= y') : x * y <= x' * y' \", '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma rdistr_<= \\\\plevels  \\\\hlevels  {x y z : ExUpperReal} : (x + y) * z <= x * z + y * z ', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>x' * y <= x * y + fromRat xx'<gamma.1 * y", "completion": "<=_* xx'<gamma.5 <=-refl <=\u2218 rdistr_<="}
{"prompt": "['p : p0 /= p1', 'p1 : Fin 1', 'p0 : Fin 1', 'R : CRing', 'A : Matrix R.E 1 1']<<<break>>>['| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| at (j : Fin len) : A j', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| E : \\\\Set', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ']<<<break>>>at {at {A} p0} p1 = R.zro", "completion": "\\case \\elim p0, \\elim p1, \\elim p \\with {\n  | 0, 0, p => absurd (p idp)\n}"}
{"prompt": "['T : FinSet']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| E : \\\\Set', '| finEq : TruncP (Equiv {Fin finCard} {E})', '| finCard : Nat', '\\\\class Equiv \\\\extends Section, Retraction', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (Equiv {Fin T.finCard} {T.E})", "completion": "finEq {T}"}
{"prompt": "['V : LModule R', 'U : LModule R', 'ub : IsBasisSet {U} {J} u', 'v : J -> V.E', 'J : \\\\Set', 'x : E {Dom {\\\\this}}', 'u : J -> U.E', 'R : Ring']<<<break>>>['\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\func sum \\\\hlevels  {this : LModule} {J : \\\\Set} (g : J -> E) (c : Array (\\\\Sigma (E {R}) J)) : E \\n  => BigSum (\\\\new Array E c.len (\\\\lam (j : Fin c.len) => (c.at j).1 *c g (c.at j).2))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', \"basisSet-split \\\\hlevels  {R : Ring} {U V : LModule R} {J : \\\\Set} {u : J -> U.E} (ub : IsBasisSet {U} {J} u) (v : J -> V.E) (x : U.E) :\\n  \\\\Sigma (y : V.E) (TruncP (\\\\Sigma (c : Array (\\\\Sigma R.E J)) (x = sum {U} {J} u c) (y = sum {V} {J} v c))) \\n=> \\\\case rec-set {\\\\Sigma (c : Array (\\\\Sigma R.E J)) (x = sum {U} {J} u c)} {V.E} (ub.2 x)\\n  (\\\\lam (s : \\\\Sigma (c : Array (\\\\Sigma R.E J)) (x = sum {U} {J} u c)) => sum {V} {J} v s.1)\\n  (\\\\lam (s : \\\\Sigma (c : Array (\\\\Sigma R.E J)) (x = sum {U} {J} u c))\\n    (s' : \\\\Sigma (c : Array (\\\\Sigma R.E J)) (x = sum {U} {J} u c)) =>\\n    ~_= {V} {J} v {s.1} {s'.1} (=_~ {U} {J} {u} ub.1 {s.1} {s'.1} (inv {U.E} {x} {sum {U} {J} u s.1} s.2 *> s'.2))) \\\\with {\\n  | (y, t) => (y, map {\\\\Sigma (a : \\\\Sigma (c : Array (\\\\Sigma R.E J)) (x = sum {U} {J} u c)) (sum {V} {J} v a.1 = y)}\\n    {\\\\Sigma (c : Array (\\\\Sigma R.E J)) (x = sum {U} {J} u c) (y = sum {V} {J} v c)} t\\n    (\\\\lam (s : \\\\Sigma (a : \\\\Sigma (c : Array (\\\\Sigma R.E J)) (x = sum {U} {J} u c)) (sum {V} {J} v a.1 = y)) =>\\n      (s.1.1, s.1.2, inv {V.E} {sum {V} {J} v s.1.1} {y} s.2)))\\n}\", '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (c : Array (\\Sigma R.E J)) (x = sum {U} {J} u c) ((basisSet-split {R} {U} {V} {J} {u} ub v x).1 = sum {V} {J} v c))", "completion": "(basisSet-split ub v x).2"}
{"prompt": "[\"a' : Rat\", 'b : Real', \"a'<b : b.L a'\"]<<<break>>>['| L Rat : \\\\Prop', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '| L-rounded {q : Rat} (L q) : TruncP (\\\\Sigma (r : Rat) (L r) (q < r))']<<<break>>>TruncP (\\Sigma (r : Rat) (b.L r) (a' < r))", "completion": "L-rounded a'<b"}
{"prompt": "['x1 : X.E', 'X : ExPseudoNormedAbGroup', 'x2 : X.E']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '\\\\lemma terms-equality \\\\hlevels  {A : AbGroup} (env : Array A.E) (t s : Term env.len)\\n  (_ : interpretNF {toCGroup A} {env.len} env.at (normalize {env.len} (t :* :inverse {env.len} s)) = A.zro) :\\n  interpret {toCGroup A} {env.len} env.at t = interpret {toCGroup A} {env.len} env.at s ', ':inverse (Term n)', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func normalize \\\\plevels  \\\\hlevels  {n4 : Nat} (_ : Term n4) : Array Int n4 \\n  | {n}, var v => singleAt {Int} {n} v (pos 1) (pos 0)\\n  | {n}, :ide => replicate {Int} n (pos 0)\\n  | {n}, :inverse t => map {Int} {Int} negative (normalize {n} t)\\n  | {n}, t :* s => mkArray {Int} {n} (\\\\lam (j : Fin n) => at {normalize {n} t} j + at {normalize {n} s} j)', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '| at (j : Fin len) : A j', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', 'var (Fin n)', '\\\\func interpretNF \\\\hlevels  {G : CGroup} {n : Nat} (env : Fin n -> G.E) (l : Array Int n) : G.E \\n  => sBigProd {G} (toArray {G} l (\\\\new Array G.E l.len env))', '\\\\infixl 7 :* (_ _ : Term n)']<<<break>>>norm {X} x2 <= norm {X} (x1 X.+ (x2 - x1))", "completion": "=_<= (pmap norm abGroup)"}
{"prompt": "['g : OrderedC*AlgebraHom X Z', 'map-char : \\\\Pi {x : E} ->\\nfunc {dense-normed-lift {toBanach {X}} {toBanach {Y}} {Z} (toIsometry {f} fi) ((dense-toNormed {f}).1 fd) (toNormed {g})}\\n  (func {toIsometry {f} fi} x) = func {toNormed {g}} x', 'fi : IsIsometric {f}', 'Z : StoneC*Algebra', 'Y : OrderedC*Algebra', 'fd : IsDense {f}', 'X : OrderedC*Algebra', 'f : OrderedC*AlgebraHom X Y', 'map : NormedAbGroupMap (toBanach {Y}) Z {\\n  | func => cauchy-lift {toBanach {X}} {toBanach {Y}} {Z} (toIsometry {f} fi) {?hidden} (toNormed {g})\\n}']<<<break>>>['\\\\lemma fromNormed \\\\hlevels  {X : OrderedC*Algebra} {Y : StoneC*Algebra} (f : RingHom X Y) (_ : \\\\Pi {x : X.E} -> Y.norm (f.func x) <= norm x) :\\nOrderedC*AlgebraHom X Y {\\n  | func => f.func\\n} ', '\\\\lemma *-locally-uniform \\\\hlevels  {X : ExPseudoNormedPseudoRing} : LocallyUniformMap (X \u2a2f X) X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 X.* s.2\\n} ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| Cod : BaseSet', '\\\\instance RegularPreuniformSpaceHasProduct \\\\hlevels  : HasProduct RegularPreuniformSpace {\\n  | Product => ProductRegularPreuniformSpace\\n} => \\\\new HasProduct', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : TopSpace} (g : ContMap Y Z) (f : ContMap X Y) : ContMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\func dense-normed-lift \\\\hlevels  {X Y : ExPseudoNormedAbGroup} {Z : CompleteExNormedAbGroup} (f : NormedIsometricMap X Y) (fd : IsDense {f})\\n  (g : NormedAbGroupMap X Z) : NormedAbGroupMap Y Z {\\n  | func => cauchy-lift {X} {Y} {Z} f {?hidden} g\\n} => \\\\new NormedAbGroupMap {\\n  | func-+ => {?hidden}\\n  | func-norm => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '\\\\lemma dense-lift-unique \\\\hlevels  {X Y : TopSpace} {Z : HausdorffTopSpace} (f : ContMap X Y) (_ : IsDense {f}) (g h : ContMap Y Z)\\n  (_ : \\\\Pi (x : X.E) -> g.func (f.func x) = h.func (f.func x)) (y : Y.E) : g.func y = h.func y ', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| func-norm {x : E {Dom}} : norm {Cod} (func x) <= norm {Dom} x', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func proj1 \\\\hlevels  {X Y : TopSpace} : ContMap (X \u2a2f Y) X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| ide : E', '\\\\instance TopSpaceHasProduct \\\\hlevels  : HasProduct TopSpace {\\n  | Product => ProductTopSpace\\n} => \\\\new HasProduct', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| func-ide : func (ide {Dom}) = ide {Cod}', '\\\\class OrderedC*AlgebraHom \\\\extends RingHom, PosetHom \\\\hlevels ', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ', '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '\\\\lemma toNormed \\\\hlevels  {this : OrderedC*AlgebraHom} : NormedAbGroupMap (toBanach {Dom}) (toBanach {Cod}) {\\n  | func => func\\n} ', '\\\\lemma toIsometry \\\\hlevels  {this : OrderedC*AlgebraHom} (_ : IsIsometric) : NormedIsometricMap (toBanach {Dom}) (toBanach {Cod}) {\\n  | func => func\\n} ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", \"\\\\lemma isDense \\\\hlevels  {X X' Y Y' : TopSpace} {f : ContMap X Y} {g : ContMap X' Y'} (_ : IsDense {f}) (_ : IsDense {g}) :\\n  IsDense {prod {X} {X'} {Y} {Y'} f g} \", '\\\\lemma dense-toNormed \\\\hlevels  {this : OrderedC*AlgebraHom} : OrderedC*AlgebraHom.IsDense <-> ContMap.IsDense {toNormed} ', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func toBanach \\\\hlevels  {this107 : OrderedC*Algebra} : RealPreBanachAlgebra E {\\n  | isOpen => isOpen\\n  | isCauchy => isCauchy\\n  | isUniform => isUniform\\n  | dist => ExPseudoNormedAbGroup.dist\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | negative => negative\\n  | norm => OrderedC*Algebra.toBanach.norm\\n  | * => (Semigroup.*)\\n  | ide => ide\\n  | natCoef => natCoef\\n} => \\\\new RealPreBanachAlgebra {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | norm-double => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | norm_*_<= => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_ide_<= => {?hidden}\\n}', '\\\\func proj2 \\\\hlevels  {X Y : TopSpace} : ContMap (X \u2a2f Y) Y {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.2\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', \"\\\\func prod \\\\hlevels  {X X' Y Y' : TopSpace} (f : ContMap X Y) (f' : ContMap X' Y') : ContMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} x, func {f' \u2218 proj2 {X} {X'}} x)\\n} => tuple {X \u2a2f X'} {Y} {Y'} (f \u2218 proj1 {X} {X'}) (f' \u2218 proj2 {X} {X'})\"]<<<break>>>OrderedC*AlgebraHom Y Z {\n  | func => map.func\n}", "completion": "fromNormed (\\new RingHom {\n  | func => map\n  | func-+ => map.func-+\n  | func-ide => pmap map (inv (func-ide {f})) *> map-char *> func-ide {g}\n  | func-* => \\lam {x} {y} => dense-lift-unique (prod (toNormed {f}) (toNormed {f})) (isDense ((dense-toNormed {f}).1 fd) ((dense-toNormed {f}).1 fd))\n    (map \u2218 *-locally-uniform) (*-locally-uniform \u2218 prod map map)\n    (\\lam s => pmap map (inv (func-* {f})) *> map-char *> func-* {g} *> inv (pmap2 (*) map-char map-char)) (x, y)\n}) (func-norm {map})"}
{"prompt": "['R : GradedCRing']<<<break>>>['\\\\class Locale \\\\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\\\hlevels  {\\n  | Join-ldistr>= {J : \\\\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\\\lam (j : J) => e \u2227 f j)\\n  | basicCover-stable => \\\\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\\\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\\n    meet-univ {x} {Join {J} (\\\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\\\lam (j : J) => (g j).1} {x}\\n  | ldistr>= => \\\\lam {x : E} {y : E} {z : E} => (\\n    \\\\have t => path (\\\\lam (i : I) (b : Bool) => (\\\\case b \\\\with {\\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\\n          }) @ i)\\n    \\\\in transportInv\\n        {Bool -> E} (\\\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\\n          {\\\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\\\lam (b : Bool) => x \u2227 if {E} b y z} t\\n          (Join-ldistr>= {Bool} {\\\\lam (p0 : Bool) => if {E} p0 y z} {x}))\\n  | Meet-cond => \\\\lam {J : \\\\Set} (j : J) {f : J -> E} =>\\n  Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n    {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)\\n  | join-left => \\\\lam {x : E} {y : E} => Join-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | join-right => \\\\lam {x : E} {y : E} => Join-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | Meet-univ => \\\\lam {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) =>\\n  Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n    {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  | join-univ => \\\\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\\n  Join-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n    | true => x<=z\\n    | false => y<=z\\n  }))\\n  | join => \\\\lam (x : E) (y : E) => Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)\\n  | Meet => \\\\lam {J : \\\\Set} (g : J -> E) =>\\n    Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)\\n  | isBasicCover => \\\\lam (x : Ob) {J : \\\\Set} (g : J -> Ob) => x <= Join {J} (\\\\lam (j : J) => (g j).1)\\n}', '\\\\func closure \\\\hlevels  {P : FramePres} {J : \\\\Set} (g : J -> P.E) : Opens P \\n=> (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g, \\\\lam (x : P.E) (c : SCover {P} x (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g)) =>\\n  cover-trans {P} {x} {J} {g} {\\\\Sigma (x : P.E) (Cover {P} x {J} g)} {\\\\lam (t : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => t.1} c (\\\\lam (p0 : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => p0.2))', '| conj E E : E', '\\\\func SCover \\\\hlevels  {this : FramePres} (x : E) (U : E -> \\\\Prop) : \\\\Prop \\n  => Cover x {\\\\Sigma (x : E) (U x)} (\\\\lam (t : \\\\Sigma (x : E) (U x)) => t.1)', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| E : \\\\Set', '\\\\func ProjPres \\\\hlevels  (R : GradedCRing) : FramePres (Carrier R) {\\n  | conj => h* {R}\\n  | BasicCover => Indexing {Or (\\\\Sigma (n : Nat) (a b : R.E) (R.isHomogen a (suc n)) (R.isHomogen b (suc n))) Nat}\\n    {\\\\Sigma (a : R.E) (n : Nat) (R.isHomogen a (suc n))}\\n    (\\\\lam (p0 : Or (\\\\Sigma (n : Nat) (a b : R.E) (R.isHomogen a (suc n)) (R.isHomogen b (suc n))) Nat) => (\\\\case p0 \\\\with {\\n      | inl (n, a, b, ah, bh) =>\\n        (Bool, (a R.+ b, n, R.homogen-+ {suc n} {a} {b} ah bh), \\\\lam (p0 : Bool) => if {Carrier R} p0 (a, n, ah) (b, n, bh))\\n      | inr n => (Empty, (R.zro, n, R.homogen-zro {suc n}), absurd {\\\\Sigma (a : R.E) (n : Nat) (R.isHomogen a (suc n))})\\n    }))\\n} => \\\\new FramePres', '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x']<<<break>>>Locale (Opens (ProjPres R)) {\n  | <= => (<=)\n  | meet => \\lam (U : E {\\this}) (V : E {\\this}) =>\n    closure {ProjPres R} {\\Sigma (a b : E) (U.1 a) (V.1 b)} (\\lam (t : \\Sigma (a b : E) (U.1 a) (V.1 b)) => conj t.1 t.2)\n  | top => (\\lam (_ : E) => \\Sigma, \\lam (e : E) (_ : SCover {ProjPres R} e (\\lam (_ : E) => \\Sigma)) => ())\n  | Join => \\lam {J : \\Set} (f : J -> E {\\this}) =>\n    closure {ProjPres R} {\\Sigma (j : J) (x : E) ((f j).1 x)} (\\lam (p0 : \\Sigma (j : J) (x : E) ((f j).1 x)) => p0.2)\n}", "completion": "PresentedFrame (ProjPres R)"}
{"prompt": "['j : Ob {J {\\\\this}}', \"w : Ob {J {limit {D} {commaPrecat {TrivialCat} {C} {C'} (Const {TrivialCat} {C'} (Functor.F {G} j')) p}\\n  (Comp {commaPrecat {TrivialCat} {C} {C'} (Const {TrivialCat} {C'} (Functor.F {G} j')) p} {C} {D} RightKanExt.DoubleLimit.F\\n    (rightForget {TrivialCat} {C} {C'} (Const {TrivialCat} {C'} (Functor.F {G} j')) p))}}\", \"j' : Ob {J {\\\\this}}\", 'this : DoubleLimit', \"h : Hom {J {\\\\this}} j j'\"]<<<break>>>[\"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| D : Precat', \"| p : Functor C C'\", \"\\\\func lim' \\\\plevels obj >= hom \\\\hlevels  {this : DoubleLimit} :\\n  Limit {commaPrecat {J} {C} {C'} G p} {D} (Comp {commaPrecat {J} {C} {C'} G p} {C} {D} F (rightForget {J} {C} {C'} G p)) \\n  => limit {D} {commaPrecat {J} {C} {C'} G p} (Comp {commaPrecat {J} {C} {C'} G p} {C} {D} F (rightForget {J} {C} {C'} G p))\", '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '| G : Functor J D', \"| C' : Precat\", '| C : Precat', '| C : Precat', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", \"| G : Functor J C'\", '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| apex : Ob {D}', '| id (X : Ob) : Hom X X', '| D : Precat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| J : Precat', '| Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)']<<<break>>>Func {Cone.G} {(j, w.2, id {C'} (F {p} w.2) \u2218 w.3 \u2218 Func {RightKanExt.DoubleLimit.G} {j} {j'} h)} {(j', w.2, w.3)}\n  (h, id {RightKanExt.DoubleLimit.C} w.2, inv {Hom {C'} (F {RightKanExt.DoubleLimit.G} j) (F {p} w.2)}\n    {Func {p} {w.2} {w.2} (id {RightKanExt.DoubleLimit.C} w.2) \u2218 (id {C'} (F {p} w.2) \u2218 w.3 \u2218 Func {RightKanExt.DoubleLimit.G} {j} {j'} h)}\n    {w.3 \u2218 Func {RightKanExt.DoubleLimit.G} {j} {j'} h}\n    (pmap {Hom {C'} (F {p} w.2) (F {p} w.2)} {Hom {C'} (F {RightKanExt.DoubleLimit.G} j) (F {p} w.2)}\n      (\\lam (_x : Hom {C'} (F {p} w.2) (F {p} w.2)) => _x \u2218 (id {C'} (F {p} w.2) \u2218 w.3 \u2218 Func {RightKanExt.DoubleLimit.G} {j} {j'} h))\n      {Func {p} {w.2} {w.2} (id {Functor.C {p}} w.2)} {id {Functor.D {p}} (F {p} w.2)} (Func-id {p} {w.2}) *> id-left {C'} {F {RightKanExt.DoubleLimit.G} j} {F {p} w.2}\n      {id {C'} (F {p} w.2) \u2218 w.3 \u2218 Func {RightKanExt.DoubleLimit.G} {j} {j'} h} *> o-assoc {C'} {F {RightKanExt.DoubleLimit.G} j} {F {RightKanExt.DoubleLimit.G} j'} {F {p} w.2} {F {p} w.2} {id {C'} (F {p} w.2)}\n      {w.3} {Func {RightKanExt.DoubleLimit.G} {j} {j'} h} *> id-left {C'} {F {RightKanExt.DoubleLimit.G} j} {F {p} w.2} {w.3 \u2218 Func {RightKanExt.DoubleLimit.G} {j} {j'} h})) \u2218 coneMap (j, w.2, id {C'} (F {p} w.2) \u2218 w.3 \u2218 Func {RightKanExt.DoubleLimit.G} {j} {j'} h) = coneMap (j', w.2, w.3)", "completion": "coneCoh {lim' {this}} {(j, w.2, id (p {this} w.2) \u2218 w.3 \u2218 Func {G {this}} h)} {(j', w.2, w.3)}\n  (h, id w.2, inv $ pmap (\\lam _x => _x \u2218 _) Func-id *> id-left *> o-assoc *> id-left)"}
{"prompt": "['S : SubRing R', 'R : Ring', 'c : Contr R.E']<<<break>>>['| center : A', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"| contraction (a' : A) : center = a'\", '| contains_ide : contains (ide {S})', '| A : \\\\Type', '| ide : E', '| E : \\\\Set', '| contains (E {S}) : \\\\Prop']<<<break>>>S.contains c.center", "completion": "rewrite (contraction {c} 1) (contains_ide {S})"}
{"prompt": "[]<<<break>>>['| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '\\\\instance CRingCat : Cat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {RingCat} {CRing} (\\\\new Embedding {CRing} {Ob} (\\\\lam (R : A {\\\\this}) => R) {\\n  | isEmb => \\\\lam (R S : A {\\\\this}) =>\\n  \\\\new Retraction {R = S} {f {\\\\this} R = f {\\\\this} S} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {R} {S}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new CRing (E {p @ i}) {\\n      | zro => zro {p @ i}\\n      | + => (+) {p @ i}\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*) {p @ i}\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | negative => negative {p @ i}\\n      | negative-left => {?hidden}\\n      | ide => ide {p @ i}\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef {p @ i}\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n    })\\n    | f_sec => idpe {R = S}\\n  }\\n})', '| Hom Ob Ob : \\\\Set', '| id (X : Ob) : Hom X X', '\\\\class Functor \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F (Ob {C}) : Ob {D}\\n  | Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)\\n  | Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)\\n  | Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Ob : \\\\hType', '| C : Precat', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}']<<<break>>>Functor CRingCat SetCat (\\lam (R : Ob {C {\\this}}) => R.E) {\n  | Func => \\lam {X Y : Ob {C {\\this}}} (f : Hom {C {\\this}} X Y) => f.func\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "completion": "\\new Functor {\n  | C => CRingCat\n  | D => SetCat\n  | F => \\lam R => R\n  | Func => \\lam f => f\n  | Func-id => idp\n  | Func-o => idp\n}"}
{"prompt": "['u : E', 'this : Dec', 'b : Array E 2', 'm : Array Nat 2', 'a : E']<<<break>>>['| len : Nat', '\\\\field mData : MonoidData {R} vars', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| M : Monoid', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '| E : \\\\Set', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', '| vars : Array (E {M})', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>CRingData (a :: b !! 0 :: pow u (m !! 1) :: u :: b !! 1 :: pow a (m !! 0) :: nil) {\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new CRingData {\n  | R => this\n  | vars => a :: b !! 0 :: pow u (m !! 1) :: u :: b !! 1 :: pow a (m !! 0) :: nil\n}"}
{"prompt": "['X : ExPseudoNormedRing', 'x : X.E', 'eps : Rat', 'xy<eps : U {X.dist x y} eps', 'y : X.E']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| dist E E : ExUpperReal', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '| dist-symm {x y : E} : dist x y = dist y x', '\\\\lemma <_<= \\\\plevels  \\\\hlevels  {x : ExUpperReal} {q : Rat} (_ : x.U q) : x <= fromRat q ', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>X.dist y x + X.norm x <= fromRat eps + X.norm x", "completion": "<=_+ {ExUpperRealAbMonoid} (transport (\\lam _x => _x <= _) (dist-symm {X}) $ <_<= xy<eps) <=-refl"}
{"prompt": "['a^n=c : pow {R} a n = c', 'R : CRing', 'n : Nat', 'a : E {P {\\\\this}}', 'y : R.E', 'c : R.E']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\instance LocRing \\\\hlevels  {R : CRing} (S : SubMonoid R) : CRing (Type {R} {S}) {\\n  | zro => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.zro, R.ide, S.contains_ide)\\n  | + => ++ {R} {S}\\n  | * => ** {R} {S}\\n  | negative => neg {R} {S}\\n  | ide => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.ide, R.ide, S.contains_ide)\\n  | natCoef => \\\\lam (n : Nat) => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2}\\n    (R.natCoef n, R.ide, S.contains_ide)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '| E : \\\\Set', '| negative E : E', '| contains (E {S}) : \\\\Prop', 'in~ A', '| len : Nat', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', '| ide-left {x : E} : ide * x = x', '| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| contains_ide : contains (ide {S})', '\\\\func powers \\\\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (pow {M} a n = x))) \\n=> \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\func inl~ \\\\hlevels  {R : CRing} {S : SubMonoid R} (x : SType {R} S) : Type {R} {S} \\n  => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} x', '| C : Semiring', 'suc Nat', '\\\\lemma lmake \\\\hlevels  {M : CMonoid} {x : M.E} (y : M.E) (_ : y M.* x = M.ide) : Inv {M} x y ', 'coef C', 'nil', 'inP A', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', ':ide', '\\\\lemma equals1 \\\\hlevels  {R : CRing} {S : SubMonoid R} {a b : SType {R} S} (_ : a.1 R.* b.2 = b.1 R.* a.2) : inl~ {R} {S} a = inl~ {R} {S} b ', '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', ':zro', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '\\\\lemma pow_*-comm \\\\hlevels  {this : CMonoid} {a b : E} {n : Nat} : pow (a * b) n = pow a n * pow b n ', '\\\\func SType \\\\hlevels  {R : CRing} (S : SubMonoid R) : \\\\Set => \\\\Sigma (_ y : R.E) (S.contains y)', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '| zro : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", 'var V', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>Inv {LocRing {R} (powers {R} (a R.* (y R.+ pow {R} a n)))} (in~ {SType {R} (powers {R} (a R.* (y R.+ pow {R} a n)))}\n  {\\lam (a1 : SType {R} (powers {R} (a R.* (y R.+ pow {R} a n)))) (b : SType {R} (powers {R} (a R.* (y R.+ pow {R} a n)))) =>\n    a1.1 R.* b.2 = b.1 R.* a1.2}\n  (y R.* pow {R} (y R.+ pow {R} a n) n, pow {R} (a R.* (y R.+ pow {R} a n)) n,\n    inP {\\Sigma (n1 : Nat) (pow {R} (a R.* (y R.+ pow {R} a n)) n1 = pow {R} (a R.* (y R.+ pow {R} a n)) n)}\n      (n, idp {R.E} {pow {R} (a R.* (y R.+ pow {R} a n)) n})) + ide)\n  (inl~ {R} {powers {R} (a R.* (y R.+ pow {R} a n))} (pow {R} a (suc n), a R.* (y R.+ pow {R} a n),\n    inP {\\Sigma (n1 : Nat) (pow {R} (a R.* (y R.+ pow {R} a n)) n1 = a R.* (y R.+ pow {R} a n))}\n      (1, R.ide-left {a R.* (y R.+ pow {R} a n)})))", "completion": "lmake (inl~ (pow a (suc n), a * (y + pow a n), later $ inP (1, ide-left))) (equals1 $ later $ rewrite pow_*-comm equation)"}
{"prompt": "['this : AddGroup', 'x : E']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| negative E : E', '| E : \\\\Set', '| negative-right {x : E} : x + negative x = zro']<<<break>>>negative x + negative (negative x) = zro", "completion": "negative-right {this}"}
{"prompt": "['x : InfReal', 'this : InfReal (L {LowerRealAbMonoid.meet x y}) (U {ExUpperReal.meet x y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n}', 'y : InfReal']<<<break>>>['| LU-located {q r : Rat} (q < r) : L q || U r', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| L Rat : \\\\Prop', 'byLeft A', '\\\\lemma meet_U \\\\plevels  \\\\hlevels  {x y : ExUpperReal} {a : Rat} : U {meet x y} a <-> x.U a || y.U a ', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| U Rat : \\\\Prop', '| \\\\infix 4 < E E : \\\\Prop', '\\\\lemma meet_L \\\\plevels  \\\\hlevels  {x y : LowerReal} {a : Rat} : L {meet x y} a <-> (\\\\Sigma (x.L a) (y.L a)) ', 'byRight B']<<<break>>>\\Pi {q r : Rat} -> q < r -> L {\\this} q || U {\\this} r", "completion": "\\lam q<r => (\\scase LU-located {x} q<r, LU-located {y} q<r \\with {\n  | byLeft q<x, byLeft q<y => byLeft $ meet_L.2 (q<x, q<y)\n  | _, byRight y<r => byRight $ meet_U.2 (byRight y<r)\n  | byRight x<r, _ => byRight $ meet_U.2 (byLeft x<r)\n})"}
{"prompt": "['bs : Array A.E n', 'as : Array A.E n', 'A : Dec', 'n : Nat']<<<break>>>['\\\\func trichotomy {n1 : Nat} {A2 : Dec} (as1 bs1 : Array A.E n1) : Tri {\\\\new StrictPoset (Array A.E n1) {\\n  | < => (<A)\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n}} as1 bs1 \\n  | {0}, {A}, nil, nil => equals {\\\\new StrictPoset (Array A.E 0) {\\n    | < => (<A)\\n    | <-irreflexive => {?hidden}\\n    | <-transitive => {?hidden}\\n  }} {nil} {nil} (idp {Array A.E 0} {nil})\\n  | {suc n}, {A}, a :: as, b :: bs => \\\\case A.trichotomy a b \\\\with {\\n    | less a<b => less {\\\\new StrictPoset (Array A.E (suc n)) {\\n      | < => (<A)\\n      | <-irreflexive => {?hidden}\\n      | <-transitive => {?hidden}\\n    }} {a :: as} {b :: bs} (<head {n} {A} {a} {as} {b} {bs} a<b)\\n    | equals a=b => \\\\case LexicographicalArray.trichotomy {n} {A} as bs \\\\with {\\n      | less as<bs => less {\\\\new StrictPoset (Array A.E (suc n)) {\\n        | < => (<A)\\n        | <-irreflexive => {?hidden}\\n        | <-transitive => {?hidden}\\n      }} {a :: as} {b :: bs} (<tail {n} {A} {a} {as} {b} {bs} a=b as<bs)\\n      | equals as=bs => equals {\\\\new StrictPoset (Array A.E (suc n)) {\\n        | < => (<A)\\n        | <-irreflexive => {?hidden}\\n        | <-transitive => {?hidden}\\n      }} {a :: as} {b :: bs} (pmap2 {A.E} {Array A.E n} {Array A.E (suc n)} (::) {a} {b} a=b {as} {bs} as=bs)\\n      | greater as>bs => greater {\\\\new StrictPoset (Array A.E (suc n)) {\\n        | < => (<A)\\n        | <-irreflexive => {?hidden}\\n        | <-transitive => {?hidden}\\n      }} {a :: as} {b :: bs} (<tail {n} {A} {b} {bs} {a} {as} (inv {A.E} {a} {b} a=b) as>bs)\\n    }\\n    | greater a>b => greater {\\\\new StrictPoset (Array A.E (suc n)) {\\n      | < => (<A)\\n      | <-irreflexive => {?hidden}\\n      | <-transitive => {?hidden}\\n    }} {a :: as} {b :: bs} (<head {n} {A} {b} {bs} {a} {as} a>b)\\n  }', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class StrictPoset \\\\extends BaseSet \\\\hlevels  {\\n  | \\\\infix 4 < E E : \\\\Prop\\n  | <-irreflexive {x : E} : Not (x < x)\\n  | <-transitive \\\\alias \\\\infixr 9 <\u2218 {x y z : E} (x < y) (y < z) : x < z\\n  | \\\\infix 4 > E E : \\\\Prop\\n  | > => \\\\lam (x : E) (y : E) => y < x\\n}', '\\\\data \\\\infix 4 <A \\\\hlevels  {n : Nat} {A : Dec} (_ _ : Array A.E n) : \\\\Prop \\\\with\\n  | {suc n}, {A}, a :: as, b :: bs => <head (a A.< b)\\n  | {suc n}, {A}, a :: as, b :: bs => <tail (a = b) (as <A bs)', \"\\\\data Tri \\\\hlevels  {A : StrictPoset} (_ _ : A.E) \\n  | less (a A.< a')\\n  | equals (a = a')\\n  | greater (a A.> a')\", '\\\\lemma <-irreflexive {n : Nat} {A : Dec} {l : Array A.E n} (_ : l <A l) : Empty ', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\lemma <-transitive {n : Nat} {A : Dec} {as bs cs : Array A.E n} (_ : as <A bs) (_ : bs <A cs) : as <A cs ']<<<break>>>Tri {\\new StrictPoset (Array A.E n) {\n  | < => (<A)\n  | <-irreflexive => {?hidden}\n  | <-transitive => {?hidden}\n}} as bs", "completion": "trichotomy as bs"}
{"prompt": "[\"-fx<=a' : negative {Cod} (func x) <= a' *q ide {Cod}\", 'this : OrderedC*AlgebraHom', 'x : E {Dom}', \"a'>0 : zro < a'\", \"a' : Rat\"]<<<break>>>['\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| ide : E', '| \\\\infix 4 <= E E : \\\\Prop', '| Cod : BaseSet', '| negative E : E', '| func (E {Dom}) : E {Cod}', '\\\\lemma <=_*q-rotate_finv-left \\\\hlevels  {this : PosetQModule} {q : Rat} (_ : zro < q) {a b : E} (_ : a <= q *q b) : finv q *q a <= b ']<<<break>>>finv a' *q negative {Cod} (func x) <= ide {Cod}", "completion": "<=_*q-rotate_finv-left a'>0 -fx<=a'"}
{"prompt": "['x>=0 : fromInt (pos 0) <= x', 'x : Rat']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', 'pos Nat', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\func ratDenom \\\\plevels  \\\\hlevels  (_ : Rat) : Nat \\n  | rat nom d denom/=0 reduced => d', '| zro_*-left {x : E} : zro * x = zro', '\\\\func ratNom \\\\plevels  \\\\hlevels  (_ : Rat) : Int \\n  | rat n denom denom/=0 reduced => n', \"\\\\func transport2 {A B : \\\\Type} (C : A -> B -> \\\\Type) {a a' : A} {b b' : B} (_ : a = a') (_ : b = b') (_ : C a b) : C a' b' \\n  | {A}, {B}, C, {a}, {a'}, {b}, {b'}, idp, idp, c => c\", '| ide-right {x : E} : x * ide = x', '\\\\lemma <=-char-conv \\\\plevels  \\\\hlevels  {q r : Rat} (_ : q <= r) : ratNom q * pos (ratDenom r) <= ratNom r * pos (ratDenom q) ']<<<break>>>pos 0 <= ratNom x", "completion": "transport2 (\\lam p0 p1 => pos p0 <= p1) (zro_*-left {NatSemiring}) ide-right (<=-char-conv x>=0)"}
{"prompt": "['B : Rat', 'B1 : E']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| join-left {x y : E} : x <= x \u2228 y']<<<break>>>fromRat B <= fromRat B1", "completion": "<=-rat.1 join-left"}
{"prompt": "['t : Term Int env.len', 's : Term Int env.len', 'env : Array R.E', 'R : Ring']<<<break>>>['| len : Nat', '\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| env : Array (E {R})', \"\\\\func RingData \\\\hlevels  {R1 : Ring} (env : Array R.E) : Data R1 IntRing IntRing (intMap' {R1}) env => \\\\new Data {\\n  | alg-comm => {?hidden}\\n}\", \"\\\\func multiply \\\\hlevels  {n2 : Nat} {C2 : Monoid} (_ _ : NF C.E n2) : NF C.E n2 \\n  | {n}, {C}, l1, nil => nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, l1, l2 => multiply' {n} {C} l1 l2 (nil {\\\\Sigma (List (Fin n)) C.E})\", \"\\\\lemma collapse-consistent \\\\hlevels  {this : Data} {l : NF} : interpretNF' (collapse {len {env}} {C} l) = interpretNF' l \", '| R : Semiring', '\\\\func collapse \\\\hlevels  {n2 : Nat} {C2 : AddMonoid} (_ : NF C.E n2) : NF C.E n2 \\n  | {n}, {C}, nil => nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, a :: l => collapse1 {n} {C} a.2 a.1 l', '| C : Semiring', '| E : \\\\Set', \"\\\\func interpretNF' \\\\hlevels  {this3 : Data} (_ : NF) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => mulCoef x.2 x.1\\n  | {this}, x :: l => mulCoef x.2 x.1 + interpretNF' l\", '\\\\func normalize \\\\hlevels  {n7 : Nat} {C7 : Dec} (_ : Term C.E n7) : NF C.E n7 \\n  | {n}, {C}, var v => (v :: nil {Fin n}, C.ide) :: nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, coef c => (nil {Fin n}, c) :: nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, :zro => nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, :ide => (nil {Fin n}, C.ide) :: nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, :negative t =>\\n  map {\\\\Sigma (List (Fin n)) C.E} {\\\\Sigma (List (Fin n)) C.E} (\\\\lam (s : \\\\Sigma (List (Fin n)) C.E) => (s.1, C.negative s.2))\\n    (normalize {n} {C} t)\\n  | {n}, {C}, t :+ s => normalize {n} {C} t ++ normalize {n} {C} s\\n  | {n}, {C}, t :* s =>\\n    remove0 {n} {C} {\\\\new C {}} (collapse {n} {C} (multiply {n} {C} (normalize {n} {C} t) (normalize {n} {C} s)))']<<<break>>>interpretNF' {RingData {R1} env1}\n  (collapse {len {env}} {C} (multiply {env.len} {IntRing} (normalize {env.len} {IntRing} t) (normalize {env.len} {IntRing} s))) = interpretNF'\n  {RingData {R1} env1} (multiply {env.len} {IntRing} (normalize {env.len} {IntRing} t) (normalize {env.len} {IntRing} s))", "completion": "collapse-consistent {RingData {R} env}"}
{"prompt": "['l : PFunc {V} {B}', 'B : BooleanRing', 'V : PosetQModule', 'b : B.E']<<<break>>>['| len : Nat', '| \\\\infixl 7 * E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func diff \\\\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y', \"\\\\lemma BigJoin_join \\\\hlevels  {this : BottomJoinSemilattice} {n : Nat} {l l' : Array E n} :\\n  BigJoin (\\\\new Array E n (\\\\lam (i : Fin n) => l.at i \u2228 l'.at i)) = BigJoin l \u2228 BigJoin l' \", '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>BigJoin {B} (\\new Array B.E l.len (\\lam (i : Fin l.len) =>\n  at {map {\\Sigma V.E B.E} {B.E} (\\lam (s : \\Sigma V.E B.E) => b B.* s.2) l} i B.\u2228 at {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2)\n    (map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 b)) l)} i)) = BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (s : \\Sigma V.E B.E) => b B.* s.2) l) B.\u2228 BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2)\n  (map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 b)) l))", "completion": "BigJoin_join {B} {_} {map (\\lam s => b * s.2) l}"}
{"prompt": "['j<=k : j <= k', 'j : Nat', 'k : Nat']<<<break>>>[\"\\\\lemma <=_exists \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n <= m) : n + (m -' n) = m \", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)']<<<break>>>j + (k -' j) = k", "completion": "<=_exists j<=k"}
{"prompt": "['E : CocompleteCat', 'C : Precat', 'A : Functor C E', 'x : C.Ob']<<<break>>>['\\\\instance Precategory-of-elements \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (P : Ob) : Precat (\\\\Sigma (c : C.Ob) (Functor.F {P.F} c)) {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => \\\\Sigma (u : C.Hom x.1 y.1) (x.2 = Func {P.F} {y.1} {x.1} u y.2)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (C.id p0.1, transportInv\\n    {Functor.F {P.F} p0.1 -> Functor.F {P.F} p0.1} (\\\\lam (x : Functor.F {P.F} p0.1 -> Functor.F {P.F} p0.1) => p0.2 = x p0.2)\\n      {Func {P.F} {p0.1} {p0.1} (id p0.1)} {id (Functor.F {P.F} p0.1)} (Func-id {P.F} {p0.1})\\n      (idp {Functor.F {P.F} p0.1} {p0.2}))\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) =>\\n  (p0.1 C.\u2218 p1.1, p1.2 *> transportInv {Functor.F {P.F} Y.1}\\n    (\\\\lam (x : Functor.F {P.F} Y.1) => Func {P.F} {Y.1} {X.1} p1.1 x = Func {P.F} {Z.1} {X.1} (p0.1 C.\u2218 p1.1) Z.2) {Y.2}\\n    {Func {P.F} {Z.1} {Y.1} p0.1 Z.2} p0.2 (transportInv {Functor.F {P.F} Z.1 -> Functor.F {P.F} X.1}\\n      (\\\\lam (x : Functor.F {P.F} Z.1 -> Functor.F {P.F} X.1) => Func {P.F} {Y.1} {X.1} p1.1 (Func {P.F} {Z.1} {Y.1} p0.1 Z.2) = x Z.2)\\n      {Func {P.F} {Z.1} {X.1} (p1.1 \u2218 p0.1)} {Func {P.F} {Y.1} {X.1} p1.1 \u2218 Func {P.F} {Z.1} {Y.1} p0.1}\\n      (Func-o {P.F} {Z.1} {Y.1} {X.1} {p1.1} {p0.1})\\n      (idp {Functor.F {P.F} X.1} {Func {P.F} {Y.1} {X.1} p1.1 (Func {P.F} {Z.1} {Y.1} p0.1 Z.2)})))\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func hom-presheaf \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (c : C.Ob) : VPresheaf SetCat C\\n  (\\\\new Functor (op {VPresheaf.C {\\\\this}}) (VPresheaf.D {\\\\this}) (\\\\lam (x : Ob {Functor.C {\\\\this}}) => C.Hom x c) {\\n    | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) (g : F {\\\\this} X) => g C.\u2218 f\\n    | Func-id => {?hidden}\\n    | Func-o => {?hidden}\\n  }) => \\\\new VPresheaf', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| Hom Ob Ob : \\\\Set', '\\\\class Functor \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F (Ob {C}) : Ob {D}\\n  | Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)\\n  | Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)\\n  | Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f\\n}', '\\\\func projection \\\\plevels obj >= hom \\\\hlevels  {C1 : Precat} {P : Ob} : Functor (Precategory-of-elements {C1} P) C1 (\\\\lam (p0 : Ob {C {\\\\this}}) => p0.1) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (p0 : Hom {C {\\\\this}} X Y) => p0.1\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func diagram-functor \\\\hlevels  {C1 : Precat} {E : CocompleteCat} {A : Functor C1 E} (P : Ob) :\\nFunctor (Precategory-of-elements {C1} P) E (\\\\lam (X : Ob {C {\\\\this}}) => A.F (F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => A.Func {F X} {F Y} (Func {X} {Y} f)\\n} => Comp {Precategory-of-elements {C1} P} {C1} {E} A (projection {C1} {P})', '| Ob : \\\\hType', '| C : Precat', '| F (Ob {C}) : Ob {D}']<<<break>>>Functor (Precategory-of-elements {C1} (hom-presheaf {C1} x)) E (\\lam (X : Ob {C {\\this}}) => A.F (F X)) {\n  | Func => \\lam {X Y : Ob {C {\\this}}} (f : Hom {C {\\this}} X Y) => A.Func {F X} {F Y} (Func {X} {Y} f)\n}", "completion": "diagram-functor {C} {E} {A} (hom-presheaf x)"}
{"prompt": "['p2 : Hom M L', 'U : M.E', 'L : Locale', 'b : L.E', 'a : L.E', 'p : a L.\u2227 b L.<= SJoin {L} (\\\\lam (x : L.E) => p1.func x M.\u2227 p2.func x M.<= U)', 'M : Locale', 'p1 : Hom M L']<<<break>>>['| func-<= {x y : E {Dom}} (x <= y) : func x <= func y', '\\\\lemma meet-comm \\\\hlevels  {this : MeetSemilattice} {x y : E} : x \u2227 y = y \u2227 x ', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| Cod : BaseSet', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\func SJoin \\\\hlevels  {this : CompleteLattice} (U : E -> \\\\Prop) : E => Join {\\\\Sigma (b : E) (U b)} (\\\\lam (t : Total {E} U) => t.1)', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>func {p2} (b L.\u2227 a) <= func {p2} (SJoin {L} (\\lam (x : L.E) => p1.func x M.\u2227 p2.func x M.<= U))", "completion": "func-<= (=_<= meet-comm <=\u2218 p)"}
{"prompt": "[]<<<break>>>['apply (f : S.Symb s) (DArray {len {S.domain {s} f}} (\\\\lam (j : Fin (len {S.domain {s} f})) => Term {S} V (at {S.domain {s} f} j)))', '\\\\lemma SigmaFin (S : FinSet) (Q : S.E -> FinSet) : FinSet (\\\\Sigma (i : S.E) (E {Q i})) {\\n  | finCard => FinSum {NatSemiring} {S} (\\\\lam (i : S.E) => finCard {Q i})\\n} ', 'var (V s)', '\\\\class Theory \\\\extends Signature {\\n  | axioms Sequent : \\\\Prop\\n}', '| Sort : \\\\Set', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\data Formula \\\\hlevels  {S : Signature} (S.Sort -> \\\\Set) \\n  | equality {s : S.Sort} (Term {S} V s) (Term {S} V s)\\n  | predicate (P : S.PredSymb) (DArray {len {S.predDomain P}} (\\\\lam (j : Fin (len {S.predDomain P})) => Term {S} V (at {S.predDomain P} j)))', '\\\\func Sequent {S : Signature} : \\\\1-Type \\n  => \\\\Sigma (V : S.Sort -> \\\\Set) (FinSet (\\\\Sigma (s : S.Sort) (V s))) (Array (Formula {S} V)) (Formula {S} V)', '\\\\func coe (A : I -> \\\\Type) (a : A left) (i : I) : A i ', '\\\\data Term \\\\hlevels  {S : TermSig} (S.Sort -> \\\\Set) S.Sort \\n  | var (V s)\\n  | apply (f : S.Symb s) (DArray {len {S.domain {s} f}} (\\\\lam (j : Fin (len {S.domain {s} f})) => Term {S} V (at {S.domain {s} f} j)))', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '| domain {s : Sort} (Symb s) : Array Sort', '\\\\func finSet {A : FinSet} : FinSet => A', '| at (j : Fin len) : A j', '| Symb Sort : \\\\Set', '| E : \\\\Set', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'equality {s : S.Sort} (Term {S} V s) (Term {S} V s)', '\\\\instance UnitFin : FinSet (\\\\Sigma) {\\n  | finCard => 1\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case finEq {\\\\this} \\\\with {\\n    | inP e => \\\\case decideEq (e.ret x) (e.ret y) \\\\with {\\n      | yes q => yes {x = y} (isInj {symQEquiv {Fin (finCard {\\\\this})} {E {\\\\this}} (fromEquiv e)} {x} {y} q)\\n      | no q => no {x = y} (\\\\lam (p : x = y) => q (pmap {E {\\\\this}} {Fin (finCard {\\\\this})} e.ret {x} {y} p))\\n    }\\n  })\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '| finCard : Nat', 'right', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\type arraySubset {X : \\\\Type} (l : Array X) (x : X) : \\\\Prop => TruncP (\\\\Sigma (j : Fin l.len) (l !! j = x))', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\class FinSet \\\\extends KFinSet, Choice, DecSet {\\n  | finEq : TruncP (Equiv {Fin finCard} {E})\\n  | #-comparison => \\\\lam (x : E) (y : E) (z : E) (x/=z : x # z) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => byRight {x # y} {y # z} (\\\\lam (y=z : y = z) => x/=z (x=y *> y=z))\\n    | no x/=y => byLeft {x # y} {y # z} x/=y\\n  })\\n  | #-symmetric => /=-sym {E}\\n  | # => (/=)\\n  | nonEqualApart => \\\\lam {x y : E} (p : x /= y) => p\\n  | tightness => \\\\lam {x : E} {y : E} (x//=y : Not (x # y)) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => x=y\\n    | no x/=y => absurd {x = y} (x//=y x/=y)\\n  })\\n  | finSurj => map {Equiv {Fin finCard} {E}} {\\\\Sigma (f : Fin finCard -> E) (IsSurj {Fin finCard} {E} f)} finEq\\n    (\\\\lam (e : Equiv {Fin finCard} {E}) => (e.f, isSurjMap {ESEquiv.fromEquiv e}))\\n  | #-irreflexive => \\\\lam {x : E} (p : x # x) => p (idp {E} {x})\\n  | choice => \\\\lam {B : E -> \\\\Set} => (\\\\scase finEq \\\\with {\\n    | inP e => transport {\\\\Type} (\\\\lam (x : \\\\Type) => \\\\Pi {A : x -> \\\\Set} -> (\\\\Pi (i : x) -> TruncP (A i)) -> TruncP (\\\\Pi (i : x) -> A i))\\n      {Fin finCard} {E} (Equiv-to-= {Fin finCard} {E} e) (finiteAC {finCard}) {B}\\n  })\\n}', '\\\\lemma FinSum_replicate {this : Semiring} {A : FinSet} {x : E} : FinSum {A} (\\\\lam (_ : A.E) => x) = natCoef A.finCard * x ']<<<break>>>Theory {\n  | Sort => \\Sigma\n  | Symb => \\lam (_ : Sort {\\this}) => Fin 2\n  | domain => \\lam {s : Sort {\\this}} (p0 : Symb {\\this} s) => (\\case p0 \\with {\n    | zero => nil\n    | suc zero => () :: () :: nil\n  })\n  | PredSymb => Empty\n  | predDomain => absurd {Array (Sort {\\this})}\n  | axioms => arraySubset {Sequent} ((\\lam (_ : Sort {\\this}) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n    | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n  }) (SigmaFin UnitFin (\\lam (_ : E) => UnitFin)) right} {}, nil,\n    equality {\\lam (_ : Sort {\\this}) => \\Sigma} {()} (apply {\\lam (_ : Sort {\\this}) => \\Sigma} {()} 1\n      (apply {\\lam (_ : Sort {\\this}) => \\Sigma} {at {domain {\\this} {()} 1} 0} 0 nil :: var {\\lam (_ : Sort {\\this}) => \\Sigma} {at {domain {\\this} {()} 1} 1} () :: nil))\n      (var {\\lam (_ : Sort {\\this}) => \\Sigma} {()} ())) :: (\\lam (_ : Sort {\\this}) => \\Sigma, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n    }) (SigmaFin UnitFin (\\lam (_ : E) => UnitFin)) right} {}, nil,\n      equality {\\lam (_ : Sort {\\this}) => \\Sigma} {()} (apply {\\lam (_ : Sort {\\this}) => \\Sigma} {()} 1\n        (var {\\lam (_ : Sort {\\this}) => \\Sigma} {at {domain {\\this} {()} 1} 0} () :: apply {\\lam (_ : Sort {\\this}) => \\Sigma} {at {domain {\\this} {()} 1} 1} 0 nil :: nil))\n        (var {\\lam (_ : Sort {\\this}) => \\Sigma} {()} ())) :: (\\lam (_ : Sort {\\this}) => Fin 3, \\new finSet {coe (\\lam (i : I) => FinSet (\\Sigma E E) {\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\n      }) (SigmaFin UnitFin (\\lam (_ : E) => FinFin 3)) right} {}, nil, equality {\\lam (_ : Sort {\\this}) => Fin 3} {()}\n        (apply {\\lam (_ : Sort {\\this}) => Fin 3} {()} 1 (apply {\\lam (_ : Sort {\\this}) => Fin 3} {at {domain {\\this} {()} 1} 0} 1\n          (var {\\lam (_ : Sort {\\this}) => Fin 3} {at {domain {\\this} {at {domain {\\this} {()} 1} 0} 1} 0} 0 :: var {\\lam (_ : Sort {\\this}) => Fin 3} {at {domain {\\this} {at {domain {\\this} {()} 1} 0} 1} 1} 1 :: nil) :: var {\\lam (_ : Sort {\\this}) => Fin 3} {at {domain {\\this} {()} 1} 1} 2 :: nil))\n        (apply {\\lam (_ : Sort {\\this}) => Fin 3} {()} 1\n          (var {\\lam (_ : Sort {\\this}) => Fin 3} {at {domain {\\this} {()} 1} 0} 0 :: apply {\\lam (_ : Sort {\\this}) => Fin 3} {at {domain {\\this} {()} 1} 1} 1\n            (var {\\lam (_ : Sort {\\this}) => Fin 3} {at {domain {\\this} {at {domain {\\this} {()} 1} 1} 1} 0} 1 :: var {\\lam (_ : Sort {\\this}) => Fin 3} {at {domain {\\this} {at {domain {\\this} {()} 1} 1} 1} 1} 2 :: nil) :: nil))) :: nil)\n}", "completion": "\\new Theory {\n  | Sort => \\Sigma\n  | Symb => \\lam _ => Fin 2\n  | domain => \\lam p0 => (\\case p0 \\with {\n    | 0 => nil\n    | 1 => () :: () :: nil\n  })\n  | PredSymb => Empty\n  | predDomain => absurd\n  | axioms => arraySubset {Sequent {\\this}}\n    ((\\lam _ => \\Sigma, finSet, nil, equality (apply 1 (apply 0 nil :: var () :: nil)) (var ())) :: (\\lam _ => \\Sigma, finSet, nil, equality (apply 1 (var () :: apply 0 nil :: nil)) (var ())) :: (\\lam _ => Fin 3, finSet, nil,\n      equality (apply 1 (apply 1 (var 0 :: var 1 :: nil) :: var 2 :: nil)) (apply 1 (var 0 :: apply 1 (var 1 :: var 2 :: nil) :: nil))) :: nil)\n}"}
{"prompt": "['L : Locale', 'h : isHausdorffLocale L', 'U : E {L {image {diagonal {LocaleCat} L1}}}']<<<break>>>['true', '\\\\instance colimit-obj {J : Precat} (G : Functor J FrameUPresCat) : FrameUPres (FTerm {J} G) {\\n  | conj => fconj {J} {G}\\n  | BasicCover => \\\\lam {K : \\\\Set} (x : E {\\\\this}) (f : K -> E {\\\\this}) =>\\n  (\\\\Sigma (j : J.Ob) (y : E {G.F j}) (g : K -> E {G.F j}) (BasicCover {G.F j} {K} y g) (x = finj {J} {G} {j} y)\\n    (\\\\Pi (k : K) -> f k = finj {J} {G} {j} (g k))) || ((K, f) = (\\\\Sigma, \\\\lam (_ : \\\\Sigma) => funit {J} {G}))\\n  | unit => funit {J} {G}\\n} => \\\\new FrameUPres {\\n  | isUnit => {?hidden}\\n}', '\\\\func FrameCat : Cat Locale {\\n  | Hom => FrameHom\\n  | id => \\\\lam (L : Ob {\\\\this}) => \\\\new FrameHom L L {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n  }\\n  | o => FrameCat.o\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func SJoin \\\\hlevels  {this : CompleteLattice} (U : E -> \\\\Prop) : E => Join {\\\\Sigma (b : E) (U b)} (\\\\lam (t : Total {E} U) => t.1)', '\\\\func functor \\\\plevels obj >= hom {J : \\\\Type} {D : Precat} (G : J -> D.Ob) : Functor (DiscretePrecat J) D G {\\n  | Func => map {J} {D} G\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\lemma cover-trans1 \\\\hlevels  {P : FramePres} {x : P.E} {J : \\\\Set} {g : J -> P.E} {y : P.E} (_ : Cover1 {P} x y) (_ : Cover {P} y {J} g) :\\n  Cover {P} x {J} g ', \"\\\\lemma cover-conj1 \\\\hlevels  {P : FramePres} {a a' b b' : P.E} (_ : Cover1 {P} a a') (_ : Cover1 {P} b b') : Cover1 {P} (P.conj a b) (P.conj a' b') \", '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func proj1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 0) => proj {Bprod x y} 0', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| reflector (Ob {D}) : Ob {C}', '| at (j : Fin len) : A j', '\\\\instance FrameUPresCocompleteCat : CocompleteCat FrameUPres {\\n  | Hom => FrameUPresHom\\n  | id => \\\\lam (X : Ob) => \\\\new FrameUPresHom X X {\\n    | func => \\\\lam (x : X.E) => x\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => \\\\new FrameUPresHom X Z {\\n    | func => \\\\lam (x : X.E) => g.func (f.func x)\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | colimit => \\\\lam {J1 : Precat} (G1 : Functor J1 this1) =>\\n  \\\\new Limit {Precat.op {J1}} {Precat.op} (Functor.op {G1}) (colimit-obj {J1} G1) {\\n    | coneMap => colimitMap {J1} G1\\n    | coneCoh => {?hidden}\\n    | isLimit => {?hidden}\\n    | limMap => colimit-univ {J1} G1\\n    | limBeta => {?hidden}\\n    | limUnique => {?hidden}\\n  }\\n} => \\\\new CocompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| colimit {J : Precat} (G : Functor J \\\\this) : Limit {Precat.op {J}} {Precat.op} (Functor.op {G})', '| E : \\\\Set', \"\\\\data FTerm {J : Precat} (Functor J FrameUPresCat) : \\\\Set \\n  | finj {j : J.Ob} (E {G.F j})\\n  | fconj (FTerm {J} G) (FTerm {J} G)\\n  | funit\\n  | finj-eq {j j' : J.Ob} (J.Hom j j') (E {G.F j}) I\\n  | fconj-eq {j : J.Ob} (_ _ : E {G.F j}) I\\n  | funit-eq {j : J.Ob} I\", '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\class Locale \\\\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\\\hlevels  {\\n  | Join-ldistr>= {J : \\\\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\\\lam (j : J) => e \u2227 f j)\\n  | basicCover-stable => \\\\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\\\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\\n    meet-univ {x} {Join {J} (\\\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\\\lam (j : J) => (g j).1} {x}\\n  | ldistr>= => \\\\lam {x : E} {y : E} {z : E} => (\\n    \\\\have t => path (\\\\lam (i : I) (b : Bool) => (\\\\case b \\\\with {\\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\\n          }) @ i)\\n    \\\\in transportInv\\n        {Bool -> E} (\\\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\\n          {\\\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\\\lam (b : Bool) => x \u2227 if {E} b y z} t\\n          (Join-ldistr>= {Bool} {\\\\lam (p0 : Bool) => if {E} p0 y z} {x}))\\n  | Meet-cond => \\\\lam {J : \\\\Set} (j : J) {f : J -> E} =>\\n  Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n    {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)\\n  | join-left => \\\\lam {x : E} {y : E} => Join-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | join-right => \\\\lam {x : E} {y : E} => Join-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | Meet-univ => \\\\lam {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) =>\\n  Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n    {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  | join-univ => \\\\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\\n  Join-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n    | true => x<=z\\n    | false => y<=z\\n  }))\\n  | join => \\\\lam (x : E) (y : E) => Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)\\n  | Meet => \\\\lam {J : \\\\Set} (g : J -> E) =>\\n    Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)\\n  | isBasicCover => \\\\lam (x : Ob) {J : \\\\Set} (g : J -> Ob) => x <= Join {J} (\\\\lam (j : J) => (g j).1)\\n}', '| conj E E : E', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func proj2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 1) => proj {Bprod x y} 1', '\\\\instance FrameUPresCat : Cat FrameUPres {\\n  | Hom => FrameUPresHom\\n  | id => \\\\lam (X : Ob {\\\\this}) => \\\\new FrameUPresHom X X {\\n    | func => \\\\lam (x : X.E) => x\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new FrameUPresHom X Z {\\n    | func => \\\\lam (x : X.E) => g.func (f.func x)\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func SCover \\\\hlevels  {this : FramePres} (x : E) (U : E -> \\\\Prop) : \\\\Prop \\n  => Cover x {\\\\Sigma (x : E) (U x)} (\\\\lam (t : \\\\Sigma (x : E) (U x)) => t.1)', '\\\\lemma coneMap_finj {J : Precat} {G : Functor J FrameCat} (j : J.Ob) (x : E {G.F j}) :\\nfunc {coneMap {colimit {J} G} j} x = embed {colimit-obj {J} (Comp {J} {FrameBicat} {FrameUPresCat} FrameUnitalReflectiveSubcat G)}\\n  (finj {J} {Comp {J} {FrameCat} {FrameUPresCat} FrameUnitalReflectiveSubcat G} {j} x) ', '| func (E {Dom}) : E {Cod}', '\\\\func fpair {L M : Locale} (a : L.E) (b : M.E) : FTerm {Precat.op {DiscretePrecat (Fin 2)}}\\n  (Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n    (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})) => fconj {Precat.op {DiscretePrecat (Fin 2)}}\\n  {Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n    (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})}\\n  (finj {Precat.op {DiscretePrecat (Fin 2)}}\\n    {Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n      (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})} {0} a)\\n  (finj {Precat.op {DiscretePrecat (Fin 2)}}\\n    {Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\\n      (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})} {1} b)', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', 'false', '\\\\func Total {B : \\\\Type} (F : B -> \\\\Type) : \\\\Type => \\\\Sigma (b : B) (F b)', 'finj {j : J.Ob} (E {G.F j})', '| bottom : E', '\\\\func FrameUnitalReflectiveSubcat : ReflectiveSubPrecat FrameCat FrameUPresCat FrameUnitalSubcat.F {\\n  | Func => FrameUnitalSubcat.Func\\n  | reflector => reflector\\n  | reflectorMap => \\\\lam (X : Ob {D {\\\\this}}) => \\\\new FrameUPresHom X (Functor.F {\\\\this} (reflector {\\\\this} X)) {\\n    | func => embed {X}\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | isReflective => \\\\lam {X : Ob {D {\\\\this}}} {Y : Ob {C {\\\\this}}} =>\\n  \\\\new QEquiv {Hom {C {\\\\this}} (reflector {\\\\this} X) Y} {Hom {D {\\\\this}} X (Functor.F {\\\\this} Y)}\\n    (\\\\lam (p0 : A {\\\\this}) => Functor.Func {\\\\this} {reflector {\\\\this} X} {Y} p0 \u2218 ReflectiveSubPrecat.reflectorMap {\\\\this} X) {\\n    | ret => ret {isReflective {X} {Y}}\\n    | ret_f => ret_f {isReflective {X} {Y}}\\n    | f_sec => \\\\lam (h : B {\\\\this}) => path (\\\\lam (i : I) => (\\n      \\\\have arg => path (\\\\lam (i : I) => func {f_ret {isReflective {X} {Y}} h @ i})\\n      \\\\in \\\\new FrameUPresHom X (Functor.F {\\\\this} Y) {\\n            | func => arg @ i\\n            | func-conj => {?hidden}\\n            | func-basicCover => {?hidden}\\n            | func-unit => {?hidden}\\n          }))\\n  }\\n} => \\\\new ReflectiveSubPrecat {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', '\\\\func FrameBicat : BicompleteCat Locale {\\n  | Hom => FrameHom\\n  | id => \\\\lam (L : Ob) => \\\\new FrameHom L L {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n  }\\n  | o => FrameCat.o\\n  | pullback => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} (f : Hom {\\\\this} X Z) (g1 : Hom {\\\\this} Y Z) =>\\n  \\\\new Pullback {X} {Y} {Z} f g1 (pullback-obj {X} {Y} {Z} f g1) {\\n    | pbProj1 => proj1 {f.Dom} {g.Dom} {f.Cod} {f} {g1}\\n    | pbProj2 => proj2 {f.Dom} {g.Dom} {f.Cod} {f} {g1}\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {Pullback.D {\\\\this}}} (p1 : Hom {Pullback.D {\\\\this}} w (x {\\\\this})) (p2 : Hom {Pullback.D {\\\\this}} w (y {\\\\this}))\\n      (c : Pullback.f {\\\\this} Precat.\u2218 p1 = g {\\\\this} Precat.\u2218 p2) => \\\\new FrameHom w (Pullback.apex {\\\\this}) {\\n      | func => \\\\lam (x : E {Dom {\\\\this}}) => (p1.func x, p2.func x, path (\\\\lam (i : I) => func {c @ i} x))\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | terminal => fromLimit {Empty} (limit {\\\\this} {DiscretePrecat Empty} (functor {Empty} (absurd {Ob {\\\\this}})))\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J1 : Precat} (G1 : Functor J1 this4) => \\\\new Limit {J1} G1 (limit-obj {J1} G1) {\\n    | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => \\\\new FrameHom (Cone.apex {\\\\this}) (F {G {\\\\this}} j) {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => P.1 j\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | coneCoh => {?hidden}\\n    | isLimit => {?hidden}\\n    | limMap => limMap-impl\\n    | limBeta => {?hidden}\\n    | limUnique => {?hidden}\\n  }\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this4) => reflectiveSubPrecatColimit\\n    {J} FrameUnitalReflectiveSubcat G (colimit {J} (Comp {J} {FrameUPresCat} FrameUnitalReflectiveSubcat G))\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func DiscretePrecat (X : \\\\Type) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Trunc0 (x = y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => in0 {x = x} (idp {X} {x})\\n  | o => o {X}\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '\\\\func closure \\\\hlevels  {P : FramePres} {J : \\\\Set} (g : J -> P.E) : Opens P \\n=> (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g, \\\\lam (x : P.E) (c : SCover {P} x (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g)) =>\\n  cover-trans {P} {x} {J} {g} {\\\\Sigma (x : P.E) (Cover {P} x {J} g)} {\\\\lam (t : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => t.1} c (\\\\lam (p0 : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => p0.2))', '| apex : Ob {D}', 'cover-inj (j : J) (g j = x)', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| Ob : \\\\hType', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>\\Pi (j : \\Sigma (b c : L.E) (b L.\u2227 c L.<= SJoin {L} (\\lam (x : L.E) => U.1 (fpair {L} {L} x x)))) ->\nSCover {colimit-obj {Precat.op {DiscretePrecat (Fin 2)}}\n  (Comp {Precat.op {DiscretePrecat (Fin 2)}} {FrameBicat} {FrameUPresCat} FrameUnitalReflectiveSubcat\n    (Functor.op {functor {Fin 2} {LocaleCat} (at {L :: L :: nil})}))}\n  ((\\lam (j : \\Sigma (b c : L.E) (b L.\u2227 c L.<= SJoin {L} (\\lam (x : L.E) => U.1 (fpair {L} {L} x x)))) => fpair {L} {L} j.1 j.2) j)\n  (closure {colimit-obj {Precat.op {DiscretePrecat (Fin 2)}}\n    (Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\n      (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: L :: nil))}))} {\\Sigma (b c : L.E) (b L.\u2227 c L.<= L.bottom)}\n    (\\lam (j : \\Sigma (b c : L.E) (b L.\u2227 c L.<= L.bottom)) => fpair {L} {L} j.1 j.2) \u2228 U).1", "completion": "later (\\lam j => (\n  \\have t => h j.1 j.2 U (j.3 <=\u2218 Join-univ (\\lam k => Join-cond $ later (_, \\lam {x} c => U.2 x (cover-trans c (\\lam p0 => (\n          \\let (a, b, a<=k, b<=k) => p0\n          \\in (at) (rewrite coneMap_finj a<=k) a<=k\n                ((at) (rewrite coneMap_finj b<=k) b<=k (cover-trans1 (cover-conj1 a<=k b<=k) (cover-inj (_, k.2) idp)))))))))\n          (cover-inj (_, _, rewrite coneMap_finj $ cover-inj () idp, rewrite coneMap_finj $ cover-inj () idp) idp)\n  \\in cover-trans t (\\lam l => cover-inj (l.2, \\case l.1.2 \\with {\n        | byLeft v => cover-inj (false, l.2, v l.3) idp\n        | byRight v => cover-inj (true, l.2, cover-trans (transport (\\lam p0 => p0.1 l.2) v.4 l.3) (\\lam p0 => (\n          \\let (a, b, a<=v1, b<=v2) => p0\n          \\in cover-trans1 (cover-conj1 (rewrite coneMap_finj a<=v1 at a<=v1 $ a<=v1) (rewrite coneMap_finj b<=v2 at b<=v2 $ b<=v2))\n                (cover-inj (v.1, v.2, v.3) idp)))) idp\n      }) idp)))"}
{"prompt": "['C : Set (Set (E {f.Dom}))', 'X : ExPseudoMetricSpace', 'g : \\\\Pi (x : X.E) -> TruncP (\\\\Sigma (U1 : Set X.E) (C U1) (\\\\Pi {y : X.E} -> U {X.dist x y} delta -> U1 y))', 'delta : Rat']<<<break>>>['\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| U Rat : \\\\Prop', '| dist E E : ExUpperReal', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U1 : Set X.E) (C U1) (\\Pi {y : X.E} -> U {X.dist ?x y} delta -> U1 y))", "completion": "g _"}
{"prompt": "['l : Array U.E', 'U : FinModule R']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set']<<<break>>>Array U.E l.len l.at", "completion": "\\new l"}
{"prompt": "['R : BooleanAlgebra', 'z : E {\\\\this}', 'x : E {\\\\this}', 'y : E {\\\\this}']<<<break>>>['\\\\lemma meet-comm \\\\hlevels  {this : MeetSemilattice} {x y : E} : x \u2227 y = y \u2227 x ', '\\\\lemma meet-assoc \\\\hlevels  {this : MeetSemilattice} {x y z : E} : x \u2227 y \u2227 z = x \u2227 (y \u2227 z) ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '| join-left {x y : E} : x <= x \u2228 y', '| compl E : E', '\\\\lemma \\\\infixr 9 =<= \\\\hlevels  {E1 : Preorder} {x y z : E.E} (_ : x = y) (_ : y E.<= z) : x E.<= z ', '| join-univ {x y z : E} (x <= z) (y <= z) : x \u2228 y <= z', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| join-right {x y : E} : y <= x \u2228 y', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>z R.\u2227 (x R.\u2227 y) R.\u2228 z R.\u2227 (R.compl x R.\u2227 R.compl y) R.<= x R.\u2227 (y R.\u2227 z) R.\u2228 x R.\u2227 (R.compl y R.\u2227 R.compl z) R.\u2228 (y R.\u2227 R.compl z R.\u2227 R.compl x R.\u2228 z R.\u2227 R.compl y R.\u2227 R.compl x)", "completion": "join-univ (meet-comm =<= meet-assoc =<= join-left <=\u2218 join-left)\n  ((pmap ((\u2227) _) meet-comm *> inv meet-assoc) =<= join-right <=\u2218 join-right)"}
{"prompt": "['P : A {\\\\this}', 'Q : A {\\\\this}', 'S : A {\\\\this}', 'R : Ring', 'm : Nat', 'p0 : P ~ Q', 'this : Equivalence (Matrix R.E n m) {\\n  | ~ => (M~)\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', 'p1 : Q ~ S', 'n : Nat']<<<break>>>[\"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", 'inP A', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\instance MatrixRing \\\\hlevels  (R : Ring) (n : Nat) : Ring (Matrix R.E n n) {\\n  | zro => \\\\new Array (Array R.E n) n (\\\\lam (_ : Fin n) => \\\\new Array R.E n (\\\\lam (_ : Fin n) => R.zro))\\n  | + => \\\\lam (M : E) (N : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => at {at {M} i} j R.+ at {at {N} i} j)\\n  | * => (product)\\n  | negative => \\\\lam (M : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => R.negative (at {at {M} i} j))\\n  | ide => ide {R} {n}\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '| val : E {M}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infix 4 ~ A A : \\\\Prop', '| E : \\\\Set', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '\\\\lemma product-assoc \\\\hlevels  {R : Ring} {n m k l : Nat} (A : Matrix R.E n m) (B : Matrix R.E m k) (C : Matrix R.E k l) :\\n  A product B product C = A product (B product C) ', '\\\\lemma product \\\\hlevels  {M : Monoid} (i j : Inv {M}) : Inv {M} (i.val M.* j.val) ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\type \\\\infix 4 M~ \\\\hlevels  {R : Ring} {n m : Nat} (A B : Matrix R.E n m) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (B = C.val product A product D.val))', '\\\\func \\\\infixl 7 product \\\\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))']<<<break>>>P ~ S", "completion": "\\scase \\elim p0, \\elim p1 \\with {\n  | inP s, inP t => inP (product t.1 s.1, product s.2 t.2,\n    t.3 *> pmap (\\lam p0 => _ product p0 product _) s.3 *> pmap (\\lam _x => _x product _) {_ product (_ product P product _)} {_ * _ product P product _}\n      (pmap ((product) _) (product-assoc _ _ _) *> inv (product-assoc _ _ (P product _)) *> inv (product-assoc (_ * _) _ _)) *> product-assoc (_ * _ product P) _ _)\n}"}
{"prompt": "['P : A -> \\\\Prop', 'a : A', 'Q : A -> \\\\Prop', 'q : Q a']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', 'byRight B']<<<break>>>P a || Q a", "completion": "byRight q"}
{"prompt": "['X : ExPseudoNormedAbGroup', 'x : X.E', 'y : X.E']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma simplify-correct \\\\hlevels  {this : CGroupData} (t : GroupTerm V) : interpret t = interpret (simplify t) ', '| norm_+ {x y : E} : norm (x AddMonoid.+ y) <= norm x ExUpperReal.+ norm y', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| V : \\\\Set', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', ':inv (GroupTerm V)', '| at (j : Fin len) : A j', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| E : \\\\Set', '| negative E : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class CGroupData \\\\extends NatData \\\\hlevels ', '\\\\lemma negative_zro \\\\hlevels  {this : AddGroup} : negative zro = zro ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '| zro-right {x : E} : x + zro = x', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '| zro : E', 'var V', '\\\\infixl 6 :* (_ _ : GroupTerm V)', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro-left {x : E} : zro + x = x']<<<break>>>norm {X} x <= norm {X} y + norm {X} (x - y)", "completion": "transport (\\lam p0 => norm p0 <= _) simplify norm_+"}
{"prompt": "[\"s' : R.E\", \"v' : R.E\", 't : R.E', 'v : R.E', 'u : R.E', 'B : Matrix R.E 2 2', \"t' : R.E\", \"u' : R.E\", 'R : CRing', 'A : Matrix R.E 2 2', 's : R.E']<<<break>>>['| len : Nat', '\\\\field mData : MonoidData {R} vars', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| M : Monoid', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '| E : \\\\Set', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', '| vars : Array (E {M})', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>CRingData {R} (t' :: B !! 0 !! 0 :: s' :: u' :: B !! 1 !! 1 :: v' :: at {A} 0 !! 0 :: u :: at {A} 1 !! 0 :: v :: s :: t :: nil) {\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new CRingData {\n  | R => R\n  | vars => t' :: B !! 0 !! 0 :: s' :: u' :: B !! 1 !! 1 :: v' :: A !! 0 !! 0 :: u :: A !! 1 !! 0 :: v :: s :: t :: nil\n}"}
{"prompt": "['p : Prime {NatSemiring} 0']<<<break>>>['\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| isCancelable-left {x y : E {M}} (e * x = e * y) : x = y', '| E : \\\\Set', '| M : CMonoid']<<<break>>>0 = 1", "completion": "isCancelable-left {p} {0} {1} idp"}
{"prompt": "['a : E', 'this : OrderedC*Algebra', 'aa<=qq : a Semigroup.* a <= q RatField.* q *q ide', 'q : Rat', 'q>0 : zro < q']<<<break>>>['| c*-<=-square {a : E} (a * a <= ide) : a <= ide', '| ide : E', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma <=_*q-rotate_finv-left \\\\hlevels  {this : PosetQModule} {q : Rat} (_ : zro < q) {a b : E} (_ : a <= q *q b) : finv q *q a <= b ', '\\\\lemma *q-comm-left \\\\hlevels  {this : QPseudoAlgebra} {r : Rat} {a b : E} : r *q (a * b) = r *q a * b ', '\\\\lemma <_*_positive_positive \\\\hlevels  {this : OrderedSemiring} {x y : E} (_ : zro < x) (_ : zro < y) : zro < x * y ', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '| \\\\infixl 7 * E E : E', '\\\\lemma *q-assoc \\\\hlevels  {this : QModule} {q r : Rat} {a : E} : q * r *q a = q *q (r *q a) ', '\\\\lemma *q-comm-right \\\\hlevels  {this : QPseudoAlgebra} {r : Rat} {a b : E} : r *q (a * b) = a * (r *q b) ', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\lemma <=_*q-rotate-right \\\\hlevels  {this : PosetQModule} {q : Rat} (_ : zro < q) {a b : E} (_ : finv q *q a <= b) : a <= q *q b ', '| finv E : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\lemma finv_* {this : DiscreteField} {x y : E} : finv (x * y) = finv y * finv x ']<<<break>>>a <= q *q ide", "completion": "<=_*q-rotate-right {this} q>0\n  (c*-<=-square {this} $ =_<= (inv (pmap (\\lam _x => _x *q {this} _) (finv_* {RatField}) *> *q-assoc {this} *> pmap ((*q) {this} _) (*q-comm-right {this}) *> *q-comm-left {this})) <=\u2218 {this} <=_*q-rotate_finv-left {this} (<_*_positive_positive {RatField} q>0 q>0) aa<=qq)"}
{"prompt": "['Y : Ob {C {\\\\this}}', 'X : Ob {C {\\\\this}}', 'h : B {\\\\this}']<<<break>>>['| func-image {y : E {Cod}} : Cover {Cod} y {E {Dom}} func', '\\\\lemma locale_cover {L : Locale} {x : L.E} {J : \\\\Set} {g : J -> L.E} (_ : Cover {F L} x {J} g) : x L.<= L.Join {J} g ', '| Join {J : \\\\Set} (J -> E) : E', '| top : E', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}']<<<break>>>Y.top Y.<= Y.Join {X.E} h.func", "completion": "locale_cover (func-image {h})"}
{"prompt": "['X : \\\\Set', 'CA : \\\\Pi {C : Set (Set X)} -> A C -> \\\\Pi (x : X) -> TruncP (\\\\Sigma (U : Set X) (C U) (U x))', 'A : Set (Set X) -> \\\\Prop']<<<break>>>['closure (A C)', '| R (E {A}) (E {A}) : \\\\Prop', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\func ClosurePrecoverSpace \\\\hlevels  {X : \\\\Set} (A : Set (Set X) -> \\\\Prop)\\n  (CA : \\\\Pi {C : Set (Set X)} -> A C -> \\\\Pi (x : X) -> TruncP (\\\\Sigma (U : Set X) (C U) (U x))) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => Closure {X} A\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '| A : TopMeetSemilattice', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma closure-subset \\\\hlevels  {X : \\\\Set} {A : Set (Set X) -> \\\\Prop} {C D : Set (Set X)} (_ : Closure {X} A D) (_ : D \u2286 C) : Closure {X} A C ']<<<break>>>\\Pi {V U : E {A}} ->\n  TruncP (\\Sigma (E : Set (Set X)) (A1 E) (\\Pi {W : Set X} -> E W -> \\Sigma (x : X) ((\u2227) V W x) -> W \u2286 U)) -> R V U", "completion": "\\lam p0 => (\\case \\elim p0 \\with {\n  | inP (E, AE, h) => closure-subset (closure AE) (\\lam EW => h EW)\n})"}
{"prompt": "['j : Fin n', 'k : Nat', 'n : Nat', 'inj : IsInj {Fin (suc k)} {Fin n} l.at', 'l : Array (Fin n) (suc k)', 't : \\\\Sigma (j1 : Fin l.len) (l.at j1 = j)']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '\\\\lemma steps {n k : Nat} {m : Fin (suc k)} {l : Array (Fin n) (suc k)} {inj : IsInj {Fin (suc k)} {Fin n} l.at} :\\n  f {pow {SymmetricGroup n} (isEquiv {FinFin n} (func {n} {k} l) (func-inj {n} {k} {l} inj)) m} (l.at 0) = l.at m ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', 'inP A', '\\\\instance SymmetricGroup \\\\hlevels  (n : Nat) : Group (Sym n) {\\n  | ide => idEquiv {Fin n}\\n  | * => transEquiv {Fin n} {Fin n} {Fin n}\\n  | inverse => \\\\lam (e : E {\\\\this}) => symQEquiv {Fin n} {Fin n} (fromEquiv e)\\n} => \\\\new Group {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | inverse-right => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func cycle {n2 k1 : Nat} (l1 : Array (Fin n2) k1) (_ : IsInj {Fin k1} {Fin n2} l.at) : Sym n2 \\n  | {n}, {0}, l, inj => ide\\n  | {n}, {suc k}, l, inj => isEquiv {FinFin n} (func {n} {k} l) (func-inj {n} {k} {l} inj)', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>TruncP (\\Sigma (k1 : Nat) (f {pow {SymmetricGroup n} (cycle {n} {suc k} l inj) k1} (l.at 0) = j))", "completion": "inP (t.1, steps *> t.2)"}
{"prompt": "['z : P.E', \"comm : \\\\Pi {x y : P.E} -> R x y -> \\\\Pi (z : P.E) -> \\\\Pi (l : Array P.E) -> Cover {P} y {Fin (suc l.len)} (at {z :: l}) ->\\n  TruncP (\\\\Sigma (l' : Array P.E) (\\\\Pi (j : Fin l'.len) -> R (l'.at j) z) (Cover {P} x {Fin (len {l' ++ l})} (at {l' ++ l})))\", 'x : P.E', 'f : I -> P.E', 'leq : \\\\Pi {x y : P.E} -> R x y -> Cover1 {P} x y', 'Rxz : R x z', 'R : P.E -> P.E -> \\\\Prop', 'dense : \\\\Pi {x z : P.E} -> R x z -> TruncP (\\\\Sigma (y : P.E) (R x y) (R y z))', 'z<=l : Cover {P} z {Fin l.len} (\\\\lam (i : Fin l.len) => f (l.at i))', 'P : FramePres', 'l : Array I']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| <=-refl {x : E} : x <= x', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', \"\\\\lemma comm-lem {P : FramePres} (R : P.E -> P.E -> \\\\Prop) (_ : \\\\Pi {x y : P.E} -> R x y -> Cover1 {P} x y)\\n  (_ : \\\\Pi {x z : P.E} -> R x z -> TruncP (\\\\Sigma (y : P.E) (R x y) (R y z)))\\n  (_ : \\\\Pi {x y : P.E} -> R x y -> \\\\Pi (z : P.E) -> \\\\Pi (l : Array P.E) -> Cover {P} y {Fin (suc l.len)} (at {z :: l}) ->\\n    TruncP (\\\\Sigma (l' : Array P.E) (\\\\Pi (j : Fin l'.len) -> R (l'.at j) z) (Cover {P} x {Fin (len {l' ++ l})} (at {l' ++ l}))))\\n  (k : Nat) {x y : P.E} (_ : R x y) {n : Nat} {g : Fin n -> P.E} (_ : k <= n) (_ : Cover {P} y {Fin n} g) :\\nTruncP (\\\\Sigma (g' : Fin n -> Array P.E) (Cover {P} x {Fin (len {Big {Array P.E} {Array P.E} (++) nil (\\\\new Array (Array P.E) n g')})}\\n  (at {Big {Array P.E} {Array P.E} (++) nil (\\\\new Array (Array P.E) n g')}))\\n  (\\\\Pi (j : Fin n) -> j < k -> \\\\Pi (i : Fin (len {g' j})) -> R (at {g' j} i) (g j))\\n  (\\\\Pi (j : Fin n) -> k <= j -> g' j = g j :: nil)) \", '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| at (j : Fin len) : A j', '| E : \\\\Set']<<<break>>>TruncP (\\Sigma (g' : Fin l.len -> Array P.E)\n  (Cover {P} x {Fin (len {Big {Array P.E} {Array P.E} (++) nil (\\new Array (Array P.E) l.len g')})}\n    (at {Big {Array P.E} {Array P.E} (++) nil (\\new Array (Array P.E) l.len g')}))\n  (\\Pi (j : Fin l.len) -> j < l.len -> \\Pi (i : Fin (len {g' j})) -> R (at {g' j} i) (f (l.at j)))\n  (\\Pi (j : Fin l.len) -> l.len <= j -> g' j = f (l.at j) :: nil))", "completion": "comm-lem R leq dense comm (len {l}) Rxz <=-refl z<=l"}
{"prompt": "['R : TopRing', 'x : X.E', 'X : TopSpace']<<<break>>>['\\\\class ContMap \\\\extends SetHom \\\\hlevels  {\\n  | func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))\\n}', '\\\\type ContGerm \\\\hlevels  (X Y : TopSpace) (x : X.E) : \\\\Set => Quotient {\\\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)} (~)', '| *-cont : ContMap (ProductTopSpace \\\\this \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 * s.2\\n}', '\\\\func inCG \\\\hlevels  {X Y : TopSpace} {x : X.E} {U : Set X.E} (Uo : X.isOpen U) (Ux : U x) (f : ContMap (TopSub {X} U) Y) : ContGerm X Y x \\n  => in~ {\\\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)} {(~)} (U, Uo, Ux, f)', '| open-top : isOpen top', '| negative-cont : ContMap \\\\this \\\\this {\\n  | func => negative\\n}', '\\\\func natCoefImpl \\\\hlevels  {this2 : Semiring} (_ : Nat) : E \\n  | {this}, 0 => zro\\n  | {this}, suc n => natCoefImpl n + ide', '| isOpen (Set E) : \\\\Prop', '| top : E', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '\\\\func tuple \\\\hlevels  {X3 Y3 Z3 : TopSpace} {x3 : X.E} (_ : ContGerm X3 Y3 x3) (_ : ContGerm X3 Z3 x3) : ContGerm X3 (Y3 \u2a2f Z3) x3 \\n  | {X}, {Y}, {Z}, {x}, in~ (U, Uo, Ux, f), in~ (V, Vo, Vx, g) =>\\n  inCG {X} {Y \u2a2f Z} {x} {\\\\lam (x : X.E) => \\\\Sigma (U x) (V x)} (X.open-inter {U} {V} Uo Vo) (Ux, Vx)\\n    (tuple {TopSub {X} (U \u2227 V)} {Y} {Z} (f \u2218 TopSub-inc {X} {U \u2227 V} {U} (meet-left {U} {V}))\\n      (g \u2218 TopSub-inc {X} {U \u2227 V} {V} (meet-right {U} {V})))\\n  | {X}, {Y}, {Z}, {x}, in~ (U, Uo, Ux, f), ~-equiv y z r i => (\\\\case r \\\\with {\\n    | inP (V, Vo, Vx, p, q, r) =>\\n    ~-cgequiv {X} {Y \u2a2f Z} {x} {(\\\\lam (x : X.E) => \\\\Sigma (U x) (y.1 x), X.open-inter {U} {y.1} Uo y.2, (Ux, y.3),\\n      tuple {TopSub {X} (U \u2227 y.1)} {Y} {Z} (f \u2218 TopSub-inc {X} {U \u2227 y.1} {U} (meet-left {U} {y.1}))\\n        (y.4 \u2218 TopSub-inc {X} {U \u2227 y.1} {y.1} (meet-right {U} {y.1})))}\\n      {(\\\\lam (x : X.E) => \\\\Sigma (U x) (z.1 x), X.open-inter {U} {z.1} Uo z.2, (Ux, z.3),\\n        tuple {TopSub {X} (U \u2227 z.1)} {Y} {Z} (f \u2218 TopSub-inc {X} {U \u2227 z.1} {U} (meet-left {U} {z.1}))\\n          (z.4 \u2218 TopSub-inc {X} {U \u2227 z.1} {z.1} (meet-right {U} {z.1})))} {U \u2227 V} (X.open-inter {U} {V} Uo Vo) (Ux, Vx)\\n      (meet-monotone {SetLattice X.E} {U} {V} {U} {y.1} (<=-refl {U}) p)\\n      (meet-monotone {SetLattice X.E} {U} {V} {U} {z.1} (<=-refl {U}) q)\\n      (\\\\lam {x : X.E} (s : (\u2227) U V x) => path (\\\\lam (i : I) => (\\n        \\\\have arg => (pmap {\\\\Sigma (x : X.E) (\\\\property (U x))} {Y.E} f.func {func {TopSub-inc {X} {U \u2227 y.1} {U} (meet-left {U} {y.1})}\\n                (x, meet-monotone {SetLattice X.E} {U} {V} {U} {y.1} (<=-refl {U}) p {x} s)}\\n                {func {TopSub-inc {X} {U \u2227 z.1} {U} (meet-left {U} {z.1})}\\n                  (x, meet-monotone {SetLattice X.E} {U} {V} {U} {z.1} (<=-refl {U}) q {x} s)}\\n                (path (\\\\lam (i : I) => (\\n                  \\\\have arg => idp {X.E} {(func {TopSub-inc {X} {U \u2227 y.1} {U} (meet-left {U} {y.1})}\\n                          (x, meet-monotone {SetLattice X.E} {U} {V} {U} {y.1} (<=-refl {U}) p {x} s)).1}\\n                  \\\\in (arg @ i, prop-dpi (\\\\lam (i : I) => U (arg @ i)) (func {TopSub-inc {X} {U \u2227 y.1} {U} (meet-left {U} {y.1})}\\n                        (x, meet-monotone {SetLattice X.E} {U} {V} {U} {y.1} (<=-refl {U}) p {x} s)).2\\n                        (func {TopSub-inc {X} {U \u2227 z.1} {U} (meet-left {U} {z.1})}\\n                          (x, meet-monotone {SetLattice X.E} {U} {V} {U} {z.1} (<=-refl {U}) q {x} s)).2 @ i)))),\\n                pmap {\\\\Sigma (x : X.E) (\\\\property (y.1 x))} {Z.E} (func {y.4}) {func {TopSub-inc {X} {U \u2227 y.1} {y.1} (meet-right {U} {y.1})}\\n                  (x, meet-monotone {SetLattice X.E} {U} {V} {U} {y.1} (<=-refl {U}) p {x} s)} {(x, p {x} s.2)} (path (\\\\lam (i : I) => (\\n                  \\\\have arg => idp {X.E} {(func {TopSub-inc {X} {U \u2227 y.1} {y.1} (meet-right {U} {y.1})}\\n                          (x, meet-monotone {SetLattice X.E} {U} {V} {U} {y.1} (<=-refl {U}) p {x} s)).1}\\n                  \\\\in (arg @ i, prop-dpi (\\\\lam (i : I) => y.1 (arg @ i)) (func {TopSub-inc {X} {U \u2227 y.1} {y.1} (meet-right {U} {y.1})}\\n                        (x, meet-monotone {SetLattice X.E} {U} {V} {U} {y.1} (<=-refl {U}) p {x} s)).2 (x, p {x} s.2).2 @ i)))) *> r {x} s.2 *> pmap {\\\\Sigma (x : X.E) (\\\\property (z.1 x))} {Z.E} (func {z.4}) {(x, q {x} s.2)}\\n                  {func {TopSub-inc {X} {U \u2227 z.1} {z.1} (meet-right {U} {z.1})}\\n                    (x, meet-monotone {SetLattice X.E} {U} {V} {U} {z.1} (<=-refl {U}) q {x} s)}\\n                  (path (\\\\lam (i : I) => (\\n                    \\\\have arg => idp {X.E} {x}\\n                    \\\\in (arg @ i,\\n                          prop-dpi (\\\\lam (i : I) => z.1 (arg @ i)) (x, q {x} s.2).2 (func {TopSub-inc {X} {U \u2227 z.1} {z.1} (meet-right {U} {z.1})}\\n                            (x, meet-monotone {SetLattice X.E} {U} {V} {U} {z.1} (<=-refl {U}) q {x} s)).2 @ i)))))\\n          \\\\in (arg.1 @ i, arg.2 @ i))))\\n  }) @ i\\n  | {X}, {Y}, {Z}, {x}, ~-equiv y z r i, in~ (V, Vo, Vx, g) => (\\\\case r \\\\with {\\n    | inP (U, Uo, Ux, p, q, r) =>\\n    ~-cgequiv {X} {Y \u2a2f Z} {x} {(\\\\lam (x : X.E) => \\\\Sigma (y.1 x) (V x), X.open-inter {y.1} {V} y.2 Vo, (y.3, Vx),\\n      tuple {TopSub {X} (y.1 \u2227 V)} {Y} {Z} (y.4 \u2218 TopSub-inc {X} {y.1 \u2227 V} {y.1} (meet-left {y.1} {V}))\\n        (g \u2218 TopSub-inc {X} {y.1 \u2227 V} {V} (meet-right {y.1} {V})))}\\n      {(\\\\lam (x : X.E) => \\\\Sigma (z.1 x) (V x), X.open-inter {z.1} {V} z.2 Vo, (z.3, Vx),\\n        tuple {TopSub {X} (z.1 \u2227 V)} {Y} {Z} (z.4 \u2218 TopSub-inc {X} {z.1 \u2227 V} {z.1} (meet-left {z.1} {V}))\\n          (g \u2218 TopSub-inc {X} {z.1 \u2227 V} {V} (meet-right {z.1} {V})))} {U \u2227 V} (X.open-inter {U} {V} Uo Vo) (Ux, Vx)\\n      (meet-monotone {SetLattice X.E} {U} {V} {y.1} {V} p (<=-refl {V}))\\n      (meet-monotone {SetLattice X.E} {U} {V} {z.1} {V} q (<=-refl {V}))\\n      (\\\\lam {x : X.E} (s : (\u2227) U V x) => path (\\\\lam (i : I) => (\\n        \\\\have arg => (pmap {\\\\Sigma (x : X.E) (\\\\property (y.1 x))} {Y.E} (func {y.4}) {func {TopSub-inc {X} {y.1 \u2227 V} {y.1} (meet-left {y.1} {V})}\\n                (x, meet-monotone {SetLattice X.E} {U} {V} {y.1} {V} p (<=-refl {V}) {x} s)} {(x, p {x} s.1)} (path (\\\\lam (i : I) => (\\n                \\\\have arg => idp {X.E} {(func {TopSub-inc {X} {y.1 \u2227 V} {y.1} (meet-left {y.1} {V})}\\n                        (x, meet-monotone {SetLattice X.E} {U} {V} {y.1} {V} p (<=-refl {V}) {x} s)).1}\\n                \\\\in (arg @ i, prop-dpi (\\\\lam (i : I) => y.1 (arg @ i)) (func {TopSub-inc {X} {y.1 \u2227 V} {y.1} (meet-left {y.1} {V})}\\n                      (x, meet-monotone {SetLattice X.E} {U} {V} {y.1} {V} p (<=-refl {V}) {x} s)).2 (x, p {x} s.1).2 @ i)))) *> r {x} s.1 *> pmap {\\\\Sigma (x : X.E) (\\\\property (z.1 x))} {Y.E} (func {z.4}) {(x, q {x} s.1)}\\n                {func {TopSub-inc {X} {z.1 \u2227 V} {z.1} (meet-left {z.1} {V})}\\n                  (x, meet-monotone {SetLattice X.E} {U} {V} {z.1} {V} q (<=-refl {V}) {x} s)}\\n                (path (\\\\lam (i : I) => (\\n                  \\\\have arg => idp {X.E} {x}\\n                  \\\\in (arg @ i,\\n                        prop-dpi (\\\\lam (i : I) => z.1 (arg @ i)) (x, q {x} s.1).2 (func {TopSub-inc {X} {z.1 \u2227 V} {z.1} (meet-left {z.1} {V})}\\n                          (x, meet-monotone {SetLattice X.E} {U} {V} {z.1} {V} q (<=-refl {V}) {x} s)).2 @ i)))),\\n                pmap {\\\\Sigma (x : X.E) (\\\\property (V x))} {Z.E} g.func {func {TopSub-inc {X} {y.1 \u2227 V} {V} (meet-right {y.1} {V})}\\n                  (x, meet-monotone {SetLattice X.E} {U} {V} {y.1} {V} p (<=-refl {V}) {x} s)}\\n                  {func {TopSub-inc {X} {z.1 \u2227 V} {V} (meet-right {z.1} {V})}\\n                    (x, meet-monotone {SetLattice X.E} {U} {V} {z.1} {V} q (<=-refl {V}) {x} s)}\\n                  (path (\\\\lam (i : I) => (\\n                    \\\\have arg => idp {X.E} {(func {TopSub-inc {X} {y.1 \u2227 V} {V} (meet-right {y.1} {V})}\\n                            (x, meet-monotone {SetLattice X.E} {U} {V} {y.1} {V} p (<=-refl {V}) {x} s)).1}\\n                    \\\\in (arg @ i, prop-dpi (\\\\lam (i : I) => V (arg @ i)) (func {TopSub-inc {X} {y.1 \u2227 V} {V} (meet-right {y.1} {V})}\\n                          (x, meet-monotone {SetLattice X.E} {U} {V} {y.1} {V} p (<=-refl {V}) {x} s)).2\\n                          (func {TopSub-inc {X} {z.1 \u2227 V} {V} (meet-right {z.1} {V})}\\n                            (x, meet-monotone {SetLattice X.E} {U} {V} {z.1} {V} q (<=-refl {V}) {x} s)).2 @ i)))))\\n          \\\\in (arg.1 @ i, arg.2 @ i))))\\n  }) @ i', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\instance ContGermRing \\\\hlevels  (X : TopSpace) (Y : TopRing) (x : X.E) : Ring (ContGerm X Y x) {\\n  | zro => in~ {\\\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)} {(~)}\\n    (top, X.open-top, (), const {TopSub {X} top} {Y} Y.zro)\\n  | + => \\\\lam (f : E) (g : E) => comp-right {X} {ProductTopSpace Y Y} {Y} {x} (ContGerm.tuple {X} {Y} {Y} {x} f g) Y.+-cont\\n  | * => \\\\lam (f : E {\\\\this}) (g : E {\\\\this}) =>\\n    comp-right {X} {ProductTopSpace Y Y} {Y} {x} (ContGerm.tuple {X} {Y} {Y} {x} f g) Y.*-cont\\n  | negative => \\\\lam (f : E) => comp-right {X} {Y} {Y} {x} f Y.negative-cont\\n  | ide => inCG {X} {Y} {x} {top} X.open-top () (const {TopSub {X} top} {Y} Y.ide)\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', 'in~ A', '| +-cont : ContMap (ProductTopSpace \\\\this \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 + s.2\\n}', '\\\\func comp-right \\\\hlevels  {X2 Y2 Z2 : TopSpace} {x2 : X.E} (_ : ContGerm X2 Y2 x2) (_ : ContMap Y2 Z2) : ContGerm X2 Z2 x2 \\n  | {X}, {Y}, {Z}, {x}, in~ (U, Uo, Ux, g), h => inCG {X} {Z} {x} {U} Uo Ux (h \u2218 g)\\n  | {X}, {Y}, {Z}, {x}, ~-equiv y z r i, h => (\\\\case r \\\\with {\\n    | inP (V, Vo, Vx, p, q, r) => ~-cgequiv {X} {Z} {x} {(y.1, y.2, y.3, h \u2218 y.4)} {(z.1, z.2, z.3, h \u2218 z.4)} {V} Vo Vx p q\\n      (\\\\lam {x : X.E} (Vx : V x) => pmap {Y.E} {Z.E} h.func {func {y.4} (x, p {x} Vx)} {func {z.4} (x, q {x} Vx)} (r {x} Vx))\\n  }) @ i', '| ide : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func TopSub \\\\hlevels  {X : TopSpace} (S : Set X.E) : TopSpace (\\\\Sigma (x : X.E) (\\\\property (S x))) {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) =>\\n    TruncP (\\\\Sigma (V : Set X.E) (X.isOpen V) (U = (\\\\lam (p0 : \\\\Sigma (x : X.E) (\\\\property (S x))) => p0.1) ^-1 V))\\n} => TopTransfer {\\\\Sigma (x : X.E) (\\\\property (S x))} {X} (\\\\lam (p0 : \\\\Sigma (x : X.E) (\\\\property (S x))) => p0.1)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func equivalence \\\\hlevels  {X Y : TopSpace} {x : X.E} : Equivalence (\\\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)) {\\n  | ~ => \\\\lam (f : A {\\\\this}) (g : A {\\\\this}) => TruncP (\\\\Sigma (V : Set X.E) (X.isOpen V) (V x) (p : V \u2286 f.1) (q : V \u2286 g.1)\\n    (\\\\Pi {x : X.E} -> \\\\Pi (Vx : V x) -> func {f.4} (x, p {x} Vx) = func {g.4} (x, q {x} Vx)))\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', '\\\\instance ContGermAbGroup \\\\hlevels  (X : TopSpace) (Y : TopAbGroup) (x : X.E) : AbGroup (ContGerm X Y x) {\\n  | zro => inCG {X} {Y} {x} {top} X.open-top () (const {TopSub {X} top} {Y} Y.zro)\\n  | + => \\\\lam (f : E {\\\\this}) (g : E {\\\\this}) =>\\n    comp-right {X} {ProductTopSpace Y Y} {Y} {x} (ContGerm.tuple {X} {Y} {Y} {x} f g) Y.+-cont\\n  | negative => \\\\lam (f : E {\\\\this}) => comp-right {X} {Y} {Y} {x} f Y.negative-cont\\n} => \\\\new AbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n}', '| zro : E', '\\\\class Ring \\\\extends PseudoRing, Semiring \\\\hlevels ', '\\\\instance ProductTopSpace \\\\hlevels  (X Y : TopSpace) : TopSpace (\\\\Sigma X.E Y.E) {\\n  | isOpen => \\\\lam (W : Set (E {\\\\this})) =>\\n  \\\\Pi {s : E {\\\\this}} -> W s -> TruncP (\\\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\\n    (\\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}', '\\\\func const \\\\hlevels  {Y X : TopSpace} (x : X.E) : ContMap Y X {\\n  | func => \\\\lam (_ : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}']<<<break>>>Ring (ContGerm X R x) {\n  | zro => in~ {\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) R)} {(~)}\n    (top, X.open-top, (), const {TopSub {X} top} {R} R.zro)\n  | + => \\lam (f : E) (g : E) => comp-right {X} {ProductTopSpace R R} {R} {x} (tuple {X} {R} {R} {x} f g) R.+-cont\n  | * => \\lam (f : E {\\this}) (g : E {\\this}) => comp-right {X} {ProductTopSpace R R} {R} {x} (tuple {X} {R} {R} {x} f g) R.*-cont\n  | negative => \\lam (f : E) => comp-right {X} {R} {R} {x} f R.negative-cont\n  | ide => inCG {X} {R} {x} {top} X.open-top () (const {TopSub {X} top} {R} R.ide)\n  | natCoef => natCoefImpl\n}", "completion": "ContGermRing X R x"}
{"prompt": "['a : Nat -> E', 'this : IntegralDomain', 's : \\\\Sigma (j : Nat) (LDiv {DivQuotientMonoid this} (func {map {nonZeroCMonoid} (embedMonoid {subMonoid})} (a j))\\n  (func {map {nonZeroCMonoid} (embedMonoid {subMonoid})} (a (suc j))))', 'd : LDiv {DivQuotientMonoid nonZeroCMonoid} (a s.1) (a (suc s.1))']<<<break>>>['suc Nat', \"\\\\instance DivQuotientMonoid \\\\hlevels  (M : CMonoid) : OrderedCMonoid (DivQuotient M) {\\n  | <= => (<=C)\\n  | ide => inD {M} M.ide\\n  | * => (*')\\n} => \\\\new OrderedCMonoid {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | <=_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', 'inP A', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\func nonZeroCMonoid \\\\hlevels  {this1 : IntegralDomain} : CancelCMonoid (\\\\Sigma (x : E) (#0 x)) {\\n  | ide => (ide, zro#ide)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, #0-* {x.1} {y.1} x.2 y.2)\\n} => \\\\new CancelCMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | cancel_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (j : Nat) (LDiv {DivQuotientMonoid nonZeroCMonoid} (a j) (a (suc j))))", "completion": "inP (s.1, d)"}
{"prompt": "['this : OrderedC*Algebra', \"a' : Rat\", \"a'>0 : zro < a'\", 'x : E', \"x<=a' : x <= a' *q ide\"]<<<break>>>['\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| ide : E', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma <=_*q-rotate_finv-left \\\\hlevels  {this : PosetQModule} {q : Rat} (_ : zro < q) {a b : E} (_ : a <= q *q b) : finv q *q a <= b ']<<<break>>>finv a' *q x <= ide", "completion": "<=_*q-rotate_finv-left {this} a'>0 x<=a'"}
{"prompt": "['b : Bool', 's : S.E', 'a : \\\\Sigma S.E Bool', 'x : List (\\\\Sigma S.E Bool)', 'S : DecSet']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func helper1 \\\\hlevels  {S : DecSet} {x : S.E} : S.decideEq x x = yes {x = x} (idp {S.E} {x}) \\n=> \\\\case S.decideEq x x, idp {Dec (x = x)} {S.decideEq x x} \\\\with {\\n  | yes e, p => pmap {x = x} {Dec (x = x)} (yes {x = x}) {e} {idp {S.E} {x}} (set-pi {S.E} {x} {x} {e} {idp {S.E} {x}})\\n  | no n, p => absurd {no {x = x} n = yes {x = x} (idp {S.E} {x})} (n (idp {S.E} {x}))\\n}', 'true', '\\\\func not \\\\plevels  \\\\hlevels  (_ : Bool) : Bool \\n  | true => false\\n  | false => true', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\func helper2 \\\\plevels  \\\\hlevels  (p : Bool) : p xor not p = true => \\\\case p \\\\with {\\n  | false => idp {Bool} {false xor not false}\\n  | true => idp {Bool} {true xor not true}\\n}', '\\\\func \\\\infixl 2 xor \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | false, false => false\\n  | false, true => true\\n  | true, false => true\\n  | true, true => false', 'yes E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)']<<<break>>>(\\case S.decideEq s s, b xor not b \\with {\n  | yes e, true => (a.1, a.2) :: x\n  | d, b1 => (s, b) :: (s, not b) :: (a.1, a.2) :: x\n}) = a :: x", "completion": "rewrite helper1 (rewrite helper2 idp)"}
{"prompt": "['y : E', \"eps' : Rat\", 'this : ExPseudoMetricSpace', 'eps : Rat', 'x : E', \"d : U {dist x y} (eps \u2227 eps')\"]<<<break>>>['\\\\lemma U_<= \\\\plevels  \\\\hlevels  {this : ExUpperReal} {q r : Rat} (_ : U q) (_ : q <= r) : U r ', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| U Rat : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| dist E E : ExUpperReal']<<<break>>>U {dist x y} eps", "completion": "U_<= d meet-left"}
{"prompt": "['a : Rat', 'x : ExUpperReal', 'y : ExUpperReal']<<<break>>>['\\\\lemma mid>left \\\\plevels  \\\\hlevels  {a b : Rat} (_ : a < b) : a < mid a b ', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'inP A', '\\\\func mid \\\\plevels  \\\\hlevels  (a b : Rat) : Rat => (a + b) * ratio (pos 1) 2', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| <-transitive \\\\alias \\\\infixr 9 <\u2218 {x y z : E} (x < y) (y < z) : x < z', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', '\\\\lemma <->refl \\\\plevels  \\\\hlevels  {P : \\\\Prop} : P <-> P ', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma mid<right \\\\plevels  \\\\hlevels  {a b : Rat} (_ : a < b) : mid a b < b ', '| U Rat : \\\\Prop']<<<break>>>U {x ExUpperReal.* y} a <-> TruncP (\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b RatField.* c < a))", "completion": "rewrite (\\peval x * y) <->refl"}
{"prompt": "['S : CRing', 'f : RingHom R S', 'R : CRing', 'n : Nat']<<<break>>>['suc Nat', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '\\\\func mPolyHom \\\\hlevels  {J : \\\\Set} {R : CRing} : RingHom R (MonoidRing (PermSetMonoid J) R) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => inMS~ {E} {R} ((a, ide) :: nil)\\n} => monoidRingHom {PermSetMonoid J} {R}', '\\\\func id \\\\hlevels  {M : Monoid} : MonoidHom M M {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new MonoidHom {\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\func polyMapEval-unique \\\\hlevels  {R2 S2 : Ring} (f2 g2 : RingHom (PolyRing R2) S2)\\n  (_ : \\\\Pi (r : R.E) -> f.func (padd {R2} (pzero {R2}) r) = g.func (padd {R2} (pzero {R2}) r))\\n  (_ : f.func (padd {R2} ide R.zro) = g.func (padd {R2} ide R.zro)) (x1 : E) : f.func x1 = g.func x1 \\n  | {R}, {S}, f, g, p, q, pzero => f.func-zro *> inv {S.E} {g.func (pzero {R})} {S.zro} g.func-zro\\n  | {R}, {S}, f, g, p, q, padd x e =>\\n  pmap {Poly R} {S.E} f.func {padd {R} x e} {x Semigroup.* padd {R} ide R.zro + padd {R} zro e} (padd-expand {R} {x} {e}) *> f.func-+ {x PolyRing.* padd {R} ide R.zro} {padd {R} zro e} *> pmap2 {S.E} {S.E} {S.E} (S.+) {f.func (x Semigroup.* padd {R} ide R.zro)} {g.func (x Semigroup.* padd {R} ide R.zro)}\\n    (f.func-* {x} {padd {R} ide R.zro} *> pmap2 {S.E} {S.E} {S.E} (S.*) {f.func x} {g.func x} (polyMapEval-unique {R} {f.Cod} f g p q x) {f.func (padd {R} ide R.zro)}\\n      {g.func (padd {R} ide R.zro)} q *> inv {S.E} {g.func (x Semigroup.* padd {R} ide R.zro)} {g.func x S.* g.func (padd {R} ide R.zro)}\\n      (g.func-* {x} {padd {R} ide R.zro})) {f.func (padd {R} (pzero {R}) e)} {g.func (padd {R} (pzero {R}) e)} (p e) *> inv {S.E} {g.func (x Semigroup.* padd {R} ide R.zro + padd {R} (pzero {R}) e)}\\n    {g.func (x Semigroup.* padd {R} ide R.zro) S.+ g.func (padd {R} (pzero {R}) e)}\\n    (g.func-+ {x Semigroup.* padd {R} ide R.zro} {padd {R} (pzero {R}) e}) *> inv {S.E} {g.func (padd {R} x e)} {g.func (x Semigroup.* padd {R} ide R.zro + padd {R} (pzero {R}) e)}\\n    (pmap {Poly R} {S.E} g.func {padd {R} x e} {x Semigroup.* padd {R} ide R.zro + padd {R} zro e} (padd-expand {R} {x} {e}))', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\instance MonoidRing \\\\hlevels  (M : Monoid) (R : Ring) : Ring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | negative => negative {M.E} {R}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| Cod : BaseSet', '\\\\func retHom \\\\hlevels  {n : Nat} {R : CRing} :\\nRingHom (MonoidRing (PermSetMonoid (Fin n)) (PolyAlgebra R)) (MonoidAlgebra (PermSetMonoid (Fin (suc n))) R) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) =>\\n  func {mPolyEval {Fin n} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (\\\\lam (j : Fin n) => mVar {Fin (suc n)} {R} (fsuc {n} j))}\\n    (func {mPoly-mapHom {Fin n} {PolyAlgebra R} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (polyMapEvalRingHom\\n      {R} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (mPolyHom {Fin (suc n)} {R}) (mVar {Fin (suc n)} {R} 0))} x)\\n} => mPolyMapEvalRingHom {Fin n} {PolyAlgebra R} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (polyMapEvalRingHom\\n  {R} {MonoidAlgebra (PermSetMonoid (Fin (suc n))) R} (mPolyHom {Fin (suc n)} {R}) (mVar {Fin (suc n)} {R} 0))\\n  (\\\\lam (j : Fin n) => mVar {Fin (suc n)} {R} (fsuc {n} j))', '\\\\type PermSet \\\\hlevels  (A : \\\\Set) : \\\\Set => Quotient {Array A} (EPerm {A})', \"\\\\data EPerm {A : \\\\Type} (_ _ : Array A) \\\\with\\n  | {A}, nil, nil => eperm-nil\\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)\", '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '| at (j : Fin len) : A j', '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| E : \\\\Set', '\\\\func func \\\\hlevels  {M : Monoid} {R : Semiring} (s t : \\\\Sigma R.E M.E) : \\\\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)', '\\\\func mPoly-mapHom \\\\hlevels  {J : \\\\Set} {R S : CRing} (f : RingHom R S) :\\nRingHom (MonoidRing (Dom {id {PermSetMonoid J}}) f.Dom) (MonoidRing (Cod {id {PermSetMonoid J}}) f.Cod) {\\n  | func => monoidSet-map {E {Dom {id {PermSetMonoid J}}}} {E {Cod {id {PermSetMonoid J}}}} (func {id {PermSetMonoid J}}) f\\n} => monoidSet-ringHom (id {PermSetMonoid J}) f', '\\\\func \\\\infixl 8 compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {R S T : Ring} (g : RingHom S T) (f : RingHom R S) : RingHom R T {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", 'in~ A', '| ide-right {x : E} : x * ide = x', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\instance MonoidAlgebra \\\\hlevels  (M : CMonoid) (R1 : CRing) : CAlgebra R1 (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | negative => negative {M.E} {R1}\\n  | *c => \\\\lam (x : E {R}) => (Semigroup.*) (func {monoidRingHom {M} {R1}} x)\\n  | * => (MonoidSemiring.*)\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | coefMap => coefMap-impl\\n} => homAlgebra {R1} {\\\\new CRing (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (MonoidSemiring.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => negative {M.E} {R1}\\n  | negative-left => {?hidden}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}} (monoidRingHom {M} {R1})', '\\\\func polyMapRingHom \\\\hlevels  (f : RingHom) : RingHom (PolyRing f.Dom) (PolyRing f.Cod) {\\n  | func => polyMap f\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '| ide-left {x : E} : ide * x = x', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\instance PolyAlgebra \\\\hlevels  (R1 : CRing) : CAlgebra R1 (Poly R1) {\\n  | zro => pzero {R1}\\n  | + => (+)\\n  | negative => negative {R1}\\n  | *c => (*c)\\n  | * => (*)\\n  | ide => padd {R1} (pzero {R1}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R1} (pzero {R1}) (R.natCoef n)\\n  | coefMap => coefMap-impl\\n} => \\\\new CAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| ide : E', '| zro : E', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\type MonoidSet \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : \\\\Set => Quotient {Array (\\\\Sigma R.E M)} (~)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '| zro_*-left {x : E} : zro * x = zro']<<<break>>>\\Pi (x : E) ->\nfunc {mPoly-mapHom {Fin (suc n)} {R} {S} f \u2218 retHom {n} {R} \u2218 mPolyHom {Fin n} {PolyAlgebra R}} x = func {retHom {n} {S} \u2218 mPoly-mapHom {Fin n} {PolyAlgebra R} {PolyAlgebra S} (polyMapRingHom f) \u2218 mPolyHom {Fin n} {PolyAlgebra R}}\n  x", "completion": "polyMapEval-unique (mPoly-mapHom f \u2218 retHom {n} \u2218 mPolyHom)\n  (retHom {n} \u2218 mPoly-mapHom {_} {PolyAlgebra R} {PolyAlgebra S} (polyMapRingHom f) \u2218 mPolyHom {_} {PolyAlgebra R})\n  (\\lam r => simplify) simplify"}
{"prompt": "['C : Precat', 'D : Precat']<<<break>>>['| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| Hom Ob Ob : \\\\Set', '| id (X : Ob) : Hom X X', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Ob : \\\\hType', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\class Precat \\\\plevels obj >= hom \\\\hlevels  {\\n  | Ob : \\\\hType\\n  | Hom Ob Ob : \\\\Set\\n  | id (X : Ob) : Hom X X\\n  | \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z\\n  | id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f\\n  | id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f\\n  | o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)\\n}']<<<break>>>Precat (\\Sigma C.Ob D.Ob) {\n  | Hom => \\lam (X : Ob {\\this}) (Y : Ob {\\this}) => \\Sigma (C.Hom X.1 Y.1) (D.Hom X.2 Y.2)\n  | id => \\lam (X : Ob {\\this}) => (C.id X.1, D.id X.2)\n  | o => \\lam {X Y Z : Ob {\\this}} (f : Hom {\\this} Y Z) (g : Hom {\\this} X Y) => (f.1 C.\u2218 g.1, f.2 D.\u2218 g.2)\n  | id-left => {?hidden}\n  | id-right => {?hidden}\n  | o-assoc => {?hidden}\n}", "completion": "\\new Precat {\n  | Ob => \\Sigma (Ob {C}) (Ob {D})\n  | Hom => \\lam X Y => \\Sigma (Hom {C} X.1 Y.1) (Hom {D} X.2 Y.2)\n  | id => \\lam X => (id X.1, id X.2)\n  | o => \\lam f g => (f.1 \u2218 g.1, f.2 \u2218 g.2)\n  | id-left => rewrite (id-left, id-left) idp\n  | id-right => rewrite (id-right, id-right) idp\n  | o-assoc => rewrite (o-assoc, o-assoc) idp\n}"}
{"prompt": "[\"c' : Q.E\", 'Q : Dec', 'i : Fin l.len', 'l : Array E', \"x' : E\"]<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', 'suc Nat', '\\\\type Interval \\\\hlevels  (Q : Poset) : \\\\Set => \\\\Sigma Q.E Q.E', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', 'cover-inj (j : J) (g j = x)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\instance RealPres \\\\hlevels  (Q : Dec) : FramePres (Interval Q) {\\n  | conj => (\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))} {Interval Q}\\n    (\\\\lam (p0 : \\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))) =>\\n    (\\\\case p0 \\\\with {\\n      | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n        | zero => (p, q)\\n        | suc zero => (r, s)\\n      }))\\n      | (false, (p, q)) => (\\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\\n        \\\\lam (t : \\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\\n    }))\\n} => \\\\new FramePres']<<<break>>>Cover {RealPres Q} (l.at i) {Fin (len {((x'.1, c') :: nil) ++ l})} (at {((x'.1, c') :: nil) ++ l})", "completion": "cover-inj (suc i) idp"}
{"prompt": "['y : S.E', 'x : S.E', 'S : CoverSpace']<<<break>>>['| <=<-right {U V W : E {A}} (U <= V) (R V W) : R U W', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| <=<-left {U V W : E {A}} (R U V) (V <= W) : R U W', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\type \\\\infix 4 CF~ \\\\hlevels  {S : CoverSpace} (F1 G : WeaklyCauchyFilter S) : \\\\Prop \\n  => \\\\Pi {C : Set (Set S.E)} -> S.isCauchy C -> TruncP (\\\\Sigma (U : Set S.E) (C U) (\\\\Sigma (F.F U) (G.F U)))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma <=<_<= \\\\hlevels  {X : PrecoverSpace} {V U : Set X.E} (_ : V <=< U) : V <= U ', '| isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '| at (j : Fin len) : A j', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| isOpen (Set E) : \\\\Prop', '| E : \\\\Set', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '\\\\lemma single_<= \\\\hlevels  {X : \\\\Set} {a : X} {U : Set X} (_ : U a) : single {X} a \u2286 U ']<<<break>>>at {((<=<) (single {S.E} x) \u2286 (<=<) (single {S.E} y)) :: (pointCF {S} x CF~ pointCF {S} y) :: (pointCF {S} x = pointCF {S} y) :: (\\Pi {U : Set S.E} -> single {S.E} x <=< U <-> single {S.E} y <=< U) :: (\\Pi {U : Set S.E} -> single {S.E} x <=< U -> U y) :: (\\Pi {U V : Set S.E} -> single {S.E} x <=< U -> single {S.E} y <=< V -> TruncP (\\Sigma (e : S.E) ((\u2227) U V e))) :: (\\Pi {U V : Set S.E} -> S.isOpen U -> S.isOpen V -> U x -> V y -> TruncP (\\Sigma (e : S.E) ((\u2227) U V e))) :: (\\Pi {C : Set (Set S.E)} -> S.isCauchy C -> TruncP (\\Sigma (U : Set S.E) (C U) (\\Sigma (U x) (U y)))) :: nil}\n  7 -> (<=<) (single {S.E} x) \u2286 (<=<) (single {S.E} y)", "completion": "\\lam f {U} p => (\\case f (isRegular p) \\with {\n  | inP (V, inP (W, g, V<=<W), (Vx, Vy)) => <=<-left (<=<-right (single_<= Vy) V<=<W) $ g (x, (idp, <=<_<= V<=<W Vx))\n})"}
{"prompt": "['l : Array A.E n', 'a : A.E', 'x : A.E', 'n : Nat', 'A : DecSet', 'p : \\\\Pi (j : Fin (suc l.len)) -> at {x :: l} j = a']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func count \\\\hlevels  {A1 : DecSet} (_ : Array A.E) (_ : A.E) : Nat \\n  | {A}, nil, a => 0\\n  | {A}, :: {n} x l, a => \\\\case A.decideEq a x \\\\with {\\n    | yes p => suc (count {A} l a)\\n    | no n => count {A} l a\\n  }', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma decideEq=_reduce \\\\hlevels  {A : DecSet} {x y : A.E} (p : x = y) : A.decideEq x y = yes {x = y} p ', 'suc Nat', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', 'yes E', '\\\\lemma count-all \\\\hlevels  {A : DecSet} {l : Array A.E} {a : A.E} (_ : \\\\Pi (j : Fin l.len) -> l.at j = a) : count {A} l a = l.len ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>(\\case A.decideEq a (at {x :: l} 0) \\with {\n  | yes p => suc (count {A} l a)\n  | no n => count {A} l a\n}) = suc l.len", "completion": "rewrite (decideEq=_reduce $ inv $ p 0) (pmap suc $ count-all (\\lam j => p (suc j)))"}
{"prompt": "['q : Not (j = i)', 'i : Fin (suc n)', 'r : E {R {\\\\this}}', 'k : Fin (suc n)', 'R : CRing', 'j : Fin (suc n)', 'n : Nat', 'M : Array E n', 'x : E {Dom {\\\\this}}']<<<break>>>['\\\\func newIndex \\\\plevels  \\\\hlevels  {n2 : Nat} {j1 i2 : Fin (suc n2)} (_ : i2 /= j1) : Fin n2 \\n  | {n}, {zero}, {zero}, p => absurd {Fin n} (p (idp {Fin (suc n)} {0}))\\n  | {suc n}, {zero}, {suc i}, p => i\\n  | {suc n}, {suc j}, {zero}, p => 0\\n  | {suc n}, {suc j}, {suc i}, p =>\\n    suc (newIndex {n} {j} {i} (\\\\lam (q : i = j) => p (pmap {Fin (suc n)} {Fin (suc (suc n))} (fsuc {suc n}) {i} {j} q)))', '\\\\lemma toReplace \\\\hlevels  {R : Ring} {A B : LModule R} {n : Nat} {f : Array A.E n -> B.E} (_ : isMultiLinear {R} {n} {A} {B} f) (l : Array A.E n)\\n  (j : Fin n) : LinearMap {R} A B {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => f (replace {A.E} l j x)\\n} ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func replicate {A : \\\\Type} (n : Nat) (a : A) : Array A n (\\\\lam (_ : Fin n) => a) => \\\\new DArray', 'suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| Cod : BaseSet', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| zro : E', '\\\\func skip {A1 : \\\\Type} {n1 : Nat} (_ : Array A1 (suc n1)) (_ : Fin (suc n1)) : Array A1 n1 \\n  | {A}, {n}, a :: l, zero => l\\n  | {A}, {suc n}, a :: l, suc k => a :: skip {A} {n} l k', '\\\\func determinant {R : CRing} {n : Nat} (M : Matrix R.E n n) : R.E => FinSum {R} {SymFin n}\\n  (\\\\lam (e : Sym n) => sign {R} {n} e R.* BigProd {R} (\\\\new Array R.E n (\\\\lam (j : Fin n) => at {at {M} (f {e} j)} j)))', '| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x', '\\\\func insert {A3 : \\\\Type} (_ : A3) (l2 : Array A3) (_ : Fin (suc l.len)) : Array A3 (suc l.len) \\n  | {A}, a, nil, j => a :: nil\\n  | {A}, a, :: {n} b l, zero => a :: b :: l\\n  | {A}, a, :: {n} b l, suc j => b :: insert {A} a l j', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '\\\\lemma multilinear {R : CRing} {n : Nat} : isMultiLinear {R} {n} {ArrayLModule {R} n (RingLModule R)} {RingLModule R} (determinant {R} {n}) ', '| func (E {Dom}) : E {Cod}', '\\\\func RingLModule \\\\hlevels  (R1 : Ring) : LModule R1 R.E {\\n  | zro => R.zro\\n  | + => (R.+)\\n  | negative => R.negative\\n  | *c => (R.*)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '| Dom : BaseSet', '\\\\instance ArrayLModule \\\\hlevels  {R1 : Ring} (n : Nat) (M : LModule R1) : LModule R1 (Array M.E n) {\\n  | zro => \\\\new Array M.E n (\\\\lam (_ : Fin n) => M.zro)\\n  | + => \\\\lam (f : E {\\\\this}) (g : E {\\\\this}) => \\\\new Array M.E n (\\\\lam (j : Fin n) => f.at j M.+ g.at j)\\n  | negative => \\\\lam (f : E {\\\\this}) => \\\\new Array M.E n (\\\\lam (j : Fin n) => M.negative (f.at j))\\n  | *c => \\\\lam (r : E {R {\\\\this}}) (f : E {\\\\this}) => \\\\new Array M.E n (\\\\lam (j : Fin n) => r M.*c f.at j)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}']<<<break>>>func {toReplace {R} {ArrayLModule {R} n (RingLModule R)} {RingLModule R} {n} {determinant {R} {n}} (multilinear {R} {n})\n  (map {Array R.E (suc n)} {Array R.E n} (\\lam (p0 : Array R.E (suc n)) => skip {R.E} {n} p0 k)\n    (skip {Array R.E (suc n)} {n} (insert {Array R.E (suc n)} (replicate {R.E} (suc n) R.zro) M j) i))\n  (newIndex {n} {i} {j} q)} (r *c skip {R.E} {n} x k) = r *c func {toReplace {R} {ArrayLModule {R} n (RingLModule R)} {RingLModule R} {n} {determinant {R} {n}} (multilinear {R} {n})\n  (map {Array R.E (suc n)} {Array R.E n} (\\lam (p0 : Array R.E (suc n)) => skip {R.E} {n} p0 k)\n    (skip {Array R.E (suc n)} {n} (insert {Array R.E (suc n)} (replicate {R.E} (suc n) R.zro) M j) i))\n  (newIndex {n} {i} {j} q)} (skip {R.E} {n} x k)", "completion": "func-*c {toReplace {R} {_} {_} {n} multilinear _ _}"}
{"prompt": "['S : Set (Set (E {\\\\this}))', 'Y : TopSpace', 'U : Set (E {\\\\this})', 'p : U = top', 'y : Partial Y.E', 'SU : S U']<<<break>>>['byLeft A', '\\\\func defined \\\\hlevels  {X : \\\\Set} (x : X) : Partial X {\\n  | isDefined => \\\\Sigma\\n  | value => \\\\lam (_ : isDefined {\\\\this}) => x\\n} => \\\\new Partial', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| isDefined : \\\\Prop', '\\\\func Union \\\\hlevels  {X : \\\\hType} (S : Set X -> \\\\hType) : Set X => \\\\lam (a : X) => TruncP (\\\\Sigma (U : Set X) (S U) (U a))', 'inP A', '| value isDefined : E', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\class Partial \\\\hlevels  {\\n  | E : \\\\Set\\n  | isDefined : \\\\Prop\\n  | value isDefined : E\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| top : E', '| isOpen (Set E) : \\\\Prop', '| top-univ {x : E} : x <= top', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y']<<<break>>>(Union {Partial Y.E} S = top) || (\\Sigma (U' : Set Y.E) (Y.isOpen U') (p : y.isDefined) (U' (y.value p))\n  (\\Pi {y' : Y.E} -> U' y' -> Union {Partial Y.E} S (defined {Y.E} y')))", "completion": "byLeft (<=-antisymmetric top-univ (\\lam _ => inP (U, SU, rewrite p ())))"}
{"prompt": "['this : MeetSemilattice']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| Hom Ob Ob : \\\\Set', '| \\\\infix 4 <= E E : \\\\Prop', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| tupleMap {Z : Ob {D}} (\\\\Pi (j : J) -> Hom {D} Z (G j)) : Hom {D} Z apex', '| D : Precat', '| proj (j : J) : Hom {D} apex (G j)', '| apex : Ob {D}', '| meet-right {x y : E} : x \u2227 y <= y', \"\\\\lemma prop-pi \\\\plevels  \\\\hlevels  {A : \\\\Prop} {a a' : A} : a = a' \", '| G J : Ob {D}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| J : \\\\Type', '| at (j : Fin len) : A j', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| meet-left {x y : E} : x \u2227 y <= x', '| Ob : \\\\hType', '| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', '| E : \\\\Set', '\\\\class Product \\\\plevels obj >= hom {\\n  | J : \\\\Type\\n  | D : Precat\\n  | G J : Ob {D}\\n  | apex : Ob {D}\\n  | proj (j : J) : Hom {D} apex (G j)\\n  | tupleMap {Z : Ob {D}} (\\\\Pi (j : J) -> Hom {D} Z (G j)) : Hom {D} Z apex\\n  | tupleBeta {Z : Ob {D}} {f : \\\\Pi (j : J) -> Hom {D} Z (G j)} {j : J} : proj j \u2218 tupleMap {Z} f = f j\\n  | tupleEq {Z : Ob {D}} {h1 h2 : Hom {D} Z apex} (\\\\Pi (j : J) -> proj j \u2218 h1 = proj j \u2218 h2) : h1 = h2\\n}']<<<break>>>\\Pi (x : Ob) -> \\Pi (y : Ob) -> Product {Fin 2} (at {x :: y :: nil}) (x \u2227 y) {\n  | proj => \\lam (p0 : J {\\this}) => (\\case p0 \\with {\n    | zero => meet-left {x} {y}\n    | suc zero => meet-right {x} {y}\n  })\n  | tupleMap => \\lam {Z : Ob {D {\\this}}} (f : \\Pi (j : J {\\this}) -> Hom {D {\\this}} Z (G {\\this} j)) => meet-univ {x} {y} {Z} (f 0) (f 1)\n  | tupleBeta => {?hidden}\n  | tupleEq => {?hidden}\n}", "completion": "\\lam x y => \\new Product {\n  | apex => x \u2227 {this} y\n  | proj => \\lam p0 => (\\case \\elim p0 \\with {\n    | 0 => meet-left {this}\n    | 1 => meet-right {this}\n  })\n  | tupleMap => \\lam f => meet-univ {this} (f 0) (f 1)\n  | tupleBeta => prop-pi\n  | tupleEq => \\lam _ => prop-pi\n}"}
{"prompt": "['this : UnitalBooleanRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| ide : E', '| isBooleanRing {x : E} : x * x = x', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '\\\\type \\\\infix 4 <= \\\\hlevels  {R : Semigroup} (x y : R.E) : \\\\Prop => x R.* y = x', '\\\\lemma double=0 \\\\hlevels  {this : BooleanRing} {x : E} : x + x = zro ', '| compl E : E', '| zro : E', '| \\\\infixl 7 * E E : E', '| ldistr {x y z : E} : x * (y + z) = x * y + x * z', '| bottom : E', '| zro_*-right {x : E} : x * zro = zro', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| ide-right {x : E} : x * ide = x']<<<break>>>\\Pi {a : E} -> a \u2227 compl a <= bottom", "completion": "\\lam {a} => zro_*-right {this} *> inv (ldistr {this} *> pmap2 ((+) {this}) (isBooleanRing {this}) (ide-right {this}) *> double=0 {this})"}
{"prompt": "['f : I.E -> CoverMap X Y', 'X : CoverSpace', 'fc : \\\\Pi {E1 : Set (Set Y.E)} -> Y.isUniform E1 -> TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isCauchy C)\\n  (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (N : I.E) (D : Set (Set X.E)) (X.isCauchy D) (\\\\Pi {V : Set X.E} ->\\n    D V -> TruncP (\\\\Sigma (W : Set Y.E) (E1 W) (\\\\Pi {n : I.E} -> N I.<= n -> \\\\Pi {x : X.E} -> U x -> V x -> W (func {f n} x)))))))', 'this : PrecoverMap (precover {I} \u2a2f X) Y {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => func {f s.1} s.2\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', 'Y : RegularPreuniformSpace', 'I : DirectedSet']<<<break>>>['\\\\instance PrecoverSpaceHasProduct \\\\hlevels  : HasProduct PrecoverSpace {\\n  | Product => ProductPrecoverSpace\\n} => \\\\new HasProduct', '\\\\func PrecoverTransfer \\\\hlevels  {X : \\\\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '\\\\lemma closure-univ-cover \\\\hlevels  {X : \\\\Set} {A : Set (Set X) -> \\\\Prop} {Y : PrecoverSpace} {f : Y.E -> X}\\n  (_ : \\\\Pi {C : Set (Set X)} -> A C -> Y.isCauchy (\\\\lam (U : Set Y.E) => TruncP (\\\\Sigma (V : Set X) (C V) (U = f ^-1 V))))\\n  {C : Set (Set X)} (_ : Closure {X} A C) :\\n  Y.isCauchy (\\\\lam (U : Set Y.E) => TruncP (\\\\Sigma (V : Set X) (C V) (U = f ^-1 V))) ', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| isCauchy (Set (Set E)) : \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| Cod : BaseSet', '| func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '\\\\func precover \\\\hlevels  {I : DirectedSet} : PrecoverSpace I.E {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n  \\\\Sigma (TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (N : I.E) (\\\\Pi {n : I.E} -> N I.<= n -> U n)))\\n    (\\\\Pi (n : I.E) -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (C V) (V n)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))', '| uniform-cauchy {C : Set (Set E)} : isCauchy C <-> Closure {E} isUniform C', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\instance PrecoverLattice \\\\hlevels  (X : \\\\Set) : CompleteLattice (PrecoverSpace X) {\\n  | <= => \\\\lam (A : E {\\\\this}) (B : E {\\\\this}) => \\\\Pi {C : Set (Set X)} -> A.isCauchy C -> B.isCauchy C\\n  | meet => meet-impl\\n  | join => join-impl\\n  | top => DiscreteCover X\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n  ClosurePrecoverSpace {X} (\\\\lam (C : Set (Set X)) => TruncP (\\\\Sigma (j : J) (isCauchy {f j} C)))\\n    (\\\\lam {C : Set (Set X)} (e : TruncP (\\\\Sigma (j : J) (isCauchy {f j} C))) (x : X) => (\\\\case e \\\\with {\\n      | inP (j, Cc) => cauchy-cover {f j} {C} Cc x\\n    }))\\n  | Meet => Meet-impl\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '\\\\lemma directedProdCover-char \\\\hlevels  {I : DirectedSet} {X : CoverSpace} {D : Set (Set (\\\\Sigma I.E X.E))} :\\n  isCauchy {precover {I} \u2a2f X} D <-> DirectProdCover {I} {X} D ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', '\\\\lemma makeCauchy \\\\hlevels  {this : PreuniformSpace} {C : Set (Set E)} (_ : isUniform C) : isCauchy C ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func (E {Dom}) : E {Cod}', '\\\\lemma cauchy-subset \\\\hlevels  {X : PrecoverSpace} {C D : Set (Set X.E)} (_ : X.isCauchy C) (_ : \\\\Pi {U : Set X.E} -> C U -> D U) : X.isCauchy D ']<<<break>>>\\Pi {D : Set (Set (E {Cod {\\this}}))} -> isCauchy {Cod {\\this}} D ->\n  Closure {\\Sigma E X.E} (\\lam (C : Set (Set (\\Sigma E X.E))) => TruncP (\\Sigma (j : Bool) (isCauchy C)))\n    (\\lam (U : Set (E {precover {I} \u2a2f X})) =>\n      TruncP (\\Sigma (V : Set Y.E) (D V) (U = (\\lam (a : \\Sigma I.E X.E) => func {f a.1} a.2) ^-1 V)))", "completion": "\\lam Dc => closure-univ-cover {_} {_} {precover \u2a2f X} (\\lam {E} Eu => (\\case fc Eu \\with {\n  | inP (C, Cc, h) => directedProdCover-char.2 (cauchy-subset\n    (cauchy-glue Cc {\\lam U V => \u2203 (\\Sigma (N : I) (W : E) (\u2200 (\\Pi {n : _} (N <= n) -> \u2200 (\\Pi {x : _} -> U x -> V x -> W (f n x)))))}\n      (\\lam CU => (\\case h CU \\with {\n        | inP (N, D, Dc, Dg) => cauchy-subset Dc (\\lam {V} DV => (\\case Dg DV \\with {\n          | inP (W, EW, Eg) => inP $ later (N, W, EW, Eg)\n        }))\n      })))\n      (\\lam {p0} p1 => (\\case \\elim p0, \\elim p1 \\with {\n        | _, inP (U, V, CU, inP (N, W, EW, g), idp) => inP $ later (N, _, inP (W, EW, idp), \\lam p p0 => (\n          \\let (Ux, Vx) => p0\n          \\in g p Ux Vx))\n      })),\n      \\lam n => cauchy-subset (func-cover {f n} $ makeCauchy {Y} Eu) (\\lam {p0} p1 => (\\case \\elim p0, \\elim p1 \\with {\n        | _, inP (V, DV, idp) => inP $ later (_, inP (V, DV, idp), \\lam s => s)\n      })))\n})) (uniform-cauchy.1 Dc)"}
{"prompt": "['b : E', 'this : BezoutRing', 'c : E', 'z : E', 'g : GCD a b z']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '| inv : E {M}', '\\\\lemma product-left \\\\hlevels  {M : Monoid} (x : M.E) {y z : M.E} (y|z : LDiv {M} y z) : LDiv {M} (x M.* y) (x M.* z) y|z.inv ', '| res|val2 : LDiv {M} res val2']<<<break>>>LDiv (c * z) (c * b) (inv {g.res|val2})", "completion": "product-left c (res|val2 {g})"}
{"prompt": "[\"bv' : IsBasis {V} lv'\", 'V : LModule R', \"lu' : Array U.E lu.len\", \"bu' : IsBasis {U} lu'\", 'U : LModule R', 'R : SmithDomain', \"lv' : Array V.E lv.len\"]<<<break>>>['| A : \\\\Type', '| \\\\infixl 6 + E E : E', '| ide_*c {a : E} : ide {R} *c a = a', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', '\\\\class LinearMap \\\\extends AddGroupHom \\\\hlevels  {\\n  | R : Ring\\n  | func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x\\n}', '\\\\lemma BigSum-unique \\\\hlevels  {this : AddMonoid} {l : Array E} (i : Fin l.len) (_ : \\\\Pi (j : Fin l.len) -> i /= j -> l.at j = zro) : BigSum l = l.at i ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| Cod : BaseSet', '\\\\lemma basis-split-unique \\\\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) {x : E} (d : Array (E {R}) l.len)\\n  (_ : x = BigSum (\\\\new Array E l.len (\\\\lam (j : Fin l.len) => d.at j *c l.at j))) (j : Fin l.len) :\\n  at {basis-split {l} lb x} j = d.at j ', '| ret B : A', '\\\\func id \\\\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => a\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '\\\\lemma basis_split_/= \\\\hlevels  {this : LModule} {l : Array E} {lb : IsBasis l} {j k : Fin l.len} (_ : j /= k) :\\n  at {basis-split {l} lb (l.at j)} k = zro {R} ', '| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x', '| at (j : Fin len) : A j', '\\\\func matrixExt {R : \\\\Type} {n m : Nat} {M N : Matrix R n m}\\n  (p : \\\\Pi (i : Fin n) -> \\\\Pi (j : Fin m) -> at {at {M} i} j = at {at {N} i} j) : M = N \\n  => path (\\\\lam (i : I) => mkMatrix {R} {n} {m} (\\\\lam (j : Fin n) (k : Fin m) => p j k @ i))', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '\\\\lemma basis_split_= \\\\hlevels  {this : LModule} {l : Array E} {lb : IsBasis l} {j : Fin l.len} : at {basis-split {l} lb (l.at j)} j = ide {R} ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma basis-ext \\\\hlevels  {R : Ring} {U V : LModule R} (f g : LinearMap {R} U V) {l : Array U.E} (_ : IsGenerated {U} l)\\n  (_ : \\\\Pi (j : Fin l.len) -> f.func (l.at j) = g.func (l.at j)) (u : U.E) : f.func u = g.func u ', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func extend \\\\hlevels  {R : Ring} {U V : LModule R} {l : Array U.E} (lb : IsBasis {U} l) (lv : Array V.E l.len) : LinearMap {R} U V {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) =>\\n    BigSum {V} (\\\\new Array V.E l.len (\\\\lam (j : Fin l.len) => at {basis-split {U} {l} lb x} j V.*c lv.at j))\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '| ide : E', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '| R : Ring', '\\\\func matrix-equiv {R1 : Ring} {U V : LModule R1} {lu : Array U.E} {lv : Array V.E} (bu : IsBasis {U} lu) (bv : IsBasis {V} lv) :\\nQEquiv {LinearMap {R1} U V} {Matrix R.E lu.len lv.len} (toMatrix {R1} {U} {V} {lv} lu bv) {\\n  | ret => toLinearMap {R1} {U} {V} {lu} bu lv\\n  | ret_f => \\\\lam (f1 : A {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => \\\\lam (u : U.E) => toLinearMap_toMatrix-left {R1} {U} {f.Cod} {lu.len} {\\\\new lu {\\n            | A => \\\\lam (_ : Fin (len {\\\\this})) => U.E\\n          }}\\n            {\\\\new lu {\\n              | A => \\\\lam (_ : Fin (len {\\\\this})) => U.E\\n            }} bu bu {lv} {bv} {f1} {u} *> pmap {U.E} {V.E} f.func {func {extend {R1} {U} {U} {lu} bu (\\\\new Array U.E lu.len lu.at)} u} {func {id {R1} {U}} u}\\n            (basis-ext {R1} {U} {U} (extend {R1} {U} {U} {lu} bu (\\\\new Array U.E lu.len lu.at)) (id {R1} {U}) {lu} bu.2\\n              (\\\\lam (j : Fin lu.len) =>\\n              inv {U.E} {func {id {R1} {U}} (lu.at j)} {func {extend {R1} {U} {U} {lu} bu (\\\\new Array U.E lu.len lu.at)} (lu.at j)}\\n                (basis-split-char {U} {lu} {bu} {func {id {R1} {U}} (lu.at j)})) u)\\n    \\\\in \\n          \\\\let h1 => path (\\\\lam (i : I) (e : U.E) => arg e @ i)\\n          \\\\in \\\\new LinearMap {R1} U V {\\n                | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                | func-+ => {?hidden}\\n                | func-*c => {?hidden}\\n              }))\\n  | f_sec => \\\\lam (A : B {\\\\this}) => matrixExt {R.E} {lu.len} {lv.len} {toMatrix {R1} {U} {V} {lv} lu bv (sec {\\\\this} A)} {A}\\n    (\\\\lam (i : Fin lu.len) (j : Fin lv.len) => pmap {V.E} {R.E} (\\\\lam (p0 : V.E) => at {basis-split {V} {lv} bv p0} j)\\n      {BigSum {V} (\\\\new Array V.E lu.len (\\\\lam (j : Fin lu.len) =>\\n        at {basis-split {U} {lu} bu (lu.at i)} j V.*c BigSum {V} (\\\\new Array V.E lv.len (\\\\lam (k : Fin lv.len) => at {at {A} j} k V.*c lv.at k))))}\\n      {BigSum {V} (\\\\new Array V.E lv.len (\\\\lam (k : Fin lv.len) => at {at {A} i} k V.*c lv.at k))}\\n      (BigSum-unique {V} {\\\\new Array V.E lu.len (\\\\lam (j : Fin lu.len) =>\\n        at {basis-split {U} {lu} bu (lu.at i)} j V.*c BigSum {V} (\\\\new Array V.E lv.len (\\\\lam (k : Fin lv.len) => at {at {A} j} k V.*c lv.at k)))}\\n        i (\\\\lam (k : Fin lu.len) (i/=k : i /= k) => pmap {R.E} {V.E}\\n          (\\\\lam (_x : R.E) => _x V.*c BigSum {V} (\\\\new Array V.E lv.len (\\\\lam (k1 : Fin lv.len) => at {at {A} k} k1 V.*c lv.at k1)))\\n          {at {basis-split {U} {lu} bu (lu.at i)} k} {R.zro} (basis_split_/= {U} {lu} {bu} {i} {k} i/=k) *> *c_zro-left {V} {BigSum {V} (\\\\new Array V.E lv.len (\\\\lam (k1 : Fin lv.len) => at {at {A} k} k1 V.*c lv.at k1))}) *> pmap {R.E} {V.E}\\n        (\\\\lam (_x : R.E) => _x V.*c BigSum {V} (\\\\new Array V.E lv.len (\\\\lam (k : Fin lv.len) => at {at {A} i} k V.*c lv.at k)))\\n        {at {basis-split {U} {lu} bu (lu.at i)} i} {R.ide} (basis_split_= {U} {lu} {bu} {i}) *> V.ide_*c {BigSum {V} (\\\\new Array V.E lv.len (\\\\lam (k : Fin lv.len) => at {at {A} i} k V.*c lv.at k))}) *> basis-split-unique\\n    {V} {lv} bv {BigSum {V} (\\\\new Array V.E lv.len (\\\\lam (j : Fin lv.len) => at {at {A} i} j V.*c lv.at j))} (at {A} i)\\n      (idp {V.E} {BigSum {V} (\\\\new Array V.E lv.len (\\\\lam (j : Fin lv.len) => at {at {A} i} j V.*c lv.at j))}) j)\\n} => \\\\new QEquiv', 'basis-split \\\\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1', '| zro : E', '\\\\lemma basis-split-char \\\\hlevels  {this : LModule} {l : Array E} {lb : IsBasis l} {x : E} :\\n  x = BigSum (\\\\new Array E l.len (\\\\lam (j : Fin l.len) => at {basis-split {l} lb x} j *c l.at j)) ', '\\\\lemma *c_zro-left \\\\hlevels  {this : LModule} {a : E} : zro {R} *c a = zro ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '| f A : B', \"\\\\lemma toLinearMap_toMatrix-left \\\\hlevels  {R : Ring} {U V : LModule R} {n : Nat} {lu lu' : Array U.E n} (_ : IsBasis {U} lu) (bu' : IsBasis {U} lu')\\n  {lv : Array V.E} {bv : IsBasis {V} lv} {f : LinearMap {R} U V} {u : U.E} :\\n  func {toLinearMap {R} {U} {V} {lu'} bu' lv (toMatrix {R} {U} {V} {lv} lu bv f)} u = f.func (func {extend {R} {U} {U} {lu'} bu' lu} u) \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| sec B : A', '\\\\func toMatrix \\\\hlevels  {R : Ring} {U V : LModule R} {lv : Array V.E} (lu : Array U.E) (bv : IsBasis {V} lv) (f : LinearMap {R} U V) :\\n  Matrix R.E lu.len lv.len \\n  => mkMatrix {R.E} {lu.len} {lv.len} (\\\\lam (i : Fin lu.len) => at {basis-split {V} {lv} bv (f.func (lu.at i))})', '| \\\\infixl 7 *c (E {R}) E : E', '| B : \\\\Type', '| func (E {Dom}) : E {Cod}', '\\\\func toLinearMap \\\\hlevels  {R : Ring} {U V : LModule R} {lu : Array U.E} (bu : IsBasis {U} lu) (lv : Array V.E) (A : Matrix R.E lu.len lv.len) :\\nLinearMap {R} U V {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => BigSum {V} (\\\\new Array V.E lu.len (\\\\lam (j : Fin lu.len) =>\\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\\n} => extend {R} {U} {V} {lu} bu\\n  (\\\\new Array V.E lu.len (\\\\lam (j : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))', '| Dom : BaseSet']<<<break>>>QEquiv {LinearMap {R1} U V} {Matrix R.E lu'.len lv'.len} (toMatrix {R1} {U} {V} {lv'} lu' bv') {\n  | ret => toLinearMap {R1} {U} {V} {lu'} bu' lv'\n  | ret_f => \\lam (f1 : A {\\this}) => path (\\lam (i : I) => (\n    \\have arg => \\lam (u : U.E) => toLinearMap_toMatrix-left {R1} {U} {f.Cod} {lu'.len} {\\new lu' {\n            | A => \\lam (_ : Fin (len {\\this})) => U.E\n          }}\n            {\\new lu' {\n              | A => \\lam (_ : Fin (len {\\this})) => U.E\n            }} bu' bu' {lv'} {bv'} {f1} {u} *> pmap {U.E} {V.E} f.func {func {extend {R1} {U} {U} {lu'} bu' (\\new Array U.E lu'.len lu'.at)} u} {func {id {R1} {U}} u}\n            (basis-ext {R1} {U} {U} (extend {R1} {U} {U} {lu'} bu' (\\new Array U.E lu'.len lu'.at)) (id {R1} {U}) {lu'} bu'.2\n              (\\lam (j : Fin lu'.len) =>\n              inv {U.E} {func {id {R1} {U}} (lu'.at j)} {func {extend {R1} {U} {U} {lu'} bu' (\\new Array U.E lu'.len lu'.at)} (lu'.at j)}\n                (basis-split-char {U} {lu'} {bu'} {func {id {R1} {U}} (lu'.at j)})) u)\n    \\in \n          \\let h1 => path (\\lam (i : I) (e : U.E) => arg e @ i)\n          \\in \\new LinearMap {R1} U V {\n                | func => \\lam (e : E {Dom {\\this}}) => arg e @ i\n                | func-+ => {?hidden}\n                | func-*c => {?hidden}\n              }))\n  | f_sec => \\lam (A : B {\\this}) => matrixExt {R.E} {lu'.len} {lv'.len} {toMatrix {R1} {U} {V} {lv'} lu' bv' (sec {\\this} A)} {A}\n    (\\lam (i : Fin lu'.len) (j : Fin lv'.len) => pmap {V.E} {R.E} (\\lam (p0 : V.E) => at {basis-split {V} {lv'} bv' p0} j)\n      {BigSum {V} (\\new Array V.E lu'.len (\\lam (j : Fin lu'.len) =>\n        at {basis-split {U} {lu'} bu' (lu'.at i)} j V.*c BigSum {V} (\\new Array V.E lv'.len (\\lam (k : Fin lv'.len) => at {at {A} j} k V.*c lv'.at k))))}\n      {BigSum {V} (\\new Array V.E lv'.len (\\lam (k : Fin lv'.len) => at {at {A} i} k V.*c lv'.at k))}\n      (BigSum-unique {V} {\\new Array V.E lu'.len (\\lam (j : Fin lu'.len) =>\n        at {basis-split {U} {lu'} bu' (lu'.at i)} j V.*c BigSum {V} (\\new Array V.E lv'.len (\\lam (k : Fin lv'.len) => at {at {A} j} k V.*c lv'.at k)))}\n        i (\\lam (k : Fin lu'.len) (i/=k : i /= k) => pmap {R.E} {V.E}\n          (\\lam (_x : R.E) => _x V.*c BigSum {V} (\\new Array V.E lv'.len (\\lam (k1 : Fin lv'.len) => at {at {A} k} k1 V.*c lv'.at k1)))\n          {at {basis-split {U} {lu'} bu' (lu'.at i)} k} {R.zro} (basis_split_/= {U} {lu'} {bu'} {i} {k} i/=k) *> *c_zro-left {V} {BigSum {V} (\\new Array V.E lv'.len (\\lam (k1 : Fin lv'.len) => at {at {A} k} k1 V.*c lv'.at k1))}) *> pmap {R.E} {V.E}\n        (\\lam (_x : R.E) => _x V.*c BigSum {V} (\\new Array V.E lv'.len (\\lam (k : Fin lv'.len) => at {at {A} i} k V.*c lv'.at k)))\n        {at {basis-split {U} {lu'} bu' (lu'.at i)} i} {R.ide} (basis_split_= {U} {lu'} {bu'} {i}) *> V.ide_*c {BigSum {V} (\\new Array V.E lv'.len (\\lam (k : Fin lv'.len) => at {at {A} i} k V.*c lv'.at k))}) *> basis-split-unique\n    {V} {lv'} bv' {BigSum {V} (\\new Array V.E lv'.len (\\lam (j : Fin lv'.len) => at {at {A} i} j V.*c lv'.at j))} (at {A} i)\n      (idp {V.E} {BigSum {V} (\\new Array V.E lv'.len (\\lam (j : Fin lv'.len) => at {at {A} i} j V.*c lv'.at j))}) j)\n}", "completion": "matrix-equiv bu' bv'"}
{"prompt": "['a : E', 'this : Locale', 'p : \\\\Sigma (b : E) (b \u2227 x.1 <= y.1)', 'x : E']<<<break>>>['| meet-left {x y : E} : x \u2227 y <= x', '\\\\func \\\\infixr 5 --> \\\\hlevels  {this : Locale} (x y : E) : E => SJoin (\\\\lam (p0 : E) => p0 \u2227 x <= y)', '| <=-refl {x : E} : x <= x', '| \\\\infix 4 <= E E : \\\\Prop', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>(a --> p.1) \u2227 x.1 \u2227 a <= (a --> p.1) \u2227 a", "completion": "meet-monotone {this} (meet-left {this}) (<=-refl {this})"}
{"prompt": "['CU : C U', 'e : \\\\Pi {U : Set (E {\\\\this})} -> C U -> isCauchy {\\\\this} (D U)', 'x : X.E', 'U : Set (E {\\\\this})', 'this : CoverSpace X.E {\\n  | isOpen => PrecoverSpace.isOpen\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    \\\\Pi (x : X.E) -> TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (V : Set X.E) (X.isOpen V) (V x) (V \u2286 U))\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n}', 'X : TopSpace', 'D : Set (E {\\\\this}) -> Set (Set (E {\\\\this}))']<<<break>>>['| isOpen (Set E) : \\\\Prop', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U1 : Set (E {\\this})) (D U U1) (V : Set X.E) (X.isOpen V) (V x) (V \u2286 U1))", "completion": "e CU x"}
{"prompt": "['Pe : Equiv {Fin P.finCard} {P.E}', 'f2 : \\\\Pi (i : Fin c.len) -> \\\\Sigma (j : Fin d.len) ((c !! i).1 = (d !! j).1) ((c !! i).2 B.<= (d !! j).2)', 'V : PosetQModule', 'f1 : \\\\Pi (i : Fin b.len) -> \\\\Sigma (j : Fin d.len) ((b !! i).1 = (d !! j).1) ((b !! i).2 B.<= (d !! j).2)', 'b<d : SFRefines {V} {B} b d', 'b : PFunc {V} {B}', 'd : PFunc {V} {B}', 'c : PFunc {V} {B}', 'P : FinSet (\\\\Sigma (i : E) E) {\\n  | finCard => FinSum {NatSemiring} {ProdFin (FinFin b.len) (FinFin c.len)} (\\\\lam (i : E) => finCard)\\n}', 'dr : IsReduced {V} {B} d', 'B : BooleanRing']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\lemma BigJoin-univ \\\\hlevels  {this : BottomJoinSemilattice} {l : Array E} {x : E} (_ : \\\\Pi (j : Fin l.len) -> l.at j <= x) : BigJoin l <= x ', 'FinJoin {this : BottomJoinSemilattice} {J : FinSet} (a : J.E -> E) : E => FinSum {toMonoid this} {J} a', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'byLeft A', '| <=-refl {x : E} : x <= x', '\\\\lemma FinJoin-cond {this : BottomJoinSemilattice} {J : FinSet} (j : J.E) {a : J.E -> E} : a j <= FinJoin {J} a ', '\\\\instance ProdFin (A B : FinSet) : FinSet (\\\\Sigma A.E B.E) {\\n  | finCard => natCoef A.finCard * B.finCard\\n} => transport {Nat} (\\\\lam (finCard : Nat) => FinSet (\\\\Sigma A.E B.E) {\\n  | finCard => finCard\\n}) {FinSum {NatSemiring} {A} (\\\\lam (_ : A.E) => B.finCard)} {natCoef A.finCard * B.finCard}\\n  (FinSum_replicate {NatSemiring} {A} {B.finCard}) (SigmaFin A (\\\\lam (_ : A.E) => B))', '\\\\lemma FinJoin=BigJoin {this : BottomJoinSemilattice} {n : Nat} {x : Fin n -> E} : FinJoin {FinFin n} x = BigJoin (\\\\new Array E n x) ', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| finCard : Nat', '\\\\lemma FinJoin_Equiv {this : BottomJoinSemilattice} {A B : FinSet} (e : Equiv {A.E} {B.E}) {x : B.E -> E} :\\n  FinJoin {B} x = FinJoin {A} (\\\\lam (a : A.E) => x (e.f a)) ', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', 'byRight B', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| zro : E', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma BigJoin-rdistr \\\\hlevels  {this : BottomDistributiveLattice} {l : Array E} {x : E} :\\n  BigJoin l \u2227 x = BigJoin (\\\\new Array E l.len (\\\\lam (j : Fin l.len) => l.at j \u2227 x)) ', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\func DecFin {P : \\\\Prop} (d : Dec P) : FinSet P {\\n  | finCard => rec {Nat} {P} (\\\\lam (_ : P) => 1) (\\\\lam (_ : Not P) => 0) d\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case finEq {\\\\this} \\\\with {\\n    | inP e => \\\\case decideEq (e.ret x) (e.ret y) \\\\with {\\n      | yes q => yes {x = y} (isInj {symQEquiv {Fin (finCard {\\\\this})} {E {\\\\this}} (fromEquiv e)} {x} {y} q)\\n      | no q => no {x = y} (\\\\lam (p : x = y) => q (pmap {E {\\\\this}} {Fin (finCard {\\\\this})} e.ret {x} {y} p))\\n    }\\n  })\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '| bottom-univ {x : E} : bottom <= x']<<<break>>>\\Pi (j : Fin c.len) ->\n((c !! j).1 = V.zro) || (c !! j).2 B.<= BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (\\new Array (\\Sigma V.E B.E) P.finCard\n  (\\lam (j : Fin P.finCard) => ((b.at (Pe.f j).1.1).1, (b.at (Pe.f j).1.1).2 B.* (c.at (Pe.f j).1.2).2))))", "completion": "\\lam j => (\\case b<d.1 (f2 j).1 \\with {\n  | byLeft q => byLeft $ (f2 j).2 *> q\n  | byRight q => byRight $ meet-univ ((f2 j).3 <=\u2218 q) <=-refl <=\u2218 =_<= (BigJoin-rdistr {B}) <=\u2218 BigJoin-univ {B} (\\lam i => later (\\case decideEq (f1 i).1 (f2 j).1 \\with {\n    | yes e => FinJoin-cond {B} {P} ((i, j), e) {\\lam s => (b s.1.1).2 * (c s.1.2).2} <=\u2218 =_<= (FinJoin_Equiv {B} {_} {P} Pe *> FinJoin=BigJoin {B})\n    | no e => meet-monotone {B} (f1 i).3 (f2 j).3 <=\u2218 =_<= (dr e) <=\u2218 bottom-univ\n  }))\n})"}
{"prompt": "['Y : Ob {C {\\\\this}}', 'E : Precat', \"a : NatTrans {C} {E} F' F\", \"b : NatTrans {D} {E} G G'\", 'F : Functor C E', 'p0 : Hom {C {\\\\this}} X Y', 'X : Ob {C {\\\\this}}', \"G' : Functor D E\", \"F' : Functor C E\", 'f_g_c : Hom {C {\\\\this}} X Y', 'G : Functor D E', \"d : HData {E} {Fin 7} (\\\\lam (j : Fin 7) => (\\\\case j \\\\with {\\n  | zero => F.F X.1\\n  | suc zero => G.F Y.2\\n  | suc (suc zero) => G.F X.2\\n  | suc (suc (suc zero)) => F'.F X.1\\n  | suc (suc (suc (suc zero))) => G'.F Y.2\\n  | suc (suc (suc (suc (suc zero)))) => F'.F Y.1\\n  | suc (suc (suc (suc (suc (suc zero))))) => F.F Y.1\\n}))\\n  (\\\\lam (i : V {\\\\this}) (j : V {\\\\this}) => (\\\\case i, j \\\\with {\\n    | suc (suc (suc (suc (suc zero)))), suc (suc (suc (suc (suc (suc zero))))) => Fin 1\\n    | suc (suc (suc zero)), suc (suc (suc (suc (suc zero)))) => Fin 1\\n    | zero, suc (suc zero) => Fin 1\\n    | suc zero, suc (suc (suc (suc zero))) => Fin 1\\n    | suc (suc (suc (suc (suc (suc zero))))), suc zero => Fin 1\\n    | suc (suc (suc zero)), zero => Fin 1\\n    | suc (suc zero), suc zero => Fin 1\\n    | v, v => Fin 0\\n  }))\\n  (\\\\lam {i : V {\\\\this}} {j : V {\\\\this}} (k : H {\\\\this} i j) => (\\\\case i, j, k \\\\with {\\n    | suc (suc (suc (suc (suc zero)))), suc (suc (suc (suc (suc (suc zero))))), zero => a.trans Y.1\\n    | suc (suc (suc zero)), suc (suc (suc (suc (suc zero)))), zero => F'.Func {X.1} {Y.1} p0.1\\n    | zero, suc (suc zero), zero => X.3\\n    | suc zero, suc (suc (suc (suc zero))), zero => b.trans Y.2\\n    | suc (suc (suc (suc (suc (suc zero))))), suc zero, zero => Y.3\\n    | suc (suc (suc zero)), zero, zero => a.trans X.1\\n    | suc (suc zero), suc zero, zero => G.Func {X.2} {Y.2} p0.2\\n  }))\"]<<<break>>>[\"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| H V V : \\\\Set', '\\\\lemma terms-equality \\\\plevels obj >= hom \\\\hlevels  {this : HData} {a b : V} (t s : CatTerm {V} a b H)\\n  (_ : interpretNF {a} {b} (normalize {V} {a} {b} {H} t) = interpretNF {a} {b} (normalize {V} {a} {b} {H} s)) :\\n  interpret {a} {b} t = interpret {a} {b} s ', '\\\\class HData \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | V : \\\\Set\\n  | f V : Ob {C}\\n  | H V V : \\\\Set\\n  | g {x y : V} (H x y) : Hom {C} (f x) (f y)\\n}', ':nil (a = b)', '| F : Functor C D', '\\\\func interpretNF \\\\plevels obj >= hom \\\\hlevels  {this3 : HData} {a3 b2 : V} (_ : CatNF {V} a3 b2 H) : Hom {C} (f a3) (f b2) \\n  | {this}, {a}, {b}, :nil idp => id {C} (f a)\\n  | {this}, {a}, {b}, :cons {c} h (:nil idp) => g {a} {b} h\\n  | {this}, {a}, {b}, :cons {c} h t => g {c} {b} h \u2218 interpretNF {a} {c} t', '| V : \\\\Set', 'var (H a b)', '| C : Precat', \"\\\\lemma interpretNF_++ \\\\plevels obj >= hom \\\\hlevels  {this : HData} {a b c : V} (h : CatNF {V} b c H) (h' : CatNF {V} a b H) :\\n  interpretNF {a} {c} (h :++ h') = interpretNF {b} {c} h \u2218 interpretNF {a} {b} h' \", \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X', '\\\\func normalize {V : \\\\Type} {a b : V} {H : V -> V -> \\\\Type} (t : CatTerm {V} a b H) : CatNF {V} a b H \\n  => aux {V} {a} {a} {b} {H} t (:nil {V} {a} {a} {H} (idp {V} {a}))', '| Hom Ob Ob : \\\\Set', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', ':o (c : V) (CatTerm {V} c b H) (CatTerm {V} a c H)', '\\\\func interpret \\\\plevels obj >= hom \\\\hlevels  {this3 : HData} {a3 b2 : V} (_ : CatTerm {V} a3 b2 H) : Hom {C} (f a3) (f b2) \\n  | {this}, {a}, {b}, var h => g {a} {b} h\\n  | {this}, {a}, {b}, :id idp => id {C} (f a)\\n  | {this}, {a}, {b}, :o c t s => interpret {c} {b} t \u2218 interpret {a} {c} s', '\\\\infixl 7 :cons {c : V} (H c b) (CatNF {V} a c H)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '\\\\lemma normalize-consistent \\\\plevels obj >= hom \\\\hlevels  {this : HData} {a b : V} (t : CatTerm {V} a b H) :\\n  interpret {a} {b} t = interpretNF {a} {b} (normalize {V} {a} {b} {H} t) ', '| D : Precat', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| G : Functor C D', '| f V : Ob {C}', '| g {x y : V} (H x y) : Hom {C} (f x) (f y)']<<<break>>>interpret {\\new HData {E} {Fin 6} (\\lam (j : Fin 6) => (\\case j \\with {\n  | zero => Functor.F {a.F} X.1\n  | suc zero => Functor.F {a.G} Y.1\n  | suc (suc zero) => Functor.F {a.F} Y.1\n  | suc (suc (suc zero)) => G'.F Y.2\n  | suc (suc (suc (suc zero))) => Functor.F {b.F} Y.2\n  | suc (suc (suc (suc (suc zero)))) => F.F X.1\n}))\n  (\\lam (i : V {\\this}) (j : V {\\this}) => (\\case i, j \\with {\n    | zero, suc (suc zero) => Fin 1\n    | suc zero, suc (suc (suc (suc zero))) => Fin 1\n    | zero, suc (suc (suc (suc (suc zero)))) => Fin 1\n    | suc (suc (suc (suc (suc zero)))), suc zero => Fin 1\n    | suc (suc (suc (suc zero))), suc (suc (suc zero)) => Fin 1\n    | suc (suc zero), suc zero => Fin 1\n    | v, v => Fin 0\n  }))\n  (\\lam {i : V {\\this}} {j : V {\\this}} (k : H {\\this} i j) => (\\case i, j, k \\with {\n    | zero, suc (suc zero), zero => F'.Func {X.1} {Y.1} p0.1\n    | suc zero, suc (suc (suc (suc zero))), zero => Y.3\n    | zero, suc (suc (suc (suc (suc zero)))), zero => a.trans X.1\n    | suc (suc (suc (suc (suc zero)))), suc zero, zero => F.Func {X.1} {Y.1} p0.1\n    | suc (suc (suc (suc zero))), suc (suc (suc zero)), zero => b.trans Y.2\n    | suc (suc zero), suc zero, zero => a.trans Y.1\n  }))} {0} {3} (:o {Fin 6} {0} {3} {\\lam (i : Fin 6) (j : Fin 6) => (\\case i, j \\with {\n  | zero, suc (suc zero) => Fin 1\n  | suc zero, suc (suc (suc (suc zero))) => Fin 1\n  | zero, suc (suc (suc (suc (suc zero)))) => Fin 1\n  | suc (suc (suc (suc (suc zero)))), suc zero => Fin 1\n  | suc (suc (suc (suc zero))), suc (suc (suc zero)) => Fin 1\n  | suc (suc zero), suc zero => Fin 1\n  | f, f => Fin 0\n})} 2 (:o {Fin 6} {2} {3} {\\lam (i : Fin 6) (j : Fin 6) => (\\case i, j \\with {\n  | zero, suc (suc zero) => Fin 1\n  | suc zero, suc (suc (suc (suc zero))) => Fin 1\n  | zero, suc (suc (suc (suc (suc zero)))) => Fin 1\n  | suc (suc (suc (suc (suc zero)))), suc zero => Fin 1\n  | suc (suc (suc (suc zero))), suc (suc (suc zero)) => Fin 1\n  | suc (suc zero), suc zero => Fin 1\n  | f, f => Fin 0\n})} 1 (:o {Fin 6} {1} {3} {\\lam (i : Fin 6) (j : Fin 6) => (\\case i, j \\with {\n  | zero, suc (suc zero) => Fin 1\n  | suc zero, suc (suc (suc (suc zero))) => Fin 1\n  | zero, suc (suc (suc (suc (suc zero)))) => Fin 1\n  | suc (suc (suc (suc (suc zero)))), suc zero => Fin 1\n  | suc (suc (suc (suc zero))), suc (suc (suc zero)) => Fin 1\n  | suc (suc zero), suc zero => Fin 1\n  | f, f => Fin 0\n})} 4 (var {Fin 6} {4} {3} {\\lam (i : Fin 6) (j : Fin 6) => (\\case i, j \\with {\n  | zero, suc (suc zero) => Fin 1\n  | suc zero, suc (suc (suc (suc zero))) => Fin 1\n  | zero, suc (suc (suc (suc (suc zero)))) => Fin 1\n  | suc (suc (suc (suc (suc zero)))), suc zero => Fin 1\n  | suc (suc (suc (suc zero))), suc (suc (suc zero)) => Fin 1\n  | suc (suc zero), suc zero => Fin 1\n  | f, f => Fin 0\n})} 0)\n  (var {Fin 6} {1} {4} {\\lam (i : Fin 6) (j : Fin 6) => (\\case i, j \\with {\n    | zero, suc (suc zero) => Fin 1\n    | suc zero, suc (suc (suc (suc zero))) => Fin 1\n    | zero, suc (suc (suc (suc (suc zero)))) => Fin 1\n    | suc (suc (suc (suc (suc zero)))), suc zero => Fin 1\n    | suc (suc (suc (suc zero))), suc (suc (suc zero)) => Fin 1\n    | suc (suc zero), suc zero => Fin 1\n    | f, f => Fin 0\n  })} 0))\n  (var {Fin 6} {2} {1} {\\lam (i : Fin 6) (j : Fin 6) => (\\case i, j \\with {\n    | zero, suc (suc zero) => Fin 1\n    | suc zero, suc (suc (suc (suc zero))) => Fin 1\n    | zero, suc (suc (suc (suc (suc zero)))) => Fin 1\n    | suc (suc (suc (suc (suc zero)))), suc zero => Fin 1\n    | suc (suc (suc (suc zero))), suc (suc (suc zero)) => Fin 1\n    | suc (suc zero), suc zero => Fin 1\n    | f, f => Fin 0\n  })} 0))\n  (var {Fin 6} {0} {2} {\\lam (i : Fin 6) (j : Fin 6) => (\\case i, j \\with {\n    | zero, suc (suc zero) => Fin 1\n    | suc zero, suc (suc (suc (suc zero))) => Fin 1\n    | zero, suc (suc (suc (suc (suc zero)))) => Fin 1\n    | suc (suc (suc (suc (suc zero)))), suc zero => Fin 1\n    | suc (suc (suc (suc zero))), suc (suc (suc zero)) => Fin 1\n    | suc (suc zero), suc zero => Fin 1\n    | f, f => Fin 0\n  })} 0)) = d.g {1} {4} 0 E.\u2218 (Y.3 E.\u2218 F.Func {X.1} {Y.1} f) E.\u2218 d.g {3} {0} 0", "completion": "\n  \\let d => \\new HData {E} (\\lam (j : Fin 6) => (\\case j \\with {\n         | 0 => Functor.F {a.F} X.1\n         | 1 => F {a.G} Y.1\n         | 2 => Functor.F {a.F} Y.1\n         | 3 => G'.F Y.2\n         | 4 => Functor.F {b.F} Y.2\n         | 5 => F.F X.1\n       }))\n         (\\lam i j => (\\case i, j \\with {\n           | 0, 2 => Fin 1\n           | 1, 4 => Fin 1\n           | 0, 5 => Fin 1\n           | 5, 1 => Fin 1\n           | 4, 3 => Fin 1\n           | 2, 1 => Fin 1\n           | _, _ => Fin 0\n         }))\n         (\\lam {i} {j} k => (\\case \\elim i, \\elim j, k \\with {\n           | 0, 2, 0 => F'.Func {X.1} {Y.1} f\n           | 1, 4, 0 => Y.3\n           | 0, 5, 0 => a.trans X.1\n           | 5, 1, 0 => F.Func {X.1} {Y.1} f\n           | 4, 3, 0 => b.trans Y.2\n           | 2, 1, 0 => a.trans Y.1\n         }))\n  \\in transportInv (\\lam x0 => substitution_meta) ((normalize-consistent {_} {0} {3}\n        (:o {V {d}} {0} {3} {H {d}} 2 (:o {V {d}} {2} {3} {H {d}} 1 (:o {V {d}} {1} {3} {H {d}} 4 (var 0) (var 0)) (var 0)) (var 0)) *> interpretNF_++ (0 :cons {V {d}} {1} {3} {H {d}} {4} (0 :cons {V {d}} {1} {4} {H {d}} {1} :nil idp))\n        (0 :cons {V {d}} {0} {1} {H {d}} {2} (0 :cons {V {d}} {0} {2} {H {d}} {0} :nil idp)) *> pmap (\\lam occurVar => interpretNF (0 :cons {V {d}} {1} {3} {H {d}} {4} (0 :cons {V {d}} {1} {4} {H {d}} {1} :nil idp)) \u2218 occurVar)\n        (inv (normalize-consistent {d} {0} {1} (:o {V {d}} {0} {1} {H {d}} 2 (var 0) (var 0))))) *> pmap (\\lam (occurVar : Hom {a.D} (Functor.F {a.F} X.1) (Functor.F {a.G} Y.1)) =>\n        interpretNF (0 :cons {V {d}} {1} {3} {H {d}} {4} (0 :cons {V {d}} {1} {4} {H {d}} {1} :nil idp)) \u2218 occurVar)\n        (a.natural {X.1} {Y.1} f)) equation"}
{"prompt": "['M : Locale', 'J : \\\\Set', 'g : J -> E {Dom {\\\\this}}', 'j : J', 'p0 : \\\\Sigma (b : M.E) (b <=< M.Join {J} g)']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\func neg \\\\hlevels  {this : Locale} (x : E) : E => x --> bottom', '\\\\type \\\\infix 4 <=< \\\\hlevels  {this : Locale} (x y : E) : \\\\Prop => top <= neg x \u2228 y', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma SJoin-cond \\\\hlevels  {this : CompleteLattice} {U : E -> \\\\Prop} {x : E} (_ : U x) : x <= SJoin U ', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '\\\\func SJoin \\\\hlevels  {this : CompleteLattice} (U : E -> \\\\Prop) : E => Join {\\\\Sigma (b : E) (U b)} (\\\\lam (t : Total {E} U) => t.1)', 'byRight B']<<<break>>>\\Pi {x : M.E} -> x <=< g j -> x M.<= SJoin {M} (\\lam (b : M.E) => (b = neg {M} p0.1) || (\\Sigma (j : J) (b <=< g j)))", "completion": "\\lam x<=<gj => SJoin-cond {M} $ byRight $ later (j, x<=<gj)"}
{"prompt": "['R : CRing', 'a : R.E', 'p : Poly R', 'n : Nat', 'b : R.E']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '\\\\lemma BigSum_suc \\\\hlevels  {this : AddMonoid} {n : Nat} {l : Array E (suc n)} : BigSum l = BigSum (\\\\new Array E n l.at) + l.at (fromNat {n} n) ', 'suc Nat', '\\\\func polyCoef \\\\hlevels  {R4 : AddPointed} (_ : Poly R4) (_ : Nat) : R.E \\n  | {R}, pzero, n => R.zro\\n  | {R}, padd p e, 0 => e\\n  | {R}, padd p e, suc n => polyCoef {R} p n\\n  | {R}, peq i, 0 => idp {R.E} {R.zro} @ i\\n  | {R}, peq i, suc n => idp {R.E} {R.zro} @ i', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>BigSum {R} (\\new Array R.E (suc n) (\\lam (j : Fin (suc n)) => polyCoef {R} p j R.* pow {R} a j R.* pow {R} b (n -' j))) = BigSum {R} (\\new Array R.E n (\\lam (i : Fin n) => polyCoef {R} p i R.* pow {R} a i R.* pow {R} b (n -' i))) R.+ polyCoef {R} p (fromNat {n} n) R.* pow {R} a (fromNat {n} n) R.* pow {R} b (n -' fromNat {n} n)", "completion": "BigSum_suc {R} {n} {\\lam j => polyCoef p j * pow a j * pow b (n -' j)}"}
{"prompt": "['f : A.E -> B.E', 'A : InhSpace', 'g : A.E -> C.E', 'this : Connected0 (PushoutData {A.E} {B.E} {C.E} f g) {\\n  | isInh => {?hidden}\\n  | isConn0 => {?hidden}\\n}', 'C : Connected0', 'B : Connected0']<<<break>>>['\\\\data PushoutData {A B C : \\\\Type} (A -> B) (A -> C) \\n  | pinl B\\n  | pinr C\\n  | pglue A I', 'pinr C', 'pglue A I', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", 'inP A', '| E : \\\\Type', '| isConn0 (x y : E) : TruncP (x = y)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'right', '| isInh : TruncP E', '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'pinl B', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", 'left', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>\\Pi (x : E {\\this}) -> \\Pi (y : E {\\this}) -> TruncP (x = y)", "completion": "\\lam x y => (\\scase isInh, \\elim x, \\elim y \\with {\n  | inP a, pinl b, pinl b' => map (isConn0 b b') (pmap pinl)\n  | inP a, pinl b, pinr c => \\scase isConn0 b (f a), isConn0 (g a) c \\with {\n    | inP p, inP q => inP (pmap pinl p *> path (pglue a) *> pmap pinr q)\n  }\n  | inP a, pinr c, pinl b => \\scase isConn0 c (g a), isConn0 (f a) b \\with {\n    | inP p, inP q => inP (pmap pinr p *> inv (path (pglue a)) *> pmap pinl q)\n  }\n  | inP a, pinr c, pinr c' => map (isConn0 c c') (pmap pinr)\n})"}
{"prompt": "['F : VSheaf D (framePresSite P)', 'P : FramePres', 'this : VSheaf D (PresentedFrame P) (extend {P} {D} {F}) {\\n  | isSheaf => {?hidden}\\n}', 'D : CompleteCat']<<<break>>>['| A : \\\\Type', '| x : Ob {C}', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '| limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j', '| D : Precat', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| ret B : A', \"\\\\lemma prop-pi \\\\plevels  \\\\hlevels  {A : \\\\Prop} {a a' : A} : a = a' \", '| J : Precat', '\\\\func extend-proj \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (y : P.E) :\\n  D.Hom (Functor.F (embed {P} y)) (Functor.F {F.F} y) \\n=> coneMap {D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= embed {P} y)}\\n  (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= embed {P} y)) => t.1)}} (limFunctor {P} {D} {F} (embed {P} y))}\\n  (y, \\\\lam {x : P.E} (d : (embed {P} y).1 x) => d)', \"\\\\func framePresSite \\\\hlevels  (P : FramePres) : SiteWithBasis P.E {\\n  | Hom => Cover1 {P}\\n  | id => <=-refl\\n  | o => \\\\lam {X Y Z : Ob} (f : Hom Y Z) (g : Hom X Y) => g <=\u2218 f\\n  | pullback => \\\\lam {x1 y1 z1 : P.E} (f1 : Cover1 {P} x1 z1) (g1 : Cover1 {P} y1 z1) => \\\\new Pullback {x1} {y1} {z1} f1 g1 (P.conj x1 y1) {\\n    | pbProj1 => cover-proj1 {P} {apex {\\\\this}} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x {\\\\this}} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {x1})\\n    | pbProj2 => cover-proj2 {P} {P.conj x1 y1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => y1} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {y1})\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {D {\\\\this}}} (p1 : Hom {D {\\\\this}} w (x {\\\\this})) (p2 : Hom {D {\\\\this}} w (y {\\\\this}))\\n      (_ : f {\\\\this} \u2218 p1 = g {\\\\this} \u2218 p2) => cover-prod {P} {w} {x1} {y1} p1 p2\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | isBasicCover => \\\\lam (x : Ob {\\\\this}) {J : \\\\Set} (g : J -> Ob) =>\\n  TruncP (\\\\Sigma (y : P.E) (Cover1 {P} x y) (g' : J -> P.E) (P.BasicCover {J} y g')\\n    (\\\\Pi (j : J) -> \\\\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (g j).1)))\\n} => \\\\new SiteWithBasis {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | basicCover-stable => {?hidden}\\n}\", '\\\\lemma cover-lem \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} {a : P.E} {J1 : \\\\Set} {g : J1 -> P.E}\\n  (_ : Cover {P} a {J1} g) : Limit {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} a}\\n  {\\\\Sigma (y : ObOver {framePresPreorder P} a) (TruncP (\\\\Sigma (j : J1) (Cover1 {P} y.1 (g j))))}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} a) (TruncP (\\\\Sigma (j : J1) (Cover1 {P} y.1 (g j))))) => p.1)}} {D}\\n  (Comp {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} a}\\n    {\\\\Sigma (y : ObOver {framePresPreorder P} a) (TruncP (\\\\Sigma (j : J1) (Cover1 {P} y.1 (g j))))}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} a) (TruncP (\\\\Sigma (j : J1) (Cover1 {P} y.1 (g j))))) => p.1)}}\\n    {Precat.op {framePresSite P}} {D} F.F (Functor.op {diagram {genSieve {P} a {J1} g}})) (Functor.F {F.F} apex) {\\n  | coneMap => \\\\lam (j : Ob {J}) => Func {F.F} {apex} {Functor.F j} (coneMap j)\\n} ', '| E : \\\\Set', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\func isInj {this : Equiv} {a a' : A} (p : f a = f a') : a = a' \\n  => inv {A} {ret (f a)} {a} (ret_f a) *> pmap {B} {A} ret {f a} {f a'} p *> ret_f a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func limMap-impl \\\\plevels obj >= hom \\\\hlevels  {this : Limit} {z : Ob {D}} (c : Cone {J} {D} G z) : Hom {D} z apex => ret {isLimit z} c', '| C : Precat', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '\\\\lemma genSieve \\\\hlevels  {P : FramePres} (a : P.E) {J : \\\\Set} (g : J -> P.E) : Sieve {framePresPreorder P} a\\n  (\\\\lam {b : Ob {C {\\\\this}}} (_ : Hom {C {\\\\this}} b (x {\\\\this})) => TruncP (\\\\Sigma (j : J) (Cover1 {P} b (g j)))) ', '\\\\class Sieve \\\\extends Presieve \\\\plevels obj >= hom \\\\hlevels  {\\n  | isSieve {z y : Ob {C}} (g : Hom {C} z y) {f : Hom {C} y x} (S {y} f) : S {z} (f \u2218 g)\\n}', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\lemma extend-proj-nat'' \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} {U V : E} (U<=V : U <= V) {x : P.E}\\n  (x<=U : embed {P} x <= U) :\\nconeMap {D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= U)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= U)) => t.1)}}\\n  (limFunctor {P} {D} {F} U)} (x, x<=U) D.\u2218 Func {V} {U} U<=V = coneMap {D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= V)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= V)) => t.1)}}\\n  (limFunctor {P} {D} {F} V)} (x, x<=U <=\u2218 U<=V) \", \"\\\\lemma coneMap-nat \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} {U V : E} (h' : U <= V)\\n  {a : \\\\Sigma (x : P.E) (embed {P} x <= U)} {b : \\\\Sigma (y : P.E) (embed {P} y <= V)} (h : Cover1 {P} a.1 b.1) :\\n  coneMap a D.\u2218 Func {V} {U} h' = Func {F.F} {b.1} {a.1} h D.\u2218 coneMap b \", '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| limit {J : Precat} (G : Functor J \\\\this) : Limit {J} G', '\\\\lemma limBeta-impl \\\\plevels obj >= hom \\\\hlevels  {this : Limit} {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap-impl {z} c = c.coneMap j ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| sec B : A', '| isCover (x : Ob) (Sieve x) : \\\\Prop', '| isBasicCover (x : Ob) {J : \\\\Set} (J -> Ob) : \\\\Prop', '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x', '\\\\func framePresPreorder \\\\hlevels  (P : FramePres) : Preorder P.E {\\n  | <= => Cover1 {P}\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', '\\\\func limFunctor \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\\nFunctor (Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})\\n  D (\\\\lam (X : Ob {C {\\\\this}}) => Functor.F {F.F} (Functor.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => Func {F.F} {Functor.F X} {Functor.F Y} (Func {X} {Y} f)\\n} => Comp {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  {Precat.op {framePresSite P}} {D} F.F\\n  (Functor.op {embedding {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})', '\\\\func Cover1 \\\\hlevels  {P : FramePres} (x y : P.E) : \\\\Prop => Cover {P} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => y)', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', '\\\\type ObOver \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : \\\\hType => \\\\Sigma (y : C.Ob) (C.Hom y x)', '\\\\func coe (A : I -> \\\\Type) (a : A left) (i : I) : A i ', '| limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', \"\\\\lemma extend-proj-nat \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} {y z : P.E} (h : Cover1 {P} y z)\\n  (h' : embed {P} y <= embed {P} z) :\\n  extend-proj {P} {D} {F} y D.\u2218 Func {embed {P} z} {embed {P} y} h' = Func {F.F} {z} {y} h D.\u2218 extend-proj {P} {D} {F} z \", '| G : Functor J D', '\\\\func subPrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} {X : \\\\hType} (f : X -> C.Ob) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => C.Hom (f x) (f y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => C.id (f x)\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} => (C.\u2218)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func lim \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\\nLimit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  {D} (limFunctor {P} {D} {F} b) \\n=> D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  (limFunctor {P} {D} {F} b)', '\\\\instance SlicePrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : Precat (ObOver {C} x) {\\n  | Hom => \\\\lam (p0 : Ob {\\\\this}) (p1 : Ob {\\\\this}) => \\\\Sigma (h : C.Hom p0.1 p1.1) (p1.2 C.\u2218 h = p0.2)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (C.id p0.1, C.id-right {p0.1} {x} {p0.2})\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) => (p0.1 C.\u2218 p1.1,\\n    inv {C.Hom X.1 x} {Z.2 C.\u2218 p0.1 C.\u2218 p1.1} {Z.2 C.\u2218 (p0.1 C.\u2218 p1.1)} (C.o-assoc {X.1} {Y.1} {Z.1} {x} {Z.2} {p0.1} {p1.1}) *> pmap {C.Hom Y.1 x} {C.Hom X.1 x} (\\\\lam (_x : C.Hom Y.1 x) => _x C.\u2218 p1.1) {Z.2 C.\u2218 p0.1} {Y.2} p0.2 *> p1.2)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func map \\\\plevels obj >= hom \\\\hlevels  {C D : Precat} (F1 : Functor C D) {J1 : Precat} {G : Functor J1 C} (c : Cone {J1} {C} G) :\\nCone {J1} {D} (Comp {J1} {C} {D} F1 G) (F.F c.apex) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => F.Func {c.apex} {G.F j} (c.coneMap j)\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| C : Precat', '| isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\\\new \\\\this {}) z)', '| S {y : Ob {C}} (Hom {C} y x) : \\\\Prop', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", \"\\\\lemma extend-proj-nat' \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} {y : P.E} {V : E} (h' : embed {P} y <= V) :\\nextend-proj {P} {D} {F} y D.\u2218 Func {V} {embed {P} y} h' = coneMap {D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= V)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= V)) => t.1)}}\\n  (limFunctor {P} {D} {F} V)} (y, h') \", '| F : Functor (op {C}) D', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", \"\\\\func pathOver {A : I -> \\\\Type} {a : A left} {a' : A right} (p : coe A a right = a') : Path A a a' \\n  => concat {A} {a} {coe A a right} {a'} (idpOver A a) p\", \"\\\\class Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | J : Precat\\n  | D : Precat\\n  | G : Functor J D\\n  | apex : Ob {D}\\n  | coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)\\n  | coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\\n}\", '| limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'right', '\\\\class Limit \\\\extends Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\\\new \\\\this {}) z)\\n  | limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex\\n  | limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j\\n  | limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g\\n}', '\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '\\\\func embedding \\\\plevels obj >= hom \\\\hlevels  {C1 : Precat} {X : \\\\hType} (f : X -> C.Ob) : FullyFaithfulFunctor (subPrecat {C1} {X} f) C1 f {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (h : Hom {C {\\\\this}} X Y) => h\\n} => \\\\new FullyFaithfulFunctor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n}', '| D : Cat', '| apex : Ob {D}', '| isSieve {z y : Ob {C}} (g : Hom {C} z y) {f : Hom {C} y x} (S {y} f) : S {z} (f \u2218 g)', 'cover-inj (j : J) (g j = x)', '| D : Precat', '\\\\func conePullback \\\\plevels obj >= hom \\\\hlevels  {J1 : Precat} {D1 : Precat} {F1 : Functor J1 D1} (C : Cone {J1} {D1} F1) (z : D.Ob) (f : D.Hom z C.apex) :\\nCone {J1} {D1} F1 z {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => C.coneMap j D.\u2218 f\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| Ob : \\\\hType', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| B : \\\\Type', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func extend \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} :\\nFunctor (op {PresentedFrame P}) D (\\\\lam (b : Ob {C {\\\\this}}) => apex) {\\n  | Func => \\\\lam {a : Ob {C {\\\\this}}} {b : Ob {C {\\\\this}}} (b<=a : Hom {C {\\\\this}} a b) => limMap {apex} (cone {P} {D} {F} {a} {b} b<=a)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func cone \\\\plevels obj >= hom \\\\hlevels  {this2 : Presieve} :\\nCone {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)} (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)) => p.1)}}\\n  {Precat.op {C}} (Functor.op {diagram}) x {\\n  | coneMap => \\\\lam (p0 : Ob {J {\\\\this}}) => p0.1.2\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func diagram \\\\plevels obj >= hom \\\\hlevels  {this1 : Presieve} : Functor (subPrecat {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)) => p.1)) Presieve.C\\n  (\\\\lam (X : Ob {Functor.C {\\\\this}}) => F (F X)) {\\n  | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) => Func {F X} {F Y} (Func {X} {Y} f)\\n} => Comp {subPrecat {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)) => p.1)} {SlicePrecat {Presieve.C} x} {Presieve.C}\\n  (forget {Presieve.C} x) (embedding {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : Ob) (S {y.1} y.2)) => p.1))']<<<break>>>\\Pi {U : Ob {C {\\this}}} -> \\Pi {s : Sieve {C {\\this}} U} -> isCover {C {\\this}} U s ->\n  Limit {Precat.op {subPrecat {SlicePrecat {C {\\this}} U} {\\Sigma (y : ObOver {C {\\this}} U) (s.S {y.1} y.2)}\n    (\\lam (p : \\Sigma (y : ObOver {C {\\this}} U) (s.S {y.1} y.2)) => p.1)}} {D {\\this}}\n    (Comp {Precat.op {subPrecat {SlicePrecat {C {\\this}} U} {\\Sigma (y : ObOver {C {\\this}} U) (s.S {y.1} y.2)}\n      (\\lam (p : \\Sigma (y : ObOver {C {\\this}} U) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C {\\this}}} {D {\\this}}\n      (VPresheaf.F {\\this}) (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F {\\this}} apex) {\n    | coneMap => \\lam (j : Ob {J}) => Func {VPresheaf.F {\\this}} {apex} {Functor.F j} (coneMap j)\n    | coneCoh => {?hidden}\n  }", "completion": "\\lam {U} {s : Sieve} p0 => (\\scase \\elim p0 \\with {\n  | inP (J, g, U<=g, g<=s) => \\new Limit {\n    | isLimit => \\lam z => (\n      \\have | lim (j : \\Sigma (x : P) (embed x <= U)) => cover-lem (U<=g (j.2 (cover-inj () idp)))\n            | lem (j : \\Sigma (x : P) (embed x <= U)) (k : \\Sigma (y : \\Sigma (y : P) (Cover1 y j.1)) (\u2203 (\\Sigma (j : \\Sigma (j : J) (x : P) ((g j).1.1 x)) (Cover1 y.1 j.2)))) : s (\\lam d => j.2 (cover-trans d (\\lam _ => k.1.2))) => \\case k.2 \\with {\n              | inP ((j, z, z<=gj), y<=z) => transport (\\lam p0 => s p0) prop-pi (isSieve {s} {embed k.1.1}\n                (\\lam {w} w<=y => (g j).1.2 w (cover-trans w<=y (\\lam _ => cover-trans y<=z (\\lam _ => cover-inj (z, z<=gj) idp))))\n                (g<=s j))\n            }\n      \\in \\new QEquiv {\n            | ret => \\lam (c : Cone) => (\n              \\have cone j => \\new Cone (G {lim j}) z {\n                      | coneMap => \\lam k => extend-proj k.1.1 \u2218 coneMap {c} ((embed k.1.1, \\lam z<=y => j.2 (cover-trans z<=y (\\lam _ => k.1.2))), lem j (k.1, k.2))\n                      | coneCoh => \\lam h => inv o-assoc *> pmap (\\lam _x => _x \u2218 _) (inv (extend-proj-nat h.1 (\\lam p0 => cover-trans p0 (\\lam _ => h.1)))) *> o-assoc *> pmap ((\u2218) _) (coneCoh {c} (later (\\lam p0 => cover-trans p0 (\\lam _ => h.1), prop-pi)))\n                    }\n              \\in limMap {lim U} (\\new Cone {\n                    | coneMap => \\lam j => limMap {lim j} (cone j)\n                    | coneCoh => \\lam {j} {j'} h => limUnique {lim j'}\n                      (\\lam k => inv o-assoc *> pmap (\\lam _x => _x \u2218 _) (inv Func-o) *> limBeta {lim j} (cone j) ((k.1.1, k.1.2 <=\u2218 {framePresPreorder P} h), k.2) *> path (\\lam i => extend-proj k.1.1 \u2218 coneMap {c} ((embed k.1.1, prop-pi i), pathOver prop-pi i)) *> inv (limBeta {lim j'} (cone j') k))\n                  }))\n            | ret_f => \\lam h => limUnique (\\lam j => limBeta {lim (apex {cone {s}})} _ j *> limUnique {lim j} (\\lam k => later $ limBeta {lim j} _ k *> inv o-assoc *> pmap (\\lam _x => _x \u2218 h)\n              (extend-proj-nat' _ *> inv (coneCoh {_} {j} {later (k.1.1, \\lam d => j.2 (cover-trans d (\\lam _ => k.1.2)))} $ later k.1.2)) *> o-assoc))\n            | f_sec => \\lam (c : Cone) =>\n            exts (\\lam m => limUnique (\\lam j => inv o-assoc *> pmap (\\lam _x => _x \u2218 _) (extend-proj-nat'' m.1.2 _) *> limBeta {lim U} _ (j.1, j.2 <=\u2218 m.1.2) *> limUnique {lim (j.1, j.2 <=\u2218 m.1.2)}\n              (\\lam k => limBeta {lim (j.1, j.2 <=\u2218 m.1.2)} _ k *> pmap ((\u2218) _) (inv (coneCoh {c} (\\lam d => j.2 (cover-trans d (\\lam _ => k.1.2)), prop-pi))) *> inv o-assoc *> pmap (\\lam _x => _x \u2218 _) (coneMap-nat (\\lam d => j.2 (cover-trans d (\\lam _ => k.1.2))) {(k.1.1, \\lam d => d)} {j} k.1.2) *> o-assoc)))\n          })\n  }\n})"}
{"prompt": "['b : E', 'x : Rat', 'c_d : \\n  \\\\let (a, b) => conj a b\\n  \\\\in \\\\Sigma (a < x) (x < b)', 'a : E']<<<break>>>[\"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '| join-left {x y : E} : x <= x \u2228 y', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)']<<<break>>>a.1 < x", "completion": "join-left <\u2218r c"}
{"prompt": "['lu : Array U.E', 'R : Ring', 'f : LinearMap {R} V W', 'lv : Array V.E', 'A : Matrix R.E lu.len lv.len', 'V : LModule R', 'W : LModule R', 'bu : IsBasis {U} lu', 'U : LModule R']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 8 compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {R1 : Ring} {U V W : LModule R1} (g : LinearMap {R1} V W) (f : LinearMap {R1} U V) : LinearMap {R1} U W {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => g.func (f.func a)\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '\\\\func toLinearMap \\\\hlevels  {R : Ring} {U V : LModule R} {lu : Array U.E} (bu : IsBasis {U} lu) (lv : Array V.E) (A : Matrix R.E lu.len lv.len) :\\nLinearMap {R} U V {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => BigSum {V} (\\\\new Array V.E lu.len (\\\\lam (j : Fin lu.len) =>\\n    at {basis-split {U} {lu} bu x} j V.*c at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))\\n} => extend {R} {U} {V} {lu} bu\\n  (\\\\new Array V.E lu.len (\\\\lam (j : Fin lu.len) => at {at {product-gen {R} {V} {lu.len} {lv.len} {1} A (mkColumn {V.E} lv)} j} 0))', '| Dom : BaseSet']<<<break>>>\\Pi {x y : E {Dom {f \u2218 toLinearMap {R} {U} {V} {lu} bu lv A}}} ->\n  func {f \u2218 toLinearMap {R} {U} {V} {lu} bu lv A} (x + y) = func {f \u2218 toLinearMap {R} {U} {V} {lu} bu lv A} x + func {f \u2218 toLinearMap {R} {U} {V} {lu} bu lv A} y", "completion": "func-+ {f \u2218 toLinearMap {R} {U} {V} {lu} bu lv A}"}
{"prompt": "['X : TopLModule R', 'x : E']<<<break>>>['\\\\class ContMap \\\\extends SetHom \\\\hlevels  {\\n  | func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))\\n}', '| E : \\\\Set', '\\\\func const \\\\hlevels  {Y X : TopSpace} (x : X.E) : ContMap Y X {\\n  | func => \\\\lam (_ : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| Dom : BaseSet']<<<break>>>ContMap X X {\n  | func => \\lam (_ : E {Dom {\\this}}) => x.1\n}", "completion": "const x.1"}
{"prompt": "['X : PseudoNormedAbGroup', 'x : X.E', 'y : X.E']<<<break>>>['\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\lemma lnorm_-left \\\\hlevels  {X : PseudoNormedAbGroup} {x y : X.E} : lnorm {X} x - lnorm {X} y <= lnorm {X} (x - y) ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma lnorm_- \\\\hlevels  {X : PseudoNormedAbGroup} {x y : X.E} : lnorm {X} (x - y) = lnorm {X} (y - x) ', '\\\\func lnorm \\\\hlevels  {X : PseudoNormedAbGroup} (x : X.E) : Real => X.norm x', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>lnorm {X} y - lnorm {X} x <= lnorm {X} (x - y)", "completion": "transport ((<=) _) lnorm_- lnorm_-left"}
{"prompt": "['Q : Fin n -> Nat', 'n : Nat']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func f {n1 : Nat} {Q1 : Fin n1 -> Nat} (_ : Fin (BigSum {NatSemiring} (\\\\new Array Nat n1 Q1))) :\\n  \\\\Sigma (i : Fin n1) (Fin (Q1 i)) \\n  | {suc n}, {Q}, k =>\\n  \\\\case OrFin.aux.f {Q 0} {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))} k \\\\with {\\n    | inl s => (0, s)\\n    | inr t => \\n      \\\\have (i, r) => SigmaFin.aux.f {n} {\\\\lam (j : Fin n) => Q (suc j)} t\\n      \\\\in (suc i, r)\\n  }', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func ret {n2 : Nat} {Q2 : Fin n2 -> Nat} (_ : \\\\Sigma (i : Fin n2) (Fin (Q2 i))) :\\n  Fin (BigSum {NatSemiring} (\\\\new Array Nat n2 Q2)) \\n  | {0}, {Q}, ((), f)\\n  | {suc n}, {Q}, (zero, j) => fin-inc {Q 0} {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))} j\\n  | {suc n}, {Q}, (suc i, j) => fin-raise {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (i : Fin n) => Q (suc i)))} {Q 0}\\n    (ret {n} {\\\\lam (i : Fin n) => Q (suc i)} (i, j))', '\\\\func f_sec {n2 : Nat} {Q2 : Fin n2 -> Nat} (p : \\\\Sigma (i : Fin n2) (Fin (Q2 i))) : SigmaFin.aux.f {n2} {Q2} (ret {n2} {Q2} p) = p \\n  | {0}, {Q}, ((), f)\\n  | {suc n}, {Q}, (zero, j) =>\\n  transportInv {Or (Fin (Q 0)) (Fin (Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))))}\\n    (\\\\lam (x : Or (Fin (Q 0)) (Fin (Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))))) =>\\n    (\\\\case x \\\\with {\\n      | inl s => (0, s)\\n      | inr t => \\n        \\\\have (i, r) => SigmaFin.aux.f {n} {\\\\lam (j : Fin n) => Q (suc j)} t\\n        \\\\in (suc i, r)\\n    }) = (0, j))\\n    {OrFin.aux.f {Q 0} {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))}\\n      (fin-inc {Q 0} {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))} j)}\\n    {inl {Fin (Q 0)} {Fin (Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j))))} j}\\n    (ret_inl-lem {Q 0} {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))} j)\\n    (idp {\\\\Sigma (i : Fin (suc n)) (Fin (Q i))}\\n      {\\\\case inl {Fin (Q 0)} {Fin (Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j))))} j \\\\with {\\n        | inl s => (0, s)\\n        | inr t => \\n          \\\\have (i, r) => SigmaFin.aux.f {n} {\\\\lam (j : Fin n) => Q (suc j)} t\\n          \\\\in (suc i, r)\\n      }})\\n  | {suc n}, {Q}, (suc i, j) =>\\n  transportInv {Or (Fin (Q 0)) (Fin (Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))))}\\n    (\\\\lam (x : Or (Fin (Q 0)) (Fin (Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))))) =>\\n    (\\\\case x \\\\with {\\n      | inl s => (0, s)\\n      | inr t => \\n        \\\\have (i, r) => SigmaFin.aux.f {n} {\\\\lam (j : Fin n) => Q (suc j)} t\\n        \\\\in (suc i, r)\\n    }) = (suc i, j))\\n    {OrFin.aux.f {Q 0} {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))}\\n      (fin-raise {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))} {Q 0}\\n        (ret {n} {\\\\lam (i : Fin n) => Q (suc i)} (i, j)))}\\n    {inr {Fin (Q 0)} {Fin (Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j))))}\\n      (ret {n} {\\\\lam (i : Fin n) => Q (suc i)} (i, j))}\\n    (ret_inr-lem {Q 0} {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))}\\n      (ret {n} {\\\\lam (i : Fin n) => Q (suc i)} (i, j)))\\n    (transportInv {\\\\Sigma (i : Fin n) (Fin (Q (suc i)))} (\\\\lam (x : \\\\Sigma (i : Fin n) (Fin (Q (suc i)))) => (\\n      \\\\have (i, r) => x\\n      \\\\in (suc i, r)) = (suc i, j))\\n      {SigmaFin.aux.f {n} {\\\\lam (i : Fin n) => Q (suc i)} (ret {n} {\\\\lam (i : Fin n) => Q (suc i)} (i, j))} {(i, j)}\\n      (f_sec {n} {\\\\lam (i : Fin n) => Q (suc i)} (i, j)) (idp {\\\\Sigma (i : Fin (suc n)) (Fin (Q i))} {\\n        \\\\have (i, r) => (i, j)\\n        \\\\in (suc i, r)}))']<<<break>>>\\Pi (p : \\Sigma (i : Fin n) (Fin (Q i))) -> f {n} {Q} (ret {n} {Q} p) = p", "completion": "f_sec {n} {Q}"}
{"prompt": "['S : DecSet', 'a2 : \\\\Sigma S.E Bool', 'a1 : \\\\Sigma S.E Bool', 'e1 : a1.1 = a2.1', 'p3 : a1.2 xor a2.2 = true', 'e2 : a.1 = a3.1', 'a : \\\\Sigma S.E Bool', 'x2 : List (\\\\Sigma S.E Bool)', 'a3 : \\\\Sigma S.E Bool']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func not \\\\plevels  \\\\hlevels  (_ : Bool) : Bool \\n  | true => false\\n  | false => true', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'nil', 'yes E', '| \\\\infixl 7 * E E : E', 'false', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| E : \\\\Set', '\\\\instance ListMonoid \\\\hlevels  {A : \\\\Set} : Monoid (List A) {\\n  | ide => nil {A}\\n  | * => (++)\\n} => \\\\new Monoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n}', '\\\\func helper1 \\\\plevels  \\\\hlevels  {a2 b2 : Bool} (_ : a2 xor b2 = true) : not a2 = b2 \\n  | {false}, {true}, p => idp {Bool} {not false}\\n  | {true}, {false}, p => idp {Bool} {not true}', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)']<<<break>>>\\Sigma ((\\case yes {a.1 = a3.1} e2, false \\with {\n  | yes e, true => x2\n  | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\n}) = (a :: nil {\\Sigma S.E Bool}) * (a3 :: x2))\n  (a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\Sigma S.E Bool}) * ((a1.1, not a1.2) :: nil {\\Sigma S.E Bool}) * (a3 :: x2))", "completion": "(idp, rewrite {2} e1 (rewrite (helper1 p3) idp))"}
{"prompt": "['q : Rat', 'B : Rat', 'r-q>0 : \\\\Pi {q : Rat} -> \\\\Pi {r : Rat} -> L q -> U r -> interpret {\\\\new LinearRatData (q :: r :: nil) {\\n  | mData => \\\\new MonoidData {R {\\\\this}} (vars {\\\\this})\\n  | interpretNF_negate => {?hidden}\\n}} (:zro {Rat} {Fin 2}) < interpret {\\\\new LinearRatData (q :: r :: nil) {\\n  | mData => \\\\new MonoidData {R {\\\\this}} (vars {\\\\this})\\n  | interpretNF_negate => {?hidden}\\n}} (var {E} {Fin 2} 1 :+ :negative {E} {Fin 2} (var {E} {Fin 2} 0))', 'Lq : L q', 'Ur : U (B + ide)']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '| finv-right {x : E} (x /= zro) : x * finv x = ide', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| finv E : E', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| E : \\\\Set', '\\\\lemma >_/= \\\\hlevels  {this : StrictPoset} {x y : E} (_ : x > y) : x /= y ']<<<break>>>(B + ide - q) * finv (B + ide - q) = ide", "completion": "finv-right (>_/= {RatField} $ r-q>0 Lq Ur)"}
{"prompt": "['tau2 : \\\\Pi {s : Sort {T}} -> U s -> Term {T} V s', 'V : Sort {T} -> \\\\Set', 'tauE : \\\\Pi {s : Sort {T}} -> \\\\Pi (u : U s) -> isTheorem {T} {V} phis (equality {T} {V} {s} (tau1 {s} u) (tau2 {s} u))', 'rho : Env V', 'tau1 : \\\\Pi {s : Sort {T}} -> U s -> Term {T} V s', 't : isTheorem {T} {V} phis (substF {T} {U} {V} chi tau1)', 'c : \\\\Pi (j : Fin phis.len) -> isFormulaTrue {V} rho (phis !! j)', 'phis : Array (Formula {T} V)', 'chi : Formula {T} U', 'this : Model', 'U : Sort {T} -> \\\\Set']<<<break>>>['| E (Sort {T}) : \\\\Set', \"\\\\func isFormulaTrue \\\\hlevels  {this2 : Structure} {V2 : Sort {T} -> \\\\Set} (_ : Env V2) (_ : Formula {T} V2) : \\\\Prop \\n  | {this}, {V}, rho, equality {s} t t' => interpret {V} rho {s} t = interpret {V} rho {s} t'\\n  | {this}, {V}, rho, predicate P d =>\\n  relation P (\\\\new DArray {len {predDomain {T} P}} (\\\\lam (j : Fin (len {predDomain {T} P})) => E (at {predDomain {T} P} j))\\n    (\\\\lam (j : Fin (len {predDomain {T} P})) => interpret {V} rho {at {predDomain {T} P} j} (d.at j)))\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func Env \\\\hlevels  {this : Structure} (V : Sort {T} -> \\\\Set) : \\\\Set => \\\\Pi {s : Sort {T}} -> V s -> E s', 'equality {s : S.Sort} (Term {S} V s) (Term {S} V s)', '| Sort : \\\\Set', '\\\\lemma dir \\\\plevels  \\\\hlevels  {A B : \\\\Prop} (_ : A = B) (_ : A) : B ', '\\\\func interpret \\\\hlevels  {this1 : Structure} {V1 : Sort {T} -> \\\\Set} (_ : Env V1) {s2 : Sort {T}} (_ : Term {T} V1 s2) : E s2 \\n  | {this}, {V}, rho, {s}, var v => rho {s} v\\n  | {this}, {V}, rho, {s}, apply f d =>\\n  operation {s} f (\\\\new DArray {len {domain {T} {s} f}} (\\\\lam (j : Fin (len {domain {T} {s} f})) => E (at {domain {T} {s} f} j))\\n    (\\\\lam (j : Fin (len {domain {T} {s} f})) => interpret {V} rho {at {domain {T} {s} f} j} (d.at j)))', '\\\\func substF \\\\hlevels  {S2 : Signature} {U2 V2 : S.Sort -> \\\\Set} (_ : Formula {S2} U2) (_ : \\\\Pi {s : S.Sort} -> U2 s -> Term {S2} V2 s) :\\n  Formula {S2} V2 \\n  | {S}, {U}, {V}, equality {s} t1 t2, rho =>\\n    equality {S} {V} {s} (subst {S} {U} {V} {s} t1 rho) (subst {S} {U} {V} {s} t2 rho)\\n  | {S}, {U}, {V}, predicate P ts, rho => predicate {S} {V} P\\n    (\\\\new DArray {len {S.predDomain P}} (\\\\lam (j : Fin (len {S.predDomain P})) => Term {S} V (at {S.predDomain P} j))\\n      (\\\\lam (j : Fin (len {S.predDomain P})) => subst {S} {U} {V} {at {S.predDomain P} j} (ts.at j) rho))', '| T : Signature', '\\\\lemma theoremIsTrue {this : Model} {V : Sort {T} -> \\\\Set} {phis : Array (Formula {T} V)} {psi : Formula {T} V}\\n  (_ : isTheorem {T} {V} phis psi) (rho : Env V) (_ : \\\\Pi (j : Fin phis.len) -> isFormulaTrue {V} rho (phis !! j)) :\\n  isFormulaTrue {V} rho psi ', '\\\\lemma subst_isFormulaTrue \\\\hlevels  {this : Structure} {U V : Sort {T} -> \\\\Set} {rho : Env V} {tau : \\\\Pi {s : Sort {T}} -> U s -> Term {T} V s}\\n  {phi : Formula {T} U} :\\n  isFormulaTrue {V} rho (substF {T} {U} {V} phi tau) = isFormulaTrue {U} (\\\\lam {s : Sort {T}} (u : U s) => interpret {V} rho {s} (tau {s} u)) phi ']<<<break>>>isFormulaTrue {U} (\\lam {s : Sort {T}} (u : U s) => interpret {V} rho {s} (tau2 {s} u)) chi", "completion": "transport (\\lam (rho : Env {this} U) => isFormulaTrue {this} rho chi) (ext (\\lam u => theoremIsTrue (tauE u) rho c))\n  (dir (subst_isFormulaTrue {this}) (theoremIsTrue t rho c))"}
{"prompt": "['m : Nat', 'this : Group', 'n : Nat', 'a : E']<<<break>>>['suc Nat', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', '| E : \\\\Set', '| inverse E : E', '\\\\lemma pow_* \\\\hlevels  {this : Monoid} {a : E} {n m : Nat} : pow a (n * m) = pow (pow a n) m ', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>pow (inverse a) (suc n * m) = pow (pow (inverse a) (suc n)) m", "completion": "pow_* {this}"}
{"prompt": "['dq : degree<= {R} q k', 'k : Nat', 'R : Ring', 'g : Poly R', 'dg : degree<= {R} g n', 'q : Poly R', 'n : Nat']<<<break>>>['\\\\lemma leadCoef-product \\\\hlevels  {R : Ring} {p q : Poly R} {n m : Nat} (_ : degree<= {R} p n) (_ : degree<= {R} q m) :\\n  polyCoef {R} (p * q) (n + m) = polyCoef {R} p n R.* polyCoef {R} q m ', '| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func polyCoef \\\\hlevels  {R4 : AddPointed} (_ : Poly R4) (_ : Nat) : R.E \\n  | {R}, pzero, n => R.zro\\n  | {R}, padd p e, 0 => e\\n  | {R}, padd p e, suc n => polyCoef {R} p n\\n  | {R}, peq i, 0 => idp {R.E} {R.zro} @ i\\n  | {R}, peq i, suc n => idp {R.E} {R.zro} @ i', '| E : \\\\Set']<<<break>>>polyCoef {R} (q * g) (k + n) = polyCoef {R} q k R.* polyCoef {R} g n", "completion": "leadCoef-product dq dg"}
{"prompt": "['G : Group', 'x : G.E', 'g : G.E', \"g' : G.E\"]<<<break>>>['| \\\\infixl 7 * E E : E', '| E : \\\\Set', '| *-assoc {x y z : E} : x * y * z = x * (y * z)']<<<break>>>x G.* g G.* g' = x G.* (g G.* g')", "completion": "(\\lam (x : G.E) => G.*-assoc {x} {g} {g'}) x"}
{"prompt": "['d : InList {Nat} a acc', 'a : Nat', 'acc : List Nat', 'G : Graph Nat', 'n : Nat', 'l : List Nat']<<<break>>>[\"\\\\func collect' \\\\plevels  \\\\hlevels  (_ : Graph Nat) (_ : List Nat) (_ : Nat) : List Nat \\n  | G, l, 0 => nil {Nat}\\n  | G, l, suc n => makeStep' G l ++ collect' G (makeStep' G l) n\", 'suc Nat', \"\\\\data InList {A : \\\\Type} A (List A) : \\\\Prop \\\\with\\n  | {A}, a, a' :: l => here (a = a')\\n  | {A}, a, a' :: l => there (InList {A} a l)\", \"\\\\lemma InList_++-left {A : \\\\Type} {a : A} {l l' : List A} (_ : InList {A} a l) : InList {A} a (l ++ l') \", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys']<<<break>>>InList {Nat} a (acc ++ collect' G l (suc n))", "completion": "InList_++-left d"}
{"prompt": "['V2 : Set Y.E', 'V : Set Y.E', 'Y : RegularPreuniformSpace', 'X : RegularPreuniformSpace', 'V=V1V2 : V = V1 \u2227 V2', 'U2 : Set X.E', 'U1 : Set X.E', 'V1 : Set Y.E']<<<break>>>[\"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func Prod \\\\hlevels  {X Y : \\\\hType} (U : Set X) (V : Set Y) : Set (\\\\Sigma X Y) => \\\\lam (s : \\\\Sigma X Y) => \\\\Sigma (U s.1) (V s.2)']<<<break>>>Prod {X.E} {Y.E} (U1 \u2227 U2) V \u2286 Prod {X.E} {Y.E} U1 V1 \u2227 Prod {X.E} {Y.E} U2 V2", "completion": "rewrite V=V1V2 (\\lam {s} p0 => (\n  \\let ((U1x, U2x), (V1y, V2y)) => p0\n  \\in ((U1x, V1y), (U2x, V2y))))"}
{"prompt": "['E : CocompleteCat', 'this : Limit {Precat.op {Precategory-of-elements {C} (hom-presheaf {C} x)}} {Precat.op {E}}\\n  (Functor.op {diagram-functor {C} {E} {A1} (hom-presheaf {C} x)}) (A.F x) {\\n  | coneMap => \\\\lam (p0 : Ob {J {\\\\this}}) => (\\\\case p0 \\\\with {\\n    | (c, p) => A.Func {c} {x} p\\n  })\\n  | coneCoh => {?hidden}\\n  | isLimit => {?hidden}\\n  | limMap => \\\\lam {z : Ob {Cone.D {\\\\this}}} (cone : Cone {J {\\\\this}} {Cone.D {\\\\this}} (G {\\\\this}) z) => cone.coneMap (x, C.id x)\\n  | limBeta => {?hidden}\\n  | limUnique => {?hidden}\\n}', 'C : Precat', 'A : Functor C E', 'x : C.Ob']<<<break>>>['\\\\instance Precategory-of-elements \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (P : Ob) : Precat (\\\\Sigma (c : C.Ob) (Functor.F {P.F} c)) {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => \\\\Sigma (u : C.Hom x.1 y.1) (x.2 = Func {P.F} {y.1} {x.1} u y.2)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (C.id p0.1, transportInv\\n    {Functor.F {P.F} p0.1 -> Functor.F {P.F} p0.1} (\\\\lam (x : Functor.F {P.F} p0.1 -> Functor.F {P.F} p0.1) => p0.2 = x p0.2)\\n      {Func {P.F} {p0.1} {p0.1} (id p0.1)} {id (Functor.F {P.F} p0.1)} (Func-id {P.F} {p0.1})\\n      (idp {Functor.F {P.F} p0.1} {p0.2}))\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) =>\\n  (p0.1 C.\u2218 p1.1, p1.2 *> transportInv {Functor.F {P.F} Y.1}\\n    (\\\\lam (x : Functor.F {P.F} Y.1) => Func {P.F} {Y.1} {X.1} p1.1 x = Func {P.F} {Z.1} {X.1} (p0.1 C.\u2218 p1.1) Z.2) {Y.2}\\n    {Func {P.F} {Z.1} {Y.1} p0.1 Z.2} p0.2 (transportInv {Functor.F {P.F} Z.1 -> Functor.F {P.F} X.1}\\n      (\\\\lam (x : Functor.F {P.F} Z.1 -> Functor.F {P.F} X.1) => Func {P.F} {Y.1} {X.1} p1.1 (Func {P.F} {Z.1} {Y.1} p0.1 Z.2) = x Z.2)\\n      {Func {P.F} {Z.1} {X.1} (p1.1 \u2218 p0.1)} {Func {P.F} {Y.1} {X.1} p1.1 \u2218 Func {P.F} {Z.1} {Y.1} p0.1}\\n      (Func-o {P.F} {Z.1} {Y.1} {X.1} {p1.1} {p0.1})\\n      (idp {Functor.F {P.F} X.1} {Func {P.F} {Y.1} {X.1} p1.1 (Func {P.F} {Z.1} {Y.1} p0.1 Z.2)})))\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func hom-presheaf \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (c : C.Ob) : VPresheaf SetCat C\\n  (\\\\new Functor (op {VPresheaf.C {\\\\this}}) (VPresheaf.D {\\\\this}) (\\\\lam (x : Ob {Functor.C {\\\\this}}) => C.Hom x c) {\\n    | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) (g : F {\\\\this} X) => g C.\u2218 f\\n    | Func-id => {?hidden}\\n    | Func-o => {?hidden}\\n  }) => \\\\new VPresheaf', '| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| D : Precat', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| apex : Ob {D}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| D : Precat', '\\\\func projection \\\\plevels obj >= hom \\\\hlevels  {C1 : Precat} {P : Ob} : Functor (Precategory-of-elements {C1} P) C1 (\\\\lam (p0 : Ob {C {\\\\this}}) => p0.1) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (p0 : Hom {C {\\\\this}} X Y) => p0.1\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| G : Functor J D', '| J : Precat', '| Ob : \\\\hType', '\\\\func diagram-functor \\\\hlevels  {C1 : Precat} {E : CocompleteCat} {A : Functor C1 E} (P : Ob) :\\nFunctor (Precategory-of-elements {C1} P) E (\\\\lam (X : Ob {C {\\\\this}}) => A.F (F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => A.Func {F X} {F Y} (Func {X} {Y} f)\\n} => Comp {Precategory-of-elements {C1} P} {C1} {E} A (projection {C1} {P})', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}']<<<break>>>\\Pi {i : Ob {J {\\this}}} -> \\Pi {j : Ob {J {\\this}}} ->\n  \\Pi (h : Hom {J {\\this}} i j) -> Func {G {\\this}} {i} {j} h \u2218 coneMap {\\this} i = coneMap {\\this} j", "completion": "\\lam {i} {j} h => (\\scase \\elim i, \\elim j, \\elim h \\with {\n  | (c, p), (c', p'), (f, eq) => rewriteI (Func-o {A}, eq) idp\n})"}
{"prompt": "['D : Array X.E', 'C : Set (Set X.E)', 'j : Fin D.len', 'X : ExPseudoMetricSpace', 'eps : Rat', 'h : \\\\Pi (x : X.E) -> TruncP (\\\\Sigma (U1 : Set X.E) (C U1) (\\\\Pi {y : X.E} -> U {X.dist x y} eps -> U1 y))']<<<break>>>['| at (j : Fin len) : A j', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| U Rat : \\\\Prop', '| dist E E : ExUpperReal', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U1 : Set X.E) (C U1) (\\Pi {y : X.E} -> U {X.dist (D.at j) y} eps -> U1 y))", "completion": "h (D j)"}
{"prompt": "['a : E', 'this : Locale', 'p : \\\\Sigma (b : E) (b \u2227 x.1 <= y.1)']<<<break>>>['| meet-left {x y : E} : x \u2227 y <= x', '| \\\\infix 4 <= E E : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>p.1 \u2227 a \u2227 a <= p.1 \u2227 a", "completion": "meet-left {this}"}
{"prompt": "['p : g j = P.conj a b', 'J : \\\\Set', 'a : P.E', 'P : FramePres', 'b : P.E', 'g : J -> P.E', 'j : J']<<<break>>>['| conj E E : E', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', 'cover-inj (j : J) (g j = x)']<<<break>>>\\Sigma -> Cover {P} (P.conj a b) {J} g", "completion": "\\lam _ => cover-inj j p"}
{"prompt": "['R : Domain', \"e' : R.E\", \"p#0' : #0 {R} p\", \"q#0 : #0 {R} (padd {R} q e')\", 'q : Poly R', 'e : R.E', 'p : Poly R']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| \\\\infixl 6 + E E : E', '| \\\\infix 8 #0 E : \\\\Prop', '\\\\lemma #0-+-left \\\\hlevels  {this : With#} {x y : E} (_ : #0 x) : #0 (x + y) || #0 y ', '\\\\func * {R3 : Ring} (_ _ : Poly R3) : Poly R3 \\n  | {R}, pzero, q => pzero {R}\\n  | {R}, padd p e, q => padd {R} (p * q) R.zro + e *c q\\n  | {R}, peq i, q =>\\n    (pmap {Poly R} {Poly R} ((+) (padd {R} (pzero {R}) R.zro)) {R.zro *c q} {pzero {R}} (zro_*c {R} {q}) *> path (peq {R})) @ i', 'padd (Poly R) R.E', '\\\\func \\\\infixl 7 *c \\\\hlevels  {R3 : Ring} (_ : R.E) (_ : Poly R3) : Poly R3 \\n  | {R}, r, pzero => pzero {R}\\n  | {R}, r, padd p e => padd {R} (r *c p) (r R.* e)\\n  | {R}, r, peq i =>\\n    (pmap {R.E} {Poly R} (padd {R} (pzero {R})) {r R.* R.zro} {R.zro} (R.zro_*-right {r}) *> path (peq {R})) @ i', '\\\\lemma #0-* {R : Domain} {p q : Poly R} (_ : #0 {R} p) (_ : #0 {R} q) : #0 {R} (p * q) ', '\\\\instance PolyRingWith# \\\\hlevels  (R : With#) : With# (Poly R) {\\n  | zro => pzero {R}\\n  | + => (+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n  | #0 => #0 {R}\\n} => \\\\new With# {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | #0-zro => {?hidden}\\n  | #0-+ => {?hidden}\\n  | #0-tight => {?hidden}\\n  | #0-*-left => {?hidden}\\n  | #0-*-right => {?hidden}\\n}']<<<break>>>#0 (p * padd {R} q e' + e *c q) || #0 (e *c q)", "completion": "#0-+-left {PolyRingWith# R} (#0-* p#0' q#0)"}
{"prompt": "['this : BoundedDistributiveLattice Bool {\\n  | <= => (BoolLattice.<=)\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet => (and)\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join => (or)\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | ldistr>= => {?hidden}\\n  | bottom => false\\n  | bottom-univ => {?hidden}\\n  | top => true\\n  | top-univ => {?hidden}\\n}']<<<break>>>['false', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', '\\\\data \\\\infix 4 <= \\\\plevels  \\\\hlevels  (_ _ : Bool) \\\\with\\n  | false, y => false<=_\\n  | true, true => true<=true', '| E : \\\\Set', 'true<=true', 'false<=_']<<<break>>>\\Pi {x : E {\\this}} -> \\Pi {y : E {\\this}} -> x <= (x or y)", "completion": "\\lam {x} {y} => cases x (\\case  \\with {}) constructor"}
{"prompt": "[\"context : List tc.Sort'\", 'arguments : DArray {arity {ms} {s} m}\\n  (\\\\lam (index : Fin (arity {ms} {s} m)) => Term (tc.envs color) context (ms.m-domain {s} m !! index) ms)', \"ms : MetaContext tc.Sort'\", 'tc : TheoremContext', \"context' : List tc.Sort'\", \"sublist : SubList {tc.Sort'} context context'\", 'm : ms.metaname s', \"s : tc.Sort'\", 'color : E {tc.Color}']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\lemma injection-weakening-commutation \\\\hlevels  {tc : TheoremContext} (color : E {tc.Color}) {context context' : List tc.Sort'} {ms : MetaContext tc.Sort'}\\n  {s : tc.Sort'} (sublist : SubList {tc.Sort'} context context') (t : Term (tc.envs color) context s ms) :\\nweakening {env {tc}} {s} {context} {context'} {ms} (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {ms} {color} t)\\n  sublist = inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context'} {ms} {color}\\n  (weakening {tc.envs color} {s} {context} {context'} {ms} t sublist) \", '\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', '| Sort : \\\\Set', '\\\\func inject-term \\\\hlevels  {J3 Sort4 : \\\\Set} (S3 : J3 -> FSignature {\\n  | Sort => Sort4\\n}) {s3 : Sort4} {c3 : List Sort4} {mc3 : MetaContext Sort4} {j2 : J3} (_ : Term (S3 j2) c3 s3 mc3) :\\n  Term (SumFSignature {J3} {Sort4} S3) c3 s3 mc3 \\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, var index p => var {SumFSignature {J} {Sort1} S} {c} {s} {mc} index p\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, metavar m args =>\\n  metavar {SumFSignature {J} {Sort1} S} {c} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term (SumFSignature {J} {Sort1} S) c (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => inject-term {J} {Sort1} S {mc.m-domain {s} m !! i} {c} {mc} {j} (args.at i)))\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, func f args => func {SumFSignature {J} {Sort1} S} {c} {s} {mc} (j, f)\\n    (\\\\new DArray {FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f)}\\n      (\\\\lam (index : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        Term (SumFSignature {J} {Sort1} S) (c ++ (j, f) !!domain index) ((j, f) !!sort index) mc)\\n      (\\\\lam (i : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        inject-term {J} {Sort1} S {(j, f) !!sort i} {c ++ (j, f) !!domain i} {mc} {j} (args.at i)))', \"| Sort' : \\\\Set\", \"\\\\func weakening \\\\hlevels  {env3 : FSignature} {s'3 : env.Sort} {narrow-context3 wide-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Term env3 narrow-context3 s'3 mc3) (_ : SubList {env.Sort} narrow-context3 wide-context3) :\\n  Term env3 wide-context3 s'3 mc3 \\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, var index p, sublist =>\\n  var {env} {wide-context} {s'} {mc} (shift-index {env.Sort} {narrow-context} {wide-context} sublist index)\\n    (proof {env.Sort} {narrow-context} {wide-context} {s'} sublist index p)\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, metavar m arguments, sublist =>\\n  metavar {env} {wide-context} {s'} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s'} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s'} m)) => Term env wide-context (mc.m-domain {s'} m !! index) mc)\\n    (\\\\lam (i1 : Fin (MetaContext.arity {mc} {s'} m)) =>\\n      weakening {env} {mc.m-domain {s'} m !! i1} {narrow-context} {wide-context} {mc} (arguments.at i1) sublist))\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, func f arguments, sublist =>\\n  func {env} {wide-context} {s'} {mc} f (\\\\new DArray {FSignature.arity {env} {s'} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s'} f)) => Term env (wide-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i1 : Fin (FSignature.arity {env} {s'} f)) =>\\n    weakening {env} {f !!sort i1} {narrow-context ++ f !!domain i1} {wide-context ++ f !!domain i1} {mc} (arguments.at i1)\\n      (extend-right-both {env.Sort} {narrow-context} {wide-context} sublist {f !!domain i1})))\", '\\\\func arity \\\\hlevels  {this : MetaContext} {s : Sort} (m : metaname s) : Nat => length {Sort} (m-domain {s} m)', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '| Color : DecSet', '| at (j : Fin len) : A j', \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", \"\\\\instance env \\\\hlevels  {this1 : TheoremContext} : FSignature {\\n  | Sort => Sort'\\n  | symbol => \\\\lam (s : Sort {\\\\this}) => \\\\Sigma (j : E {Color}) (symbol {envs j} s)\\n  | domain => \\\\lam {s : Sort {\\\\this}} (symb : symbol {\\\\this} s) => domain {envs symb.1} {s} symb.2\\n} => SumFSignature {E {Color}} {Sort'} envs\", '| E : \\\\Set', '| m-domain {s : Sort} (metaname s) : List Sort']<<<break>>>\\Pi (index : Fin (arity {ms} {s} m)) -> weakening {env {tc}} {ms.m-domain {s} m !! index} {context} {context'} {ms}\n  (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {ms.m-domain {s} m !! index} {context} {ms} {color} (arguments.at index))\n  sublist = inject-term {E {tc.Color}} {tc.Sort'} tc.envs {ms.m-domain {s} m !! index} {context'} {ms} {color}\n  (weakening {tc.envs color} {ms.m-domain {s} m !! index} {context} {context'} {ms} (arguments.at index) sublist)", "completion": "\\lam index => injection-weakening-commutation color sublist (arguments index)"}
{"prompt": "['y : \\\\Sigma Bool (Fin n)', 'n : Nat', 'x : \\\\Sigma Bool (Fin n)']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>Dec (x.2 = y.2)", "completion": "decideEq x.2 y.2"}
{"prompt": "['x : E {Dom {\\\\this}}', 'b : Rat', 'y : E {Dom {\\\\this}}', 'x2y2<b : U {dist x.2 y.2} b']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma dist-right \\\\plevels  \\\\hlevels  {x y : ExUpperReal} {a : Rat} (_ : U {dist x y} a) : y <= x + fromRat a ', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}']<<<break>>>y.2 <= x.2 + fromRat b", "completion": "dist-right x2y2<b"}
{"prompt": "['a : R.E', 'dp=0 : degree {R} (padd {R} p a) = 0', 'p : Poly R', 'R : Dec']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func degree \\\\hlevels  {R1 : Ring.Dec} (_ : Poly R1) : Nat \\n  | {R}, pzero => 0\\n  | {R}, padd p e => \\\\case decideEq p zro \\\\with {\\n    | yes p => 0\\n    | no n => suc (degree {R} p)\\n  }\\n  | {R}, peq i => idp {Nat} {0} @ i', 'suc Nat', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma decideEq/=_reduce \\\\hlevels  {A : DecSet} {x y : A.E} (p : x /= y) : A.decideEq x y = no {x = y} p ', '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', 'padd (Poly R) R.E', '\\\\instance PolyDecRing \\\\hlevels  (R : Dec) : Dec (Poly R) {\\n  | zro => pzero {R}\\n  | + => (+)\\n  | negative => negative {R}\\n  | #0 => #0\\n  | decideEq => decideEq {R}\\n  | * => (*)\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | #0-zro => {?hidden}\\n  | nonZeroApart => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| zro : E', 'pzero', 'no (Not E)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '\\\\func leadCoef \\\\hlevels  {R3 : Ring.Dec} (_ : Poly R3) : R.E \\n  | {R}, pzero => R.zro\\n  | {R}, padd p e => \\\\case decideEq p zro \\\\with {\\n    | yes p => e\\n    | no n => leadCoef {R} p\\n  }\\n  | {R}, peq i => idp {R.E} {\\\\case decideEq (pzero {R}) zro \\\\with {\\n    | yes p => R.zro\\n    | no n => R.zro\\n  }} @ i', '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>padd {R} p a = padd {R} (pzero {R}) (\\case decideEq p zro \\with {\n  | yes p => a\n  | no n => leadCoef {R} p\n})", "completion": "\\case decideEq p zro \\as d : case_return_arg_1_1 \\return (\\lam (e : R.E) => padd {R} p a = padd {R} (pzero {R}) e) case_return_arg_1 \\with {\n  | yes p=0 => pmap (\\lam p0 => padd p0 a) p=0\n  | no p/=0 => \\case rewrite (decideEq/=_reduce p/=0) in dp=0 \\with {}\n}"}
{"prompt": "['h3 : U3 <=<ta (\\\\lam (x : X.E) => single {RegularCauchyFilter X} (func {completion {X}} x) <=< U2)', 'U3_0 : U3 X.zro', 'U3o : X.isOpen U3', 'F : RegularCauchyFilter X', 'X : TopAbGroup', 'U2<=<U1 : U2 <=< U1', 'FU3x : mkSet {X} (\\\\lam (y : X.E) => U3 (x - y)) F', 'U3 : Set X.E', 'U2 : Set E', 'U1 : Set (E {\\\\this})', 'x : X.E']<<<break>>>['| F (E {A}) : \\\\Prop', '\\\\func completion \\\\hlevels  {S : CoverSpace} : CoverMap S (coverSpace {S}) {\\n  | func => pointCF {S}\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', \"\\\\lemma topAb-neighborhood \\\\hlevels  {X : TopAbGroup} {F1 G : RegularCauchyFilter X} {U : Set E} :\\nsingle {RegularCauchyFilter X} (F1 - G) <=< U <-> TruncP (\\\\Sigma (U' : Set E) (U' <=< U) (V1 : Set X.E) (F.F V1) (V2 : Set X.E) (G.F V2)\\n  (\\\\Pi {x : X.E} -> V1 x -> \\\\Pi {y : X.E} -> V2 y -> U' (pointCF {X} (x - y)))) \", 'inP A', '\\\\lemma UBall-open \\\\hlevels  {this : TopAbGroup} {U : Set E} (_ : isOpen U) {x : E} : isOpen (UBall U x) ', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\lemma <=<_<= \\\\hlevels  {X : PrecoverSpace} {V U : Set X.E} (_ : V <=< U) : V <= U ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', \"\\\\func UBall \\\\hlevels  {this : TopAbGroup} (U : Set E) (x : E) : Set E => \\\\lam (x' : E) => U (x - x')\", '\\\\instance Completion \\\\hlevels  (X : CoverSpace) : CompleteCoverSpace (RegularCauchyFilter X) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X}}\\n  | isCauchy => isCCauchy {X}\\n} => \\\\new CompleteCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\instance UniformCompletion \\\\hlevels  (X1 : UniformSpace) : CompleteUniformSpace (RegularCauchyFilter X1) {\\n  | isOpen => isOpen {coverSpace {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set (E {\\\\this}))) => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C)\\n    (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (D V) (mkSet {X1} U \u2286 V))))\\n} => \\\\new CompleteUniformSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cover => {?hidden}\\n  | uniform-top => {?hidden}\\n  | uniform-refine => {?hidden}\\n  | uniform-inter => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | uniform-star => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\lemma UBall-center \\\\hlevels  {this : TopAbGroup} {U : Set E} (_ : U zro) {x : E} : UBall U x x ', '\\\\lemma diff-cancel-left \\\\hlevels  {this : AbGroup} {x y z : E} : x - z - (x - y) = y - z ', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\lemma open-char \\\\hlevels  {this : PrecoverSpace} {S : Set E} : isOpen S <-> (\\\\Pi {x : E} -> S x -> single {E} x <=< S) ', '\\\\func abGroup \\\\hlevels  {X : TopAbGroup} : AbGroup (RegularCauchyFilter X) {\\n  | zro => pointCF {X} X.zro\\n  | + => +-func {X}\\n  | negative => func {negative-cover {X}}\\n} => \\\\new AbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n}']<<<break>>>U1 (pointCF {X} x - F)", "completion": "<=<_<= (topAb-neighborhood.2 $ inP (U2, U2<=<U1, UBall {X} U3 x, (open-char {X}).1 (UBall-open {X} U3o) $ UBall-center {X} {U3} U3_0, _, FU3x,\n  \\lam {y} p {z} q => transport (\\lam w => U2 (pointCF w)) (diff-cancel-left {X}) $ <=<_<= (h3 q p) idp)) idp"}
{"prompt": "['y : E', 'this : ExPseudoNormedAbGroup', 'x : E']<<<break>>>['| norm E : ExUpperReal', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '| negative E : E', '| norm_negative {x : E} : norm (negative x) = norm x']<<<break>>>norm (negative (y - x)) = norm (y - x)", "completion": "norm_negative {this}"}
{"prompt": "['a : E', 'r : SType {IntRing} subset', 'this : QModule']<<<break>>>['| center : A', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\lemma >_/= \\\\hlevels  {this : QModule} {d : Int} (_ : signum d = pos 1) : iabs d /= 0 ', '| E : \\\\Set', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a', '\\\\lemma ud-cond \\\\hlevels  {this : QModule} {a : E} {n : Nat} {n/=0 : n /= 0} : n *n center.1 = a ', '\\\\lemma uniquelyDivisible \\\\hlevels  {this : QModule} (a : E) {n : Nat} (_ : n /= 0) : Contr (\\\\Sigma (b : E) (n *n b = a)) ']<<<break>>>iabs r.2 *n center.1 = a", "completion": "ud-cond {this}"}
{"prompt": "['this : Data', 'a1 : \\\\Sigma (List (Fin (len {env}))) (E {C})']<<<break>>>['| len : Nat', '| env : Array (E {R})', '\\\\lemma mulCoef-consistent \\\\hlevels  {this : Data} {c : E {C}} {l : List (Fin (len {env}))} :\\n  mulCoef c l = func {alg} c * interpretNF {R} {Fin (len {env})} (at {env}) l ', '| \\\\infixl 7 * E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func interpretNF \\\\hlevels  {M2 : Monoid} {V1 : \\\\Set} (_ : V1 -> M.E) (_ : List V1) : M.E \\n  | {M}, {V}, env, nil => M.ide\\n  | {M}, {V}, env, x :: nil => env x\\n  | {M}, {V}, env, x :: l => env x M.* interpretNF {M} {V} env l', '| R : Semiring', '\\\\func mulCoef \\\\hlevels  {this2 : Data} (_ : E {C}) (_ : List (Fin (len {env}))) : E {R} \\n  | {this}, c, nil => func {alg} c\\n  | {this}, c, l => \\\\case decideEq {D} c (ide {C}) \\\\with {\\n    | yes p => interpretNF {R} {Fin (len {env})} (at {env}) l\\n    | no n => func {alg} c * interpretNF {R} {Fin (len {env})} (at {env}) l\\n  }', '| at (j : Fin len) : A j', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| alg : SemiringHom C R']<<<break>>>mulCoef a1.2 a1.1 = func {alg} a1.2 * interpretNF {R} {Fin (len {env})} (at {env}) a1.1", "completion": "mulCoef-consistent {this}"}
{"prompt": "['x : InfReal']<<<break>>>['| A : TopMeetSemilattice', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| \\\\infix 4 < E E : \\\\Prop', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '| zro : E', '\\\\type \\\\infix 4 < \\\\plevels  \\\\hlevels  (x y : InfReal) : \\\\Prop => TruncP (\\\\Sigma (a : Rat) (x.U a) (y.L a))', '\\\\class InfReal \\\\extends LowerReal, ExUpperReal \\\\hlevels  {\\n  | LU-disjoint {q : Rat} (L q) (U q) : Empty\\n  | LU-located {q r : Rat} (q < r) : L q || U r\\n  | LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\class SetFilter \\\\extends Filter \\\\hlevels  {\\n  | X : \\\\Set\\n  | A => SetLattice X\\n}', '\\\\func NFilter (x : InfReal) :\\nSetFilter InfReal (\\\\lam (U : E {A {\\\\this}}) => (\\\\Sigma (eps : Real) (zro StrictPoset.< eps) (x1 : Real) (x1 = x)\\n  (\\\\Pi {y : Real} -> abs {RealAbGroup} (x1 - y) StrictPoset.< eps -> U y)) || (\\\\Sigma (B : Real) (B InfRealAbMonoid.< x) (\\\\Pi {y : InfReal} -> B InfRealAbMonoid.< y -> U y))) \\n=> \\\\new SetFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n}', '| E : \\\\Set', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>SetFilter InfReal (\\lam (U : E {A {\\this}}) => (\\Sigma (eps : Real) (zro StrictPoset.< eps) (x1 : Real) (x1 = x)\n  (\\Pi {y : Real} -> abs {RealAbGroup} (x1 - y) StrictPoset.< eps -> U y)) || (\\Sigma (B : Real) (B InfRealAbMonoid.< x) (\\Pi {y : InfReal} -> B InfRealAbMonoid.< y -> U y)))", "completion": "NFilter x"}
{"prompt": "['e : Sym (suc n)', 'n : Nat', 's : f {e} 0 > f {e} (suc j)', 'j : Fin n']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| f A : B', 'suc Nat', \"\\\\func isInj {this : Equiv} {a a' : A} (p : f a = f a') : a = a' \\n  => inv {A} {ret (f a)} {a} (ret_f a) *> pmap {B} {A} ret {f a} {f a'} p *> ret_f a'\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func skip \\\\plevels  \\\\hlevels  {n2 : Nat} (x2 x3 : Fin (suc n2)) (_ : x2 /= x3) : Fin n2 \\n  | {n}, zero, zero, d => absurd {Fin n} (d (idp {Fin (suc n)} {0}))\\n  | {n}, zero, suc x, d => x\\n  | {suc n}, suc x0, zero, d => 0\\n  | {suc n}, suc x0, suc x, d =>\\n    suc (skip {n} x0 x (\\\\lam (x0=x : x0 = x) => d (pmap {Fin (suc n)} {Fin (suc (suc n))} suc {x0} {x} x0=x)))', '\\\\lemma skip-left \\\\plevels  \\\\hlevels  {n : Nat} {x0 x : Fin (suc n)} {d : x0 /= x} (_ : x < x0) : skip {n} x0 x d = x ']<<<break>>>skip {n} (f {e} 0) (f {e} (suc j)) (\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})) = f {e} (suc j)", "completion": "skip-left s"}
{"prompt": "['R : GradedCRing', 'n1=d1d*l1 : n1 = suc g1.2 * l1', 'l1 : Nat', 'y1 : R.E', 'y1h : R.isHomogen y1 n1', 'n1 : Nat', 'g1 : Carrier R']<<<break>>>['\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', 'suc Nat', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| isHomogen E Nat : \\\\Prop']<<<break>>>R.isHomogen y1 (suc g1.2 * l1)", "completion": "rewrite n1=d1d*l1 y1h"}
{"prompt": "['this : LModule', 's : \\\\Sigma (l : Array E) (IsBasis l)']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\type IsBasisSet \\\\hlevels  {this : LModule} {J : \\\\Set} (g : J -> E) : \\\\Prop => \\\\Sigma (IsIndependentSet {J} g) (IsGeneratingSet {J} g)', '| at (j : Fin len) : A j', '\\\\lemma IsBasis<->IsBasisSet \\\\hlevels  {this : LModule} {l : Array E} : IsBasis l <-> IsBasisSet {Fin l.len} l.at ']<<<break>>>IsBasisSet {Fin (len {s.1})} (at {s.1})", "completion": "(IsBasis<->IsBasisSet {this}).1 s.2"}
{"prompt": "['this : GCD {M1} x y M.ide (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val1 {\\\\this}) x {\\n  | inv-right => {?hidden}\\n})\\n  (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val2 {\\\\this}) y {\\n    | inv-right => {?hidden}\\n  })\\n  (\\\\lam (g : E {M {\\\\this}}) (g|x : LDiv {M {\\\\this}} g (val1 {\\\\this})) (g|y : LDiv {M {\\\\this}} g (val2 {\\\\this})) => (\\n    \\\\have i => c g g|x g|y\\n    \\\\in \\\\new LDiv {M {\\\\this}} g (res {\\\\this}) i.inv {\\n          | inv-right => {?hidden}\\n        }))', 'g : E {M {\\\\this}}', 'i : Inv {M} g']<<<break>>>['| res : E {M}', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '| inv : E {M}', '| inv-right : val * inv = elem', '| M : CMonoid']<<<break>>>LDiv {M {\\this}} g (res {\\this}) i.inv {\n  | inv-right => {?hidden}\n}", "completion": "\\new LDiv g ide (inv {i}) (inv-right {i})"}
{"prompt": "['x : X.E', 'D : Array (Set X.E)', 'Dc : IsCover {X.E} (\\\\lam (V : Set X.E) => TruncP (\\\\Sigma (j : Fin D.len) (D !! j = V)))', 'X : RegularPreuniformSpace']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U : Set X.E) (TruncP (\\Sigma (j : Fin D.len) (D !! j = U))) (U x))", "completion": "Dc x"}
{"prompt": "[]<<<break>>>['true', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'inP A', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP Bool", "completion": "inP true"}
{"prompt": "['b-a>0 : interpret {\\\\new LinearRatAlgebraData {RealField} (a :: b :: zro :: nil) {\\n  | mData => \\\\new MonoidData {R {\\\\this}} (vars {\\\\this})\\n  | interpretNF_negate => {?hidden}\\n}} (:zro {Rat} {Fin 3}) < interpret {\\\\new LinearRatAlgebraData {RealField} (a :: b :: zro :: nil) {\\n  | mData => \\\\new MonoidData {R {\\\\this}} (vars {\\\\this})\\n  | interpretNF_negate => {?hidden}\\n}} (var {E} {Fin 3} 1 :+ :negative {E} {Fin 3} (var {E} {Fin 3} 0))', 'a : Real', 'b : Real', '/b-a : E', 'x : Real', 'n : Nat', 'x>=a : a <= x']<<<break>>>['true', '\\\\lemma rat_real_<= \\\\plevels  \\\\hlevels  {a b : Rat} : a <= b <-> fromRat a <= fromRat b ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma pinv>0 \\\\hlevels  {this : OrderedField} {x : E} (x>0 : zro < x) : zro < pinv x {?hidden} ', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '| <=_*-positive {x y : E} (zro <= x) (zro <= y) : zro <= x * y', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '\\\\lemma fromNat_>=0 \\\\plevels  \\\\hlevels  {n : Nat} : fromInt (pos 0) <= fromInt (pos n) ', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| E : \\\\Set', '| len : Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', 'LessOrEquals', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>zro <= (x - a) * fromRat (fromInt (pos n)) * /b-a", "completion": "<=_*-positive (<=_*-positive linarith $ rat_real_<=.1 fromNat_>=0) (<=-less $ pinv>0 {RealField} b-a>0)"}
{"prompt": "['l : Array (\\\\Sigma V.E B.E) n', 'B : BooleanRing', 'a : \\\\Sigma V.E B.E', 'n : Nat', 'j : Fin (len {map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (a.1 V.+ s.1, a.2 B.* s.2)) (reduce {V} {B} l) ++ map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (s.1, diff {B} s.2 a.2)) (reduce {V} {B} l)})', 'V : PosetQModule']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '| \\\\infixl 6 + E E : E', '\\\\func index-left {A1 : \\\\Type} {l1 m1 : Array A1} (_ : Fin l.len) : Fin (len {l1 ++ m1}) \\n  | {A}, {:: {n} a l}, {m}, zero => 0\\n  | {A}, {:: {n} a l}, {m}, suc i => suc (index-left {A} {l} {m} i)', 'suc Nat', '\\\\func ++_index-left {A2 : \\\\Type} {l2 m2 : Array A2} (i1 : Fin l.len) : at {l2 ++ m2} (index-left {A2} {l2} {m2} i1) = l.at i1 \\n  | {A}, {:: {n} a l}, {m}, zero => idp {A} {at {(a :: l) ++ m} (index-left {A} {a :: l} {m} 0)}\\n  | {A}, {:: {n} a l}, {m}, suc i => ++_index-left {A} {l} {m} i', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '| join-left {x y : E} : x <= x \u2228 y', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '\\\\func diff \\\\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| bottom : E', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| join-right {x y : E} : y <= x \u2228 y', '\\\\lemma diff_<= \\\\hlevels  {this : BooleanRing} {x y : E} : diff x y <= x ', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func split-index {A3 : \\\\Type} {l2 m3 : Array A3} (i2 : Fin (len {l2 ++ m3})) :\\n  Or (\\\\Sigma (j : Fin l.len) (i2 = index-left {A3} {l2} {m3} j)) (\\\\Sigma (j : Fin m.len) (i2 = index-right {A3} {l2} {m3} j)) \\n  | {A}, {nil}, {m}, i =>\\n  inr {\\\\Sigma (j : Fin 0) (i = index-left {A} {nil} {m} j)} {\\\\Sigma (j : Fin m.len) (i = index-right {A} {nil} {m} j)}\\n    (i, idp {Fin (len {nil ++ m})} {i})\\n  | {A}, {:: {n} a l}, {m}, zero => inl {\\\\Sigma (j : Fin (suc l.len)) (0 = index-left {A} {a :: l} {m} j)}\\n    {\\\\Sigma (j : Fin m.len) (0 = index-right {A} {a :: l} {m} j)} (0, idp {Fin (suc (len {l ++ m}))} {0})\\n  | {A}, {:: {n} a l}, {m}, suc i => \\\\case split-index {A} {l} {m} i \\\\with {\\n    | inl r => inl {\\\\Sigma (j : Fin (suc l.len)) (suc i = index-left {A} {a :: l} {m} j)}\\n      {\\\\Sigma (j : Fin m.len) (suc i = index-right {A} {a :: l} {m} j)} (suc r.1, path (\\\\lam (i : I) => suc (r.2 @ i)))\\n    | inr r => inr {\\\\Sigma (j : Fin (suc l.len)) (suc i = index-left {A} {a :: l} {m} j)}\\n      {\\\\Sigma (j : Fin m.len) (suc i = index-right {A} {a :: l} {m} j)} (r.1, path (\\\\lam (i : I) => suc (r.2 @ i)))\\n  }', '\\\\func index-right {A1 : \\\\Type} {l1 m1 : Array A1} (_ : Fin m.len) : Fin (len {l1 ++ m1}) \\n  | {A}, {nil}, {m}, i => i\\n  | {A}, {:: {n} a l}, {m}, i => suc (index-right {A} {l} {m} i)', '\\\\func ++_index-right {A2 : \\\\Type} {l1 m2 : Array A2} {i2 : Fin m.len} : at {l1 ++ m2} (index-right {A2} {l1} {m2} i2) = m.at i2 \\n  | {A}, {nil}, {m}, {i} => idp {A} {at {nil ++ m} (index-right {A} {nil} {m} i)}\\n  | {A}, {:: {n} a l}, {m}, {i} => ++_index-right {A} {l} {m} {i}', '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', 'byRight B', '| zro : E', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\lemma BigJoin-cond \\\\hlevels  {this : BottomJoinSemilattice} {l : Array E} (j : Fin l.len) : l.at j <= BigJoin l ', '\\\\lemma reduce_BigJoin \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l : PFunc {V} {B}} :\\n  BigJoin {B} (map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) (reduce {V} {B} l)) = BigJoin {B} (map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) l) ', '\\\\func reduce \\\\hlevels  {V2 : PosetQModule} {B2 : BooleanRing} (_ : PFunc {V2} {B2}) : PFunc {V2} {B2} \\n  | {V}, {B}, nil => nil\\n  | {V}, {B}, :: {n} x l => add {V} {B} x.1 x.2 (reduce {V} {B} l)']<<<break>>>((((a.1, diff {B} a.2 (BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (reduce {V} {B} l)))) :: map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (a.1 V.+ s.1, a.2 B.* s.2)) (reduce {V} {B} l) ++ map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 a.2)) (reduce {V} {B} l)) !! suc j).1 = V.zro) || (((a.1, diff {B} a.2 (BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (reduce {V} {B} l)))) :: map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (a.1 V.+ s.1, a.2 B.* s.2)) (reduce {V} {B} l) ++ map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 a.2)) (reduce {V} {B} l)) !! suc j).2 B.<= BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (a :: l))", "completion": "byRight (\\case split-index j \\with {\n  | inl (k, jp) => rewrite (jp, ++_index-left) $ meet-left <=\u2218 join-left\n  | inr (k, jp) =>\n    rewrite (jp, ++_index-right) $ diff_<= {B} <=\u2218 BigJoin-cond {B} {map (\\lam p0 => p0.2) (reduce {V} {B} l)} k <=\u2218 =_<= (reduce_BigJoin {V} {B}) <=\u2218 join-right\n})"}
{"prompt": "[\"d : CGroupData {toCGroup this} (\\\\lam (a : V {\\\\this}) => at {x :: y :: x' :: z :: nil} (fromNat {3} a))\"]<<<break>>>['| V : \\\\Set', 'var V', '| G : Group', '\\\\infixl 6 :* (_ _ : GroupTerm V)', ':inv (GroupTerm V)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma simplify-correct \\\\hlevels  {this : CGroupData} (t : GroupTerm V) : interpret t = interpret (simplify t) ', '| E : \\\\Set', '\\\\func interpret \\\\hlevels  {this4 : GroupData} (_ : GroupTerm V) : E {G} \\n  | {this}, var x => f x\\n  | {this}, :ide => ide {G}\\n  | {this}, :inv t => inverse {G} (interpret t)\\n  | {this}, t :* s => interpret t * interpret s', ':ide', '\\\\func simplify \\\\plevels  \\\\hlevels  (t : GroupTerm Nat) : GroupTerm Nat => removeVars t\\n  (countVars (group {ProductDecSet NatSemiring DecBool} (sort {LexicographicalProduct NatSemiring BoolPoset} (toList t false))))']<<<break>>>interpret {d}\n  (var {d.V} 0 :* :inv {d.V} (var {d.V} 1) :* (:inv {d.V} (:inv {d.V} (var {d.V} 1)) :* :inv {d.V} (var {d.V} 2)) :* (:inv {d.V} (:inv {d.V} (var {d.V} 2)) :* :inv {d.V} (:inv {d.V} (:inv {d.V} (var {d.V} 3))) :* :ide {Nat})) = interpret {d}\n  (simplify (var {d.V} 0 :* :inv {d.V} (var {d.V} 1) :* (:inv {d.V} (:inv {d.V} (var {d.V} 1)) :* :inv {d.V} (var {d.V} 2)) :* (:inv {d.V} (:inv {d.V} (var {d.V} 2)) :* :inv {d.V} (:inv {d.V} (:inv {d.V} (var {d.V} 3))) :* :ide {Nat})))", "completion": "simplify-correct {d}\n  (var 0 :* :inv (var 1) :* (:inv (:inv (var 1)) :* :inv (var 2)) :* (:inv (:inv (var 2)) :* :inv (:inv (:inv (var 3))) :* :ide))"}
{"prompt": "['A : \\\\Type', 'm : Nat', 'n : Nat', 'a : A']<<<break>>>['\\\\func replicate {A : \\\\Type} (n : Nat) (a : A) : Array A n (\\\\lam (_ : Fin n) => a) => \\\\new DArray', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)']<<<break>>>Array A (n + m) (\\lam (_ : Fin (n + m)) => a)", "completion": "replicate (n + m) a"}
{"prompt": "['this : Dec', 'q : v * d = ide - u * c', 'env : Array E 4']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', \"\\\\func ringInterpretNF' \\\\hlevels  {R3 : Ring} {env2 : Array R.E} (_ : NF Int env.len) : R.E \\n  | {R}, {env}, nil => R.zro\\n  | {R}, {env}, x :: nil => ringMulCoef {R} {env} x.2 x.1\\n  | {R}, {env}, x :: l => ringMulCoef {R} {env} x.2 x.1 R.+ ringInterpretNF' {R} {env} l\", 'nil', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func normalize \\\\hlevels  {n7 : Nat} {C7 : Dec} (_ : Term C.E n7) : NF C.E n7 \\n  | {n}, {C}, var v => (v :: nil {Fin n}, C.ide) :: nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, coef c => (nil {Fin n}, c) :: nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, :zro => nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, :ide => (nil {Fin n}, C.ide) :: nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, :negative t =>\\n  map {\\\\Sigma (List (Fin n)) C.E} {\\\\Sigma (List (Fin n)) C.E} (\\\\lam (s : \\\\Sigma (List (Fin n)) C.E) => (s.1, C.negative s.2))\\n    (normalize {n} {C} t)\\n  | {n}, {C}, t :+ s => normalize {n} {C} t ++ normalize {n} {C} s\\n  | {n}, {C}, t :* s =>\\n    remove0 {n} {C} {\\\\new C {}} (collapse {n} {C} (multiply {n} {C} (normalize {n} {C} t) (normalize {n} {C} s)))', '\\\\func NF \\\\hlevels  (C : \\\\Set) (n : Nat) : \\\\Set => List (\\\\Sigma (List (Fin n)) C)', '\\\\func sortMonomials \\\\hlevels  {n : Nat} {C : \\\\Set} (l : NF C n) : List (\\\\Sigma (List (Fin n)) C) \\n=> map {\\\\Sigma (List (Fin n)) C} {\\\\Sigma (List (Fin n)) C} (\\\\lam (s : \\\\Sigma (List (Fin n)) C) => (sort {FinOrder n} s.1, s.2))\\n  l', '\\\\func interpret \\\\hlevels  {R6 : Ring} (env4 : Array R.E) (_ : Term Int env.len) : R.E \\n  | {R}, env, coef c => intCoef {R} c\\n  | {R}, env, var c => env.at c\\n  | {R}, env, :zro => R.zro\\n  | {R}, env, :ide => R.ide\\n  | {R}, env, :negative t => R.negative (interpret {R} env t)\\n  | {R}, env, t :+ s => interpret {R} env t R.+ interpret {R} env s\\n  | {R}, env, t :* s => interpret {R} env t R.* interpret {R} env s', '| E : \\\\Set', ':ide', '\\\\infixl 7 :* (_ _ : Term C n)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', 'var (Fin n)', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func multiply \\\\hlevels  {n2 : Nat} {C2 : Monoid} (_ _ : NF C.E n2) : NF C.E n2 \\n  | {n}, {C}, l1, nil => nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, l1, l2 => multiply' {n} {C} l1 l2 (nil {\\\\Sigma (List (Fin n)) C.E})\", '\\\\data Term \\\\hlevels  \\\\Set Nat \\n  | var (Fin n)\\n  | coef C\\n  | :zro\\n  | :ide\\n  | :negative (Term C n)\\n  | \\\\infixl 6 :+ (_ _ : Term C n)\\n  | \\\\infixl 7 :* (_ _ : Term C n)', 'pos Nat', ':negative (Term C n)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', \"\\\\func ringInterpretNF \\\\hlevels  {R : Ring} (env : Array R.E) (l : NF Int env.len) : R.E \\n=> ringInterpretNF' {R} {env} (remove0 {env.len} {IntRing} {IntRing}\\n  (collapse {env.len} {IntRing} (sort {LexicographicalProduct (LexicographicalList (FinOrder env.len)) IntRing} l)))\", \"\\\\lemma apply-axioms \\\\hlevels  {R : CRing} (env : Array R.E)\\n  (l : Array (\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)))\\n  (add : NF Int env.len) : ringInterpretNF {R} env (sortMonomials\\n  {env.len} {Int} (Big {List (\\\\Sigma (List (Fin env.len)) Int)} {List (\\\\Sigma (List (Fin env.len)) Int)} (++) add\\n    (map {\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)}\\n      {List (\\\\Sigma (List (Fin env.len)) Int)}\\n      (\\\\lam (s : \\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)) =>\\n        multiply {env.len} {IntRing} s.1 (normalize {env.len} {IntRing} (s.2 :+ :negative {E} {env.len} s.3))) l))) = ringInterpretNF' {R} {env} add \", '\\\\infixl 6 :+ (_ _ : Term C n)', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>ringInterpretNF env (sortMonomials {env.len} {Int}\n  (Big {List (\\Sigma (List (Fin env.len)) Int)} {List (\\Sigma (List (Fin env.len)) Int)} (++) (nil {\\Sigma (List (Fin 4)) Int})\n    (map {\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret env t = interpret env s)}\n      {List (\\Sigma (List (Fin env.len)) Int)}\n      (\\lam (s : \\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret env t = interpret env s)) =>\n        multiply {env.len} {IntRing} s.1 (normalize {env.len} {IntRing} (s.2 :+ :negative {E} {env.len} s.3)))\n      (((nil {Fin 4}, pos 1) :: nil {\\Sigma (List (Fin 4)) Int}, var {Int} {env.len} 3 :* var {Int} {env.len} 2,\n        :ide {Int} {4} :+ :negative {Int} {env.len} (var {Int} {env.len} 1 :* var {Int} {env.len} 0), q) :: nil)))) = ringInterpretNF' {env} (nil {\\Sigma (List (Fin 4)) Int})", "completion": "apply-axioms env (((nil, 1) :: nil, var 3 :* var 2, :ide :+ :negative (var 1 :* var 0), q) :: nil) nil"}
{"prompt": "['this : LatticeAbGroup', 'z : E', 'y : E', 'x : E']<<<break>>>['| \\\\infixl 6 + E E : E', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '| negative-right {x : E} : x + negative x = zro', '| zro : E', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro-left {x : E} : zro + x = x', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| negative E : E', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>x \u2227 y \u2228 x \u2227 z <= (x + negative (y \u2228 z)) \u2227 zro + (negative ((x + negative (y \u2228 z)) \u2227 zro) + (x \u2227 y \u2228 x \u2227 z))", "completion": "=_<= (inv (pmap (\\lam _x => _x + {this} _) (negative-right {this}) *> zro-left {this}) *> +-assoc {this})"}
{"prompt": "['this : PrecoverMap (precover {I} \u2a2f X) Y {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => func {f s.1} s.2\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', 'fc : \\\\Pi {D : Set (Set Y.E)} -> Y.isCauchy D -> X.isCauchy (\\\\lam (U : Set X.E) =>\\n  TruncP (\\\\Sigma (N : I.E) (V : Set Y.E) (D V) (\\\\Pi {n : I.E} -> \\\\Pi {x : X.E} -> N I.<= n -> U x -> V (func {f n} x))))', 'I : DirectedSet', 'X : CoverSpace', 'Y : CoverSpace', 'f : I.E -> CoverMap X Y']<<<break>>>['\\\\func PrecoverTransfer \\\\hlevels  {X : \\\\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '\\\\instance PrecoverLattice \\\\hlevels  (X : \\\\Set) : CompleteLattice (PrecoverSpace X) {\\n  | <= => \\\\lam (A : E {\\\\this}) (B : E {\\\\this}) => \\\\Pi {C : Set (Set X)} -> A.isCauchy C -> B.isCauchy C\\n  | meet => meet-impl\\n  | join => join-impl\\n  | top => DiscreteCover X\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n  ClosurePrecoverSpace {X} (\\\\lam (C : Set (Set X)) => TruncP (\\\\Sigma (j : J) (isCauchy {f j} C)))\\n    (\\\\lam {C : Set (Set X)} (e : TruncP (\\\\Sigma (j : J) (isCauchy {f j} C))) (x : X) => (\\\\case e \\\\with {\\n      | inP (j, Cc) => cauchy-cover {f j} {C} Cc x\\n    }))\\n  | Meet => Meet-impl\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '| Cod : BaseSet', '| func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))', '\\\\lemma directedProdCover-char \\\\hlevels  {I : DirectedSet} {X : CoverSpace} {D : Set (Set (\\\\Sigma I.E X.E))} :\\n  isCauchy {precover {I} \u2a2f X} D <-> DirectProdCover {I} {X} D ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '\\\\lemma cauchy-subset \\\\hlevels  {X : PrecoverSpace} {C D : Set (Set X.E)} (_ : X.isCauchy C) (_ : \\\\Pi {U : Set X.E} -> C U -> D U) : X.isCauchy D ', '\\\\func precover \\\\hlevels  {I : DirectedSet} : PrecoverSpace I.E {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n  \\\\Sigma (TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (N : I.E) (\\\\Pi {n : I.E} -> N I.<= n -> U n)))\\n    (\\\\Pi (n : I.E) -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (C V) (V n)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}']<<<break>>>\\Pi {D : Set (Set (E {Cod {\\this}}))} -> isCauchy {Cod {\\this}} D ->\n  Closure {\\Sigma E X.E} (\\lam (C : Set (Set (\\Sigma E X.E))) => TruncP (\\Sigma (j : Bool) (isCauchy C)))\n    (\\lam (U : Set (\\Sigma I.E X.E)) => TruncP (\\Sigma (V : Set Y.E) (D V) (U = func {\\this} ^-1 V)))", "completion": "\\lam Dc => directedProdCover-char.2 (cauchy-subset (fc Dc) (\\lam p0 => (\\case \\elim p0 \\with {\n  | inP (N, V, DV, h) => inP $ later (N, _, inP (V, DV, idp), h)\n})),\n  \\lam n => cauchy-subset (func-cover {f n} Dc) (\\lam {p0} p1 => (\\case \\elim p0, \\elim p1 \\with {\n    | _, inP (V, DV, idp) => inP $ later (_, inP (V, DV, idp), \\lam s => s)\n  })))"}
{"prompt": "['b : Rat', 'b>0 : zro < b', 'a1 : Rat', 'a2 : Rat']<<<break>>>['| zro : E', '| meet-left {x y : E} : x \u2227 y <= x', '| \\\\infixl 7 * E E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func meet (_ _ : Rat) : Rat \\n  | rat n1 d1 denom/=0 reduced, rat n2 d2 denom/=0 reduced => \\\\case dec<_<= {IntRing} (n2 * pos d1) (n1 * pos d2) \\\\with {\\n    | inl y<x => rat n2 d2 {?hidden} {?hidden}\\n    | inr x<=y => rat n1 d1 {?hidden} {?hidden}\\n  }', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| <=_*_positive-left {x y z : E} (x <= y) (zro <= z) : x * z <= y * z', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>meet a1 a2 * b <= a1 * b", "completion": "<=_*_positive-left {RatField} meet-left (<=-less b>0)"}
{"prompt": "['X : ExPseudoNormedAbGroup', 'x : X.E', 'y : X.E', 'r : X.norm (x - y) = zro']<<<break>>>['| zro : E', '\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| <=-refl {x : E} : x <= x', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>X.norm (x - y) + X.norm y <= zro + X.norm y", "completion": "<=_+ {ExUpperRealAbMonoid} (=_<= r) <=-refl"}
{"prompt": "['M : Monoid']<<<break>>>['\\\\instance InvSubMonoid \\\\hlevels  (M : Monoid) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => Inv {M} x) => \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', '| E : \\\\Set', '\\\\class SubMonoid \\\\extends SubPointed, SubSemigroup \\\\hlevels ', '| S : BaseSet', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ']<<<break>>>SubMonoid M (\\lam (x : E {S {\\this}}) => Inv {M} x)", "completion": "InvSubMonoid M"}
{"prompt": "['d : dist (fromRat q) x < eps', 'x : Real', 'q : Rat', 'eps : Real']<<<break>>>['\\\\lemma rat_real_<= \\\\plevels  \\\\hlevels  {a b : Rat} : a <= b <-> fromRat a <= fromRat b ', '| \\\\infixl 6 + E E : E', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', '| dist E E : ExUpperReal', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma <=_+-left \\\\hlevels  {this : LinearlyOrderedAbMonoid} {a b c d : E} (_ : a <= c) (_ : b < d) : a + b < c + d ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', 'pos Nat', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\lemma dist-rat \\\\plevels  \\\\hlevels  {x y : Rat} : abs {RealAbGroup} (fromRat x - fromRat y) = fromRat (abs {RatField} (x - y)) ', '\\\\lemma rat_round-dist \\\\plevels  \\\\hlevels  {r : Rat} : abs {RatField} (fromInt (rat_round r) - r) <= ratio (pos 1) 2 ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', 'rat_round \\\\plevels  \\\\hlevels  (r : Rat) : Int => \\\\case dec<_<= {RatField} (r - fromInt (rat_floor r)) (ratio (pos 1) 2) \\\\with {\\n  | inl a => rat_floor r\\n  | inr b => rat_floor r + pos 1\\n}', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>abs {RealAbGroup} (fromRat (fromInt (rat_round q)) - fromRat q) + dist (fromRat q) x < fromRat (ratio (pos 1) 2) + eps", "completion": "<=_+-left {RealAbGroup} (transportInv (\\lam _x => _x <= _) dist-rat $ rat_real_<=.1 rat_round-dist) d"}
{"prompt": "['r : Inv {p x.1} x.2', 'x : \\\\Sigma (j : D.Ob) (F j)', 'F : Functor D CRingCat', 'D : BottomJoinSemilattice', \"this : DiscreteField (SetColimit {D} (Comp {D} {CRingCat} {SetCat} CRingCat.forget F1)) {\\n  | zro => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, zro {F D.bottom})\\n  | + => (+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (MonoidLatticeColimit.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => negative {D} {Comp {D} {AbGroupCat} {AddGroupCat} forgetToAddGroup\\n    (Comp {D} {RingCat} {AbGroupCat} forgetToAbGroup (Comp {D} {CRingCat} {RingCat} forgetToRing F1))}\\n  | negative-left => {?hidden}\\n  | ide => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, ide {F D.bottom})\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl {RingLatticeColimit {D} (Comp {D} {CRingCat} {RingCat} forgetToRing F1)}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | *-comm => {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case eitherZeroOrInv {\\\\this} (x - y) \\\\with {\\n    | byLeft x-y=0 => yes {x = y} (fromZero {x} {y} x-y=0)\\n    | byRight x-y-isInv => no {x = y} (\\\\lam (x=y : x = y) =>\\n      #-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (x : E {\\\\this}) => Inv (x - y)) {x} {y} x=y x-y-isInv))\\n  })\\n  | zeroProduct => {?hidden}\\n  | finv => finv-impl\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n  | eitherZeroOrInv => \\\\lam (p0 : E {\\\\this}) => (\\\\case p0 \\\\with {\\n    | in~ x => \\\\case eitherZeroOrInv {p x.1} x.2 \\\\with {\\n      | byLeft r => byLeft {in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n        \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x = in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n        \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, zro {F D.bottom})}\\n        {Inv (in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n          \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x)}\\n        (Paths.inv {SetColimit {D} (Comp {D} {CRingCat} {SetCat} CRingCat.forget F1)}\\n          {in~ {\\\\Sigma (j : D.E) (E {F.F j})} {\\\\lam (s : \\\\Sigma (j : D.E) (E {F.F j})) (s' : \\\\Sigma (j : D.E) (E {F.F j})) =>\\n            \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, zro {F.F D.bottom})}\\n          {in~ {\\\\Sigma (j : D.E) (E {F.F j})} {\\\\lam (s : \\\\Sigma (j : D.E) (E {F.F j})) (s' : \\\\Sigma (j : D.E) (E {F.F j})) =>\\n            \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x}\\n          (~-cequiv {D} {Comp {D} {CRingCat} {SetCat} CRingCat.forget F1} {(D.bottom, zro {F.F D.bottom})} {x} (D.bottom-univ {x.1})\\n            (func-zro {F.Func {D.bottom} {x.1} (D.bottom-univ {x.1})} *> Paths.inv {E {F.F x.1}} {x.2} {zro {F.F x.1}} r)))\\n      | byRight r => byRight {in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n        \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x = in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n        \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, zro {F D.bottom})}\\n        {Inv (in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n          \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x)}\\n        (lmake {in~ {\\\\Sigma (j : D.E) (E {F.F j})} {\\\\lam (s : \\\\Sigma (j : D.E) (E {F.F j})) (s' : \\\\Sigma (j : D.E) (E {F.F j})) =>\\n          \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x}\\n          (inC {D} {Comp {D} {CRingCat} {SetCat} CRingCat.forget F1} (x.1, r.inv))\\n          (Paths.inv {SetColimit {D} (Comp {D} {CRingCat} {SetCat} CRingCat.forget F1)} {ide {\\\\this}}\\n            {inC {D} {Comp {D} {CRingCat} {SetCat} CRingCat.forget F1} (x.1, r.inv) Semigroup.* in~ {\\\\Sigma (j : D.E) (E {F.F j})} {\\\\lam (s : \\\\Sigma (j : D.E) (E {F.F j})) (s' : \\\\Sigma (j : D.E) (E {F.F j})) =>\\n              \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x}\\n            (~-cequiv {D} {Comp {D} {CRingCat} {SetCat} CRingCat.forget F1} {(D.bottom, ide {F.F D.bottom})} {(x.1 D.\u2228 x.1,\\n              func {Func {x.1} {x.1 D.\u2228 x.1} (D.join-left {x.1} {x.1})} r.inv Semigroup.* func {Func {x.1} {x.1 D.\u2228 x.1} (D.join-right {x.1} {x.1})} x.2)}\\n              (D.bottom-univ {x.1 D.\u2228 x.1})\\n              (func-ide {F.Func {D.bottom} {x.1 D.\u2228 x.1} (D.bottom-univ {x.1 D.\u2228 x.1})} *> Paths.inv {E {F.F (x.1 D.\u2228 x.1)}} {func {F.Func {x.1} {x.1 D.\u2228 x.1} (D.join-left {x.1} {x.1})} (r.inv Semigroup.* x.2)}\\n                {ide {F.F (x.1 D.\u2228 x.1)}}\\n                (pmap {E {F.F x.1}} {E {F.F (x.1 D.\u2228 x.1)}} (func {F.Func {x.1} {x.1 D.\u2228 x.1} (D.join-left {x.1} {x.1})})\\n                  {r.inv Semigroup.* x.2} {ide {p x.1}} r.inv-left *> func-ide {F.Func {x.1} {x.1 D.\u2228 x.1} (D.join-left {x.1} {x.1})}) *> func-* {F.Func {x.1} {x.1 D.\u2228 x.1} (D.join-left {x.1} {x.1})} {r.inv} {x.2}))))\\n    }\\n  })\\n}\", 'p : \\\\Pi (d : D.E) -> DiscreteField (E {F.F d}) {\\n  | zro => zro {F.F d}\\n  | + => (+) {F.F d}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (*) {F.F d}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => negative {F.F d}\\n  | negative-left => {?hidden}\\n  | ide => ide {F.F d}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoef {F.F d}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}']<<<break>>>[\"\\\\type SetColimit \\\\hlevels  {J : Precat} (F1 : Functor J SetCat) : \\\\Set \\n=> Quotient {\\\\Sigma (j : J.Ob) (F.F j)} (\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2))\", '\\\\func forget : Functor CRingCat SetCat (\\\\lam (R : Ob {C {\\\\this}}) => R.E) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f.func\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func forgetToMonoid : Functor RingCat MonoidCat (\\\\lam (R : Ob {C {\\\\this}}) => R) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| join-left {x y : E} : x <= x \u2228 y', '| inv-left : inv * val = elem', '| \\\\infixl 7 * E E : E', '\\\\instance CRingCat : Cat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {RingCat} {CRing} (\\\\new Embedding {CRing} {Ob} (\\\\lam (R : A {\\\\this}) => R) {\\n  | isEmb => \\\\lam (R S : A {\\\\this}) =>\\n  \\\\new Retraction {R = S} {f {\\\\this} R = f {\\\\this} S} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {R} {S}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new CRing (E {p @ i}) {\\n      | zro => zro {p @ i}\\n      | + => (+) {p @ i}\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*) {p @ i}\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | negative => negative {p @ i}\\n      | negative-left => {?hidden}\\n      | ide => ide {p @ i}\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef {p @ i}\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n    })\\n    | f_sec => idpe {R = S}\\n  }\\n})', '| bottom : E', '| E : \\\\Set', '| join-right {x y : E} : y <= x \u2228 y', '\\\\instance RingCat : Cat Ring {\\n  | Hom => RingHom\\n  | id => RingHom.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func forgetToRing : Functor CRingCat RingCat (\\\\lam (R : Ob {C {\\\\this}}) => R) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", 'in~ A', '| Hom Ob Ob : \\\\Set', \"\\\\lemma ~-cequiv \\\\hlevels  {J : Precat} {F1 : Functor J SetCat} {s s' : \\\\Sigma (j : J.Ob) (F.F j)} (f : J.Hom s.1 s'.1)\\n  (_ : F.Func {s.1} {s'.1} f s.2 = s'.2) :\\nin~ {\\\\Sigma (j : J.Ob) (F.F j)} {\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2)} s = in~ {\\\\Sigma (j : J.Ob) (F.F j)} {\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2)} s' \", '| ide : E', \"\\\\func inC \\\\hlevels  {J : Precat} {F1 : Functor J SetCat} (s : \\\\Sigma (j : J.Ob) (F.F j)) : SetColimit {J} F1 \\n=> in~ {\\\\Sigma (j : J.Ob) (F.F j)} {\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2)} s\", '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| inv : E {M}', '| F (Ob {C}) : Ob {D}', '| func-ide : func (ide {Dom}) = ide {Cod}', '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| func (E {Dom}) : E {Cod}', '| bottom-univ {x : E} : bottom <= x', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\instance MonoidCat : Cat Monoid {\\n  | Hom => MonoidHom\\n  | id => MonoidHom.id\\n  | o => \\\\lam {x y z : Ob {\\\\this}} (g : Hom {\\\\this} y z) (f : Hom {\\\\this} x y) => \\\\new MonoidHom x z {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n    | func-ide => {?hidden}\\n    | func-* => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}']<<<break>>>inC {D} {Comp {D} {CRingCat} {SetCat} forget F1} (x.1, r.inv) * in~ {\\Sigma (j : D.E) (E {F.F j})} {\\lam (s : \\Sigma (j : D.E) (E {F.F j})) (s' : \\Sigma (j : D.E) (E {F.F j})) =>\n  \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} x = ide {this}", "completion": "later (inv $ ~-cequiv (bottom-univ {D}) $ func-ide *> inv (pmap (Func {F} _) (inv-left {r}) *> func-ide) *> func-*)"}
{"prompt": "['a : \\\\Sigma V.E B.E', 'l : Array (\\\\Sigma V.E B.E) n', 'n : Nat', 'V : PosetQModule', 'B : BooleanRing', 'lr : IsReduced {V} {B} (a :: l)']<<<break>>>['suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', \"\\\\func interpretNF \\\\hlevels  {B : BooleanRing} {n : Nat} (env : Fin n -> B.E) (l : NF n) : B.E \\n  => interpretNF' {B} {n} (\\\\new Array B.E n env) (collapse {n} (sort {LexicographicalArray {n} BoolOpPoset} l))\", '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\infixl 7 :* (_ _ : Term n)', '\\\\func diff \\\\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y', '\\\\lemma fsuc/=0 \\\\plevels  \\\\hlevels  {n : Nat} {x : Fin n} : fsuc {n} x /= 0 ', '\\\\lemma diff-univ \\\\hlevels  {this : BooleanRing} {x y z : E} (_ : x <= y) (_ : x * z = zro) : x <= diff y z ', '| bottom : E', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\lemma BigJoin-univ \\\\hlevels  {this : BottomJoinSemilattice} {l : Array E} {x : E} (_ : \\\\Pi (j : Fin l.len) -> l.at j <= x) : BigJoin l <= x ', 'var (Fin n)', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma terms-equality \\\\hlevels  {B : BooleanRing} (env : Array B.E) (t s : Term env.len)\\n  (_ : interpretNF {B} {env.len} env.at (normalize {env.len} (t :+ s)) = B.zro) : interpret {B} env t = interpret {B} env s ', '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', '\\\\infixl 6 :+ (_ _ : Term n)', '\\\\func normalize {n5 : Nat} (_ : Term n5) : NF n5 \\n  | {n}, var j => singleAt {Bool} {n} j true false :: nil {Array Bool n}\\n  | {n}, :zro => nil {Array Bool n}\\n  | {n}, :negative t => normalize {n} t\\n  | {n}, t :+ s => normalize {n} t ++ normalize {n} s\\n  | {n}, t :* s => multiply {n} (normalize {n} t) (normalize {n} s)', \"\\\\lemma meet_<=' \\\\hlevels  {this : MeetSemilattice} {x y : E} (_ : x \u2227 y = x) : x <= y \", '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\lemma BigJoin-cond \\\\hlevels  {this : BottomJoinSemilattice} {l : Array E} (j : Fin l.len) : l.at j <= BigJoin l ', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y']<<<break>>>BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l) = diff {B} (BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (a :: l))) (at {a :: l} 0).2", "completion": "<=-antisymmetric\n(BigJoin-univ {B} (\\lam j => diff-univ {B} (BigJoin-cond {B} {map (\\lam p0 => p0.2) (a :: l)} (suc j)) $ lr fsuc/=0))\n  (meet_<=' {B} bRing)"}
{"prompt": "['F : SetFilter X.E', 'X : UniformSpace']<<<break>>>['| F (E {A}) : \\\\Prop', '\\\\func IsCauchyFilter \\\\hlevels  {S : CoverSpace} (F1 : SetFilter S.E) : \\\\Prop \\n  => \\\\Pi {C : Set (Set S.E)} -> S.isCauchy C -> TruncP (\\\\Sigma (U : Set S.E) (C U) (F.F U))', '\\\\lemma makeCauchy \\\\hlevels  {this : PreuniformSpace} {C : Set (Set E)} (_ : isUniform C) : isCauchy C ', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>IsCauchyFilter {X} F1 -> \\Pi {C : Set (Set X.E)} -> X.isUniform C -> TruncP (\\Sigma (U : Set X.E) (C U) (F.F U))", "completion": "\\lam Fc Cu => Fc $ makeCauchy {X} Cu"}
{"prompt": "['X : PseudoValuedRing']<<<break>>>['\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma =-upper \\\\plevels  \\\\hlevels  {x y : Real} : x = y <-> x = y ', '| ide : E', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| norm E : ExUpperReal']<<<break>>>X.norm X.ide = ide {RealField} <-> X.norm X.ide = ide {RealField}", "completion": "=-upper {_} {1}"}
{"prompt": "['y : E {\\\\this}', 'S : CoverSpace', 'h1 : x.F = y.F', 'x : E {\\\\this}']<<<break>>>['| isProper {U : Set X} (F U) : TruncP (\\\\Sigma (x : X) (U x))', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Path (\\lam (i : I) => \\Pi {U : Set S.E} -> (@) h1 i U -> TruncP (\\Sigma (x : S.E) (U x))) x.isProper y.isProper", "completion": "prop-dpi (\\lam i => ext_coe) (isProper {x}) (isProper {y})"}
{"prompt": "['eh : R.isHomogen e ed', 'R : GradedCRing', 'g : Carrier R', 'l : Nat', 'y : R.E', 'k : Nat', 'n : Nat', 'm : Nat', 'e : R.E', 'a : Carrier R', 'ed : Nat', 'yh : R.isHomogen y (suc g.2 * l)']<<<break>>>['| \\\\infixl 6 + E E : E', 'suc Nat', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| isHomogen E Nat : \\\\Prop', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '| \\\\infixl 7 * E E : E', '| ldistr {x y z : E} : x * (y + z) = x * y + x * z', '| homogen-* {n m : Nat} {a b : E} (isHomogen a n) (isHomogen b m) : isHomogen (a * b) (n + m)', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma homogen-pow \\\\hlevels  {this : GradedCRing} {a : E} {n m : Nat} (_ : isHomogen a n) : isHomogen (pow a m) (n * m) ', '| E : \\\\Set', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>R.isHomogen (pow {R} g.1 (k Semigroup.* n) R.* y R.* pow {R} g.1 m R.* e R.* pow {R} a.1 n)\n  (suc g.2 Semigroup.* (k Nat.* n + l) + suc g.2 Semigroup.* m + ed + suc a.2 Semigroup.* n)", "completion": "rewrite ldistr\n  (homogen-* (homogen-* (homogen-* (homogen-* (homogen-pow {R} g.3) yh) (homogen-pow {R} g.3)) eh) (homogen-pow {R} a.3))"}
{"prompt": "[\"g : \\\\Pi {x x' : E {Dom}} -> U {dist {Dom} x x'} delta -> U {dist {Cod} (func x) (func x')} eps\", 'U : Set (E {Cod})', 'e : \\\\Pi {y : E {Cod}} -> U {dist {Cod} (func x) y} eps -> U1 y', 'this : UniformMetricMap', 'x : E {Dom}', 'delta : Rat']<<<break>>>['| U Rat : \\\\Prop', '| dist E E : ExUpperReal', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>\\Pi {y : E {Dom}} -> U {dist {Dom} x y} delta -> U1 (func y)", "completion": "\\lam d => e (g d)"}
{"prompt": "['this : DoubleLimit', \"c : Cone {J} {C'} G\"]<<<break>>>['| D : CompletePrecat', \"| G : Functor J C'\", '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\class Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | J : Precat\\n  | D : Precat\\n  | G : Functor J D\\n  | apex : Ob {D}\\n  | coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)\\n  | coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\\n}\", '| F (Ob {C}) : Ob {D}', '| F : Functor C D', \"| p : Functor C C'\", '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func RightKanExt \\\\plevels obj >= hom \\\\hlevels  {C1 C' : Precat} (D : CompletePrecat) (p : Functor C1 C') (F1 : Functor C1 D) :\\nFunctor C' D (\\\\lam (c' : Ob {C {\\\\this}}) => apex) {\\n  | Func => \\\\lam {x : Ob {C {\\\\this}}} {y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} x y) =>\\n  limMap {apex} (premap {commaPrecat {TrivialCat} {C1} {C'} (Const {TrivialCat} {C'} y) p}\\n    {commaPrecat {TrivialCat} {C1} {C'} (Const {TrivialCat} {C'} x) p} (commaFunctor {C1} {C'} {p} {y} {x} f)\\n    (lim {C1} {C'} {D} {p} F1 x))\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}\", '| J : Precat', \"| C' : Precat\", '\\\\func map \\\\plevels obj >= hom \\\\hlevels  {C D : Precat} (F1 : Functor C D) {J1 : Precat} {G : Functor J1 C} (c : Cone {J1} {C} G) :\\nCone {J1} {D} (Comp {J1} {C} {D} F1 G) (F.F c.apex) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => F.Func {c.apex} {G.F j} (c.coneMap j)\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| Ob : \\\\hType', '| J : Precat', '| C : Precat', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>Cone {RightKanExt.DoubleLimit.J} {D}\n  (Comp {RightKanExt.DoubleLimit.J} {C'} {D} (RightKanExt {C} {C'} D p RightKanExt.DoubleLimit.F) G) (Functor.F c.apex) {\n  | coneMap => \\lam (j : Ob {Cone.J {\\this}}) => Func {c.apex} {Functor.F {G} j} (c.coneMap j)\n}", "completion": "map (RightKanExt (D {this}) (p {this}) (F {this})) c"}
{"prompt": "['this : Pullback', 'c : B {\\\\this}', 'z : Ob {D {\\\\this}}']<<<break>>>[\"| diagramCoh {g g' : V {G}} (e : E {G} g g') : Func {g} {g'} e \u2218 coneMap g = coneMap g'\", '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '| y : Ob {D}', '| pbBeta2 {w : Ob {D}} {p1 : Hom {D} w x} {p2 : Hom {D} w y} {c : f \u2218 p1 = g \u2218 p2} : pbProj2 \u2218 pbMap {w} p1 p2 c = p2', '| pbProj2 : Hom {D} apex y', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| apex : Ob {D}', '| g : Hom {D} y z', '| f : Hom {D} x z', '| pbMap {w : Ob {D}} (p1 : Hom {D} w x) (p2 : Hom {D} w y) (f \u2218 p1 = g \u2218 p2) : Hom {D} w apex', '| x : Ob {D}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| z : Ob {D}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| D : Precat']<<<break>>>pbProj2 \u2218 pbMap {z1} (c.coneMap 0) (c.coneMap 1)\n  (c.diagramCoh {0} {2} () *> inv {Hom {D} z1 z} {g \u2218 c.coneMap 1} {c.coneMap 2} (c.diagramCoh {1} {2} ())) = c.coneMap 1", "completion": "pbBeta2 {this}"}
{"prompt": "['g : InterwiningMap {G} {R} A B', 'this : InterwiningMap {G1} {R} A B {\\n  | func => \\\\lam (a : E {Dom {linearMap_+ {R} {A} {B} f g}}) => f.func a B.+ g.func a\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n  | func-** => {?hidden}\\n}', 'B : LinRepres R G', 'A : LinRepres R G', 'f : InterwiningMap {G} {R} A B']<<<break>>>['| func-** {e : E {Dom}} {g : E {G}} : func (g ** e) = g ** func e', '| \\\\infixl 6 + E E : E', \"| **-ldistr {g : E {G}} {e e' : E} : g ** (e + e') = g ** e + g ** e'\", '| G : Group', '| \\\\infixl 8 ** (E {G}) E : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>\\Pi {e : E {Dom {\\this}}} -> \\Pi {g : E {G {\\this}}} -> func {\\this} (g ** e) = g ** func {\\this} e", "completion": "\\lam {e} {g} => unfold (rewrite (func-** {f}, func-** {g}, **-ldistr {B}) idp)"}
{"prompt": "['q : Rat', 'x : ExUpperReal', \"q' : Rat\", 'y : ExUpperReal', \"q'<q : q < q'\", 'e : U {\\\\this} q']<<<break>>>['\\\\func map {A B C2 D2 : \\\\Type} (_ : A -> C2) (_ : B -> D2) (_ : A || B) : C2 || D2 \\n  | {A}, {B}, {C}, {D}, f, g, byLeft a => byLeft {C} {D} (f a)\\n  | {A}, {B}, {C}, {D}, f, g, byRight b => byRight {C} {D} (g b)', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"| U-closed {q q' : Rat} (U q) (q < q') : U q'\", '| U Rat : \\\\Prop']<<<break>>>x.U q' || y.U q'", "completion": "map (\\lam p0 => U-closed {x} p0 q'<q) (\\lam p0 => U-closed {y} p0 q'<q) e"}
{"prompt": "['f : CoverMap X Y', 'F : RegularCauchyFilter X']<<<break>>>['| A : TopMeetSemilattice', '| F (E {A}) : \\\\Prop', '| func-cauchy (F1 : CauchyFilter Dom) : CauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isProper => {?hidden}\\n}', '| filter-mono {a b : E {A}} (F a) (a <= b) : F b', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| Cod : BaseSet', '\\\\class CauchyFilter \\\\extends WeaklyCauchyFilter, ProperFilter \\\\hlevels ', '| isProper {U : Set X} (F U) : TruncP (\\\\Sigma (x : X) (U x))', '\\\\func SetFilter-map \\\\hlevels  {X1 Y : \\\\Set} (f : X1 -> Y) (F1 : SetFilter X1) : SetFilter Y (\\\\lam (V : E {A {\\\\this}}) => F.F (f ^-1 V)) \\n=> \\\\new SetFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n}', '| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)', '\\\\func ProperFilter-map \\\\hlevels  {X1 Y : \\\\Set} (f : X1 -> Y) (F1 : ProperFilter X1) :\\n  ProperFilter Y (\\\\lam (V : E {A {SetFilter-map {X1} {Y} f F1}}) => F.F (f ^-1 V)) => \\\\new ProperFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isProper => {?hidden}\\n}', '| filter-top : F (top {A})', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>CauchyFilter f.Cod (\\lam (V : E {A {SetFilter-map {E {f.Dom}} {E {f.Cod}} f.func F1}}) => F.F (f.func ^-1 V)) {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isProper => {?hidden}\n}", "completion": "func-cauchy {f} F"}
{"prompt": "['h1 : (\\\\lam (e : L.E) => (\\n  \\\\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\\n          {L.Meet {\\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j1 : Bool) -> \\\\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\\n            (\\\\lam (p : \\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j1 : Bool) -> \\\\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\\n  \\\\in ((func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).1,\\n        (func {map {j} \u2218 <=-map {L1} j (j \u2228 k) (join-left {j} {k})} e).2))) = (\\\\lam (e : L.E) => (\\n  \\\\have _ => double-nucleus-left {L1} {j} {j \u2228 k} (join-left {j} {k}) e *> inv {L.E} {(func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1}\\n          {L.Meet {\\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j1 : Bool) -> \\\\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)}\\n            (\\\\lam (p : \\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j1 : Bool) -> \\\\Pi {x : L.E} -> nucleus {if {Nucleus {L1}} j1 j k} x L.<= n.nucleus x)) =>\\n              nucleus {p.1} e)} (double-nucleus-left {L1} {k} {j \u2228 k} (join-right {j} {k}) e)\\n  \\\\in ((func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).1,\\n        (func {map {k} \u2218 <=-map {L1} k (j \u2228 k) (join-right {j} {k})} e).2)))', 'x : E {Dom {\\\\this}}', 'j : Nucleus {L}', 'i : I', 'L : Locale', 'k : Nucleus {L}']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| \\\\infix 4 <= E E : \\\\Prop', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| join-left {x y : E} : x <= x \u2228 y', '\\\\func map \\\\hlevels  {this2 : Nucleus} : FrameHom L locale {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (nucleus x, nucleus-join>= {x})\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}', '| func-<= {x y : E {Dom}} (x <= y) : func x <= func y', '\\\\instance locale \\\\hlevels  {this2 : Nucleus} : Locale Subtype {\\n  | <= => \\\\lam (p0 : E {\\\\this}) (p1 : E {\\\\this}) => p0.1 <= p1.1\\n  | meet => \\\\lam (p0 : E {\\\\this}) (p1 : E {\\\\this}) => (p0.1 \u2227 p1.1,\\n    transportInv {E {L}} (\\\\lam (x : E {L}) => x <= p0.1 \u2227 p1.1) {nucleus (p0.1 \u2227 p1.1)} {nucleus p0.1 \u2227 nucleus p1.1}\\n      (nucleus-meet {p0.1} {p1.1}) (meet-monotone {L} {nucleus p0.1} {nucleus p1.1} {p0.1} {p1.1} p0.2 p1.2))\\n  | top => (top {L}, top-univ {L} {nucleus (top {L})})\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    (nucleus (Join {L} {J} (\\\\lam (p0 : J) => (f p0).1)), nucleus-join>= {Join {L} {J} (\\\\lam (p0 : J) => (f p0).1)})\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', \"\\\\instance NucleusFrame (L1 : Locale) : Locale (Nucleus {L1}) {\\n  | <= => \\\\lam (j : E {\\\\this}) (j' : E {\\\\this}) => \\\\Pi {x : L.E} -> j.nucleus x L.<= j'.nucleus x\\n  | meet => NucleusFrame.meet {L1}\\n  | top => \\\\new Nucleus {L1} (\\\\lam (_ : E {L {\\\\this}}) => L.top) {\\n    | nucleus-meet => {?hidden}\\n    | nucleus-meet>= => {?hidden}\\n    | nucleus-<= => {?hidden}\\n    | nucleus-unit => {?hidden}\\n    | nucleus-join>= => {?hidden}\\n    | nucleus-join => {?hidden}\\n  }\\n  | Join => \\\\lam {J : \\\\Set} (g : J -> E {\\\\this}) => \\\\new Nucleus {L1} (\\\\lam (x : E {L {\\\\this}}) =>\\n    L.Meet {\\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j : J) -> \\\\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)}\\n      (\\\\lam (p : \\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j : J) -> \\\\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)) => nucleus {p.1} x)) {\\n    | nucleus-meet => {?hidden}\\n    | nucleus-meet>= => {?hidden}\\n    | nucleus-<= => {?hidden}\\n    | nucleus-unit => {?hidden}\\n    | nucleus-join>= => {?hidden}\\n    | nucleus-join => {?hidden}\\n  }\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}\", '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| join-right {x y : E} : y <= x \u2228 y', \"\\\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}\"]<<<break>>>\\Pi {y : L.E} -> x L.<= y -> (@) h1 i x <= (@) h1 i y", "completion": "(@) (prop-dpi (\\lam i => ext_coe) (func-<= {map {j} \u2218 <=-map {L} j (j \u2228 k) (join-left {j} {k})})\n  (func-<= {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {j} {k})})) i {x}"}
{"prompt": "['X : PreAdditivePrecat (\\\\Sigma)', 'x : E {\\\\this}']<<<break>>>['| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| Hom Ob Ob : \\\\Set', '| id (X : Ob) : Hom X X', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z']<<<break>>>X.id () X.\u2218 x = x", "completion": "id-left {X}"}
{"prompt": "['A : \\\\Type', 'm : Nat', 'i : I', \"arg : \\\\Pi (j : Fin (0 + m)) -> at {skip {A} {m} ((++') {A} (a :: nil) {m} l') 0} j = at {(++') {A} (a :: nil) {m} l'} (suc j)\"]<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)']<<<break>>>Array A (0 + m) (\\lam (j : Fin (0 + m)) => arg j @ i)", "completion": "\\new DArray {\n  | at => \\lam j => arg j @ i\n}"}
{"prompt": "['y : Real', 'x : Real', 'x<y : x < y']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatAlgebraData {RealField} (x :: y :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (:zro {Rat} {Fin 2}) < interpret {\\new LinearRatAlgebraData {RealField} (x :: y :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}}\n  (coef {E} {Fin 2} (rat (pos 1) 4 {?hidden} {?hidden}) :* (var {E} {Fin 2} 1 :+ :negative {E} {Fin 2} (var {E} {Fin 2} 0)))", "completion": "solve<Problem {\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => x :: y :: nil\n}} ((var 0, Less, var 1) :: nil) :zro (coef (rat (pos 1) 4 {?hidden} {?hidden}) :* (var 1 :+ :negative (var 0)))\n  (4 :: 1 :: nil, 0, idp, idp {Bool} {true}) (x<y :: nil)"}
{"prompt": "['c : \\\\Pi (x : R.E) -> U x -> I.contains x', 'R : CRing', 'U : R.E -> \\\\Prop', 'I : Ideal R']<<<break>>>['| E : \\\\Set', '| contains (E {S}) : \\\\Prop']<<<break>>>\\Pi (j : \\Sigma (x : R.E) (U x)) -> I.contains j.1", "completion": "\\lam j => c j.1 j.2"}
{"prompt": "['y : E {Dom {\\\\this}}', 'X : PseudoNormedAbGroup']<<<break>>>['\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', '| E : \\\\Set', '| negative E : E', '| norm E : ExUpperReal', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>negative (negative (X.norm y)) = X.norm y", "completion": "negative-isInv {_} {X.norm y}"}
{"prompt": "['S : DecSet', 'a2 : \\\\Sigma S.E Bool', 'a1 : \\\\Sigma S.E Bool', 'e1 : a1.1 = a2.1', 'p3 : a1.2 xor a2.2 = true', 'e2 : a.1 = a3.1', 'a : \\\\Sigma S.E Bool', 'x2 : List (\\\\Sigma S.E Bool)', 'a3 : \\\\Sigma S.E Bool']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func AreAdjacent \\\\hlevels  {S : \\\\Set} (w_1 w_2 : E) : \\\\Prop => TruncP (\\\\Sigma (u_1 u_2 : E) (x : S) (p : Bool)\\n  (\\\\Sigma (w_1 = u_1 * u_2) (w_2 = u_1 * ((x, p) :: nil {\\\\Sigma S Bool}) * ((x, not p) :: nil {\\\\Sigma S Bool}) * u_2)))', '\\\\func not \\\\plevels  \\\\hlevels  (_ : Bool) : Bool \\n  | true => false\\n  | false => true', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'cin (R x y)', 'nil', 'inP A', '\\\\func W \\\\hlevels  {S : \\\\Set} : Monoid (List (\\\\Sigma S Bool)) {\\n  | ide => nil {\\\\Sigma S Bool}\\n  | * => (++)\\n} => ListMonoid {\\\\Sigma S Bool}', 'yes E', '| \\\\infixl 7 * E E : E', 'false', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| E : \\\\Set', '\\\\instance ListMonoid \\\\hlevels  {A : \\\\Set} : Monoid (List A) {\\n  | ide => nil {A}\\n  | * => (++)\\n} => \\\\new Monoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n}', '\\\\func helper1 \\\\plevels  \\\\hlevels  {a2 b2 : Bool} (_ : a2 xor b2 = true) : not a2 = b2 \\n  | {false}, {true}, p => idp {Bool} {not false}\\n  | {true}, {false}, p => idp {Bool} {not true}', '\\\\data Closure {A : \\\\Type} (A -> A -> \\\\Type) (_ _ : A) : \\\\Prop \\n  | cin (R x y)\\n  | crefl (x = y)\\n  | csym (Closure {A} R y x)\\n  | ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)']<<<break>>>Closure {List (\\Sigma S.E Bool)} (AreAdjacent {S.E}) (\\case yes {a.1 = a3.1} e2, false \\with {\n  | yes e, true => x2\n  | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\n}) (a :: a1 :: a2 :: a3 :: x2)", "completion": "cin (inP (a :: nil, a3 :: x2, a1.1, a1.2, (idp, rewrite {2} e1 (rewrite (helper1 p3) idp))))"}
{"prompt": "['this : HeytingAlebra', 'this : Functor this this ((-->) X) {\\n  | Func => -->-monotone {X}\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', 'X : E']<<<break>>>['| Hom Ob Ob : \\\\Set', '| Ob : \\\\hType', '| C : Precat', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func -->-monotone \\\\hlevels  {this : HeytingAlebra} {x y z : E} (p : y <= z) : x --> y <= x --> z \\n  => exponent-left {x --> y} {x} {z} (eval {x} {y} <=\u2218 p)', '| implies \\\\alias \\\\infixr 5 --> E E : E']<<<break>>>\\Pi {X1 Y : Ob {C {\\this}}} -> Hom {C {\\this}} X1 Y -> X --> X1 <= X --> Y", "completion": "\\lam f => -->-monotone {this} f"}
{"prompt": "['n : Nat']<<<break>>>['\\\\lemma rfunc>=0 \\\\hlevels  {n : Nat} : zro <= rfunc n ', '| \\\\infixl 6 + E E : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", 'pos Nat', '| <=_*-positive {x y : E} (zro <= x) (zro <= y) : zro <= x * y', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\lemma <=_+-positive \\\\hlevels  {this : PosetAddMonoid} {a b : E} (_ : zro <= a) (_ : zro <= b) : zro <= a + b ', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'rfunc \\\\hlevels  (_ : Nat) : Rat \\n  | 0 => zro\\n  | suc n => ratio (pos 1) 2 * (ide + rfunc n * rfunc n)', '\\\\lemma rat_<=-dec \\\\plevels  \\\\hlevels  {r q : Rat} {so : So (rat_<=_Bool r q)} : r <= q ', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>zro <= rat (pos 1) 1 {?hidden} {?hidden} + rfunc n * rfunc n", "completion": "<=_+-positive {RatField} rat_<=-dec (<=_*-positive {RatField} rfunc>=0 rfunc>=0)"}
{"prompt": "['b_Ub : \\\\Sigma (b : L.E) (U b)', 'uU : L.isUniform U', 'U : L.E -> \\\\Prop', 'x : L.E', 'L : PreuniformLocale']<<<break>>>['| isDownset {U : E -> \\\\Prop} {x y : E} (isUniform U) (U y) (x <= y) : U x', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>U (x L.\u2227 b)", "completion": "isDownset uU Ub meet-right"}
{"prompt": "['J : Ideal R', 'I : Ideal R', 'v : at {IsVonNeumannRegular {R} :: (\\\\Sigma (IsZeroDimensional {R}) (ReducedRing R.E {\\n  | zro => R.zro\\n  | + => (R.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (R.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => R.negative\\n  | negative-left => {?hidden}\\n  | ide => R.ide\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => R.natCoef\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n})) :: (\\\\Pi (I : Ideal R) -> IsFinitelyGenerated {I} -> TruncP (\\\\Sigma (u : R.E) (u R.* u = u) (IsGeneratedBy1 {I} u))) :: (\\\\Pi (I : Ideal R) -> I * I = I) :: (\\\\Pi (I J : Ideal R) -> I \u2227 J = I * J) :: nil}\\n  0', 'R : CRing']<<<break>>>['\\\\func func \\\\hlevels  {R : CRing} (I J : Ideal R) : \\\\Pi (s : \\\\Sigma (a b : R.E) (I.contains a) (J.contains b)) -> R.E \\n  => \\\\lam (s : \\\\Sigma (a b : R.E) (I.contains a) (J.contains b)) => s.1 R.* s.2', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\instance IdealMonoid \\\\hlevels  {R : CRing} : CMonoid (Ideal R) {\\n  | ide => top {R}\\n  | * => product {R}\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| S : BaseSet', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y', '\\\\instance IdealLattice \\\\hlevels  {R : CRing} : BoundedLattice (Ideal R) {\\n  | <= => \\\\lam (I : E {\\\\this}) (J : E {\\\\this}) => \\\\Pi {a : R.E} -> I.contains a -> J.contains a\\n  | meet => IdealLattice.meet {R}\\n  | join => \\\\lam (I : E {\\\\this}) (J : E {\\\\this}) => closure {R} {Or (\\\\Sigma (a : R.E) (I.contains a)) (\\\\Sigma (a : R.E) (J.contains a))}\\n    (rec {\\\\Sigma (a : R.E) (I.contains a)} {\\\\Sigma (a : R.E) (J.contains a)} {R.E}\\n      (\\\\lam (p0 : \\\\Sigma (a : R.E) (I.contains a)) => p0.1) (\\\\lam (p0 : \\\\Sigma (a : R.E) (J.contains a)) => p0.1))\\n  | top => top {R}\\n  | bottom => IdealLattice.bottom {R}\\n} => \\\\new BoundedLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | bottom-univ => {?hidden}\\n}', '\\\\lemma closure-superset \\\\hlevels  {R : CRing} {J : \\\\Set} {g : J -> R.E} (j : J) : contains (g j) ', '\\\\lemma product_meet \\\\hlevels  {R : CRing} {I J : Ideal R} : product {R} I J <= I \u2227 J ', '| meet-right {x y : E} : x \u2227 y <= y', '| contains (E {S}) : \\\\Prop', '| ideal-right {r a : E {S}} (contains a) : contains (a * r)']<<<break>>>I1 \u2227 J = I1 * J", "completion": "<=-antisymmetric (\\lam {a} c => (\\case v a \\with {\n  | inP (b, p) =>\n    rewrite p $ closure-superset {_} {_} {func I J} $ later (a * b, a, ideal-right (meet-left {IdealLattice} c), meet-right {IdealLattice} c)\n})) product_meet"}
{"prompt": "['p : IsPowerSeriesConv {X} cs', 'null : U {zro} B', 'B : Rat', 'cs : Nat -> X.E', 'X : ExPseudoNormedRing']<<<break>>>['true', '| \\\\infixl 6 + E E : E', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '| \\\\infixl 7 * E E : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| len : Nat', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '| norm E : ExUpperReal', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '| zro : E', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', '\\\\func midSum \\\\hlevels  {A3 : AddMonoid} (_ : Series A.E) (_ _ : Nat) : A.E \\n  | {A}, S, 0, m => partialSum {A} S m\\n  | {A}, S, suc n, 0 => A.zro\\n  | {A}, S, suc n, suc m => midSum {A} (\\\\lam (j : Nat) => S (suc j)) n m', 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '| U Rat : \\\\Prop', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>\\Pi {eps : Rat} -> zro < eps -> TruncP (\\Sigma (N : Nat) (\\Pi {n : Nat} ->\n  N <= n -> U {midSum {ExUpperRealAbMonoid} (\\lam (n : Nat) => X.norm (cs n) * fromRat (pow {RatValuedRing} (B + ide) n)) N n} eps))", "completion": "p (linarith $ norm>=0 |x|<B)"}
{"prompt": "['v : Array V.E', 'b : IsBasis {V} v', 'V : LModule R', 'R : Ring']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func arrayLinearMap \\\\hlevels  {R1 : Ring} {V : LModule R1} (v : Array V.E) : LinearMap {R1} (ArrayLModule {R1} v.len (RingLModule R1)) V {\\n  | func => \\\\lam (c : E {Dom {\\\\this}}) => BigSum {V} (\\\\new Array V.E v.len (\\\\lam (j : Fin v.len) => c.at j V.*c v.at j))\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\lemma surj-char \\\\hlevels  {R : Ring} {V : LModule R} {v : Array V.E} :\\n  IsSurj {Array R.E v.len} {V.E} (func {arrayLinearMap {R} {V} v}) <-> IsGenerated {V} v ', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func IsSurj {A B : \\\\Type} (f : A -> B) : \\\\Prop => \\\\Pi (y : B) -> TruncP (\\\\Sigma (x : A) (f x = y))']<<<break>>>IsSurj {Array R.E v.len} {V.E} (func {arrayLinearMap {R} {V} v})", "completion": "(surj-char {R} {V}).2 b.2"}
{"prompt": "['n : Nat', 'a : R.E', 'p0 : (\\\\case just {\\\\Sigma R.E R.E} (a, b) \\\\with {\\n  | just (a, b) => (Bool, a R.+ b, \\\\lam (p0 : Bool) => if {R.E} p0 a b)\\n  | nothing => (Empty, R.zro, absurd {R.E})\\n}).1', 'ah : R.isHomogen a (suc n)', 'bh : R.isHomogen b (suc n)', 'R : GradedCRing', 'b : R.E']<<<break>>>['true', '| \\\\infixl 6 + E E : E', 'suc Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Maybe \\\\Type \\n  | nothing\\n  | just A', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| isHomogen E Nat : \\\\Prop', 'just A', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '| zro : E', 'false', '\\\\data Empty \\\\plevels  \\\\hlevels  ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '\\\\func Carrier \\\\hlevels  (R : GradedCRing) : \\\\Set => \\\\Sigma (a : R.E) (n : Nat) (R.isHomogen a (suc n))']<<<break>>>if {R.E} p0 a b = (if {Carrier R} p0 (a, n, ah) (b, n, bh)).1", "completion": "\\case p0 \\as x \\return return_expr \\with {\n  | false => idp\n  | true => idp\n}"}
{"prompt": "['n : Nat', 'c : Rat']<<<break>>>['\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 < E E : \\\\Prop', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>ExUpperReal ((<) (pow {RatValuedRing} c n))", "completion": "pow c n"}
{"prompt": "['A : DecSet', 'l : Array A.E n', 'x : A.E', 'n : Nat', 'p : \\\\Pi (j : Fin (suc l.len)) -> at {x :: l} j /= a', 'a : A.E']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\data Empty \\\\plevels  \\\\hlevels  ', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '| E : \\\\Set']<<<break>>>at {x :: l} 0 = a -> Empty", "completion": "p 0"}
{"prompt": "['X : PrecoverSpace', 'U : Set X.E', 'V : Set X.E']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| <=-refl {x : E} : x <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func Compl \\\\hlevels  {X : \\\\hType} (U : Set X) : Set X => \\\\lam (x : X) => Not (U x)', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ']<<<break>>>\\Pi {U1 : Set X.E} ->\n  (U1 = Compl {X.E} V) || (U1 = U) -> (\\lam (W : Set X.E) => \\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U) U1", "completion": "later (\\lam p0 => (\\case p0 \\with {\n  | byLeft q => rewrite q (\\lam p0 => (\n    \\let (x, (Vx, nVx)) => p0\n    \\in absurd (nVx Vx)))\n  | byRight q => \\lam _ => rewrite q <=-refl\n}))"}
{"prompt": "['c : C.Ob', 'C : Precat']<<<break>>>['| Hom Ob Ob : \\\\Set', '| C : Precat', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}', '\\\\class VPresheaf \\\\hlevels  {\\n  | D : Cat\\n  | C : Precat\\n  | F : Functor (op {C}) D\\n}', '| D : Cat', '| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '\\\\class Functor \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F (Ob {C}) : Ob {D}\\n  | Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)\\n  | Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)\\n  | Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f\\n}', '| D : Precat', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| C : Precat', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}']<<<break>>>VPresheaf SetCat C\n  (\\new Functor (op {VPresheaf.C {\\this}}) (VPresheaf.D {\\this}) (\\lam (x : Ob {Functor.C {\\this}}) => C.Hom x c) {\n    | Func => \\lam {X Y : Ob {Functor.C {\\this}}} (f : Hom {Functor.C {\\this}} X Y) (g : F {\\this} X) => g C.\u2218 f\n    | Func-id => {?hidden}\n    | Func-o => {?hidden}\n  })", "completion": "\\new VPresheaf {\n  | F => \\new Functor {\n    | F => \\lam x => Hom x c\n    | Func => \\lam f g => g \u2218 f\n    | Func-id => exts (\\lam _ => id-right)\n    | Func-o => exts (\\lam _ => inv o-assoc)\n  }\n}"}
{"prompt": "['eps : Rat', \"eps' : Rat\", \"eps'<eps : eps' < eps\", 'x : X.E', \"xy<eps' : U {X.dist x y} eps'\", 'X : ExPseudoMetricSpace', 'y : X.E']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '| isCauchy (Set (Set E)) : \\\\Prop', '| dist E E : ExUpperReal', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| at (j : Fin len) : A j', '| E : \\\\Set', '| negative E : E', '| len : Nat', '\\\\lemma halving1/2 \\\\hlevels  {this : ExPseudoMetricSpace} {x y z : E} {c : Rat} (_ : U {dist y x} (c * ratio (pos 1) 2))\\n  (_ : U {dist y z} (c * ratio (pos 1) 2)) : U {dist x z} c ', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma uniform-subset \\\\hlevels  {X : PreuniformSpace} {C D : Set (Set X.E)} (_ : X.isUniform C) (_ : \\\\Pi {U : Set X.E} -> C U -> D U) : X.isUniform D ', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '\\\\lemma makeCauchy \\\\hlevels  {this : PreuniformSpace} {C : Set (Set E)} (_ : isUniform C) : isCauchy C ', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func OBall \\\\hlevels  {X : ExPseudoMetricSpace} (eps : Rat) (x : X.E) : Set X.E => \\\\lam (y : X.E) => U {X.dist x y} eps', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', 'coef C', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\lemma halving \\\\hlevels  {this : ExPseudoMetricSpace} {x y z : E} {a b c : Rat} (_ : U {dist x y} a) (_ : U {dist y z} b) (_ : a + b <= c) :\\n  U {dist x z} c ', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'pos Nat', '\\\\lemma metricUniform \\\\hlevels  {this : ExPseudoMetricSpace} {eps : Rat} (_ : zro < eps) :\\n  isUniform (\\\\lam (U1 : Set E) => TruncP (\\\\Sigma (x : E) (U1 = (\\\\lam (y : E) => U {dist x y} eps)))) ', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '| U Rat : \\\\Prop', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)']<<<break>>>X.isCauchy (\\lam (U : Set X.E) => U y -> U \u2286 OBall {X} eps x)", "completion": "makeCauchy {X}\n  (uniform-subset (metricUniform {_} {(eps - eps') * ratio 1 2} linarith) $ later (\\lam {p0} p1 zy<eps/4 {w} zw<eps/4 => (\\case \\elim p0, \\elim p1, \\elim zy<eps/4, \\elim w, \\elim zw<eps/4 \\with {\n    | _, inP (z, idp), zy<eps/4, w, zw<eps/4 => halving {X} xy<eps' (halving1/2 {X} zy<eps/4 zw<eps/4) linarith\n  })))"}
{"prompt": "['e : Iso', 'q : \\\\new PreuniformLocale (E {e.dom}) {\\n  | <= => (<=) {e.dom}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet => (\u2227) {e.dom}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top => top {e.dom}\\n  | top-univ => {?hidden}\\n  | Join => Join {e.dom}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n  | uniform-overt => {?hidden}\\n  | isUniform => isUniform {e.dom}\\n  | isCovering => {?hidden}\\n  | isDownset => {?hidden}\\n  | top-uniform => {?hidden}\\n  | meet-uniform => {?hidden}\\n  | <=-uniform => {?hidden}\\n  | star-uniform => {?hidden}\\n} = \\\\new PreuniformLocale (E {e.cod}) {\\n  | <= => (<=) {e.cod}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet => (\u2227) {e.cod}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top => top {e.cod}\\n  | top-univ => {?hidden}\\n  | Join => Join {e.cod}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n  | uniform-overt => {?hidden}\\n  | isUniform => isUniform {e.cod}\\n  | isCovering => {?hidden}\\n  | isDownset => {?hidden}\\n  | top-uniform => {?hidden}\\n  | meet-uniform => {?hidden}\\n  | <=-uniform => {?hidden}\\n  | star-uniform => {?hidden}\\n}', 'this : Cat PreuniformLocale {\\n  | Hom => UniformHom\\n  | id => \\\\lam (L : Ob {\\\\this}) => \\\\new UniformHom L L {\\n    | func => \\\\lam (x : L.E) => x\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n    | func-uniform => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new UniformHom X Z {\\n    | func => \\\\lam (x : E {Dom {FrameCat.o {X} {Y} {Z} g f}}) => g.func (f.func x)\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n    | func-uniform => {?hidden}\\n  }\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}']<<<break>>>['| Hom Ob Ob : \\\\Set', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)', '| dom : Ob {C}', '| \\\\infix 4 <= E E : \\\\Prop', '| Cod : BaseSet', '| cod : Ob {C}', '| id (X : Ob) : Hom X X', '| Ob : \\\\hType', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| Dom : BaseSet']<<<break>>>\\Pi {x y : E {Dom {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)}}} ->\n  func {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} x \u2227 func {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} y <= func {transport {Ob {\\this}} (Hom {\\this} e.dom) {e.dom} {e.cod} q (id {\\this} e.dom)} (x \u2227 y)", "completion": "func-meet>= {transport {PreuniformLocale} (\\lam (Cod : PreuniformLocale) => UniformHom e.dom Cod) {e.dom} {e.cod} q\n  (\\new UniformHom e.dom e.dom {\n    | func => \\lam (x : E {e.dom}) => x\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n    | func-uniform => {?hidden}\n  })}"}
{"prompt": "['g : J -> Ob', 'x : C.Ob', 'J : \\\\Set', 'D : Cat', 'z : D.Ob', 'C : SiteWithBasis']<<<break>>>[\"\\\\class MatchingFamily \\\\hlevels  {\\n  | C : SiteWithBasis\\n  | D : Cat\\n  | F : Functor (op {C}) D\\n  | x : Ob {C}\\n  | J : \\\\Set\\n  | g J : Ob\\n  | z : Ob {D}\\n  | family (j : J) : Hom {D} z (Functor.F {vsheafOnSiteWithBasis.MatchingFamily.F} (g j).1)\\n  | isMatching (j j' : J) : Func {vsheafOnSiteWithBasis.MatchingFamily.F} {(g j).1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n    (pbProj1 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) \u2218 family j = Func {vsheafOnSiteWithBasis.MatchingFamily.F} {(g j').1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n    (pbProj2 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) \u2218 family j'\\n}\", '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| Hom Ob Ob : \\\\Set', '| J : \\\\Set', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '\\\\func matchingFamily \\\\hlevels  {C1 : SiteWithBasis} {D : Cat} {F1 : Functor (op {C1}) D} (x1 : C.Ob) {J1 : \\\\Set} (g1 : J1 -> Ob) (z1 : D.Ob)\\n  (h : D.Hom z1 (F.F x1)) : MatchingFamily {C1} {D} {F1} x1 {J1} g1 z1 {\\n  | family => \\\\lam (j : J {\\\\this}) => F.Func {x1} {(g1 j).1} (g1 j).2 D.\u2218 h\\n} => \\\\new MatchingFamily {\\n  | isMatching => {?hidden}\\n}']<<<break>>>\\Pi (h : D.Hom z (F {{?error}} x)) -> MatchingFamily {C} {D} {{?error}} x {J1} g z {\n  | family => \\lam (j : J {\\this}) => Func {{?error}} {x} {(g j).1} (g j).2 D.\u2218 h\n}", "completion": "matchingFamily x g z"}
{"prompt": "['x : Real', 'y : Real', 'y<x+d : y < x + ldist {RealNormed} x y']<<<break>>>['| \\\\infixl 6 + E E : E', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| negative E : E', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| <=-refl {x : E} : x <= x', '\\\\lemma negative_- \\\\hlevels  {this : AddGroup} {x y : E} : negative (x - y) = y - x ', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '| <-irreflexive {x : E} : Not (x < x)', '| zro-right {x : E} : x + zro = x', '| \\\\infix 4 < E E : \\\\Prop', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '| zro : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func RealNormedAbGroup \\\\hlevels  : NormedAbGroup Real {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', '| negative-left {x : E} : negative x + x = zro', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| +-comm {x y : E} : x + y = y + x', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\lemma join/=right \\\\hlevels  {A : LinearOrder} {j : JoinSemilattice A.E {\\n  | <= => (<=)\\n}} {a b : A.E} (_ : b /= a \u2228 b) : a \u2228 b = a ', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>x - y \u2228 negative (x - y) = x - y", "completion": "join/=right {RealAbGroup} (\\lam p => <-irreflexive $ (rewriteI p in y<x+d) <\u2218l transportInv (\\lam _x => _x <= _)\n  (pmap ((+) x) (negative_- {RealAbGroup}) *> +-comm *> +-assoc *> pmap ((+) y) negative-left *> zro-right) <=-refl)"}
{"prompt": "['p : u = v', 'X : \\\\Set', 'v : Partial X', 'u : Partial X']<<<break>>>['\\\\class Partial \\\\hlevels  {\\n  | E : \\\\Set\\n  | isDefined : \\\\Prop\\n  | value isDefined : E\\n}', '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| isDefined : \\\\Prop', '\\\\lemma <->_= \\\\plevels  \\\\hlevels  {P Q : \\\\Prop} : (P <-> Q) <-> P = Q ']<<<break>>>u.isDefined <-> v.isDefined", "completion": "<->_=.2 (pmap (\\lam p0 => isDefined {p0}) p)"}
{"prompt": "['n : Nat', 'a : A.E', \"l'' : List (\\\\Sigma A.E Nat)\", \"p' : (\\\\case z :: l'' \\\\with {\\n  | nil => (y, 1) :: nil {\\\\Sigma A.E Nat}\\n  | (a', n) :: l' => \\\\case A.decideEq y a' \\\\with {\\n    | yes p => (a', suc n) :: l'\\n    | no n1 => (y, 1) :: (a', n) :: l'\\n  }\\n}) = (a, n) :: l'\", 'z : \\\\Sigma A.E Nat', 'A : DecSet', \"l' : List (\\\\Sigma A.E Nat)\", 'y : A.E']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', 'suc Nat', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', 'yes E', 'no (Not E)', '\\\\func headDef {A : \\\\Type} (_ : A) (_ : List A) : A \\n  | {A}, x, nil => x\\n  | {A}, x, a :: l => a', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>y = a", "completion": "\\case A.decideEq y z.1 \\as d : case_return_arg_1_1, p' \\as arg1 : case_additional_arg_1 \\return y = a \\with {\n  | yes e, p'' => e *> pmap (\\lam s => (headDef (a, n) s).1) p''\n  | no q, p'' => pmap (\\lam s => (headDef (a, n) s).1) p''\n}"}
{"prompt": "['j : Fin (len {map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (u V.+ s.1, B.bottom)) l})', 'v : V.E', 'V : PosetQModule', 'b : B.E', 'u : V.E', 'l : PFunc {V} {B}', 'B : BooleanRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', 'byRight B', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| zro : E', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| bottom : E', '| E : \\\\Set', '| bottom-univ {x : E} : bottom <= x']<<<break>>>((map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (u V.+ s.1, B.bottom)) l !! j).1 = V.zro) || (map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (u V.+ s.1, B.bottom)) l !! j).2 B.<= BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2)\n  (map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (u V.+ v V.+ s.1, b B.* s.2)) l))", "completion": "byRight bottom-univ"}
{"prompt": "['n : Nat', 'c : R.E', 'R : Ring', 'a : R.E']<<<break>>>['| M : \\\\Set', '| interpret {n : Nat} (Fin n -> M) (Term n) : M', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| interpretNF {n : Nat} (Fin n -> M) (NF n) : M', ':zro', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', 'var (Fin n)', '\\\\infixl 7 :* (_ _ : Term C n)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '\\\\lemma terms-equality \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s)) :\\n  interpret {env.len} env.at t = interpret {env.len} env.at s ', '| normalize {n : Nat} (Term n) : NF n', '| E : \\\\Set', '\\\\infixl 6 :+ (_ _ : Term C n)', '\\\\func SemiringSolverModel \\\\hlevels  (R : Semiring) : SolverModel R.E {\\n  | Term => Term Nat\\n  | NF => SemiringSolverModel.NF Nat\\n  | normalize => \\\\lam {n : Nat} => normalize {n} {NatSemiring} {NatSemiring}\\n  | interpret => \\\\lam {n : Nat} (env1 : Fin n -> M {\\\\this}) => interpret {SemiringData {R} (\\\\new Array (M {\\\\this}) n env1)}\\n  | interpretNF => \\\\lam {n : Nat} (env : Fin n -> M {\\\\this}) => interpretNF {SemiringData {R} (\\\\new Array (M {\\\\this}) n env)}\\n} => \\\\new SolverModel {\\n  | interpretNF-consistent => {?hidden}\\n}', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>interpret {3} (at {c :: pow {R} a n :: a :: nil}) (var {Nat} {3} 0 :* var {Nat} {3} 1 :* var {Nat} {3} 2 :+ :zro {Nat} {3}) = interpret {3} (at {c :: pow {R} a n :: a :: nil}) (var {Nat} {3} 0 :* (var {Nat} {3} 1 :* var {Nat} {3} 2))", "completion": "terms-equality\n  {SemiringSolverModel R} (c :: pow {R} a n :: a :: nil) (var 0 :* var 1 :* var 2 :+ :zro) (var 0 :* (var 1 :* var 2)) idp"}
{"prompt": "[]<<<break>>>['true', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true']<<<break>>>\\Sigma (true = true) (true = true)", "completion": "(idp, idp)"}
{"prompt": "[]<<<break>>>['| zro : E', '\\\\lemma norm_dist \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : X.norm x = X.dist X.zro x ', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| dist E E : ExUpperReal', '| E : \\\\Set', '| norm E : ExUpperReal', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>\\Pi {x : E} -> norm x = dist zro x", "completion": "norm_dist {RealNormed}"}
{"prompt": "['this : Data', 'm : List (Fin (len {env}))', 'a : \\\\Sigma (List (Fin (len {env}))) (E {C})']<<<break>>>['| len : Nat', '| env : Array (E {R})', '\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance LexicographicalList \\\\hlevels  (A : LinearOrder.Dec) : LinearOrder.Dec (List A.E) {\\n  | < => (<L)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case LinearOrder.Dec.trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y}\\n      (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => LexicographicalList.trichotomy {A}\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>Dec (m = a.1)", "completion": "decideEq m a.1"}
{"prompt": "['A : StoneC*PseudoAlgebra', 's : \\\\Sigma (y : A.E) (A.norm y <= ide)', 'this : StoneC*Algebra (\\\\Sigma Real A.E) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | cauchy-open => {?hidden}\\n  | isUniform => isUniform\\n  | uniform-cauchy => {?hidden}\\n  | dist => ExPseudoNormedAbGroup.dist\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro => (zro, zro)\\n  | + => \\\\lam (s : E) (t : E) => (s.1 AddMonoid.+ t.1, s.2 AddMonoid.+ t.2)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => \\\\lam (p0 : E) => (negative p0.1, negative p0.2)\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm => UnitC*Algebra.norm {A}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | norm-double => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isComplete => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | * => \\\\lam (p0 : E) (p1 : E) => (p0.1 Semigroup.* p1.1, p0.1 *c p1.2 AddMonoid.+ p1.1 *c p0.2 AddMonoid.+ p0.2 Semigroup.* p1.2)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | norm_*_<= => {?hidden}\\n  | ide => (ide, zro)\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl {UnitAlgebra RealField (toRealAlgebra {A})}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | c*-sum => {?hidden}\\n  | c*-square => {?hidden}\\n  | norm_ide_<= => {?hidden}\\n}', 'a : E {\\\\this}']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| norm_*_<= {x y : E} : norm (x Semigroup.* y) <= norm x ExUpperReal.* norm y', '\\\\infixl 7 *r \\\\hlevels  {this : RealBanachSpace} (r : Real) (a : E) : E => func {lift} (r, a)', '| norm E : ExUpperReal']<<<break>>>A.norm (((a Semigroup.* a).1 *r s.1 A.+ (a Semigroup.* a).2 A.* s.1) A.* s.1) <= A.norm ((a Semigroup.* a).1 *r s.1 A.+ (a Semigroup.* a).2 A.* s.1) ExUpperReal.* A.norm s.1", "completion": "norm_*_<= {A}"}
{"prompt": "['k : Nat', 'p : \\\\new Array E k (f {e}) = \\\\new Array E k (\\\\lam (j : Fin k) => j)', 'e : E']<<<break>>>['\\\\type Sym \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => Equiv {Fin n} {Fin n}', '\\\\lemma equals \\\\plevels  \\\\hlevels  {n : Nat} {x y : Sym n} (_ : \\\\Pi (j : Fin n) -> f {x} j = f {y} j) : x = y ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| f A : B', '| ide : E', '| at (j : Fin len) : A j', '\\\\instance SymmetricGroup \\\\hlevels  (n : Nat) : Group (Sym n) {\\n  | ide => idEquiv {Fin n}\\n  | * => transEquiv {Fin n} {Fin n} {Fin n}\\n  | inverse => \\\\lam (e : E {\\\\this}) => symQEquiv {Fin n} {Fin n} (fromEquiv e)\\n} => \\\\new Group {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | inverse-right => {?hidden}\\n}']<<<break>>>e = ide", "completion": "equals (\\lam j i => p i j)"}
{"prompt": "['g : G.E', 'P : PigeonholeSet G.E', 'G : Group']<<<break>>>['| \\\\infix 4 > E E : \\\\Prop', '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| E : \\\\Set', '\\\\lemma hasFiniteOrder \\\\hlevels  {G : Group} {P : PigeonholeSet G.E} (g : G.E) : TruncP (\\\\Sigma (n : Nat) (n > 0) (pow {G} g n = G.ide)) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>TruncP (\\Sigma (n : Nat) ((\\lam (n0 : Nat) => \\Sigma (n0 > 0) (pow {G} g n0 = G.ide)) n))", "completion": "map (hasFiniteOrder g) (\\lam t => (t.1, (t.2, t.3)))"}
{"prompt": "['x : Total {X.E} S', 'W : Set R.E', 'Wo : R.isOpen W', 'a : X.E', 'S : Set X.E', 'X : TopLModule R', 'R : NearSkewField', 'So : X.isOpen S']<<<break>>>['| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)', '| +-cont : ContMap (ProductTopSpace \\\\this \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 + s.2\\n}', '\\\\func tuple \\\\hlevels  {X Y Z : TopSpace} (f : ContMap X Y) (g : ContMap X Z) : ContMap X (Y \u2a2f Z) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, g.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\instance TopSpaceHasProduct \\\\hlevels  : HasProduct TopSpace {\\n  | Product => ProductTopSpace\\n} => \\\\new HasProduct', '| func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : TopSpace} (g : ContMap Y Z) (f : ContMap X Y) : ContMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\func id \\\\hlevels  {X : TopSpace} : ContMap X X {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| isOpen (Set E) : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| *c-cont : ContMap (ProductTopSpace R \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 *c s.2\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func const \\\\hlevels  {Y X : TopSpace} (x : X.E) : ContMap Y X {\\n  | func => \\\\lam (_ : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}']<<<break>>>R.isOpen (W \u2227 (\\lam (x1 : R.E) =>\n  S (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1)))", "completion": "open-inter Wo (func-cont {+-cont \u2218 tuple (const x.1) (*c-cont \u2218 tuple id (const a))} So)"}
{"prompt": "['P : \\\\Prop', 'f : FramePresHom P (F L)', 'L : Locale', 'x : P.E']<<<break>>>['| meet-left {x y : E} : x \u2227 y <= x', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '| top : E', '| \\\\infix 4 <= E E : \\\\Prop', '| func (E {Dom}) : E {Cod}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>P -> f.func x L.\u2227 L.top L.<= L.Join {P} (\\lam (_ : P) => f.func x)", "completion": "\\lam q => meet-left <=\u2218 Join-cond q"}
{"prompt": "['s : \\\\Sigma (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (Q = C.val product P product D.val)', 'R : Ring', 'n : Nat', 't : \\\\Sigma (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (S = C.val product Q product D.val)']<<<break>>>['| \\\\infixl 7 * E E : E', '| val : E {M}', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\instance MatrixRing \\\\hlevels  (R : Ring) (n : Nat) : Ring (Matrix R.E n n) {\\n  | zro => \\\\new Array (Array R.E n) n (\\\\lam (_ : Fin n) => \\\\new Array R.E n (\\\\lam (_ : Fin n) => R.zro))\\n  | + => \\\\lam (M : E) (N : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => at {at {M} i} j R.+ at {at {N} i} j)\\n  | * => (product)\\n  | negative => \\\\lam (M : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => R.negative (at {at {M} i} j))\\n  | ide => ide {R} {n}\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\lemma product \\\\hlevels  {M : Monoid} (i j : Inv {M}) : Inv {M} (i.val M.* j.val) ']<<<break>>>Inv {MatrixRing R n} (val {t.1} * val {s.1})", "completion": "product t.1 s.1"}
{"prompt": "['this : Locale', 'a : E', 'this : Nucleus ((-->) a) {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}']<<<break>>>['| <=-refl {x : E} : x <= x', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma meet-assoc \\\\hlevels  {this : MeetSemilattice} {x y z : E} : x \u2227 y \u2227 z = x \u2227 (y \u2227 z) ', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma meet-idemp \\\\hlevels  {this : MeetSemilattice} {x : E} : x \u2227 x = x ', '\\\\lemma eval \\\\hlevels  {this : Locale} {x y : E} : (x --> y) \u2227 x <= y ', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '\\\\lemma exponent \\\\hlevels  {this : Locale} {x y z : E} : x \u2227 y <= z <-> x <= y --> z ', '\\\\func \\\\infixr 5 --> \\\\hlevels  {this : Locale} (x y : E) : E => SJoin (\\\\lam (p0 : E) => p0 \u2227 x <= y)', '| E : \\\\Set', '| L : Locale', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>\\Pi {x : E {L {\\this}}} -> a --> a --> x <= a --> x", "completion": "\\lam {x} => (exponent {this}).1\n  (transport (\\lam p0 => _ \u2227 {this} p0 <= {this} _) (meet-idemp {this}) (transport (\\lam _x => _x <= {this} _) (meet-assoc {this})\n    (meet-monotone {this} (eval {this}) (<=-refl {this}) <=\u2218 {this} eval {this})))"}
{"prompt": "['pm : isMonic {R} p', 'Ip : I.contains p', 'R : CRing', 'p : Poly R', 'I : Ideal (PolyAlgebra R)']<<<break>>>['\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', 'inP A', '| Cod : BaseSet', 'padd (Poly R) R.E', '\\\\lemma fequiv0 \\\\hlevels  {I : Ideal} {a : E {I.S}} (_ : I.contains a) : inF {I} a = inF {I} (zro {I.S}) ', '\\\\func factorHom \\\\hlevels  {I : Ideal} : RingHom I.S (FactorRing I) {\\n  | func => inF {I}\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\instance CRingCat : Cat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {RingCat} {CRing} (\\\\new Embedding {CRing} {Ob} (\\\\lam (R : A {\\\\this}) => R) {\\n  | isEmb => \\\\lam (R S : A {\\\\this}) =>\\n  \\\\new Retraction {R = S} {f {\\\\this} R = f {\\\\this} S} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {R} {S}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new CRing (E {p @ i}) {\\n      | zro => zro {p @ i}\\n      | + => (+) {p @ i}\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*) {p @ i}\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | negative => negative {p @ i}\\n      | negative-left => {?hidden}\\n      | ide => ide {p @ i}\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef {p @ i}\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n    })\\n    | f_sec => idpe {R = S}\\n  }\\n})', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\type Type \\\\hlevels  (I : Ideal) : \\\\Set => Quotient {E {I.S}} (\\\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b))', '| E : \\\\Set', '| contains (E {S}) : \\\\Prop', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", 'in~ A', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\instance PolyAlgebra \\\\hlevels  (R1 : CRing) : CAlgebra R1 (Poly R1) {\\n  | zro => pzero {R1}\\n  | + => (+)\\n  | negative => negative {R1}\\n  | *c => (*c)\\n  | * => (*)\\n  | ide => padd {R1} (pzero {R1}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R1} (pzero {R1}) (R.natCoef n)\\n  | coefMap => coefMap-impl\\n} => \\\\new CAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| ide : E', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\func isMonic \\\\hlevels  {R : Ring} (p : Poly R) : \\\\Prop => TruncP (\\\\Sigma (n : Nat) (degree<= {R} p n) (polyCoef {R} p n = R.ide))', '\\\\func polyEval \\\\hlevels  {R3 : Ring} (_ : Poly R3) (_ : R.E) : R.E \\n  | {R}, pzero, a => R.zro\\n  | {R}, padd p e, a => polyEval {R} p a R.* a R.+ e\\n  | {R}, peq i, a => (R.zro-right {R.zro R.* a} *> R.zro_*-left {a}) @ i', '\\\\lemma factorHom_polyMapEval \\\\hlevels  {R : CRing} {I : Ideal (PolyAlgebra R)} {p : Poly R} : polyMapEval {R} {FactorRing I} (factorHom {I} \u2218 polyHom {R}) p\\n  (in~ {E {I.S}} {\\\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b)} (padd {R} ide R.zro)) = in~ {E {I.S}} {\\\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b)} p ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func polyHom \\\\hlevels  {R : Ring} : RingHom R (PolyRing R) {\\n  | func => padd {R} (pzero {R})\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '| zro : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '\\\\instance FactorRing \\\\hlevels  (I1 : Ideal) : CRing (Type I1) {\\n  | zro => inF {I1} (zro {I.S})\\n  | + => (FactorRing.+)\\n  | * => (FactorRing.*)\\n  | negative => FactorRing.negative {I1}\\n  | ide => inF {I1} (ide {I.S})\\n  | natCoef => \\\\lam (n : Nat) => inF {I1} (natCoef {I.S} n)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func polyMap \\\\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \\n  | f, pzero => pzero {f.Cod}\\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\\n  | f, peq i => transportInv\\n    {E {f.Cod}} (\\\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\\n      f.func-zro (path (peq {f.Cod})) @ i', '| S : BaseSet', '| Dom : BaseSet']<<<break>>>TruncP (\\Sigma (p : Poly (Dom {factorHom {I} \u2218 polyHom {R}})) (isMonic {Dom {factorHom {I} \u2218 polyHom {R}}} p)\n  (polyEval {Cod {factorHom {I} \u2218 polyHom {R}}} (polyMap (factorHom {I} \u2218 polyHom {R}) p)\n    ((in~ {E {I.S}} {\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b)} (padd {R} ide R.zro) :: nil) !! 0) = zro {Cod {factorHom {I} \u2218 polyHom {R}}}))", "completion": "inP (p, pm, later $ factorHom_polyMapEval *> fequiv0 Ip)"}
{"prompt": "['S : DecSet']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\lemma equivMulLeft \\\\hlevels  {S : \\\\Set} {a b c : E} (_ : a ~ b) : c * a ~ c * b ', '\\\\func inv \\\\hlevels  {S2 : \\\\Set} (_ : E) : E \\n  | {S}, nil => nil {\\\\Sigma S Bool}\\n  | {S}, (x, deg) :: l => inv {S} l ++ (x, not deg) :: nil {\\\\Sigma S Bool}', '\\\\func AreAdjacent \\\\hlevels  {S : \\\\Set} (w_1 w_2 : E) : \\\\Prop => TruncP (\\\\Sigma (u_1 u_2 : E) (x : S) (p : Bool)\\n  (\\\\Sigma (w_1 = u_1 * u_2) (w_2 = u_1 * ((x, p) :: nil {\\\\Sigma S Bool}) * ((x, not p) :: nil {\\\\Sigma S Bool}) * u_2)))', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'crefl (x = y)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", 'nil', '\\\\lemma #-symmetric \\\\hlevels  {this : DecSet} {x : E} {y : E} (x/=y : x # y) : y # x => /=-sym {E} {x} {y} x/=y', '~-equiv (x y : A) (R x y) I', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '| \\\\infixl 7 * E E : E', '\\\\func reduceHom \\\\hlevels  {S2 : DecSet} (_ : E) : List (\\\\Sigma S.E Bool) \\n  | {S}, in~ a => reduce {S} a\\n  | {S}, ~-equiv x y r i => reduce_equivWords {S} {x} {y} r @ i', 'yes E', 'no (Not E)', '\\\\class Dec \\\\extends Group, DecSet \\\\hlevels ', '\\\\func # \\\\hlevels  {this : DecSet} (x : E) (y : E) : \\\\Prop => x /= y', '\\\\func # \\\\hlevels  {this : DecSet} (x : E) (y : E) : \\\\Prop => x /= y', '\\\\func reduce \\\\hlevels  {S2 : DecSet} (_ : List (\\\\Sigma S.E Bool)) : List (\\\\Sigma S.E Bool) \\n  | {S}, nil => nil {\\\\Sigma S.E Bool}\\n  | {S}, (xa, xb) :: xs => \\\\case reduce {S} xs \\\\with {\\n    | nil => (xa, xb) :: nil {\\\\Sigma S.E Bool}\\n    | (ya, yb) :: ys => \\\\case S.decideEq xa ya, xb xor yb \\\\with {\\n      | yes e, true => ys\\n      | d, b => (xa, xb) :: (ya, yb) :: ys\\n    }\\n  }', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '\\\\instance FreeGroup \\\\hlevels  (S : \\\\Set) : Group (Quotient {List (\\\\Sigma S Bool)} (~)) {\\n  | ide => in~ {List (\\\\Sigma S Bool)} {(~)} (nil {\\\\Sigma S Bool})\\n  | * => \\\\lam (a : E {\\\\this}) (b : E {\\\\this}) => (\\\\case a, b \\\\with {\\n    | in~ a, in~ b => in~ {List (\\\\Sigma S Bool)} {(~)} (a * b)\\n    | in~ a, ~-equiv x y r i => ~-equiv {List (\\\\Sigma S Bool)} {(~)} (a * x) (a * y) (equivMulLeft {S} {x} {y} {a} r) i\\n    | ~-equiv x y r i, in~ a => ~-equiv {List (\\\\Sigma S Bool)} {(~)} (x * a) (y * a) (equivMulRight {S} {x} {y} {a} r) i\\n  })\\n  | inverse => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | in~ a => in~ {List (\\\\Sigma S Bool)} {(~)} (inv {S} a)\\n    | ~-equiv x y r i => ~-equiv {List (\\\\Sigma S Bool)} {(~)} (inv {S} x) (inv {S} y) (equiv_inv {S} {x} {y} r) i\\n  })\\n} => \\\\new Group {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | inverse-right => {?hidden}\\n}', '\\\\lemma equiv_inv \\\\hlevels  {S : \\\\Set} {a b : E} (_ : a ~ b) : inv {S} a ~ inv {S} b ', '\\\\data Closure {A : \\\\Type} (A -> A -> \\\\Type) (_ _ : A) : \\\\Prop \\n  | cin (R x y)\\n  | crefl (x = y)\\n  | csym (Closure {A} R y x)\\n  | ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', '\\\\lemma #-comparison \\\\hlevels  {this : DecSet} (x : E) (y : E) (z : E) (x/=z : x # z) : x # y || y # z => \\\\case decideEq x y \\\\with {\\n  | yes x=y => byRight {x # y} {y # z} (\\\\lam (y=z : y = z) => x/=z (x=y *> y=z))\\n  | no x/=y => byLeft {x # y} {y # z} x/=y\\n}', 'in~ A', '| ide-right {x : E} : x * ide = x', '| inverse-right {x : E} : x * inverse x = ide', '| ide-left {x : E} : ide * x = x', 'csym (Closure {A} R y x)', '\\\\func reduce_equiv \\\\hlevels  {S3 : DecSet} (x1 : List (\\\\Sigma S.E Bool)) : x1 ~ reduce {S3} x1 \\n  | {S}, nil => crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool}} {reduce {S} (nil {\\\\Sigma S.E Bool})}\\n    (idp {List (\\\\Sigma S.E Bool)} {nil {\\\\Sigma S.E Bool}})\\n  | {S}, a :: nil =>\\n  crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: nil {\\\\Sigma S.E Bool}} {reduce {S} (a :: nil {\\\\Sigma S.E Bool})}\\n    (idp {List (\\\\Sigma S.E Bool)} {a :: nil {\\\\Sigma S.E Bool}})\\n  | {S}, a :: a1 :: x => \\\\case reduce {S} x, idp {List (\\\\Sigma S.E Bool)} {reduce {S} x} \\\\with {\\n    | nil, p => \\\\case S.decideEq a.1 a1.1, idp {Dec (a.1 = a1.1)} {S.decideEq a.1 a1.1} \\\\with {\\n      | yes e, p1 => \\\\case a.2 xor a1.2, idp {Bool} {a.2 xor a1.2} \\\\with {\\n        | false, p2 => transport {List (\\\\Sigma S.E Bool)} (\\\\lam (x1 : List (\\\\Sigma S.E Bool)) => a :: a1 :: x ~ a :: a1 :: x1) {reduce {S} x}\\n          {nil {\\\\Sigma S.E Bool}} p\\n          (adjacent_cons {S.E} {a1 :: x} {a1 :: reduce {S} x} a (adjacent_cons {S.E} {x} {reduce {S} x} a1 (reduce_equiv {S} x)))\\n        | true, p2 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n          | yes e, true => nil {\\\\Sigma S.E Bool}\\n          | d, b => (a.1, a.2) :: (a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}\\n        }} (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n          | yes e, true => nil {\\\\Sigma S.E Bool}\\n          | d, b => (a.1, a.2) :: (a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}\\n        }} {a :: a1 :: x} {x} (csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n          | yes e, true => nil {\\\\Sigma S.E Bool}\\n          | d, b => (a.1, a.2) :: (a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}\\n        }} {x} (transport {List (\\\\Sigma S.E Bool)} ((~) x) {reduce {S} x} {nil {\\\\Sigma S.E Bool}} p (reduce_equiv {S} x)))\\n          (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {x} {a :: a1 :: x} (inP {\\\\Sigma (u_1 u_2 : E) (x1 : S.E) (p : Bool)\\n            (\\\\Sigma (x = u_1 * u_2) (a :: a1 :: x = u_1 * ((x1, p) :: nil {\\\\Sigma S.E Bool}) * ((x1, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n            (nil {\\\\Sigma S.E Bool}, x, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {x}, transportInv {S.E} (\\\\lam (x1 : S.E) =>\\n              a :: a1 :: x = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x1, not a.2) :: nil {\\\\Sigma S.E Bool}) * x)\\n              {a.1} {a1.1} e (transportInv {Bool} (\\\\lam (x1 : Bool) =>\\n                a :: a1 :: x = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a1.1, x1) :: nil {\\\\Sigma S.E Bool}) * x)\\n                {not a.2} {a1.2} (helper1 {a.2} {a1.2} p2) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: x})))))))\\n      }\\n      | no n, p1 => transport {List (\\\\Sigma S.E Bool)} (\\\\lam (x1 : List (\\\\Sigma S.E Bool)) => a :: a1 :: x ~ a :: a1 :: x1) {reduce {S} x}\\n        {nil {\\\\Sigma S.E Bool}} p\\n        (adjacent_cons {S.E} {a1 :: x} {a1 :: reduce {S} x} a (adjacent_cons {S.E} {x} {reduce {S} x} a1 (reduce_equiv {S} x)))\\n    }\\n    | a2 :: x1, p => \\n      \\\\have A0 => transport {List (\\\\Sigma S.E Bool)} (\\\\lam (x1 : List (\\\\Sigma S.E Bool)) => a :: a1 :: x ~ a :: a1 :: x1) {reduce {S} x} {a2 :: x1} p\\n              (adjacent_cons {S.E} {a1 :: x} {a1 :: reduce {S} x} a (adjacent_cons {S.E} {x} {reduce {S} x} a1 (reduce_equiv {S} x)))\\n      \\\\in \\\\case S.decideEq a.1 a1.1, idp {Dec (a.1 = a1.1)} {S.decideEq a.1 a1.1} \\\\with {\\n            | yes e, p1 => \\\\case S.decideEq a1.1 a2.1, idp {Dec (a1.1 = a2.1)} {S.decideEq a1.1 a2.1} \\\\with {\\n              | yes e1, p2 => \\\\case a1.2 xor a2.2, idp {Bool} {a1.2 xor a2.2} \\\\with {\\n                | false, p3 => transportInv {Dec (a.1 = a1.1)} (\\\\lam (x2 : Dec (a.1 = a1.1)) => a :: a1 :: x ~ (\\\\case x2, a.2 xor a1.2 \\\\with {\\n                  | yes e, true => (a2.1, a2.2) :: x1\\n                  | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                })) {S.decideEq a.1 a1.1} {yes {a.1 = a1.1} e} p1 (\\\\case a.2 xor a1.2, idp {Bool} {a.2 xor a1.2} \\\\with {\\n                  | false, p4 => A0\\n                  | true, p4 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} {a :: a1 :: x} {x} (csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} {x} (transport {List (\\\\Sigma S.E Bool)} ((~) x) {reduce {S} x} {a2 :: x1} p (reduce_equiv {S} x)))\\n                    (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {x} {a :: a1 :: x} (inP {\\\\Sigma (u_1 u_2 : E) (x1 : S.E) (p : Bool)\\n                      (\\\\Sigma (x = u_1 * u_2) (a :: a1 :: x = u_1 * ((x1, p) :: nil {\\\\Sigma S.E Bool}) * ((x1, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                      (nil {\\\\Sigma S.E Bool}, x, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {x}, transportInv {S.E} (\\\\lam (x1 : S.E) =>\\n                        a :: a1 :: x = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x1, not a.2) :: nil {\\\\Sigma S.E Bool}) * x)\\n                        {a.1} {a1.1} e (transportInv {Bool} (\\\\lam (x1 : Bool) =>\\n                          a :: a1 :: x = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a1.1, x1) :: nil {\\\\Sigma S.E Bool}) * x)\\n                          {not a.2} {a1.2} (helper1 {a.2} {a1.2} p4) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: x})))))))\\n                })\\n                | true, p3 => ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case \\\\case yes {a1.1 = a2.1} e1, true \\\\with {\\n                  | yes e, true => x1\\n                  | d, b => (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                } \\\\with {\\n                  | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                  | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                    | yes e, true => ys\\n                    | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                  }\\n                }} {a :: a1 :: a2 :: x1} A0 (\\\\case x1, idp {List (\\\\Sigma S.E Bool)} {x1} \\\\with {\\n                  | nil, p4 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                    | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                    | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                      | yes e, true => ys\\n                      | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                    }\\n                  }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                    | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                    | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                      | yes e, true => ys\\n                      | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                    }\\n                  }} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}}\\n                    (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                      | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                      | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                        | yes e, true => ys\\n                        | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                      }\\n                    }) = u_1 * u_2)\\n                      (a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                      (a :: nil {\\\\Sigma S.E Bool}, nil {\\\\Sigma S.E Bool}, a1.1, a1.2,\\n                        (idp {List (\\\\Sigma S.E Bool)} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                          | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                          | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                            | yes e, true => ys\\n                            | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                          }\\n                        }},\\n                          transportInv {S.E}\\n                            (\\\\lam (x : S.E) => a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * nil {\\\\Sigma S.E Bool})\\n                            {a1.1} {a2.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                              a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * nil {\\\\Sigma S.E Bool})\\n                              {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}}))))))\\n                  | a3 :: x2, p4 => \\\\case S.decideEq a.1 a3.1, idp {Dec (a.1 = a3.1)} {S.decideEq a.1 a3.1} \\\\with {\\n                    | yes e2, p5 => \\\\case a.2 xor a3.2, idp {Bool} {a.2 xor a3.2} \\\\with {\\n                      | false, p6 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case yes {a.1 = a3.1} e2, false \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a3.1} e2, false \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} {a :: a1 :: a2 :: a3 :: x2}\\n                        (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case yes {a.1 = a3.1} e2, false \\\\with {\\n                          | yes e, true => x2\\n                          | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                        }) = u_1 * u_2)\\n                          (a :: a1 :: a2 :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                          (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2, (idp {List (\\\\Sigma S.E Bool)} {\\\\case yes {a.1 = a3.1} e2, false \\\\with {\\n                            | yes e, true => x2\\n                            | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                          }},\\n                            transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: a3 :: x2}))))))\\n                      | true, p6 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case yes {a.1 = a3.1} e2, true \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool} * x2}\\n                        {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)}\\n                        {a :: a3 :: x2} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool} * x2} {a :: a3 :: x2}\\n                          (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma (nil {\\\\Sigma S.E Bool} * x2 = u_1 * u_2)\\n                            (a :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                            (nil {\\\\Sigma S.E Bool}, x2, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {nil {\\\\Sigma S.E Bool} * x2}, transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a3 :: x2 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a.2) :: nil {\\\\Sigma S.E Bool}) * x2)\\n                              {a.1} {a3.1} e2 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a3 :: x2 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a3.1, x) :: nil {\\\\Sigma S.E Bool}) * x2)\\n                                {not a.2} {a3.2} (helper1 {a.2} {a3.2} p6) (idp {List (\\\\Sigma S.E Bool)} {a :: a3 :: x2}))))))\\n                        (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a3 :: x2}\\n                          {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)}\\n                          (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma (a :: a3 :: x2 = u_1 * u_2)\\n                            ((a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                            (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2, (idp {List (\\\\Sigma S.E Bool)} {a :: a3 :: x2}, transportInv {S.E}\\n                              (\\\\lam (x : S.E) => (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)}\\n                                  {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)})))))))\\n                    }\\n                    | no n, p5 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case no {a.1 = a3.1} n, a.2 xor a3.2 \\\\with {\\n                      | yes e, true => x2\\n                      | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                    }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case no {a.1 = a3.1} n, a.2 xor a3.2 \\\\with {\\n                      | yes e, true => x2\\n                      | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                    }} {a :: a1 :: a2 :: a3 :: x2}\\n                      (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case no {a.1 = a3.1} n, a.2 xor a3.2 \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }) = u_1 * u_2)\\n                        (a :: a1 :: a2 :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                        (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2,\\n                          (idp {List (\\\\Sigma S.E Bool)} {\\\\case no {a.1 = a3.1} n, a.2 xor a3.2 \\\\with {\\n                            | yes e, true => x2\\n                            | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                          }},\\n                            transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: a3 :: x2}))))))\\n                  }\\n                })\\n              }\\n              | no n, p2 => transportInv {Dec (a.1 = a1.1)} (\\\\lam (x2 : Dec (a.1 = a1.1)) => a :: a1 :: x ~ (\\\\case x2, a.2 xor a1.2 \\\\with {\\n                | yes e, true => (a2.1, a2.2) :: x1\\n                | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n              })) {S.decideEq a.1 a1.1} {yes {a.1 = a1.1} e} p1\\n                (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case yes {a.1 = a1.1} e, a.2 xor a1.2 \\\\with {\\n                  | yes e, true => (a2.1, a2.2) :: x1\\n                  | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                }} {a :: a1 :: a2 :: x1} A0 (\\\\case a.2 xor a1.2, idp {Bool} {a.2 xor a1.2} \\\\with {\\n                  | false, p3 => crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: x1} {\\\\case yes {a.1 = a1.1} e, false \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: x1})\\n                  | true, p3 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: x1} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} {a :: a1 :: a2 :: x1}\\n                    (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                      | yes e, true => (a2.1, a2.2) :: x1\\n                      | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                    }) = u_1 * u_2)\\n                      (a :: a1 :: a2 :: x1 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                      (nil {\\\\Sigma S.E Bool}, a2 :: x1, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                        | yes e, true => (a2.1, a2.2) :: x1\\n                        | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                      }},\\n                        transportInv {S.E}\\n                          (\\\\lam (x : S.E) => a :: a1 :: a2 :: x1 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a.2) :: nil {\\\\Sigma S.E Bool}) * (a2 :: x1))\\n                          {a.1} {a1.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                            a :: a1 :: a2 :: x1 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a1.1, x) :: nil {\\\\Sigma S.E Bool}) * (a2 :: x1))\\n                            {not a.2} {a1.2} (helper1 {a.2} {a1.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: x1}))))))\\n                }))\\n            }\\n            | no n, p1 => ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case \\\\case S.decideEq a1.1 a2.1, a1.2 xor a2.2 \\\\with {\\n              | yes e, true => x1\\n              | d, b => (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n            } \\\\with {\\n              | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n              | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                | yes e, true => ys\\n                | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n              }\\n            }} {a :: a1 :: a2 :: x1} A0 (\\\\case S.decideEq a1.1 a2.1, idp {Dec (a1.1 = a2.1)} {S.decideEq a1.1 a2.1} \\\\with {\\n              | yes e, p2 => \\\\case a1.2 xor a2.2, idp {Bool} {a1.2 xor a2.2} \\\\with {\\n                | false, p3 => transportInv {Dec (a.1 = a1.1)} (\\\\lam (x : Dec (a.1 = a1.1)) =>\\n                  Closure {List (\\\\Sigma S.E Bool)} (AreAdjacent {S.E}) (a :: a1 :: a2 :: x1) (\\\\case x, a.2 xor a1.2 \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  })) {S.decideEq a.1 a1.1} {no {a.1 = a1.1} n} p1\\n                    (crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: x1} {\\\\case no {a.1 = a1.1} n, a.2 xor a1.2 \\\\with {\\n                      | yes e, true => (a2.1, a2.2) :: x1\\n                      | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                    }} (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: x1}))\\n                | true, p3 => \\\\case x1, idp {List (\\\\Sigma S.E Bool)} {x1} \\\\with {\\n                  | nil, p4 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                    | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                    | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                      | yes e, true => ys\\n                      | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                    }\\n                  }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                    | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                    | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                      | yes e, true => ys\\n                      | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                    }\\n                  }} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}}\\n                    (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                      | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                      | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                        | yes e, true => ys\\n                        | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                      }\\n                    }) = u_1 * u_2)\\n                      (a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                      (a :: nil {\\\\Sigma S.E Bool}, nil {\\\\Sigma S.E Bool}, a1.1, a1.2,\\n                        (idp {List (\\\\Sigma S.E Bool)} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                          | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                          | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                            | yes e, true => ys\\n                            | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                          }\\n                        }},\\n                          transportInv {S.E}\\n                            (\\\\lam (x : S.E) => a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * nil {\\\\Sigma S.E Bool})\\n                            {a1.1} {a2.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                              a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * nil {\\\\Sigma S.E Bool})\\n                              {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}}))))))\\n                  | a3 :: x2, p4 => \\\\case S.decideEq a.1 a3.1, idp {Dec (a.1 = a3.1)} {S.decideEq a.1 a3.1} \\\\with {\\n                    | yes e1, p5 => \\\\case a.2 xor a3.2, idp {Bool} {a.2 xor a3.2} \\\\with {\\n                      | false, p6 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case yes {a.1 = a3.1} e1, false \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a3.1} e1, false \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} {a :: a1 :: a2 :: a3 :: x2}\\n                        (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case yes {a.1 = a3.1} e1, false \\\\with {\\n                          | yes e, true => x2\\n                          | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                        }) = u_1 * u_2)\\n                          (a :: a1 :: a2 :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                          (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2, (idp {List (\\\\Sigma S.E Bool)} {\\\\case yes {a.1 = a3.1} e1, false \\\\with {\\n                            | yes e, true => x2\\n                            | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                          }},\\n                            transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: a3 :: x2}))))))\\n                      | true, p6 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case yes {a.1 = a3.1} e1, true \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool} * x2}\\n                        {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)}\\n                        {a :: a3 :: x2} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool} * x2} {a :: a3 :: x2}\\n                          (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma (nil {\\\\Sigma S.E Bool} * x2 = u_1 * u_2)\\n                            (a :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                            (nil {\\\\Sigma S.E Bool}, x2, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {nil {\\\\Sigma S.E Bool} * x2}, transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a3 :: x2 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a.2) :: nil {\\\\Sigma S.E Bool}) * x2)\\n                              {a.1} {a3.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a3 :: x2 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a3.1, x) :: nil {\\\\Sigma S.E Bool}) * x2)\\n                                {not a.2} {a3.2} (helper1 {a.2} {a3.2} p6) (idp {List (\\\\Sigma S.E Bool)} {a :: a3 :: x2}))))))\\n                        (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a3 :: x2}\\n                          {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)}\\n                          (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma (a :: a3 :: x2 = u_1 * u_2)\\n                            ((a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                            (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2, (idp {List (\\\\Sigma S.E Bool)} {a :: a3 :: x2}, transportInv {S.E}\\n                              (\\\\lam (x : S.E) => (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)}\\n                                  {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)})))))))\\n                    }\\n                    | no n1, p5 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case no {a.1 = a3.1} n1, a.2 xor a3.2 \\\\with {\\n                      | yes e, true => x2\\n                      | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                    }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case no {a.1 = a3.1} n1, a.2 xor a3.2 \\\\with {\\n                      | yes e, true => x2\\n                      | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                    }} {a :: a1 :: a2 :: a3 :: x2}\\n                      (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case no {a.1 = a3.1} n1, a.2 xor a3.2 \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }) = u_1 * u_2)\\n                        (a :: a1 :: a2 :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                        (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2,\\n                          (idp {List (\\\\Sigma S.E Bool)} {\\\\case no {a.1 = a3.1} n1, a.2 xor a3.2 \\\\with {\\n                            | yes e, true => x2\\n                            | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                          }},\\n                            transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: a3 :: x2}))))))\\n                  }\\n                }\\n              }\\n              | no n1, p2 => transportInv {Dec (a.1 = a1.1)} (\\\\lam (x : Dec (a.1 = a1.1)) =>\\n                Closure {List (\\\\Sigma S.E Bool)} (AreAdjacent {S.E}) (a :: a1 :: a2 :: x1) (\\\\case x, a.2 xor a1.2 \\\\with {\\n                  | yes e, true => (a2.1, a2.2) :: x1\\n                  | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                })) {S.decideEq a.1 a1.1} {no {a.1 = a1.1} n} p1\\n                  (crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: x1} {\\\\case no {a.1 = a1.1} n, a.2 xor a1.2 \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: x1}))\\n            })\\n          }\\n  }', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\lemma equivMulRight \\\\hlevels  {S : \\\\Set} {a b c : E} (_ : a ~ b) : a * c ~ b * c ', '\\\\instance equivWords \\\\hlevels  {S : \\\\Set} : Equivalence (List (\\\\Sigma S Bool)) {\\n  | ~ => Closure {List (\\\\Sigma S Bool)} (AreAdjacent {S})\\n} => isEquivalence {List (\\\\Sigma S Bool)} (AreAdjacent {S})', 'ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', '\\\\instance DecWordMonoid \\\\hlevels  (S : DecSet) : DecSet (List (\\\\Sigma S.E Bool)) {\\n  | # => (DecSet.#)\\n  | decideEq => word-dec {S}\\n} => \\\\new DecSet {\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\lemma tightness \\\\hlevels  {this : DecSet} {x : E} {y : E} (x//=y : Not (x # y)) : x = y => \\\\case decideEq x y \\\\with {\\n  | yes x=y => x=y\\n  | no x/=y => absurd {x = y} (x//=y x/=y)\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma #-irreflexive \\\\hlevels  {this : DecSet} {x : E} (x/=x : x # x) : Empty => x/=x (idp {E} {x})', '\\\\instance ListMonoid \\\\hlevels  {A : \\\\Set} : Monoid (List A) {\\n  | ide => nil {A}\\n  | * => (++)\\n} => \\\\new Monoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n}', '| inverse-left {x : E} : inverse x * x = ide', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\lemma nonEqualApartImpl \\\\hlevels  {this : DecSet} {x : E} {y : E} (p : x /= y) : x # y => p', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>Group.Dec (Quotient {List (\\Sigma S.E Bool)} (~)) {\n  | ide => in~ {List (\\Sigma S.E Bool)} {(~)} (nil {\\Sigma S.E Bool})\n  | * => \\lam (a : E) (b : E) => (\\case a, b \\with {\n    | in~ a, in~ b => in~ {List (\\Sigma S.E Bool)} {(~)} (a * b)\n    | in~ a, ~-equiv x y r i => ~-equiv {List (\\Sigma S.E Bool)} {(~)} (a * x) (a * y) (equivMulLeft {S.E} {x} {y} {a} r) i\n    | ~-equiv x y r i, in~ a => ~-equiv {List (\\Sigma S.E Bool)} {(~)} (x * a) (y * a) (equivMulRight {S.E} {x} {y} {a} r) i\n  })\n  | *-assoc => {?hidden}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | inverse => \\lam (x : E) => (\\case x \\with {\n    | in~ a => in~ {List (\\Sigma S.E Bool)} {(~)} (inv {S.E} a)\n    | ~-equiv x y r i => ~-equiv {List (\\Sigma S.E Bool)} {(~)} (inv {S.E} x) (inv {S.E} y) (equiv_inv {S.E} {x} {y} r) i\n  })\n  | inverse-left => {?hidden}\n  | inverse-right => {?hidden}\n  | # => (DecSet.#)\n  | #-irreflexive => {?hidden}\n  | #-symmetric => {?hidden}\n  | #-comparison => {?hidden}\n  | tightness => {?hidden}\n  | decideEq => \\lam (p0 : E {\\this}) (p1 : E {\\this}) => (\\case p0, p1 \\with {\n    | in~ x, in~ y => \n      \\have A0 => decideEq (reduceHom {S} (in~ {List (\\Sigma S.E Bool)} {(~)} x)) (reduceHom {S} (in~ {List (\\Sigma S.E Bool)} {(~)} y))\n      \\in \\case A0 \\with {\n            | yes e => yes {in~ {List (\\Sigma S.E Bool)} {(~)} x = in~ {List (\\Sigma S.E Bool)} {(~)} y}\n              (path (~-equiv {List (\\Sigma S.E Bool)} {Closure {List (\\Sigma S.E Bool)} (AreAdjacent {S.E})} x y\n                (ctrans {List (\\Sigma S.E Bool)} {AreAdjacent {S.E}} {x} {y} {reduce {S} x} (reduce_equiv {S} x)\n                  (ctrans {List (\\Sigma S.E Bool)} {AreAdjacent {S.E}} {reduce {S} x} {y} {reduceHom {S} (in~ {List (\\Sigma S.E Bool)} {(~)} y)}\n                    (crefl {List (\\Sigma S.E Bool)} {AreAdjacent {S.E}} {reduce {S} x} {reduceHom {S} (in~ {List (\\Sigma S.E Bool)} {(~)} y)} e)\n                    (csym {List (\\Sigma S.E Bool)} {AreAdjacent {S.E}} {reduceHom {S} (in~ {List (\\Sigma S.E Bool)} {(~)} y)} {y} (reduce_equiv {S} y))))))\n            | no n => no {in~ {List (\\Sigma S.E Bool)} {(~)} x = in~ {List (\\Sigma S.E Bool)} {(~)} y}\n              (\\lam (Q : in~ {List (\\Sigma S.E Bool)} {(~)} x = in~ {List (\\Sigma S.E Bool)} {(~)} y) =>\n              n (pmap {Quotient {List (\\Sigma S.E Bool)} (~)} {List (\\Sigma S.E Bool)} (reduceHom {S}) {in~ {List (\\Sigma S.E Bool)} {(~)} x}\n                {in~ {List (\\Sigma S.E Bool)} {(~)} y} Q))\n          }\n  })\n  | nonEqualApart => {?hidden}\n}", "completion": "\\new Dec {\n  | Group => FreeGroup S\n  | decideEq => \\lam p0 p1 => (\\case \\elim p0, \\elim p1 \\with {\n    | in~ x, in~ y => \n      \\have A0 => decideEq (reduceHom (in~ x)) (reduceHom (in~ y))\n      \\in \\case A0 \\with {\n            | yes e => yes (~-equiv {_} {_} x y (ctrans (reduce_equiv x) (ctrans (crefl e) (csym (reduce_equiv y)))))\n            | no n => no (\\lam Q => n (pmap reduceHom Q))\n          }\n  })\n}"}
{"prompt": "['m : Nat', 'n : Nat']<<<break>>>['suc Nat', '\\\\lemma id<suc \\\\plevels  \\\\hlevels  {n : Nat} : n < suc n ', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', \"\\\\func gcd-isGCD \\\\hlevels  {this1 : EuclideanSemiringData} (a b : E) :\\nGCD a b (gcd a b) (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val1 {\\\\this}) (reduce a b).1 {\\n  | inv-right => {?hidden}\\n})\\n  (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val2 {\\\\this}) (reduce a b).2 {\\n    | inv-right => {?hidden}\\n  }) (gcd-isGCD-fueled (suc' (euclideanMap b)) {a} {b}) => \\\\new GCD\", \"\\\\func reduce \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : \\\\Sigma E E => reduce-fueled (suc' (euclideanMap b)) a b\", '| euclideanMap E : Nat', '| val1 : E {M}', '| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', '\\\\class GCD \\\\hlevels  {\\n  | M : CMonoid\\n  | val1 : E {M}\\n  | val2 : E {M}\\n  | res : E {M}\\n  | res|val1 : LDiv {M} res val1\\n  | res|val2 : LDiv {M} res val2\\n  | res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res\\n}', '| val2 : E {M}', '| E : \\\\Set', \"\\\\lemma suc'=suc \\\\plevels  \\\\hlevels  (n : Nat) : suc' n = suc n \", '| M : CMonoid', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| res : E {M}', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\lemma reduce*fueled-left \\\\hlevels  {this : EuclideanSemiringData} (s : Nat) (a b : E) (_ : euclideanMap b < s) :\\n  (reduce-fueled s a b).1 * gcd-fueled s a b = a ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func gcd-isGCD-fueled \\\\hlevels  {this1 : EuclideanSemiringData} (s1 : Nat) {a1 b1 g1 : E} (_ : LDiv g1 a1) (_ : LDiv g1 b1) :\\n  LDiv g1 (gcd-fueled s1 a1 b1) \\n  | {this}, 0, {a}, {b}, {g}, g|a, g|b => g|a\\n  | {this}, suc s, {a}, {b}, {g}, g|a, g|b => \\\\case decideEq b zro \\\\with {\\n    | yes p => g|a\\n    | no b/=0 => gcd-isGCD-fueled s {b} {(divMod a b).2} {g} g|b\\n      (summandDiv {g|b.inv * (divMod a b).1} {(divMod a b).2} {g|a.inv} {g} (ldiv/=0 {g} {b} b/=0 g|b)\\n        (pmap {E} {E} (\\\\lam (_x : E) => _x + (divMod a b).2) {g * (g|b.inv * (divMod a b).1)} {g * g|b.inv * (divMod a b).1}\\n          (Paths.inv {E} {g * g|b.inv * (divMod a b).1} {g * (g|b.inv * (divMod a b).1)} (*-assoc {g} {g|b.inv} {(divMod a b).1})) *> pmap {E} {E} (\\\\lam (p0 : E) => p0 * (divMod a b).1 + (divMod a b).2) {g * g|b.inv} {b} g|b.inv-right *> isDivMod a b *> Paths.inv {E} {g * g|a.inv} {a} g|a.inv-right))\\n  }', '\\\\instance IntEuclidean \\\\hlevels  : EuclideanRingData Int {\\n  | zro => pos 0\\n  | + => (+)\\n  | * => (IntRing.*)\\n  | ide => pos 1\\n  | natCoef => pos\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => iabs\\n  | divMod => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\n    \\\\let! (d, m) => Nat.divMod (iabs x) (iabs y)\\n    \\\\in (pos d Semigroup.* signum y Semigroup.* signum x, pos m Semigroup.* signum x))\\n  | negative => negative\\n} => \\\\new EuclideanRingData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n  | negative-left => {?hidden}\\n}', \"\\\\func suc' \\\\plevels  \\\\hlevels  (_ : Nat) : Nat \\n  | 0 => 1\\n  | suc n => suc (suc n)\"]<<<break>>>GCD {IntEuclidean} (pos n) (pos m) (gcd {IntEuclidean} (pos n) (pos m))\n  (\\new LDiv {M {\\this}} (res {\\this}) (val1 {\\this}) (reduce {IntEuclidean} (pos n) (pos m)).1 {\n    | inv-right => {?hidden}\n  })\n  (\\new LDiv {M {\\this}} (res {\\this}) (val2 {\\this}) (reduce {IntEuclidean} (pos n) (pos m)).2 {\n    | inv-right => {?hidden}\n  }) (gcd-isGCD-fueled {IntEuclidean} (suc' (euclideanMap (pos m))) {pos n} {pos m})", "completion": "gcd-isGCD (pos n) (pos m)"}
{"prompt": "['B : Matrix R.E 2 2', 'D : Inv {MatrixRing R 2}', 'null : (\\\\lam (p0 : Matrix R.E 2 2) => at {at {p0} 0} 0) B = (\\\\lam (p0 : Matrix R.E 2 2) => at {at {p0} 0} 0)\\n  (C.val product makeMatrix {R.E} {2} {2} ((a :: b :: nil) :: (R.zro :: c :: nil) :: nil) product D.val)', 'c : R.E', 'b : R.E', 'R : CRing', 'C : Inv {MatrixRing R 2}', 'a : R.E']<<<break>>>['| zro : E', '\\\\func makeMatrix {R : \\\\Type} {n m : Nat} (M : Array (Array R m) n) : Matrix R n m => M', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| val : E {M}', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', '\\\\func \\\\infixl 7 product \\\\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))']<<<break>>>at {at {B} 0} 0 - at {at {C.val product makeMatrix {R.E} {2} {2} ((a :: b :: nil) :: (R.zro :: c :: nil) :: nil) product D.val} 0} 0 = R.zro", "completion": "toZero {R} {B !! 0 !! 0} {BigSum {R} (\\new Array R.E 2 (\\lam (j : Fin 2) => BigSum {R} (\\new Array R.E 2\n  (\\lam (j1 : Fin 2) => C.val !! 0 !! j1 R.* makeMatrix {R.E} {2} {2} ((a :: b :: nil) :: (R.zro :: c :: nil) :: nil) !! j1 !! j)) R.* D.val !! j !! 0))}\n  p"}
{"prompt": "['d : a R.* R.ide R.* c = b R.* R.ide R.* c', 'R : CRing', 'a : R.E', 'b : R.E', 'c : R.E']<<<break>>>['| \\\\infixl 7 * E E : E', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| ide : E', '| E : \\\\Set', '| ide-right {x : E} : x * ide = x']<<<break>>>a R.* c = b R.* c", "completion": "rewrite ide-right (rewrite ide-right d)"}
{"prompt": "['y : Rat', 'x : Rat']<<<break>>>['\\\\func fromRat \\\\hlevels  (x : Rat) : InfReal (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new InfReal {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n}', '\\\\class InfReal \\\\extends LowerReal, ExUpperReal \\\\hlevels  {\\n  | LU-disjoint {q : Rat} (L q) (U q) : Empty\\n  | LU-located {q r : Rat} (q < r) : L q || U r\\n  | LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| E : \\\\Set', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| \\\\infix 4 < E E : \\\\Prop', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)']<<<break>>>InfReal (\\lam (_x : Rat) => _x StrictPoset.< x + y) ((OrderedAddGroup.<) (x + y))", "completion": "fromRat (x + y)"}
{"prompt": "['X : CoverSpace', \"x' : Total {X.E} S\", \"V' : Set E\", \"x'<=<V' : single {X.E} x'.1 <=< extend {X.E} {S} V'\", 'S : Set X.E']<<<break>>>['\\\\lemma <=<_<= \\\\hlevels  {X : PrecoverSpace} {V U : Set X.E} (_ : V <=< U) : V <= U ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| E : \\\\Set', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\func extend {X : \\\\Type} {U : Set X} (V : Set (Total {X} U)) : Set X => \\\\lam (x : X) => \\\\Sigma (Ux : U x) (V (x, Ux))']<<<break>>>V' x'", "completion": "transport V' (ext idp) (<=<_<= x'<=<V' idp).2"}
{"prompt": "['N_B<N : \\\\Sigma (n : Nat) (B < fromInt (pos n))', 'NN>0 : zro < fromInt (pos N) * fromInt (pos N)']<<<break>>>['| zro : E', '\\\\lemma finv>0 {this : DiscreteOrderedField} {x : E} (_ : zro < x) : zro < finv x ', '| \\\\infixl 7 * E E : E', '| finv E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)', 'pos Nat']<<<break>>>zro < finv (fromInt (pos N) * fromInt (pos N))", "completion": "finv>0 {RatField} NN>0"}
{"prompt": "['S : Series ExUpperReal', 'eps>0 : zro < eps', 'c : IsConvUpperSeries S', 'eps : Rat']<<<break>>>['\\\\func midSum \\\\hlevels  {A3 : AddMonoid} (_ : Series A.E) (_ _ : Nat) : A.E \\n  | {A}, S, 0, m => partialSum {A} S m\\n  | {A}, S, suc n, 0 => A.zro\\n  | {A}, S, suc n, suc m => midSum {A} (\\\\lam (j : Nat) => S (suc j)) n m', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| U Rat : \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (N : Nat) (\\Pi {n : Nat} -> N <= n -> U {midSum {ExUpperRealAbMonoid} S N n} eps))", "completion": "c eps>0"}
{"prompt": "['this : InfReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (a1 : Real) (fromRat a StrictPoset.< a1) (U : E {F.A}) (F.F U) (\\\\Pi {b : F.X} -> U b -> a1 InfRealAbMonoid.< b)))\\n  (\\\\lam (b : Rat) => TruncP (\\\\Sigma (b1 : Real) (b1 StrictPoset.< fromRat b) (U : E {F.A}) (F.F U) (\\\\Pi {a : F.X} -> U a -> a InfRealAbMonoid.< b1))) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n}', 'q : Rat', 'p0 : L {\\\\this} q', 'F : StronglyRegularCauchyFilter InfRealUniformSpace']<<<break>>>['| A : TopMeetSemilattice', '| F (E {A}) : \\\\Prop', '| X : \\\\Set', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'inP A', '\\\\lemma real_<-rat-char \\\\plevels  \\\\hlevels  {x y : Real} : x < y <-> TruncP (\\\\Sigma (a : Rat) (x.U a) (y.L a)) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '\\\\lemma real_<_L \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : fromRat a < x <-> x.L a ', '| L Rat : \\\\Prop', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\type \\\\infix 4 < \\\\plevels  \\\\hlevels  (x y : InfReal) : \\\\Prop => TruncP (\\\\Sigma (a : Rat) (x.U a) (y.L a))', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| U Rat : \\\\Prop', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| E : \\\\Set', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>TruncP (\\Sigma (r : Rat) (L {\\this} r) (q < r))", "completion": "\\scase \\elim p0 \\with {\n  | inP (a1, q<a1, U, FU, g) => \\scase real_<-rat-char.1 q<a1 \\with {\n    | inP (r, q<r, r<a1) => inP (r, inP (a1, real_<_L.2 r<a1, U, FU, g), q<r)\n  }\n}"}
{"prompt": "['S : DecSet', 'a1 : \\\\Sigma S.E Bool', 'a : \\\\Sigma S.E Bool']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>Dec (a.1 = a1.1)", "completion": "decideEq a.1 a1.1"}
{"prompt": "['r1<r : fromRat r1 < fromRat r', 'r1 : E', 'r : Rat', 'S : IntervalSubset']<<<break>>>['| meet-left {x y : E} : x \u2227 y <= x', '\\\\lemma real_<_U \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : x < fromRat a <-> x.U a ', 'meet \\\\plevels  \\\\hlevels  (x y : Real) : Real => \\\\new Real (L {meet x y}) (U {meet x y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| U Rat : \\\\Prop', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>U {meet (fromRat r1) S.3} r", "completion": "real_<_U.1 (meet-left <\u2218r r1<r)"}
{"prompt": "['this : NatTrans', 'e : \\\\Pi {X : Ob {C}} -> Iso {D} {Functor.F {NatTrans.F} X} {Functor.F {G} X} (trans X)', 'this : NatTrans {NatTrans.C} {D} G NatTrans.F {\\n  | trans => \\\\lam (X : Ob {NatTrans.C {\\\\this}}) => hinv {e {X}}\\n  | natural => {?hidden}\\n}']<<<break>>>['| C : Precat', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '| C : Precat', '| F : Functor C D', '| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)', '| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X', '| Hom Ob Ob : \\\\Set', '| f_hinv : f \u2218 hinv = id {C} cod', '| hinv : Hom {C} cod dom', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| f : Hom {C} dom cod', '| dom : Ob {C}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| cod : Ob {C}', '| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| isMono {x : Ob {C}} {g h : Hom {C} x dom} (f \u2218 g = f \u2218 h) : g = h', '| D : Precat', '| id (X : Ob) : Hom X X', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| G : Functor C D']<<<break>>>\\Pi {X Y : Ob {NatTrans.C {\\this}}} -> \\Pi (f : Hom {NatTrans.C {\\this}} X Y) ->\n  trans {\\this} Y \u2218 Func {G} {X} {Y} f = Func {NatTrans.F} {X} {Y} f \u2218 trans {\\this} X", "completion": "\\lam f => isMono {e} $ rewrite (inv o-assoc, f_hinv {e}, id-left, inv o-assoc, natural {this} f, o-assoc, f_hinv {e}, id-right) idp"}
{"prompt": "['I : DirectedSet', 'p : \\\\Pi (i : I.E) -> f i = g i', 'fc : IsConvergent {I} {X} f', 'g : I.E -> X.E', 'X : CompleteCoverSpace', 'gc : IsConvergent {I} {X} g', 'f : I.E -> X.E']<<<break>>>['| value isDefined : E', '\\\\lemma limit-isLimit \\\\hlevels  {I : DirectedSet} {X : CompleteCoverSpace} {f : I.E -> X.E} {fc : IsConvergent {I} {X} f} :\\n  IsLimit {X} {I} f (value {limit {I} {X} f} fc) ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma limit-unique \\\\hlevels  {this : HausdorffTopSpace} {I : DirectedSet} {f : I.E -> E} {x y : E} (_ : IsLimit {I} f x) (_ : IsLimit {I} f y) : x = y ', '\\\\func limit \\\\hlevels  {I : DirectedSet} {X : CompleteCoverSpace} (f : I.E -> X.E) : Partial X.E {\\n  | isDefined => IsConvergent {I} {X} f\\n  | value => \\\\lam (fc : isDefined {\\\\this}) => func {completion-lift {DirectedCoverSpace I} {X} fc} (infPoint {I})\\n} => \\\\new Partial', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func IsLimit \\\\hlevels  {this : TopSpace} {I : DirectedSet} (f : I.E -> E) (l : E) : \\\\Prop \\n  => \\\\Pi {U : Set E} -> isOpen U -> U l -> TruncP (\\\\Sigma (N : I.E) (\\\\Pi {n : I.E} -> N I.<= n -> U (f n)))']<<<break>>>value {limit {I} {X} f} fc = value {limit {I} {X} g} gc", "completion": "limit-unique {X} limit-isLimit (transportInv (\\lam p0 => IsLimit {X} p0 (limit g gc)) (ext p) limit-isLimit)"}
{"prompt": "['f : Iso {C} {x} {y}', 'C : Precat', 'g : Iso {C} {y} {z}', 'x : C.Ob']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class HData \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | V : \\\\Set\\n  | f V : Ob {C}\\n  | H V V : \\\\Set\\n  | g {x y : V} (H x y) : Hom {C} (f x) (f y)\\n}', '| Hom Ob Ob : \\\\Set', '| hinv : Hom {C} cod dom', '| f : Hom {C} dom cod', '| dom : Ob {C}', '| Ob : \\\\hType', '| V : \\\\Set', '| H V V : \\\\Set', '| C : Precat', '| cod : Ob {C}']<<<break>>>HData {C1} {Fin 3} (\\lam (j : Fin 3) => (\\case j \\with {\n  | zero => g.dom\n  | suc zero => g.cod\n  | suc (suc zero) => x\n}))\n  (\\lam (i : V {\\this}) (j : V {\\this}) => (\\case i, j \\with {\n    | zero, suc zero => Fin 1\n    | zero, suc (suc zero) => Fin 1\n    | suc (suc zero), zero => Fin 1\n    | suc zero, zero => Fin 1\n    | v, v => Fin 0\n  }))\n  (\\lam {i : V {\\this}} {j : V {\\this}} (k : H {\\this} i j) => (\\case i, j, k \\with {\n    | zero, suc zero, zero => g.f\n    | zero, suc (suc zero), zero => f.hinv\n    | suc (suc zero), zero, zero => f.f\n    | suc zero, zero, zero => g.hinv\n  }))", "completion": "\\new HData {C} (\\lam (j : Fin 3) => (\\case j \\with {\n  | 0 => g.dom\n  | 1 => g.cod\n  | 2 => x\n}))\n  (\\lam i j => (\\case i, j \\with {\n    | 0, 1 => Fin 1\n    | 0, 2 => Fin 1\n    | 2, 0 => Fin 1\n    | 1, 0 => Fin 1\n    | _, _ => Fin 0\n  }))\n  (\\lam {i} {j} k => (\\case \\elim i, \\elim j, k \\with {\n    | 0, 1, 0 => g.f\n    | 0, 2, 0 => f.hinv\n    | 2, 0, 0 => f.f\n    | 1, 0, 0 => g.hinv\n  }))"}
{"prompt": "['X : PseudoMetricSpace']<<<break>>>['\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : CoverSpace} (g : CoverMap Y Z) (f : CoverMap X Y) : CoverMap X Z {\\n  | func => \\\\lam (x : E {Dom {g \u2218 f}}) => g.func (f.func x)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\func coverSpace \\\\hlevels  {X1 : StronglyRegularCoverSpace} : StronglyRegularCoverSpace (StronglyRegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => isCCauchy {X1}\\n} => \\\\new StronglyRegularCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isStronglyRegular => {?hidden}\\n}', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', \"\\\\func prod \\\\hlevels  {X Y X' Y' : CoverSpace} (f : CoverMap X Y) (g : CoverMap X' Y') : CoverMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} z, func {g \u2218 proj2 {X} {X'}} z)\\n} => tuple {Y} {Y'} {X \u2a2f X'} (f \u2218 proj1 {X} {X'}) (g \u2218 proj2 {X} {X'})\", '\\\\class CoverMap \\\\extends PrecoverMap, StronglyCauchyMap \\\\hlevels  {\\n  | func-weak-cauchy => \\\\lam (F1 : WeaklyCauchyFilter Dom) =>\\n  \\\\new WeaklyCauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n    | filter-mono => {?hidden}\\n    | filter-top => {?hidden}\\n    | filter-meet => {?hidden}\\n    | isWeaklyProper => {?hidden}\\n    | isCauchyFilter => {?hidden}\\n  }\\n}', '\\\\func strongCompletion \\\\hlevels  {S : StronglyRegularCoverSpace} : CoverMap S (coverSpace {S}) {\\n  | func => pointSCF {S}\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\lemma proj1 \\\\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) X {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} ', '| Dom : BaseSet', '\\\\lemma proj2 \\\\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) Y {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.2\\n} ']<<<break>>>CoverMap (X \u2a2f X \u2a2f X) (coverSpace {X} \u2a2f coverSpace {X} \u2a2f coverSpace {X}) {\n  | func => \\lam (z : E {Dom {\\this}}) =>\n  (func {prod {X} {coverSpace {X}} {X} {coverSpace {X}} (strongCompletion {X}) (strongCompletion {X}) \u2218 proj1 {X \u2a2f X} {X}} z,\n    func {strongCompletion {X} \u2218 proj2 {X \u2a2f X} {X}} z)\n}", "completion": "prod (prod strongCompletion strongCompletion) strongCompletion"}
{"prompt": "['h1 : x.F = y.F', 'L : Locale', 'x : E {\\\\this}', 'y : E {\\\\this}']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| Join {J : \\\\Set} (J -> E) : E', '| E : \\\\Set', '| filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> L.E} -> (@) h1 i (L.Join {J} f) -> TruncP (\\Sigma (j : J) ((@) h1 i (f j))))\n  x.filter-Join y.filter-Join", "completion": "prop-dpi (\\lam i => ext_coe) (filter-Join {x}) (filter-Join {y})"}
{"prompt": "['I : LIdeal R', 't : \\\\Sigma (x : R.E) (I.contains x) M.E']<<<break>>>['| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)', '| negative E : E', '| S : BaseSet', '| contains (E {S}) : \\\\Prop']<<<break>>>I.contains (negative {I.S} t.1)", "completion": "contains_negative t.2"}
{"prompt": "['f : UniformHom M (Completion L)', 'L : UniformLocale', 'arg : f.func = g.func', 'M : UniformLocale', 'g : UniformHom M (Completion L)']<<<break>>>['| isUniform (E -> \\\\Prop) : \\\\Prop', '| func-uniform {U : E {Dom} -> \\\\Prop} (isUniform {Dom} U) : isUniform {Cod} (\\\\lam (y : E {Cod}) => TruncP (\\\\Sigma (x : E {Dom}) (U x) (y <= func x)))', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\func Completion (L : UniformLocale) : UniformLocale (Opens (CompletionPres L)) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E) (V : E) =>\\n    closure {CompletionPres L} {\\\\Sigma (a b : E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : E) (U.1 a) (V.1 b)) => conj t.1 t.2)\\n  | top => (\\\\lam (_ : E) => \\\\Sigma, \\\\lam (e : E) (_ : SCover {CompletionPres L} e (\\\\lam (_ : E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E) =>\\n    closure {CompletionPres L} {\\\\Sigma (j : J) (x : E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : E) ((f j).1 x)) => p0.2)\\n  | isUniform => Completion.isUniform {L}\\n} => \\\\new UniformLocale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n  | uniform-overt => {?hidden}\\n  | isCovering => {?hidden}\\n  | isDownset => {?hidden}\\n  | top-uniform => {?hidden}\\n  | meet-uniform => {?hidden}\\n  | <=-uniform => {?hidden}\\n  | star-uniform => {?hidden}\\n  | isAdmissible => {?hidden}\\n}', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Path (\\lam (i : I) => \\Pi {U : M.E -> \\Prop} -> M.isUniform U -> isUniform (\\lam (y : E) => TruncP (\\Sigma (x : M.E) (U x) (y <= (@) arg i x))))\n  f.func-uniform g.func-uniform", "completion": "prop-dpi (\\lam i => ext_coe) (func-uniform {f}) (func-uniform {g})"}
{"prompt": "['X : CoverSpace', 'C : Set (Set (E {\\\\this}))']<<<break>>>['\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', '\\\\class CoverSpace \\\\extends PrecoverSpace \\\\hlevels  {\\n  | isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))\\n}', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\lemma closure-cauchy \\\\hlevels  {X : \\\\Set} {S : PrecoverSpace X} {A : Set (Set X) -> \\\\Prop} (_ : \\\\Pi {C : Set (Set X)} -> A C -> S.isCauchy C)\\n  {C : Set (Set X)} (_ : Closure {X} A C) : S.isCauchy C ', '| E : \\\\Set']<<<break>>>Closure {X.E} X.isCauchy C -> isCauchy {\\new X {}} C", "completion": "closure-cauchy (\\lam c => c)"}
{"prompt": "['context-c : List env.Sort', 'mc : MetaContext env.Sort', 'arguments : DArray {arity {mc} {s} m} (\\\\lam (index : Fin (arity {mc} {s} m)) => Term env context-a (mc.m-domain {s} m !! index) mc)', 'subst-a : Substitution {env} context-a context-b mc', 'context-a : List env.Sort', 'context-b : List env.Sort', 'm : mc.metaname s', 's : env.Sort', 'env : FSignature', 'subst-b : Substitution {env} context-b context-c mc']<<<break>>>['\\\\func apply \\\\hlevels  {env2 : FSignature} {s2 : env.Sort} {old-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\\n  (_ : Term env2 old-context2 s2 mc2) {new-context2 : List env.Sort}\\n  (_ : Substitution {env2} old-context2 new-context2 mc2) : Term env2 new-context2 s2 mc2 \\n  | {env}, {s}, {old-context}, {mc}, var index idp, {new-context}, map => map index\\n  | {env}, {s}, {old-context}, {mc}, metavar m arguments, {new-context}, map =>\\n  metavar {env} {new-context} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term env new-context (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) =>\\n      apply {env} {mc.m-domain {s} m !! i} {old-context} {mc} (arguments.at i) {new-context} map))\\n  | {env}, {s}, {old-context}, {mc}, func f arguments, {new-context}, map =>\\n  func {env} {new-context} {s} {mc} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (new-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) =>\\n    apply {env} {f !!sort i} {old-context ++ f !!domain i} {mc} (arguments.at i) {new-context ++ f !!domain i}\\n      (append-context-right {env} {old-context} {new-context} {mc} map {f !!domain i})))', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', '\\\\func Index {A : \\\\Type} (list : List A) : \\\\Type => Fin (length {A} list)', '| Sort : \\\\Set', 'metavar (m : mc.metaname termSort) (DArray {arity {mc} {termSort} m}\\n  (\\\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func arity \\\\hlevels  {this : MetaContext} {s : Sort} (m : metaname s) : Nat => length {Sort} (m-domain {s} m)', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\func subst-comm \\\\hlevels  {env3 : FSignature} {context-a3 context-b3 context-c3 : List env.Sort} {s2 : env.Sort} {mc3 : MetaContext env.Sort}\\n  (subst-a3 : Substitution {env3} context-a3 context-b3 mc3) (subst-b3 : Substitution {env3} context-b3 context-c3 mc3)\\n  (t : Term env3 context-a3 s2 mc3) :\\napply {env3} {s2} {context-b3} {mc3} (apply {env3} {s2} {context-a3} {mc3} t {context-b3} subst-a3) {context-c3} subst-b3 = apply {env3} {s2} {context-a3} {mc3} t {context-c3}\\n  (\\\\lam (i : Index {env.Sort} context-a3) => apply {env3} {context-a3 !! i} {context-b3} {mc3} (subst-a3 i) {context-c3} subst-b3) \\n  | {env}, {context-a}, {context-b}, {context-c}, {s}, {mc}, subst-a, subst-b, var index idp =>\\n  idp {Term env context-c (context-a !! index) mc}\\n    {apply {env} {context-a !! index} {context-b} {mc} (apply {env} {context-a !! index} {context-a} {mc}\\n      (var {env} {context-a} {context-a !! index} {mc} index (idp {env.Sort} {context-a !! index})) {context-b} subst-a)\\n      {context-c} subst-b}\\n  | {env}, {context-a}, {context-b}, {context-c}, {s}, {mc}, subst-a, subst-b, metavar m arguments =>\\n  mext {env} {context-c} {s} {mc} {m} {\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term env context-c (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => apply {env} {mc.m-domain {s} m !! i} {context-b} {mc}\\n      (apply {env} {mc.m-domain {s} m !! i} {context-a} {mc} (arguments.at i) {context-b} subst-a) {context-c} subst-b)}\\n    {\\\\new DArray {MetaContext.arity {mc} {s} m}\\n      (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term env context-c (mc.m-domain {s} m !! index) mc)\\n      (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) =>\\n      apply {env} {mc.m-domain {s} m !! i} {context-a} {mc} (arguments.at i) {context-c}\\n        (\\\\lam (i : Index {env.Sort} context-a) => apply {env} {context-a !! i} {context-b} {mc} (subst-a i) {context-c} subst-b))}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) =>\\n      subst-comm {env} {context-a} {context-b} {context-c} {mc.m-domain {s} m !! index} {mc} subst-a subst-b (arguments.at index))\\n  | {env}, {context-a}, {context-b}, {context-c}, {s}, {mc}, subst-a, subst-b, func f arguments =>\\n  fext {env} {context-c} {s} {mc} {f} {\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context-c ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => apply {env} {f !!sort i} {context-b ++ f !!domain i} {mc}\\n      (apply {env} {f !!sort i} {context-a ++ f !!domain i} {mc} (arguments.at i) {context-b ++ f !!domain i}\\n        (append-context-right {env} {context-a} {context-b} {mc} subst-a {f !!domain i})) {context-c ++ f !!domain i}\\n      (append-context-right {env} {context-b} {context-c} {mc} subst-b {f !!domain i}))}\\n    {\\\\new DArray {FSignature.arity {env} {s} f}\\n      (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context-c ++ f !!domain index) (f !!sort index) mc)\\n      (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) =>\\n      apply {env} {f !!sort i} {context-a ++ f !!domain i} {mc} (arguments.at i) {context-c ++ f !!domain i}\\n        (append-context-right {env} {context-a} {context-c} {mc}\\n          (\\\\lam (i : Index {env.Sort} context-a) => apply {env} {context-a !! i} {context-b} {mc} (subst-a i) {context-c} subst-b)\\n          {f !!domain i}))}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) =>\\n    subst-comm {env} {context-a ++ f !!domain index} {context-b ++ f !!domain index} {context-c ++ f !!domain index} {f !!sort index}\\n      {mc} (append-context-right {env} {context-a} {context-b} {mc} subst-a {f !!domain index})\\n      (append-context-right {env} {context-b} {context-c} {mc} subst-b {f !!domain index}) (arguments.at index) *> pmap {\\\\Pi (index1 : Index {env.Sort} (context-a ++ f !!domain index)) ->\\n      Term env (context-c ++ f !!domain index) ((context-a ++ f !!domain index) !! index1) mc}\\n      {Term env (context-c ++ f !!domain index) (f !!sort index) mc}\\n      (apply {env} {f !!sort index} {context-a ++ f !!domain index} {mc} (arguments.at index) {context-c ++ f !!domain index})\\n      {\\\\lam (i : Index {env.Sort} (context-a ++ f !!domain index)) =>\\n      apply {env} {(context-a ++ f !!domain index) !! i} {context-b ++ f !!domain index} {mc}\\n        (append-context-right {env} {context-a} {context-b} {mc} subst-a {f !!domain index} i) {context-c ++ f !!domain index}\\n        (append-context-right {env} {context-b} {context-c} {mc} subst-b {f !!domain index})}\\n      {append-context-right {env} {context-a} {context-c} {mc}\\n        (\\\\lam (i : Index {env.Sort} context-a) => apply {env} {context-a !! i} {context-b} {mc} (subst-a i) {context-c} subst-b)\\n        {f !!domain index}}\\n      (path (\\\\lam (i : I) (index1 : Index {env.Sort} (context-a ++ f !!domain index)) =>\\n        distribute-append-context-right {env} {context-a} {context-b} {context-c} {f !!domain index} {mc} subst-a subst-b index1 @ i)))', '| at (j : Fin len) : A j', '| m-domain {s : Sort} (metaname s) : List Sort', \"\\\\func mext \\\\hlevels  {env : FSignature} {context : List env.Sort} {termSort : env.Sort} {mc : MetaContext env.Sort} {m : mc.metaname termSort}\\n  {args args' : DArray {arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc)}\\n  (eq : \\\\Pi (index : Fin (arity {mc} {termSort} m)) -> args.at index = args'.at index) :\\n  metavar {env} {context} {termSort} {mc} m args = metavar {env} {context} {termSort} {mc} m args' \\n=> pmap {DArray {arity {mc} {termSort} m}\\n  (\\\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc)}\\n  {Term env context termSort mc} (metavar {env} {context} {termSort} {mc} m) {args} {args'}\\n  (path (\\\\lam (i : I) => \\\\new DArray {arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc)\\n    (\\\\lam (j : Fin (arity {mc} {termSort} m)) => eq j @ i)))\"]<<<break>>>metavar {env} {context-c} {s} {mc} m\n  (\\new DArray {arity {mc} {s} m} (\\lam (index : Fin (arity {mc} {s} m)) => Term env context-c (mc.m-domain {s} m !! index) mc)\n    (\\lam (i : Fin (arity {mc} {s} m)) => apply {env} {mc.m-domain {s} m !! i} {context-b} {mc}\n      (apply {env} {mc.m-domain {s} m !! i} {context-a} {mc} (arguments.at i) {context-b} subst-a) {context-c} subst-b)) = metavar {env} {context-c} {s} {mc} m\n  (\\new DArray {arity {mc} {s} m} (\\lam (index : Fin (arity {mc} {s} m)) => Term env context-c (mc.m-domain {s} m !! index) mc)\n    (\\lam (i : Fin (arity {mc} {s} m)) => apply {env} {mc.m-domain {s} m !! i} {context-a} {mc} (arguments.at i) {context-c}\n      (\\lam (i : Index {env.Sort} context-a) => apply {env} {context-a !! i} {context-b} {mc} (subst-a i) {context-c} subst-b)))", "completion": "mext (\\lam index => subst-comm subst-a subst-b (arguments index))"}
{"prompt": "['x/#y : Not (x # y)', 'x : E', 'this : With#', 'y : E']<<<break>>>['byLeft A', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>x < y -> Empty", "completion": "\\lam x<y => x/#y (byLeft x<y)"}
{"prompt": "['s : CatTerm {V} a b H', 'this : HData', 'a : V', 'b : V']<<<break>>>['\\\\lemma normalize-consistent \\\\plevels obj >= hom \\\\hlevels  {this : HData} {a b : V} (t : CatTerm {V} a b H) :\\n  interpret {a} {b} t = interpretNF {a} {b} (normalize {V} {a} {b} {H} t) ', '\\\\func normalize {V : \\\\Type} {a b : V} {H : V -> V -> \\\\Type} (t : CatTerm {V} a b H) : CatNF {V} a b H \\n  => aux {V} {a} {a} {b} {H} t (:nil {V} {a} {a} {H} (idp {V} {a}))', '| Hom Ob Ob : \\\\Set', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func interpret \\\\plevels obj >= hom \\\\hlevels  {this3 : HData} {a3 b2 : V} (_ : CatTerm {V} a3 b2 H) : Hom {C} (f a3) (f b2) \\n  | {this}, {a}, {b}, var h => g {a} {b} h\\n  | {this}, {a}, {b}, :id idp => id {C} (f a)\\n  | {this}, {a}, {b}, :o c t s => interpret {c} {b} t \u2218 interpret {a} {c} s', '\\\\func interpretNF \\\\plevels obj >= hom \\\\hlevels  {this3 : HData} {a3 b2 : V} (_ : CatNF {V} a3 b2 H) : Hom {C} (f a3) (f b2) \\n  | {this}, {a}, {b}, :nil idp => id {C} (f a)\\n  | {this}, {a}, {b}, :cons {c} h (:nil idp) => g {a} {b} h\\n  | {this}, {a}, {b}, :cons {c} h t => g {c} {b} h \u2218 interpretNF {a} {c} t', '| V : \\\\Set', '| H V V : \\\\Set', '| C : Precat', '| f V : Ob {C}']<<<break>>>interpret {a} {b} s = interpretNF {a} {b} (normalize {V} {a} {b} {H} s)", "completion": "normalize-consistent {this} s"}
{"prompt": "['l : Array Bool n']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\lemma nonEmpty-dec \\\\plevels  \\\\hlevels  (l : Array Bool) : Dec (NonEmpty l) ', '\\\\func NonEmpty \\\\plevels  \\\\hlevels  (l : Array Bool) : \\\\Prop => TruncP (\\\\Sigma (j : Fin l.len) (l.at j = true))']<<<break>>>Dec (NonEmpty l)", "completion": "nonEmpty-dec l"}
{"prompt": "['F : StronglyRegularCauchyFilter RatNormed', 'this : Real (\\\\lam (a : Rat) => TruncP (\\\\Sigma (x eps : Rat) (zro < eps) (F.F (OBall {RatNormed} eps x)) (a < x - eps)))\\n  (\\\\lam (b : Rat) => TruncP (\\\\Sigma (x eps : Rat) (zro < eps) (F.F (OBall {RatNormed} eps x)) (x AddMonoid.+ eps < b))) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}']<<<break>>>['| F (E {A}) : \\\\Prop', '| \\\\infixl 6 + E E : E', '\\\\lemma mid>left \\\\plevels  \\\\hlevels  {a b : Rat} (_ : a < b) : a < mid a b ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'inP A', '\\\\func mid \\\\plevels  \\\\hlevels  (a b : Rat) : Rat => (a + b) * ratio (pos 1) 2', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma mid<right \\\\plevels  \\\\hlevels  {a b : Rat} (_ : a < b) : mid a b < b ', '| U Rat : \\\\Prop', '\\\\func OBall \\\\hlevels  {X : ExPseudoMetricSpace} (eps : Rat) (x : X.E) : Set X.E => \\\\lam (y : X.E) => U {X.dist x y} eps', '\\\\instance RatNormed \\\\hlevels  : NormedAbGroup Rat {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | negative => RatField.negative\\n  | norm => \\\\lam (a : E {\\\\this}) => Real.fromRat (abs {RatField} a)\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}']<<<break>>>\\Pi {a : Rat} -> U {\\this} a -> TruncP (\\Sigma (r : Rat) (U {\\this} r) (r < a))", "completion": "\\lam {a} p0 => (\\scase \\elim p0 \\with {\n  | inP (x, eps, eps>0, FB, x+eps<a) => inP (mid (x + eps) a, inP (x, eps, eps>0, FB, mid>left x+eps<a), mid<right x+eps<a)\n})"}
{"prompt": "['null : zro <= e * e', 'q : Rat', 'e : Rat']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '| len : Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', 'LessOrEquals', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma natUnit \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n * m = 1) : m = 1 ', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatData (q :: e :: e * e :: q * q :: q * e :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 5} 3 :+ var {E} {Fin 5} 4) <= interpret {\\new LinearRatData (q :: e :: e * e :: q * q :: q * e :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}}\n  (var {E} {Fin 5} 3 :+ var {E} {Fin 5} 4 :* coef {E} {Fin 5} (rat (pos 1) 2 {?hidden} {?hidden}) :* coef {E} {Fin 5} (rat (pos 2) 1 {?hidden} {?hidden}) :+ var {E} {Fin 5} 2 :* coef {E} {Fin 5} (rat (pos 1) 2 {?hidden} {?hidden}) :* coef {E} {Fin 5} (rat (pos 1) 2 {?hidden} {?hidden}))", "completion": "solve<=Problem {\\new LinearRatData {\n  | R => RatField\n  | vars => q :: e :: e * e :: q * q :: q * e :: nil\n}} ((:zro, LessOrEquals, var 2) :: nil) (var 3 :+ var 4)\n  (var 3 :+ var 4 :* coef (rat (pos 1) 2 {?hidden} {?hidden}) :* coef (rat (pos 2) 1 {?hidden} {?hidden}) :+ var 2 :* coef (rat (pos 1) 2 {?hidden} {?hidden}) :* coef (rat (pos 1) 2 {?hidden} {?hidden}))\n  (4 :: 1 :: nil, 0, idp, idp {Bool} {true}) (_x :: nil)"}
{"prompt": "['f : V.E -> V.E', 'g : V.E -> V.E', 'V : AddMonoid', 'l : Array (\\\\Sigma V.E B.E)', 'B : BottomDistributiveLattice']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '| A (Fin len) : \\\\Type', \"\\\\lemma ~_+' \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} (bs : Array B.E) (vs vs' : Array V.E bs.len) :\\n  mkArray {\\\\Sigma V.E B.E} {bs.len} (\\\\lam (j : Fin bs.len) => (vs.at j, bs.at j)) ++ mkArray {\\\\Sigma V.E B.E} {bs.len} (\\\\lam (j : Fin bs.len) => (vs'.at j, bs.at j)) ~ mkArray {\\\\Sigma V.E B.E} {bs.len} (\\\\lam (j : Fin bs.len) => (vs.at j V.+ vs'.at j, bs.at j)) \", '| at (j : Fin len) : A j', \"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '| E : \\\\Set', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>mkArray {\\Sigma V.E B.E} {len {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l}}\n  (\\lam (j : Fin (len {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l})) =>\n  (at {map {\\Sigma V.E B.E} {V.E} (\\lam (s : \\Sigma V.E B.E) => f s.1) l} j,\n    at {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l} j)) ++ mkArray {\\Sigma V.E B.E} {len {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l}}\n  (\\lam (j : Fin (len {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l})) =>\n  (at {map {\\Sigma V.E B.E} {V.E} (\\lam (s : \\Sigma V.E B.E) => g s.1) l} j,\n    at {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l} j)) ~ mkArray {\\Sigma V.E B.E} {len {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l}}\n  (\\lam (j : Fin (len {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l})) =>\n  (at {map {\\Sigma V.E B.E} {V.E} (\\lam (s : \\Sigma V.E B.E) => f s.1) l} j V.+ at {map {\\Sigma V.E B.E} {V.E} (\\lam (s : \\Sigma V.E B.E) => g s.1) l} j,\n    at {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l} j))", "completion": "~_+' {V} {B} (map (\\lam p0 => p0.2) l) (map (\\lam s => f s.1) l) (map (\\lam s => g s.1) l)"}
{"prompt": "['A : BaseSet', 'B : AddMonoid']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func index-left {A1 : \\\\Type} {l1 m1 : Array A1} (_ : Fin l.len) : Fin (len {l1 ++ m1}) \\n  | {A}, {:: {n} a l}, {m}, zero => 0\\n  | {A}, {:: {n} a l}, {m}, suc i => suc (index-left {A} {l} {m} i)', '\\\\class FinSuppFunc \\\\extends SetHom \\\\hlevels  {\\n  | fSupp : TruncP (\\\\Sigma (s : Array (E {Dom})) (\\\\Pi (i : E {Dom}) -> (\\\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))\\n}', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| +-assoc {x y z : E} : x + y + z = x + (y + z)', '\\\\func ++_index-left {A2 : \\\\Type} {l2 m2 : Array A2} (i1 : Fin l.len) : at {l2 ++ m2} (index-left {A2} {l2} {m2} i1) = l.at i1 \\n  | {A}, {:: {n} a l}, {m}, zero => idp {A} {at {(a :: l) ++ m} (index-left {A} {a :: l} {m} 0)}\\n  | {A}, {:: {n} a l}, {m}, suc i => ++_index-left {A} {l} {m} i', 'inP A', '| Cod : BaseSet', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '| at (j : Fin len) : A j', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class AddMonoid \\\\extends AddPointed \\\\hlevels  {\\n  | \\\\infixl 6 + E E : E\\n  | zro-left {x : E} : zro + x = x\\n  | zro-right {x : E} : x + zro = x\\n  | +-assoc {x y z : E} : x + y + z = x + (y + z)\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func index-right {A1 : \\\\Type} {l1 m1 : Array A1} (_ : Fin m.len) : Fin (len {l1 ++ m1}) \\n  | {A}, {nil}, {m}, i => i\\n  | {A}, {:: {n} a l}, {m}, i => suc (index-right {A} {l} {m} i)', '| fSupp : TruncP (\\\\Sigma (s : Array (E {Dom})) (\\\\Pi (i : E {Dom}) -> (\\\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| zro-right {x : E} : x + zro = x', '\\\\func ++_index-right {A2 : \\\\Type} {l1 m2 : Array A2} {i2 : Fin m.len} : at {l1 ++ m2} (index-right {A2} {l1} {m2} i2) = m.at i2 \\n  | {A}, {nil}, {m}, {i} => idp {A} {at {nil ++ m} (index-right {A} {nil} {m} i)}\\n  | {A}, {:: {n} a l}, {m}, {i} => ++_index-right {A} {l} {m} {i}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| zro-left {x : E} : zro + x = x', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>AddMonoid (FinSuppFunc A B) {\n  | zro => \\new FinSuppFunc A B {\n    | func => \\lam (_ : E {Dom {\\this}}) => B.zro\n    | fSupp => {?hidden}\n  }\n  | + => \\lam (f : E {\\this}) (g : E {\\this}) => \\new FinSuppFunc A B {\n    | func => \\lam (a : E {Dom {\\this}}) => f.func a B.+ g.func a\n    | fSupp => {?hidden}\n  }\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n}", "completion": "\\new AddMonoid {\n  | E => FinSuppFunc A B\n  | AddPointed => FinSuppFuncAddPointed\n  | + => \\lam f g => \\new FinSuppFunc {\n    | func => \\lam a => f a + g a\n    | fSupp => \\scase fSupp {f}, fSupp {g} \\with {\n      | inP (s, c), inP (s', c') =>\n      inP (s ++ s', \\lam a d => pmap2 (+) (c a (\\lam j => rewrite ++_index-left in d (index-left j)))\n        (c' a (\\lam j => rewrite ++_index-right in d (index-right j))) *> zro-left)\n    }\n  }\n  | zro-left => exts (\\lam a => zro-left)\n  | zro-right => exts (\\lam a => zro-right)\n  | +-assoc => exts (\\lam a => +-assoc)\n}"}
{"prompt": "['a : \\\\Sigma (j : D.Ob) (F j)', 'D : BottomJoinSemilattice']<<<break>>>['| bottom : E', '| \\\\infix 4 <= E E : \\\\Prop', '| bottom-univ {x : E} : bottom <= x']<<<break>>>D.bottom D.<= a.1", "completion": "bottom-univ {D}"}
{"prompt": "['a : E {Dom {\\\\this}}', 'Uo : X.isOpen U', 'U : Set X.E', 'u3 : \\\\Pi {h : R.E} -> U (x.1 X.+ h X.*c (a X.+ b)) -> U (x.1 X.+ h X.*c a X.+ h X.*c b)', 'd : HasDeriv {R} {X} {Y} {U} Uo f', 'X : TopLModule R', 'x : Total {X.E} U', 'R : NearSkewField', 'f : Total {X.E} U -> Y.E', 'Y : HausdorffTopLModule R', 'b : E {Dom {\\\\this}}']<<<break>>>['\\\\class ContMap \\\\extends SetHom \\\\hlevels  {\\n  | func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))\\n}', '| \\\\infixl 6 + E E : E', '| +-cont : ContMap (ProductTopSpace \\\\this \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 + s.2\\n}', '\\\\lemma deriv-quot-cont \\\\hlevels  {R : NearSkewField} {X : TopLModule R} {Y : HausdorffTopLModule R} {U : Set X.E} {Uo : X.isOpen U}\\n  {f : Total {X.E} U -> Y.E} (gx : ContMap R X) (gh : ContMap R R) (ga : ContMap R X) (d : HasDeriv {R} {X} {Y} {U} Uo f)\\n  {V : Set R.E} (Vc : \\\\Pi {h : R.E} -> V h -> \\\\Sigma (U (gx.func h)) (U (gx.func h X.+ gh.func h X.*c ga.func h))) :\\nContMap (TopSub {R} V) Y {\\n  | func => \\\\lam (h : E {Dom {\\\\this}}) => deriv-quot {R} {X} {Y} {U} Uo f d ((gx.func h.1, (gh.func h.1, ga.func h.1)), Vc {h.1} h.2)\\n} ', '\\\\func tuple \\\\hlevels  {X Y Z : TopSpace} (f : ContMap X Y) (g : ContMap X Z) : ContMap X (Y \u2a2f Z) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, g.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\func TopSub \\\\hlevels  {X : TopSpace} (S : Set X.E) : TopSpace (\\\\Sigma (x : X.E) (\\\\property (S x))) {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) =>\\n    TruncP (\\\\Sigma (V : Set X.E) (X.isOpen V) (U = (\\\\lam (p0 : \\\\Sigma (x : X.E) (\\\\property (S x))) => p0.1) ^-1 V))\\n} => TopTransfer {\\\\Sigma (x : X.E) (\\\\property (S x))} {X} (\\\\lam (p0 : \\\\Sigma (x : X.E) (\\\\property (S x))) => p0.1)', '\\\\instance TopSpaceHasProduct \\\\hlevels  : HasProduct TopSpace {\\n  | Product => ProductTopSpace\\n} => \\\\new HasProduct', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : TopSpace} (g : ContMap Y Z) (f : ContMap X Y) : ContMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\func id \\\\hlevels  {X : TopSpace} : ContMap X X {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| *c-cont : ContMap (ProductTopSpace R \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 *c s.2\\n}', '\\\\func const \\\\hlevels  {Y X : TopSpace} (x : X.E) : ContMap Y X {\\n  | func => \\\\lam (_ : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| Dom : BaseSet']<<<break>>>ContMap (TopSub {R} (\\lam (x1 : R.E) =>\n  \\Sigma (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} (a X.+ b)))} x1))\n    (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1))))\n  (Y \u2a2f Y) {\n  | func => \\lam (x1 : E {Dom {\\this}}) =>\n  (func {deriv-quot-cont {R} {X} {Y} {U} {Uo} {f} (const {R} {X} x.1) (id {R}) (const {R} {X} a) d {\\lam (x1 : R.E) =>\n    \\Sigma (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} (a X.+ b)))} x1))\n      (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1))}\n      (\\lam {h1 : R.E} (u1 : (\\lam (x1 : R.E) =>\n      \\Sigma (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} (a X.+ b)))} x1))\n        (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1))) h1) =>\n        (x.2, u1.2))} x1,\n    func {deriv-quot-cont {R} {X} {Y} {U} {Uo} {f}\n      (+-cont {X} \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (*c-cont {X} \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a)))\n      (id {R}) (const {R} {X} b) d {\\lam (x1 : R.E) =>\n      \\Sigma (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} (a X.+ b)))} x1))\n        (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1))}\n      (\\lam {h : R.E}\n        (u : \\Sigma (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} (a X.+ b)))} h))\n          (U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} h))) =>\n        (u.2, u3 {(func {tuple {R} {R} {X} (id {R}) (const {R} {X} a)} h).1} u.1))} x1)\n}", "completion": "tuple (deriv-quot-cont (const x.1) id (const a) d (\\lam u => later (x.2, u.2))) (deriv-quot-cont\n  (+-cont \u2218 tuple (const x.1) (*c-cont \u2218 tuple id (const a))) id (const b) d (\\lam u => later (u.2, u3 u.1)))"}
{"prompt": "['b : E {L {\\\\this}}', 'j : Nucleus {L}', \"j' : Nucleus {L}\", 'L : Locale', 'p : \\\\Sigma (y : L.E) (a L.\u2227 b L.<= y)']<<<break>>>['| Join {J : \\\\Set} (J -> E) : E', '\\\\func Total {B : \\\\Type} (F : B -> \\\\Type) : \\\\Type => \\\\Sigma (b : B) (F b)', '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| Meet {J : \\\\Set} (J -> E) : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| Meet-cond {J : \\\\Set} (j : J) {f : J -> E} : Meet {J} f <= f j', '| join-left {x y : E} : x <= x \u2228 y']<<<break>>>Meet {L} {\\Sigma (y : L.E) (b L.<= y)}\n  (\\lam (j1 : \\Sigma (y : L.E) (b L.<= y)) => L.Join {\\Sigma (b : L.E) (b L.\u2227 j.nucleus j1.1 L.<= j'.nucleus j1.1)}\n    (\\lam (t : Total {L.E} (\\lam (p0 : L.E) => p0 L.\u2227 j.nucleus j1.1 L.<= j'.nucleus j1.1)) => t.1)) <= (\\lam (j1 : \\Sigma (y : L.E) (b L.<= y)) => L.Join {\\Sigma (b : L.E) (b L.\u2227 j.nucleus j1.1 L.<= j'.nucleus j1.1)}\n  (\\lam (t : Total {L.E} (\\lam (p0 : L.E) => p0 L.\u2227 j.nucleus j1.1 L.<= j'.nucleus j1.1)) => t.1))\n  (b \u2228 p.1, join-left {L} {b} {p.1})", "completion": "Meet-cond (later (b \u2228 p.1, join-left))"}
{"prompt": "['F : Functor D RingCat', \"this : RingHom (F.F d) (RingLatticeColimit {D} F1) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) =>\\n  in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}\", 'D : BottomJoinSemilattice', 'd : D.E']<<<break>>>[\"\\\\type SetColimit \\\\hlevels  {J : Precat} (F1 : Functor J SetCat) : \\\\Set \\n=> Quotient {\\\\Sigma (j : J.Ob) (F.F j)} (\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2))\", '| Hom Ob Ob : \\\\Set', \"\\\\lemma ~-cequiv \\\\hlevels  {J : Precat} {F1 : Functor J SetCat} {s s' : \\\\Sigma (j : J.Ob) (F.F j)} (f : J.Hom s.1 s'.1)\\n  (_ : F.Func {s.1} {s'.1} f s.2 = s'.2) :\\nin~ {\\\\Sigma (j : J.Ob) (F.F j)} {\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2)} s = in~ {\\\\Sigma (j : J.Ob) (F.F j)} {\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2)} s' \", '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}', '\\\\func forget : Functor RingCat SetCat (\\\\lam (R : Ob {C {\\\\this}}) => R.E) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f.func\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func forgetToMonoid : Functor RingCat MonoidCat (\\\\lam (R : Ob {C {\\\\this}}) => R) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| join-left {x y : E} : x <= x \u2228 y', '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| \\\\infixl 7 * E E : E', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| Ob : \\\\hType', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| func (E {Dom}) : E {Cod}', '| join-right {x y : E} : y <= x \u2228 y', '| Dom : BaseSet', '\\\\instance RingCat : Cat Ring {\\n  | Hom => RingHom\\n  | id => RingHom.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\instance MonoidCat : Cat Monoid {\\n  | Hom => MonoidHom\\n  | id => MonoidHom.id\\n  | o => \\\\lam {x y z : Ob {\\\\this}} (g : Hom {\\\\this} y z) (f : Hom {\\\\this} x y) => \\\\new MonoidHom x z {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n    | func-ide => {?hidden}\\n    | func-* => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', 'in~ A']<<<break>>>\\Pi {x : E {Dom {\\this}}} -> \\Pi {y : E {Dom {\\this}}} ->\n  in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, x * y) = in~ {\\Sigma (j : D.Ob) (F j)} {\\lam (s : \\Sigma (j : D.Ob) (F j)) (s' : \\Sigma (j : D.Ob) (F j)) =>\n    \\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n    (d D.\u2228 d, func {Func {d} {d D.\u2228 d} (D.join-left {d} {d})} x * func {Func {d} {d D.\u2228 d} (D.join-right {d} {d})} y)", "completion": "\\lam {x} {y} => ~-cequiv join-left func-*"}
{"prompt": "['this : ContMap (TopTransfer {X} {Y} f) Y {\\n  | func => f\\n  | func-cont => {?hidden}\\n}', 'U : E {Cod {\\\\this}} -> \\\\Prop', 'f : X -> Y.E', 'Uo : isOpen {Cod {\\\\this}} U', 'Y : TopSpace', 'X : \\\\Set']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| isOpen (Set E) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (V : Set Y.E) (Y.isOpen V) ((\\lam (x : E {Dom {\\this}}) => U (func {\\this} x)) = f ^-1 V))", "completion": "inP (U, Uo, idp)"}
{"prompt": "['A : StoneC*Algebra', 'x<=1 : x A.<= A.ide', '-x<=1 : A.negative x A.<= A.ide', 'x : A.E']<<<break>>>['\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\func c*abs \\\\hlevels  {A : StoneC*Algebra} (a : A.E) (a<=1 : a A.<= A.ide) (-a<=1 : A.negative a A.<= A.ide) : A.E \\n  => sqrt-t {A} (a A.* a, square-norm {A} {a} {a<=1} { -a<=1})', '| E : \\\\Set', '\\\\lemma ide_*q \\\\hlevels  {this : QModule} {a : E} : fromInt (pos 1) *q a = a ', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', 'pos Nat']<<<break>>>fromInt (pos 1) *q c*abs {A} x x<=1 -x<=1 = c*abs {A} x x<=1 -x<=1", "completion": "ide_*q {A}"}
{"prompt": "[\"uU : L.isUniform U'\", 'L : UniformLocale', \"U' : L.E -> \\\\Prop\"]<<<break>>>['| isUniform (E -> \\\\Prop) : \\\\Prop', '| star-uniform {U : E -> \\\\Prop} (isUniform U) : TruncP (\\\\Sigma (V : E -> \\\\Prop) (isUniform V) (\\\\Pi (x : E) -> V x -> U (star x V)))', '| E : \\\\Set', '\\\\func star \\\\hlevels  {L : Locale} (x : L.E) (U : L.E -> \\\\Prop) : L.E => SJoin {L} (\\\\lam (y : L.E) => \\\\Sigma (U y) (IsPositive {L} (x L.\u2227 y)))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (V : L.E -> \\Prop) (L.isUniform V) (\\Pi (x : L.E) -> V x -> U' (star {L} x V)))", "completion": "star-uniform uU"}
{"prompt": "['x : E', 'b : Rat', 'y : E', 'b>0 : U {zro} b', 'this : MeasureRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| meas E : ExUpperReal', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\lemma OBall-center \\\\hlevels  {this : PremeasureRing} {a : E} {eps : Rat} (_ : zro < eps) {c : E} : OBall a eps c c ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma OBall-open \\\\hlevels  {this : PremeasureRing} (a : E) {eps : Rat} {c : E} : isOpen (OBall a eps c) ', '\\\\lemma makeCauchy \\\\hlevels  {this : PreuniformSpace} {C : Set (Set E)} (_ : isUniform C) : isCauchy C ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma half>0 \\\\plevels  \\\\hlevels  {a : Rat} (_ : fromInt (pos 0) < a) : fromInt (pos 0) < half a ', '| U Rat : \\\\Prop', '| E : \\\\Set', '\\\\func half \\\\plevels  \\\\hlevels  (a : Rat) : Rat => a * ratio (pos 1) 2', '\\\\func topAbUniform \\\\hlevels  {this : TopAbGroup} {U : Set E} (Uo : isOpen U) (U0 : U zro) :\\n  isUniform (\\\\lam (V : Set E) => TruncP (\\\\Sigma (x : E) (V = (\\\\lam (y : E) => U (x - y))))) \\n  => (neighborhood-uniform {\\\\lam (V : Set E) => TruncP (\\\\Sigma (x : E) (V = (\\\\lam (y : E) => U (x - y))))}).2\\n  (inP {\\\\Sigma (U1 : Set E) (isOpen U1) (U1 zro) (\\\\Pi (x : E) ->\\n    TruncP (\\\\Sigma (V : Set E) (TruncP (\\\\Sigma (x : E) (V = (\\\\lam (y : E) => U (x - y))))) (\\\\Pi {y : E} -> U1 (x - y) -> V y)))}\\n    (U, Uo, U0,\\n      \\\\lam (x : E) => inP {\\\\Sigma (V : Set E) (TruncP (\\\\Sigma (x : E) (V = (\\\\lam (y : E) => U (x - y))))) (\\\\Pi {y : E} -> U (x - y) -> V y)}\\n        (\\\\lam (y : E) => U (x - y), inP {\\\\Sigma (x1 : E) ((\\\\lam (y : E) => U (x - y)) = (\\\\lam (y : E) => U (x1 - y)))}\\n          (x, idp {E -> \\\\Prop} {\\\\lam (y : E) => U (x - y)}), \\\\lam {y : E} (u : U (x - y)) => u)))']<<<break>>>isCauchy (\\lam (V : Set E) => TruncP (\\Sigma (x1 : E) (V = (\\lam (y1 : E) => U {meas ((x - y) * (zro + (x1 - y1)))} (half b)))))", "completion": "makeCauchy {this} (topAbUniform {this} (OBall-open {this} (x - y)) $ OBall-center {this} (half>0 b>0))"}
{"prompt": "['eps : Rat']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\lemma natUnit \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n * m = 1) : m = 1 ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '| \\\\infix 4 <= E E : \\\\Prop', '| zro-right {x : E} : x + zro = x', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', 'pos Nat', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| zro_*-left {x : E} : zro * x = zro', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}']<<<break>>>rat (pos 1) 1 {?hidden} {?hidden} + zro {RatField} * eps <= rat (pos 1) 1 {?hidden} {?hidden}", "completion": "=_<= (pmap ((+) _) zro_*-left *> zro-right)"}
{"prompt": "['x : Ob', 'z : Ob', 'this : PrecatWithBprod', 'y : Ob']<<<break>>>['| Hom Ob Ob : \\\\Set', '\\\\lemma pair-comp \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z w : Ob} {f : Hom x y} {g : Hom y z} {h : Hom y w} :\\n  pair {z} {w} {y} g h \u2218 f = pair {z} {w} {x} (g \u2218 f) (h \u2218 f) ', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\func proj2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 1) => proj {Bprod x y} 1', '| Bprod (x y : Ob) : Product {Fin 2} (at {x :: y :: nil})', '| apex : Ob {D}', '| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| id (X : Ob) : Hom X X', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '\\\\func proj1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 0) => proj {Bprod x y} 0', '\\\\lemma beta2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : proj2 {x} {y} \u2218 pair {x} {y} {z} f g = g ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma pair-proj \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} :\\n  pair {x} {y} {apex {Bprod x y}} (proj1 {x} {y}) (proj2 {x} {y}) = id (apex {Bprod x y}) ', '\\\\lemma beta1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : proj1 {x} {y} \u2218 pair {x} {y} {z} f g = f ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func pair \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : Hom z (apex {Bprod x y}) \\n=> tupleMap {Bprod x y} {z} (\\\\lam (p0 : J {Bprod x y}) => (\\\\case p0 \\\\with {\\n  | zero => f\\n  | suc zero => g\\n}))']<<<break>>>pair {x} {apex {Bprod y z}} {apex {Bprod x (apex {Bprod y z})}} (proj1 {x} {apex {Bprod y z}})\n  (pair {y} {z} {apex {Bprod x (apex {Bprod y z})}}\n    (proj2 {x} {y} \u2218 proj1 {apex {Bprod x y}} {z} \u2218 pair {apex {Bprod x y}} {z} {apex {Bprod x (apex {Bprod y z})}}\n      (pair {x} {y} {apex {Bprod x (apex {Bprod y z})}} (proj1 {x} {apex {Bprod y z}}) (proj1 {y} {z} \u2218 proj2 {x} {apex {Bprod y z}}))\n      (proj2 {y} {z} \u2218 proj2 {x} {apex {Bprod y z}})) (proj2 {y} {z} \u2218 proj2 {x} {apex {Bprod y z}})) = id (apex {Bprod x (apex {Bprod y z})})", "completion": "rewrite (o-assoc {this}) (rewrite (beta1 {this}) (rewrite (beta2 {this})\n  (rewrite (inv (pair-comp {this})) (rewrite (pair-proj {this}) (rewrite (id-left {this}) (pair-proj {this}))))))"}
{"prompt": "['x : E', 'n : Nat', 'this : RealPreBanachSpace']<<<break>>>['\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma *n_* \\\\plevels  \\\\hlevels  {n : Nat} {x : ExUpperReal} (_ : zro <= x) (_ : IsBounded {x}) : n *n x = fromRat (fromInt (pos n)) * x ', '\\\\lemma norm>=0 \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : zro <= X.norm x ', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '| norm-bounded (x : E) : IsBounded {norm x}', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a', 'pos Nat']<<<break>>>n *n norm x = fromRat (fromInt (pos n)) * norm x", "completion": "*n_* norm>=0 (norm-bounded {this} x)"}
{"prompt": "['L : Locale', \"j<=j' : j <= j'\", \"j' : Nucleus {L}\", 'j : Nucleus {L}', 'f : J -> E {Dom {\\\\this}}', 'J : \\\\Set']<<<break>>>['| nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y', '| Join {J : \\\\Set} (J -> E) : E', '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop']<<<break>>>j'.nucleus (j.nucleus (L.Join {J} (\\lam (p0 : J) => (f p0).1))) L.<= j'.nucleus (j'.nucleus (L.Join {J} (\\lam (p0 : J) => (f p0).1)))", "completion": "nucleus-<= j<=j'"}
{"prompt": "['n : Nat', 'l : Array (\\\\Sigma V.E B.E) n', 'B : BottomDistributiveLattice', 'a : \\\\Sigma V.E B.E', 'V : AddGroup']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma ~_negative-left \\\\hlevels  {V : AddGroup} {B : BottomDistributiveLattice} {l : Array (\\\\Sigma V.E B.E)} :\\n  map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (V.negative s.1, s.2)) l ++ l ~ nil ', \"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', \"~-zro-left {b : B.E} (l = (V.zro, b) :: l')\", '| zro : E', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', \"~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\", '| at (j : Fin len) : A j', '| E : \\\\Set', '| negative E : E']<<<break>>>(V.zro, a.2) :: \\new Array (\\Sigma V.E B.E) n (\\lam (j : Fin n) => (V.negative (at {a :: l} (suc j)).1, (at {a :: l} (suc j)).2)) ++ l ~ nil", "completion": "~-trans (~-zro-left idp) (~_negative-left {V} {B})"}
{"prompt": "['p0 : \\\\Sigma E E', \"x' : Real\", \"xy<eps_x'y'<eps : Prod {E} {E} (\\\\lam (y : Real) => U {dist x y} eps) (\\\\lam (y : Real) => U {dist x' y} eps) p0\", 'eps : Rat']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\lemma real_<_U \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : x < fromRat a <-> x.U a ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\lemma abs>=id \\\\hlevels  {this : LatticeAbGroup} {x : E} : x <= abs x ', '| \\\\infix 4 < E E : \\\\Prop', 'join \\\\plevels  \\\\hlevels  (x y : Real) : Real => \\\\new Real (L {InfRealAbMonoid.join x y}) (U {InfRealAbMonoid.join x y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func RealNormedAbGroup \\\\hlevels  : NormedAbGroup Real {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', '| negative E : E', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>x' + negative p0.2 < fromRat eps", "completion": "abs>=id {RealAbGroup} <\u2218r real_<_U.2 x'y'<eps"}
{"prompt": "['k : DiscreteField', 'x : k.E']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| zro-right {x : E} : x + zro = x', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| ide-right {x : E} : x * ide = x']<<<break>>>x = x k.* k.ide k.+ k.zro", "completion": "transport (\\lam x0 => substitution_meta)\n  (inv (path (\\lam (i : I) => k.ide-right {x} @ i k.+ k.zro) *> path ((@) (k.zro-right {x})))) idp"}
{"prompt": "['z : E {\\\\this}', 'y : E {\\\\this}', 'Y : Ob {\\\\this}', 'e : X.E', 'arg : \\\\Pi (e : X.E) -> x.func e Y.+ y.func e Y.+ z.func e = x.func e Y.+ (y.func e Y.+ z.func e)', 'x : E {\\\\this}']<<<break>>>['| \\\\infixl 6 + E E : E', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}']<<<break>>>x.func e Y.+ y.func e Y.+ z.func e = x.func e Y.+ (y.func e Y.+ z.func e)", "completion": "arg e"}
{"prompt": "['r : R.E', 'R : CRing']<<<break>>>['| \\\\infixl 7 * E E : E', '| ide : E', '| E : \\\\Set', '| ide-right {x : E} : x * ide = x']<<<break>>>r R.* R.ide R.* R.ide = r R.* R.ide", "completion": "ide-right {_} {r R.* R.ide}"}
{"prompt": "['R : Ring', 'c : Int']<<<break>>>['\\\\lemma intCoef-correct \\\\hlevels  {R : Ring} {x : Int} : Ring.intCoef {R} x = RingSolverModel.intCoef {R} x ', '| E : \\\\Set', '\\\\func intCoef \\\\hlevels  {R3 : Ring} (_ : Int) : R.E \\n  | {R}, pos n => SemiringSolverModel.natCoef {R} n\\n  | {R}, neg (suc 0) => R.negative R.ide\\n  | {R}, neg (suc n) => R.negative (R.natCoef (suc n))', '\\\\func intCoef \\\\hlevels  {this2 : Ring} (_ : Int) : E \\n  | {this}, pos n => natCoef n\\n  | {this}, neg (suc n) => negative (natCoef (suc n))']<<<break>>>Ring.intCoef {R} c = RingSolverModel.intCoef {R} c", "completion": "intCoef-correct {R}"}
{"prompt": "['A : Matrix R.E 1 2', 'R : CRing', 'bez_diag : at {(\\\\Sigma (IsStrictBezout {R}) (IsKaplansky R)) :: (\\\\Sigma (IsStrictBezout {R}) (\\\\Pi (A : Matrix R.E 2 2) ->\\n  at {at {A} 1} 0 = R.zro -> IsCoprimeArray {R} (at {at {A} 0} 0 :: at {at {A} 0} 1 :: at {at {A} 1} 1 :: nil) ->\\n    TruncP (\\\\Sigma (B : Matrix R.E 2 2) (IsDiagonal {R} {2} {2} B) (A M~ B)))) :: (\\\\Pi {n m : Nat} ->\\n    n <= m -> m <= 2 -> \\\\Pi (A : Matrix R.E n m) -> TruncP (\\\\Sigma (B : Matrix R.E n m) (IsDiagonal {R} {n} {m} B) (A M~ B))) :: (\\\\Pi {n m : Nat} -> \\\\Pi (A : Matrix R.E n m) -> TruncP (\\\\Sigma (B : Matrix R.E n m) (IsSmith {R} {n} {m} B) (A M~ B))) :: nil}\\n    1']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 6 + E E : E', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '| \\\\infixl 7 * E E : E', '| val : E {M}', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func determinant {R : CRing} {n : Nat} (M : Matrix R.E n n) : R.E => FinSum {R} {SymFin n}\\n  (\\\\lam (e : Sym n) => sign {R} {n} e R.* BigProd {R} (\\\\new Array R.E n (\\\\lam (j : Fin n) => at {at {M} (f {e} j)} j)))', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set', '| negative E : E', '\\\\func \\\\infixl 7 product \\\\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))', '| len : Nat', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', ':negative (RingTerm C V)', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '| vars : Array (E {M})', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\type IsDiagonal \\\\hlevels  {R : AddPointed} {n m : Nat} (A : Matrix R.E n m) : \\\\Prop \\n  => \\\\Pi {i : Fin n} -> \\\\Pi {j : Fin m} -> i /= j -> at {at {A} i} j = R.zro', '\\\\func makeMatrix {R : \\\\Type} {n m : Nat} (M : Array (Array R m) n) : Matrix R n m => M', '| C : Semiring', 'coef C', 'nil', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', 'inP A', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\instance MatrixRing \\\\hlevels  (R : Ring) (n : Nat) : Ring (Matrix R.E n n) {\\n  | zro => \\\\new Array (Array R.E n) n (\\\\lam (_ : Fin n) => \\\\new Array R.E n (\\\\lam (_ : Fin n) => R.zro))\\n  | + => \\\\lam (M : E) (N : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => at {at {M} i} j R.+ at {at {N} i} j)\\n  | * => (product)\\n  | negative => \\\\lam (M : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => R.negative (at {at {M} i} j))\\n  | ide => ide {R} {n}\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\lemma determinant22 {R : CRing} {A : Matrix R.E 2 2} :\\n  determinant {R} {2} A = at {at {A} 0} 0 R.* at {at {A} 1} 1 - at {at {A} 1} 0 R.* at {at {A} 0} 1 ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', ':ide', '\\\\func ide {R : Ring} {n : Nat} : Matrix R.E n n => diagonal {R} (replicate {R.E} n R.ide)', '\\\\func matrixExt {R : \\\\Type} {n m : Nat} {M N : Matrix R n m}\\n  (p : \\\\Pi (i : Fin n) -> \\\\Pi (j : Fin m) -> at {at {M} i} j = at {at {N} i} j) : M = N \\n  => path (\\\\lam (i : I) => mkMatrix {R} {n} {m} (\\\\lam (j : Fin n) (k : Fin m) => p j k @ i))', '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', ':zro', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma determinant11 {R : CRing} (A : Matrix R.E 1 1) : determinant {R} {1} A = at {at {A} 0} 0 ', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ', '\\\\lemma determinant1_Inv {R : CRing} {n : Nat} (A : Matrix R.E n n) (_ : determinant {R} {n} A = R.ide) : Inv {MatrixRing R n} A ', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)', '\\\\type \\\\infix 4 M~ \\\\hlevels  {R : Ring} {n m : Nat} (A B : Matrix R.E n m) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (B = C.val product A product D.val))']<<<break>>>TruncP (\\Sigma (B : Matrix R.E 1 2) (IsDiagonal {R} {1} {2} B) (A M~ B))", "completion": "map (bez (A 0 0) (A 0 1)) (\\lam p0 => (\n  \\let (s, t, u, v, au=bv, su+tv=1) => p0\n  \\in (makeMatrix ((s * A 0 1 + t * A 0 0, zro) :: nil), \\lam {i} {j} => (\\case \\elim i, \\elim j \\with {\n        | 0, 0 => \\lam p => absurd (p idp)\n        | 0, 1 => \\lam _ => idp\n      }),\n        inP (determinant1_Inv ide (determinant11 ide), \n          \\let C => makeMatrix ((t, negative u), (s, v))\n          \\in determinant1_Inv C (determinant22 {_} {C} *> equation),\n          matrixExt (\\lam p0 p1 => (\\case \\elim p0, \\elim p1 \\with {\n            | 0, 0 => equation\n            | 0, 1 => equation\n          }))))))"}
{"prompt": "['G : Group', 'B : LinRepres R G', 'R : Ring', 'e : E {Dom {\\\\this}}', 'A : LinRepres R G', 'g : E {G {\\\\this}}']<<<break>>>['\\\\func ProductLRepres \\\\hlevels  {R1 : Ring} {G1 : Group} (A B : LinRepres R1 G1) : LinRepres R1 G1 (\\\\Sigma A.E B.E) {\\n  | zro => (A.zro, B.zro)\\n  | + => \\\\lam (p : E) (q : E) => (p.1 A.+ q.1, p.2 B.+ q.2)\\n  | negative => \\\\lam (p : E) => (A.negative p.1, B.negative p.2)\\n  | *c => \\\\lam (r : E {R}) (p : E) => (r A.*c p.1, r B.*c p.2)\\n  | ** => \\\\lam (g : E {G {\\\\this}}) (p0 : E {\\\\this}) => (g A.** p0.1, g B.** p0.2)\\n} => \\\\new LinRepres {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | **-assoc => {?hidden}\\n  | id-action => {?hidden}\\n  | **-ldistr => {?hidden}\\n  | **-*c => {?hidden}\\n}', '| zro : E', '| \\\\infixl 8 ** (E {G}) E : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '\\\\lemma g**-zro \\\\hlevels  {this : LinRepres} {g : E {G}} : g ** zro = zro ']<<<break>>>(g A.** e, B.zro) = g ** (e, B.zro)", "completion": "rewrite (pmap (\\lam z => (g ** {A} e, z)) (inv $ g**-zro {B} {g})) idp"}
{"prompt": "['U : Set Y.E', 'Uo : Y.isOpen U', 'Y : TopSpace']<<<break>>>['\\\\func defined \\\\hlevels  {X : \\\\Set} (x : X) : Partial X {\\n  | isDefined => \\\\Sigma\\n  | value => \\\\lam (_ : isDefined {\\\\this}) => x\\n} => \\\\new Partial', '| isDefined : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'byRight B', \"\\\\instance PartialTopSpace \\\\hlevels  (Y : TopSpace) : TopSpace (Partial Y.E) {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) => \\\\Pi {y : Partial Y.E} ->\\n    U y -> (U = top) || (\\\\Sigma (U' : Set Y.E) (Y.isOpen U') (p : y.isDefined) (U' (y.value p)) (\\\\Pi {y' : Y.E} -> U' y' -> U (defined {Y.E} y')))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}\", '| value isDefined : E', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\class Partial \\\\hlevels  {\\n  | E : \\\\Set\\n  | isDefined : \\\\Prop\\n  | value isDefined : E\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| top : E', '| isOpen (Set E) : \\\\Prop', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>\\Pi {y : Partial Y.E} -> \\Sigma (p : y.isDefined) (U (y.value p)) ->\n  ((\\lam (s : E) => \\Sigma (p : s.isDefined) (U (s.value p))) = top) || (\\Sigma (U' : Set Y.E) (Y.isOpen U') (p : y.isDefined) (U' (y.value p))\n    (\\Pi {y' : Y.E} -> U' y' -> \\Sigma (p : isDefined {defined {Y.E} y'}) (U (value {defined {Y.E} y'} p))))", "completion": "\\lam yd => byRight (U, Uo, yd.1, yd.2, \\lam Uy' => ((), Uy'))"}
{"prompt": "['this : OrderedSemiring']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| natCoef Nat : E', '| zro-right {x : E} : x + zro = x', '| E : \\\\Set']<<<break>>>natCoef 0 + zro = natCoef 0", "completion": "zro-right {this}"}
{"prompt": "['M : UniformLocale', 'L : UniformLocale', 'a : at {M.E :: M.E :: (\\\\Sigma (U : M.E -> \\\\Prop) (M.isUniform U)) :: M.E :: nil} 1', 'f : UniformHom M L']<<<break>>>['| isUniform (E -> \\\\Prop) : \\\\Prop', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma <=u_<= \\\\hlevels  {L : PreuniformLocale} {a b : L.E} (_ : a <=u b) : a L.<= b ', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', 'cover-basic (P.BasicCover {J} x g)', '\\\\lemma func_positive \\\\hlevels  {f : FrameHom} {x : E {f.Dom}} (_ : IsPositive {f.Cod} (f.func x)) : IsPositive {f.Dom} x ', '\\\\func \\\\infix 4 <=u \\\\hlevels  {L : PreuniformLocale} (a b : L.E) : \\\\Prop => TruncP (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U) (star {L} a U L.<= b))', '\\\\func closure \\\\hlevels  {P : FramePres} {J : \\\\Set} (g : J -> P.E) : Opens P \\n=> (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g, \\\\lam (x : P.E) (c : SCover {P} x (\\\\lam (p0 : P.E) => Cover {P} p0 {J} g)) =>\\n  cover-trans {P} {x} {J} {g} {\\\\Sigma (x : P.E) (Cover {P} x {J} g)} {\\\\lam (t : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => t.1} c (\\\\lam (p0 : \\\\Sigma (x : P.E) (Cover {P} x {J} g)) => p0.2))', '| func-<= {x y : E {Dom}} (x <= y) : func x <= func y', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', 'cover-inj (j : J) (g j = x)', '\\\\func CompletionPres \\\\hlevels  (L : UniformLocale) : FramePres L.E {\\n  | conj => (L.\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U)) :: L.E :: nil} j)} {L.E}\\n    (\\\\lam (p0 : \\\\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U)) :: L.E :: nil} j)) =>\\n    (\\\\case p0 \\\\with {\\n      | (zero, a) => (\\\\Sigma, a, \\\\lam (_ : \\\\Sigma) => L.top)\\n      | (suc zero, a) => (IsPositive {L} a, a, \\\\lam (_ : IsPositive {L} a) => a)\\n      | (suc (suc zero), U) => (\\\\Sigma (x : L.E) (U.1 x), L.top, \\\\lam (p0 : \\\\Sigma (x : L.E) (U.1 x)) => p0.1)\\n      | (suc (suc (suc zero)), a) => (\\\\Sigma (b : L.E) (b <=u a), a, \\\\lam (p0 : \\\\Sigma (b : L.E) (b <=u a)) => p0.1)\\n    }))\\n} => \\\\new FramePres', '| at (j : Fin len) : A j', '| top : E', '\\\\lemma positive_<= \\\\hlevels  {this : Locale} {a b : E} (_ : IsPositive a) (_ : a <= b) : IsPositive b ', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func IsPositive \\\\hlevels  {this : Locale} (a : E) : \\\\Prop => \\\\Pi (P : \\\\Prop) -> a <= pHat P -> P', '\\\\lemma indexing-make \\\\hlevels  {I X : \\\\Set} {h : I -> \\\\Sigma (J : \\\\Set) X (J -> X)} (i : I) : Indexing {I} {X} h {(h i).1} (h i).2 (h i).3 ']<<<break>>>\\Pi (p : \\Sigma (b : M.E) (b <=u (\\case (1, a) \\with {\n  | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => M.top)\n  | (suc zero, a) => (IsPositive {M} a, a, \\lam (_ : IsPositive {M} a) => a)\n  | (suc (suc zero), U) => (\\Sigma (x : M.E) (U.1 x), M.top, \\lam (p0 : \\Sigma (x : M.E) (U.1 x)) => p0.1)\n  | (suc (suc (suc zero)), a) => (\\Sigma (b : M.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : M.E) (b <=u a)) => p0.1)\n}).2)) -> Cover {CompletionPres L} (f.func p.1) {\\Sigma (j : (\\case (1, a) \\with {\n  | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => M.top)\n  | (suc zero, a) => (IsPositive {M} a, a, \\lam (_ : IsPositive {M} a) => a)\n  | (suc (suc zero), U) => (\\Sigma (x : M.E) (U.1 x), M.top, \\lam (p0 : \\Sigma (x : M.E) (U.1 x)) => p0.1)\n  | (suc (suc (suc zero)), a) => (\\Sigma (b : M.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : M.E) (b <=u a)) => p0.1)\n}).1) (x : E) ((closure {CompletionPres L} {\\Sigma (b : M.E) (b <=u (\\case (1, a) \\with {\n  | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => M.top)\n  | (suc zero, a) => (IsPositive {M} a, a, \\lam (_ : IsPositive {M} a) => a)\n  | (suc (suc zero), U) => (\\Sigma (x : M.E) (U.1 x), M.top, \\lam (p0 : \\Sigma (x : M.E) (U.1 x)) => p0.1)\n  | (suc (suc (suc zero)), a) => (\\Sigma (b : M.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : M.E) (b <=u a)) => p0.1)\n}).3 j)}\n  (\\lam (t : \\Sigma (b : M.E) (b <=u (\\case (1, a) \\with {\n    | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => M.top)\n    | (suc zero, a) => (IsPositive {M} a, a, \\lam (_ : IsPositive {M} a) => a)\n    | (suc (suc zero), U) => (\\Sigma (x : M.E) (U.1 x), M.top, \\lam (p0 : \\Sigma (x : M.E) (U.1 x)) => p0.1)\n    | (suc (suc (suc zero)), a) => (\\Sigma (b : M.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : M.E) (b <=u a)) => p0.1)\n  }).3 j)) => f.func t.1)).1 x)}\n  (\\lam (p0 : \\Sigma (j : (\\case (1, a) \\with {\n    | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => M.top)\n    | (suc zero, a) => (IsPositive {M} a, a, \\lam (_ : IsPositive {M} a) => a)\n    | (suc (suc zero), U) => (\\Sigma (x : M.E) (U.1 x), M.top, \\lam (p0 : \\Sigma (x : M.E) (U.1 x)) => p0.1)\n    | (suc (suc (suc zero)), a) => (\\Sigma (b : M.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : M.E) (b <=u a)) => p0.1)\n  }).1) (x : E) ((closure {CompletionPres L} {\\Sigma (b : M.E) (b <=u (\\case (1, a) \\with {\n    | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => M.top)\n    | (suc zero, a) => (IsPositive {M} a, a, \\lam (_ : IsPositive {M} a) => a)\n    | (suc (suc zero), U) => (\\Sigma (x : M.E) (U.1 x), M.top, \\lam (p0 : \\Sigma (x : M.E) (U.1 x)) => p0.1)\n    | (suc (suc (suc zero)), a) => (\\Sigma (b : M.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : M.E) (b <=u a)) => p0.1)\n  }).3 j)}\n    (\\lam (t : \\Sigma (b : M.E) (b <=u (\\case (1, a) \\with {\n      | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => M.top)\n      | (suc zero, a) => (IsPositive {M} a, a, \\lam (_ : IsPositive {M} a) => a)\n      | (suc (suc zero), U) => (\\Sigma (x : M.E) (U.1 x), M.top, \\lam (p0 : \\Sigma (x : M.E) (U.1 x)) => p0.1)\n      | (suc (suc (suc zero)), a) => (\\Sigma (b : M.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : M.E) (b <=u a)) => p0.1)\n    }).3 j)) => f.func t.1)).1 x)) => p0.2)", "completion": "\\lam p => cover-trans (cover-basic $ indexing-make $ later (1, f p.1)) (\\lam fp1>0 => cover-inj (func_positive $ positive_<= fp1>0 $ func-<= $ <=u_<= p.2, f p.1, cover-inj p idp) idp)"}
{"prompt": "['this : OrderedC*Algebra', 'b : E', 'a : E']<<<break>>>['| \\\\infixl 6 + E E : E', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func norm {this1 : OrderedC*Algebra} (a : E) :\\n  ExUpperReal (\\\\lam (q : Rat) => TruncP (\\\\Sigma (r : Rat) (r < q) (zro < r) (a <= r *q ide) (negative a <= r *q ide))) \\n=> \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', '| \\\\infixl 7 * E E : E', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| negative E : E']<<<break>>>ExUpperReal (\\lam (q : Rat) => TruncP (\\Sigma (r : Rat) (r < q) (zro < r) (a * a + b * b <= r *q ide) (negative (a * a + b * b) <= r *q ide)))", "completion": "norm {this} (a * {this} a + {this} b * {this} b)"}
{"prompt": "['e : Iso']<<<break>>>['\\\\class Pointed \\\\extends BaseSet \\\\hlevels  {\\n  | ide : E\\n}', '| dom : Ob {C}', '| ide : E', '| E : \\\\Set']<<<break>>>Pointed (E {e.dom}) {\n  | ide => ide {e.dom}\n}", "completion": "dom {e}"}
{"prompt": "['j : Fin n', 'l : Array (Fin n) (suc k)', 'inj : IsInj {Fin (suc k)} {Fin n} l.at', 'n : Nat', 'k : Nat']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', 'suc Nat', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func cycle {n2 k1 : Nat} (l1 : Array (Fin n2) k1) (_ : IsInj {Fin k1} {Fin n2} l.at) : Sym n2 \\n  | {n}, {0}, l, inj => ide\\n  | {n}, {suc k}, l, inj => isEquiv {FinFin n} (func {n} {k} l) (func-inj {n} {k} {l} inj)', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', 'inr B', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func lift \\\\plevels  \\\\hlevels  {n : Nat} (e : Sym n) : Sym (suc n) => aux {n} {n} e', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Index {A : \\\\Type} (x : A) (l : Array A) : \\\\Type => \\\\Sigma (i : Fin l.len) (l.at i = x)', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\func fsuc \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : Fin (suc n) => suc x', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', 'index-dec \\\\hlevels  {A : DecSet} (l : Array A.E) (a : A.E) : Or (Index {A.E} a l) (Not (Index {A.E} a l)) \\n=> \\\\case find {A.E} (\\\\lam (p0 : A.E) => EqualityDecide A p0 a) l \\\\with {\\n  | inl p => inl {Index {A.E} a l} {Not (Index {A.E} a l)} (p.1, p.2)\\n  | inr q => inr {Index {A.E} a l} {Not (Index {A.E} a l)} (\\\\lam (p : Index {A.E} a l) => q {p.1} p.2)\\n}', 'inl A', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func \\\\infixl 8 mod \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n mod m', '\\\\lemma unfsuc \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : suc x = suc y) : x = y ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\"]<<<break>>>f {lift {n} (cycle {n} {suc k} l inj)} (suc j) = f {cycle {suc n} {suc k} (map {Fin n} {Fin (suc n)} (fsuc {n}) l)\n  (\\lam {i : Fin (suc k)} {j : Fin (suc k)} (p : fsuc {n} (l.at i) = fsuc {n} (l.at j)) =>\n    inj {i} {j} (unfsuc {n} {l !! i} {l !! j} p))} (suc j)", "completion": "unfold (unfold func $ unfold $ mcases () (\\case  \\with {\n  | inl p, inl q => rewrite (inj $ p.2 *> inv (unfsuc q.2)) idp\n  | inl p, inr q => absurd $ q (p.1, pmap fsuc p.2)\n  | inr p, inl q => absurd $ p (q.1, unfsuc q.2)\n  | inr p, inr q => idp\n}))"}
{"prompt": "['this : CompleteLattice', 'x : E']<<<break>>>['| Meet-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> e <= f j) : e <= Meet {J} f', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| Meet {J : \\\\Set} (J -> E) : E', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ']<<<break>>>x <= Meet {Empty} (absurd {E})", "completion": "Meet-univ {this} (\\lam p0 => (\\case p0 \\with {}))"}
{"prompt": "['B : Real', 'x : InfReal', 'C : Set (Set InfReal)', 'eps : Real', 'x<B+eps : x < B + eps', 'h : \\\\Pi (x : Real) -> TruncP (\\\\Sigma (U : Set InfReal) (C U) (\\\\Pi {y : Real} -> abs {RealAbGroup} (x - y) < eps -> U y))']<<<break>>>['\\\\func inf-real-real \\\\plevels  \\\\hlevels  (x : InfReal) {B : Real} (x<B : x < B) : Real x.L x.U => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '| \\\\infixl 6 + E E : E', '\\\\class InfReal \\\\extends LowerReal, ExUpperReal \\\\hlevels  {\\n  | LU-disjoint {q : Rat} (L q) (U q) : Empty\\n  | LU-located {q r : Rat} (q < r) : L q || U r\\n  | LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>TruncP (\\Sigma (U : Set InfReal) (C U) (\\Pi {y : Real} -> abs {RealAbGroup} (inf-real-real x {B + eps} x<B+eps - y) < eps -> U y))", "completion": "h (inf-real-real x x<B+eps)"}
{"prompt": "['S : CRing', 'Szd : IsZeroDimensional {S}', 'a : S.E']<<<break>>>['| \\\\infixl 7 * E E : E', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>TruncP (\\Sigma (b : S.E) (n : Nat) (pow {S} a n = pow {S} a (suc n) S.* b))", "completion": "Szd a"}
{"prompt": "['p : pow {R} a 0 = pow {R} a 1 R.* b', 'a : R.E', 'b : R.E', 'R : CRing']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| E : \\\\Set', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>pow {R} a 0 - pow {R} a 1 R.* b = R.zro", "completion": "toZero {R} {R.ide} {R.ide R.* a R.* b} p"}
{"prompt": "['X : \\\\Set', 'f : X -> Y.E', 'Y : ExMetricSpace', 'fi : IsInj {X} {Y.E} f']<<<break>>>[\"\\\\func ExPseudoMetricTransfer \\\\hlevels  {X : \\\\Set} {Y : ExPseudoMetricSpace} (f : X -> Y.E) : ExPseudoMetricSpace X {\\n  | isOpen => \\\\lam (U : Set E) => TruncP (\\\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => ExPseudoMetricSpace.isUniform\\n  | dist => \\\\lam (x : E {\\\\this}) (x' : E {\\\\this}) => Y.dist (f x) (f x')\\n} => \\\\new ExPseudoMetricSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n}\", '| isCauchy (Set (Set E)) : \\\\Prop', '| dist E E : ExUpperReal', '\\\\class ExMetricSpace \\\\extends ExPseudoMetricSpace, SeparatedCoverSpace \\\\hlevels  {\\n  | dist-ext {x y : E} (dist x y = zro) : x = y\\n}', '| open-top : isOpen top', '\\\\lemma dist>=0 \\\\hlevels  {X : ExPseudoMetricSpace} {x y : X.E} : zro <= X.dist x y ', '| isSeparatedCoverSpace {x y : E} (\\\\Pi {C : Set (Set E)} -> isCauchy C -> TruncP (\\\\Sigma (U : Set E) (C U) (\\\\Sigma (U x) (U y)))) : x = y', '| dist-refl {x : E} : dist x x = zro', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\func isUniform \\\\hlevels  {this : ExPseudoMetricSpace} (C : Set (Set E)) : \\\\Prop \\n  => TruncP (\\\\Sigma (eps : Rat) (zro < eps) (\\\\Pi (x : E) -> TruncP (\\\\Sigma (U1 : Set E) (C U1) (\\\\Pi {y : E} -> U {dist x y} eps -> U1 y))))', '| isOpen (Set E) : \\\\Prop', '\\\\lemma half>0 \\\\plevels  \\\\hlevels  {a : Rat} (_ : fromInt (pos 0) < a) : fromInt (pos 0) < half a ', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '\\\\func half \\\\plevels  \\\\hlevels  (a : Rat) : Rat => a * ratio (pos 1) 2', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| dist-uniform {C : Set (Set E)} : isUniform C <-> TruncP (\\\\Sigma (eps : Rat) (zro < eps) (\\\\Pi (x : E) -> TruncP (\\\\Sigma (U1 : Set E) (C U1) (\\\\Pi {y : E} -> U {dist x y} eps -> U1 y))))', '| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)', '| uniform-cauchy {C : Set (Set E)} : isCauchy C <-> Closure {E} isUniform C', '| cauchy-open {S : Set E} : isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))', '\\\\lemma halving1/2 \\\\hlevels  {this : ExPseudoMetricSpace} {x y z : E} {c : Rat} (_ : U {dist y x} (c * ratio (pos 1) 2))\\n  (_ : U {dist y z} (c * ratio (pos 1) 2)) : U {dist x z} c ', '| dist-ext {x y : E} (dist x y = zro) : x = y', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\lemma separated-char \\\\hlevels  {S : CoverSpace} {x y : S.E} :\\n  TFAE ((F {pointCF {S} x} \u2286 F {pointCF {S} y}) :: (pointCF {S} x CF~ pointCF {S} y) :: (pointCF {S} x = pointCF {S} y) :: (\\\\Pi {U : Set S.E} -> single {S.E} x <=< U <-> single {S.E} y <=< U) :: (\\\\Pi {U : Set S.E} -> single {S.E} x <=< U -> U y) :: (\\\\Pi {U V : Set S.E} -> single {S.E} x <=< U -> single {S.E} y <=< V -> TruncP (\\\\Sigma (e : S.E) ((\u2227) U V e))) :: (\\\\Pi {U V : Set S.E} -> S.isOpen U -> S.isOpen V -> U x -> V y -> TruncP (\\\\Sigma (e : S.E) ((\u2227) U V e))) :: (\\\\Pi {C : Set (Set S.E)} -> S.isCauchy C -> TruncP (\\\\Sigma (U : Set S.E) (C U) (\\\\Sigma (U x) (U y)))) :: nil) ', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| dist-symm {x y : E} : dist x y = dist y x', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma metricUniform \\\\hlevels  {this : ExPseudoMetricSpace} {eps : Rat} (_ : zro < eps) :\\n  isUniform (\\\\lam (U1 : Set E) => TruncP (\\\\Sigma (x : E) (U1 = (\\\\lam (y : E) => U {dist x y} eps)))) ', '\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', '| zro : E', '| open-Union {S : Set (Set E)} (\\\\Pi {U : Set E} -> S U -> isOpen U) : isOpen (Union {E} S)', '\\\\lemma makeCauchy \\\\hlevels  {this : PreuniformSpace} {C : Set (Set E)} (_ : isUniform C) : isCauchy C ', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| U Rat : \\\\Prop', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y', '| dist-triang {x y z : E} : dist x z <= dist x y + dist y z', '\\\\func TopTransfer \\\\hlevels  {X : \\\\Set} {Y : TopSpace} (f : X -> Y.E) : TopSpace X {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) => TruncP (\\\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}']<<<break>>>ExMetricSpace X {\n  | isOpen => \\lam (U : Set E) => TruncP (\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\n  | cauchy-open => {?hidden}\n  | isUniform => ExPseudoMetricSpace.isUniform {ExPseudoMetricTransfer {X} {Y} f}\n  | uniform-cauchy => {?hidden}\n  | dist => \\lam (x : E) (x' : E) => Y.dist (f x) (f x')\n  | dist-refl => {?hidden}\n  | dist-symm => {?hidden}\n  | dist-triang => {?hidden}\n  | dist-uniform => {?hidden}\n  | isHausdorff => {?hidden}\n  | isSeparatedCoverSpace => {?hidden}\n  | dist-ext => {?hidden}\n}", "completion": "\\new ExMetricSpace {\n  | E => X\n  | ExPseudoMetricSpace => ExPseudoMetricTransfer f\n  | dist-ext => \\lam p => fi (dist-ext p)\n}"}
{"prompt": "['z : E {\\\\this}', 'A : PosetQModule', 'x : E {\\\\this}', 'y<=z : y <= z', 'y : E {\\\\this}']<<<break>>>['\\\\lemma from>=0 \\\\hlevels  {this : PosetAddGroup} {x y : E} (_ : zro <= y - x) : x <= y ', '| \\\\infixl 6 + E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma terms-equality \\\\hlevels  {A : AbGroup} (env : Array A.E) (t s : Term env.len)\\n  (_ : interpretNF {toCGroup A} {env.len} env.at (normalize {env.len} (t :* :inverse {env.len} s)) = A.zro) :\\n  interpret {toCGroup A} {env.len} env.at t = interpret {toCGroup A} {env.len} env.at s ', ':inverse (Term n)', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| zro : E', '\\\\func normalize \\\\plevels  \\\\hlevels  {n4 : Nat} (_ : Term n4) : Array Int n4 \\n  | {n}, var v => singleAt {Int} {n} v (pos 1) (pos 0)\\n  | {n}, :ide => replicate {Int} n (pos 0)\\n  | {n}, :inverse t => map {Int} {Int} negative (normalize {n} t)\\n  | {n}, t :* s => mkArray {Int} {n} (\\\\lam (j : Fin n) => at {normalize {n} t} j + at {normalize {n} s} j)', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma <=_+-positive \\\\hlevels  {this : PosetAddMonoid} {a b : E} (_ : zro <= a) (_ : zro <= b) : zro <= a + b ', '| at (j : Fin len) : A j', '| negative E : E', '| E : \\\\Set', 'var (Fin n)', '\\\\func interpretNF \\\\hlevels  {G : CGroup} {n : Nat} (env : Fin n -> G.E) (l : Array Int n) : G.E \\n  => sBigProd {G} (toArray {G} l (\\\\new Array G.E l.len env))', '\\\\lemma to>=0 \\\\hlevels  {this : PosetAddGroup} {x y : E} (_ : x <= y) : zro <= y - x ', '\\\\infixl 7 :* (_ _ : Term n)']<<<break>>>A.negative (x - y) A.<= A.negative (x A.+ y) A.+ (z A.+ z)", "completion": "from>=0 {A} (transport ((<=) (zro {A})) abGroup $ <=_+-positive {A} (to>=0 {A} y<=z) (to>=0 {A} y<=z))"}
{"prompt": "['Y : PrecoverSpace', 'S : PrecoverSpace X', 'X : \\\\Set', 'E : Set X -> Set (Set X)', 'A : Set (Set X) -> \\\\Prop', 'p : \\\\Pi {C : Set (Set X)} -> A C -> Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set X) (C U) (f.func ^-1 V \u2286 U)))', 'g : \\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)', 'f : PrecoverMap S Y', 'U : Set X', 'DU : D U']<<<break>>>['\\\\lemma aux \\\\hlevels  {X : \\\\Set} {A : Set (Set X) -> \\\\Prop} {S : PrecoverSpace X} {Y : PrecoverSpace} {f : PrecoverMap S Y}\\n  {p : \\\\Pi {C : Set (Set X)} -> A C -> Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set X) (C U) (f.func ^-1 V \u2286 U)))}\\n  {C : Set (Set X)} (_ : Closure {X} A C) :\\n  Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set X) (C U) (f.func ^-1 V \u2286 U))) ', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Y.isCauchy (\\lam (V : Set (E {Y})) => TruncP (\\Sigma (U1 : Set X) (E1 U U1) (func {f} ^-1 V \u2286 U1)))", "completion": "aux {X} {A} {S} {Y} {f} {p} (g DU)"}
{"prompt": "['s : Q.E', 'p<r : p Q.< q', 'x : Q.E', 'q : Q.E', 'q<s : r Q.< s', 'Q : Dec', 'x<=q : x <= q', 'p : Q.E', 'r : Q.E', 'b : point {Q} x < (\\\\case (true, (p, q, r, s, p<r, q<r, q<s)) \\\\with {\\n  | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n    | zero => (p, q)\\n    | suc zero => (r, s)\\n  }))\\n  | (false, (p, q)) => (\\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\\n    \\\\lam (t : \\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\\n}).2', 'q<r : q Q.< r']<<<break>>>['true', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\type \\\\infix 4 < \\\\hlevels  {Q : BiorderedSet} (x y : Interval Q) : \\\\Prop => \\\\Sigma (y.1 Q.< x.1) (x.2 Q.< y.2)', '\\\\type Interval \\\\hlevels  (Q : Poset) : \\\\Set => \\\\Sigma Q.E Q.E', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| E : \\\\Set', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\func point \\\\hlevels  {Q : Poset} (x : Q.E) : Interval Q => (x, x)', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>point {Q} x IntervalBiordered.< (\\case (true, (p, q, r, s, p<r, q<r, q<s)) \\with {\n  | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\lam (p0 : Fin 2) => (\\case p0 \\with {\n    | zero => (p, q)\n    | suc zero => (r, s)\n  }))\n  | (false, (p, q)) => (\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\n    \\lam (t : \\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\n}).3 0", "completion": "(b.1, x<=q <\u2218r q<r)"}
{"prompt": "['pi : Inv {PolyRing R} p', 'd : degree<= {R} p 0', 'R : StrictDomain', 'p : Poly R']<<<break>>>['| elem : E {M}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma degree<=0 \\\\hlevels  {R : AddPointed} (p : Poly R) (_ : degree<= {R} p 0) : p = padd {R} (pzero {R}) (polyCoef {R} p 0) ', 'padd (Poly R) R.E', '| inv : E {M}', '| inv-right : val * inv = elem', '\\\\func \\\\infixl 7 *c \\\\hlevels  {R3 : Ring} (_ : R.E) (_ : Poly R3) : Poly R3 \\n  | {R}, r, pzero => pzero {R}\\n  | {R}, r, padd p e => padd {R} (r *c p) (r R.* e)\\n  | {R}, r, peq i =>\\n    (pmap {R.E} {Poly R} (padd {R} (pzero {R})) {r R.* R.zro} {R.zro} (R.zro_*-right {r}) *> path (peq {R})) @ i', 'pzero', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func * {R3 : Ring} (_ _ : Poly R3) : Poly R3 \\n  | {R}, pzero, q => pzero {R}\\n  | {R}, padd p e, q => padd {R} (p * q) R.zro + e *c q\\n  | {R}, peq i, q =>\\n    (pmap {Poly R} {Poly R} ((+) (padd {R} (pzero {R}) R.zro)) {R.zro *c q} {pzero {R}} (zro_*c {R} {q}) *> path (peq {R})) @ i', '\\\\lemma *c_* \\\\hlevels  {R : Ring} {c : R.E} {p : Poly R} : c *c p = padd {R} (pzero {R}) c * p ', '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '\\\\func polyCoef \\\\hlevels  {R4 : AddPointed} (_ : Poly R4) (_ : Nat) : R.E \\n  | {R}, pzero, n => R.zro\\n  | {R}, padd p e, 0 => e\\n  | {R}, padd p e, suc n => polyCoef {R} p n\\n  | {R}, peq i, 0 => idp {R.E} {R.zro} @ i\\n  | {R}, peq i, suc n => idp {R.E} {R.zro} @ i', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| M : Monoid']<<<break>>>polyCoef {R} p 0 *c pi.inv = pi.elem", "completion": "rewrite (inv *c_*) (rewrite (degree<=0 p d) (inv-right {pi}))"}
{"prompt": "['R : GradedCRing', 'q : pow {R} a.1 u = g0.1 R.* c0 R.+ g1.1 R.* c1', 'u : Nat', 'c1 : R.E', 'g0 : Carrier R', 'a : Carrier R', 'g1 : Carrier R', 'c0 : R.E']<<<break>>>['true', '| \\\\infixl 6 + E E : E', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\lemma closure2-lem \\\\hlevels  {R : CRing} {a : R.E} (f : Bool -> R.E) : contains a <-> TruncP (\\\\Sigma (c d : R.E) (a = f true R.* c R.+ f false R.* d)) ', 'inP A', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', 'false', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '| E : \\\\Set', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>TruncP (\\Sigma (l : Array (\\Sigma R.E Bool))\n  (pow {R} a.1 u = BigSum {R} (map {\\Sigma R.E Bool} {R.E} (\\lam (p : \\Sigma R.E Bool) => p.1 R.* if {R.E} p.2 g0.1 g1.1) l)))", "completion": "(closure2-lem (\\lam p0 => if p0 g0.1 g1.1)).2 (inP (c0, c1, q))"}
{"prompt": "['eps>0 : eps > zro', \"y' : Rat\", 'eps : Rat', \"x' : Rat\"]<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatData (eps :: x' :: y' :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}}\n  (var {E} {Fin 3} 1 :+ var {E} {Fin 3} 2 :+ :negative {E} {Fin 3} (var {E} {Fin 3} 0 :* coef {E} {Fin 3} (rat (pos 1) 4 {?hidden} {?hidden}))) < interpret {\\new LinearRatData (eps :: x' :: y' :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 3} 1 :+ var {E} {Fin 3} 2)", "completion": "solve<Problem {\\new LinearRatData {\n  | R => RatField\n  | vars => eps :: x' :: y' :: nil\n}} ((:zro, Less, var 0) :: nil) (var 1 :+ var 2 :+ :negative (var 0 :* coef (rat (pos 1) 4 {?hidden} {?hidden})))\n  (var 1 :+ var 2) (4 :: 1 :: nil, 0, idp, idp {Bool} {true}) (eps>0 :: nil)"}
{"prompt": "['C : Set (Set X.E)', 'lu : IsLocallyUniform {X} C E', 'X : PreuniformSpace', 'E : Set (Set X.E)']<<<break>>>['\\\\lemma makeCauchy \\\\hlevels  {this : PreuniformSpace} {C : Set (Set E)} (_ : isUniform C) : isCauchy C ', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {U : Set X.E} -> C U -> X.isCauchy (\\lam (V : Set X.E) => TruncP (\\Sigma (W : Set X.E) (E1 W) (U \u2227 V \u2286 W)))", "completion": "\\lam CU => makeCauchy {X} $ lu CU"}
{"prompt": "['V : RieszSpace', 'B : BooleanRing', 'bs : Array B.E', 'vs : Array V.E bs.len']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| A (Fin len) : \\\\Type', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray']<<<break>>>Array (\\Sigma V.E (E {B})) bs.len (\\lam (i : Fin bs.len) => (vs.at i, bs.at i))", "completion": "mkArray (\\lam i => (vs i, bs i))"}
{"prompt": "['Y : CoverSpace', 'X : CoverSpace', 'f : CoverMap X Y']<<<break>>>['\\\\type RelativeCompletion \\\\hlevels  {X Y : CoverSpace} (f : X.E -> Y.E) : \\\\Set \\n  => \\\\Sigma (F1 : RegularCauchyFilter X) (y : Y.E) (\\\\property (F {pointCF {Y} y} \u2286 F {SetFilter-map {X.E} {Y.E} f F1}))', '\\\\func inc \\\\hlevels  {X Y : CoverSpace} {f : X.E -> Y.E} (s : RelativeCompletion {X} {Y} f) : \\\\Sigma (RegularCauchyFilter X) Y.E \\n  => (s.1, s.2)', '\\\\func PrecoverTransfer \\\\hlevels  {X : \\\\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\instance ProductCoverSpace \\\\hlevels  (X Y : CoverSpace) : CoverSpace (\\\\Sigma X.E Y.E) {\\n  | isOpen => \\\\lam (W : Set E) => \\\\Pi {s : E} -> W s -> TruncP (\\\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\\n    (\\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)))\\n  | isCauchy => isCauchy {CoverTransfer {\\\\Sigma X.E Y.E} {X} (\\\\lam (p0 : \\\\Sigma X.E Y.E) => p0.1) \u2228 CoverTransfer {\\\\Sigma X.E Y.E} {Y} (\\\\lam (p0 : \\\\Sigma X.E Y.E) => p0.2)}\\n} => \\\\new CoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\instance RelativeCompletionCoverSpace \\\\hlevels  {X Y : CoverSpace} (f : X.E -> Y.E) : CoverSpace (RelativeCompletion {X} {Y} f) {\\n  | isOpen => \\\\lam (U : Set E) => TruncP (\\\\Sigma (V : Set E) (isOpen V) (U = inc {X} {Y} {f} ^-1 V))\\n  | isCauchy => isCauchy\\n} => CoverTransfer {RelativeCompletion {X} {Y} f} {ProductCoverSpace (Completion X) Y} (inc {X} {Y} {f})', '\\\\class CoverSpace \\\\extends PrecoverSpace \\\\hlevels  {\\n  | isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance Completion \\\\hlevels  (X : CoverSpace) : CompleteCoverSpace (RegularCauchyFilter X) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X}}\\n  | isCauchy => isCCauchy {X}\\n} => \\\\new CompleteCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '| isOpen (Set E) : \\\\Prop', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '\\\\func TopTransfer \\\\hlevels  {X : \\\\Set} {Y : TopSpace} (f : X -> Y.E) : TopSpace X {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) => TruncP (\\\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}']<<<break>>>CoverSpace (RelativeCompletion {X} {Y} f.func) {\n  | isOpen => \\lam (U : Set E) => TruncP (\\Sigma (V : Set E) (isOpen V) (U = inc {X} {Y} {f.func} ^-1 V))\n  | isCauchy => isCauchy\n}", "completion": "RelativeCompletionCoverSpace f"}
{"prompt": "['S : SubMonoid R', 'r : R.E', 'R : CRing', 'x : SType {R} S', 'c : S.contains ((x.1 R.+ x.2) R.* r)']<<<break>>>['| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '| ide-left {x : E} : ide * x = x', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| contains (E {S}) : \\\\Prop', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| ide-right {x : E} : x * ide = x']<<<break>>>S.contains ((x.1 R.* R.ide R.+ R.ide R.* x.2) R.* r)", "completion": "simplify c"}
{"prompt": "['L : Limit {DiscretePrecat J} {D}', 'J : \\\\Type', 'c : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)', 'D : Precat', 'Z : Ob {D {\\\\this}}']<<<break>>>['| G : Functor J D', '\\\\func cone \\\\plevels obj >= hom {J1 : \\\\Type} {D1 : Precat} {Z : D.Ob} {G : Functor (DiscretePrecat J1) D1} (c : \\\\Pi (j : J1) -> D.Hom Z (G.F j)) :\\nCone {DiscretePrecat J1} {D1} G Z {\\n  | coneMap => c\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', \"\\\\class Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | J : Precat\\n  | D : Precat\\n  | G : Functor J D\\n  | apex : Ob {D}\\n  | coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)\\n  | coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\\n}\", '\\\\func DiscretePrecat (X : \\\\Type) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Trunc0 (x = y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => in0 {x = x} (idp {X} {x})\\n  | o => o {X}\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}']<<<break>>>Cone {DiscretePrecat J} {D} L.G Z {\n  | coneMap => c\n}", "completion": "cone c"}
{"prompt": "['U : Set X.E', 'Vx : V x', 'Wx : W x', 'V : Set X.E', 'g : ContMap (TopSub {X} V) Y', 'f : ContMap (TopSub {X} U) Y', 'Ux : U x', 'Y : TopRing', 'h : ContMap (TopSub {X} W) Y', 'X : TopSpace', 'x : X.E', 'Vo : X.isOpen V', 'Uo : X.isOpen U', 'Wo : X.isOpen W', 'W : Set X.E']<<<break>>>['\\\\class ContMap \\\\extends SetHom \\\\hlevels  {\\n  | func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))\\n}', '| \\\\infixl 6 + E E : E', '| *-cont : ContMap (ProductTopSpace \\\\this \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 * s.2\\n}', '\\\\type ContGerm \\\\hlevels  (X Y : TopSpace) (x : X.E) : \\\\Set => Quotient {\\\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)} (~)', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\func tuple \\\\hlevels  {X Y Z : TopSpace} (f : ContMap X Y) (g : ContMap X Z) : ContMap X (Y \u2a2f Z) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, g.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : TopSpace} (g : ContMap Y Z) (f : ContMap X Y) : ContMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '\\\\lemma TopSub-inc \\\\hlevels  {X : TopSpace} {U V : Set X.E} (p : U \u2286 V) : ContMap (TopSub {X} U) (TopSub {X} V) {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => (s.1, p {s.1} s.2)\\n} ', '| isOpen (Set E) : \\\\Prop', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", 'in~ A', '| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)', '| +-cont : ContMap (ProductTopSpace \\\\this \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 + s.2\\n}', '| <=-refl {x : E} : x <= x', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func TopSub \\\\hlevels  {X : TopSpace} (S : Set X.E) : TopSpace (\\\\Sigma (x : X.E) (\\\\property (S x))) {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) =>\\n    TruncP (\\\\Sigma (V : Set X.E) (X.isOpen V) (U = (\\\\lam (p0 : \\\\Sigma (x : X.E) (\\\\property (S x))) => p0.1) ^-1 V))\\n} => TopTransfer {\\\\Sigma (x : X.E) (\\\\property (S x))} {X} (\\\\lam (p0 : \\\\Sigma (x : X.E) (\\\\property (S x))) => p0.1)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func equivalence \\\\hlevels  {X Y : TopSpace} {x : X.E} : Equivalence (\\\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)) {\\n  | ~ => \\\\lam (f : A {\\\\this}) (g : A {\\\\this}) => TruncP (\\\\Sigma (V : Set X.E) (X.isOpen V) (V x) (p : V \u2286 f.1) (q : V \u2286 g.1)\\n    (\\\\Pi {x : X.E} -> \\\\Pi (Vx : V x) -> func {f.4} (x, p {x} Vx) = func {g.4} (x, q {x} Vx)))\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '\\\\lemma ~-cgequiv \\\\hlevels  {X Y : TopSpace} {x : X.E} {u v : \\\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)} {V : Set X.E}\\n  (_ : X.isOpen V) (_ : V x) (p : V \u2286 u.1) (q : V \u2286 v.1)\\n  (_ : \\\\Pi {x : X.E} -> \\\\Pi (Vx : V x) -> func {u.4} (x, p {x} Vx) = func {v.4} (x, q {x} Vx)) :\\n  in~ {\\\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)} {(~)} u = in~ {\\\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)} {(~)} v ', '| meet-left {x y : E} : x \u2227 y <= x', '| ldistr {x y z : E} : x * (y + z) = x * y + x * z', '\\\\instance ProductTopSpace \\\\hlevels  (X Y : TopSpace) : TopSpace (\\\\Sigma X.E Y.E) {\\n  | isOpen => \\\\lam (W : Set (E {\\\\this})) =>\\n  \\\\Pi {s : E {\\\\this}} -> W s -> TruncP (\\\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\\n    (\\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}', '| func (E {Dom}) : E {Cod}', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>in~ {\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)} {(~)}\n  (\\lam (x : X.E) => \\Sigma (U x) (\\Sigma (V x) (W x)),\n    X.open-inter {U} {\\lam (a : X.E) => \\Sigma (V a) (W a)} Uo (X.open-inter {V} {W} Vo Wo), (Ux, (Vx, Wx)),\n    Y.*-cont \u2218 tuple {TopSub {X} (U \u2227 (\\lam (x : X.E) => \\Sigma (V x) (W x)))} {Y} {Y}\n      (f \u2218 TopSub-inc {X} {U \u2227 (\\lam (x : X.E) => \\Sigma (V x) (W x))} {U} (meet-left {U} {\\lam (x : X.E) => \\Sigma (V x) (W x)}))\n      (Y.+-cont \u2218 tuple {TopSub {X} (V \u2227 W)} {Y} {Y} (g \u2218 TopSub-inc {X} {V \u2227 W} {V} (meet-left {V} {W}))\n        (h \u2218 TopSub-inc {X} {V \u2227 W} {W} (meet-right {V} {W})) \u2218 TopSub-inc {X} {U \u2227 (\\lam (x : X.E) => \\Sigma (V x) (W x))} {\\lam (x : X.E) => \\Sigma (V x) (W x)}\n        (meet-right {U} {\\lam (x : X.E) => \\Sigma (V x) (W x)}))) = in~ {\\Sigma (U : Set X.E) (X.isOpen U) (U x) (ContMap (TopSub {X} U) Y)} {(~)}\n  (\\lam (x : X.E) => \\Sigma (\\Sigma (U x) (V x)) (\\Sigma (U x) (W x)),\n    X.open-inter {\\lam (a : X.E) => \\Sigma (U a) (V a)} {\\lam (a : X.E) => \\Sigma (U a) (W a)} (X.open-inter {U} {V} Uo Vo)\n      (X.open-inter {U} {W} Uo Wo), ((Ux, Vx), (Ux, Wx)),\n    Y.+-cont \u2218 tuple {TopSub {X} ((\\lam (x : X.E) => \\Sigma (U x) (V x)) \u2227 (\\lam (x : X.E) => \\Sigma (U x) (W x)))} {Y} {Y}\n      (Y.*-cont \u2218 tuple {TopSub {X} (U \u2227 V)} {Y} {Y} (f \u2218 TopSub-inc {X} {U \u2227 V} {U} (meet-left {U} {V}))\n        (g \u2218 TopSub-inc {X} {U \u2227 V} {V} (meet-right {U} {V})) \u2218 TopSub-inc {X} {(\\lam (x : X.E) => \\Sigma (U x) (V x)) \u2227 (\\lam (x : X.E) => \\Sigma (U x) (W x))}\n        {\\lam (x : X.E) => \\Sigma (U x) (V x)}\n        (meet-left {\\lam (x : X.E) => \\Sigma (U x) (V x)} {\\lam (x : X.E) => \\Sigma (U x) (W x)}))\n      (Y.*-cont \u2218 tuple {TopSub {X} (U \u2227 W)} {Y} {Y} (f \u2218 TopSub-inc {X} {U \u2227 W} {U} (meet-left {U} {W}))\n        (h \u2218 TopSub-inc {X} {U \u2227 W} {W} (meet-right {U} {W})) \u2218 TopSub-inc {X} {(\\lam (x : X.E) => \\Sigma (U x) (V x)) \u2227 (\\lam (x : X.E) => \\Sigma (U x) (W x))}\n        {\\lam (x : X.E) => \\Sigma (U x) (W x)}\n        (meet-right {\\lam (x : X.E) => \\Sigma (U x) (V x)} {\\lam (x : X.E) => \\Sigma (U x) (W x)})))", "completion": "~-cgequiv (open-inter Uo (open-inter Vo Wo)) (Ux, (Vx, Wx)) <=-refl (\\lam p0 => (\n  \\let (u, (v, w)) => p0\n  \\in ((u, v), (u, w))))\n  (\\lam _ => ldistr *> pmap2 (+) (pmap2 (\\lam p0 p1 => f p0 * g p1) (ext idp) (ext idp)) (pmap2 (\\lam p0 p1 => f p0 * h p1) (ext idp) (ext idp)))"}
{"prompt": "['c<y : y.L c', 'c : Rat', 'y : InfReal', 'b : Rat', 'a : Rat', 'a<=b+c : a <= b + c', \"b<b' : b < b'\", 'x : InfReal', \"b' : Rat\", \"x<b' : x.L b'\"]<<<break>>>['| L Rat : \\\\Prop', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\infixl 6 + \\\\hlevels  (x y : InfReal) : InfReal => \\\\new InfReal (L {x LowerRealAbMonoid.+ y}) (U {x ExUpperReal.+ y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n}', '| <_+-left (z : E) {x y : E} (x < y) : x + z < y + z', '\\\\lemma +_L \\\\plevels  \\\\hlevels  {x y : InfReal} {a : Rat} :\\n  L {x InfRealAbMonoid.+ y} a <-> TruncP (\\\\Sigma (b : Rat) (x.L b) (c : Rat) (y.L c) (a < b RatField.+ c)) ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'inP A', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '| \\\\infix 4 < E E : \\\\Prop', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)']<<<break>>>L {x + y} a", "completion": "+_L.2 (inP (b', x<b', c, c<y, a<=b+c <\u2218r <_+-left c b<b'))"}
{"prompt": "['delta>0 : zro < delta', 'x<b : x < S.3', 'S : IntervalSubset', 'x : Real', 'delta : Real']<<<break>>>['true', '| \\\\infixl 6 + E E : E', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func half \\\\hlevels  (x : Real) : Real => x * fromRat (ratio (pos 1) 2)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| len : Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>x <= (x + half delta) \u2227 S.3", "completion": "meet-univ (hiding fm linarith) (<=-less x<b)"}
{"prompt": "['n : E', 'A : TopAbGroup', 'U0 : U A.zro', 'U : Set A.E']<<<break>>>['| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func replicate {A : \\\\Type} (n : Nat) (a : A) : Array A n (\\\\lam (_ : Fin n) => a) => \\\\new DArray', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", 'partialSum \\\\hlevels  {A : AddMonoid} (S : Series A.E) (n : Nat) : A.E => BigSum {A} (\\\\new Array A.E n S)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\lemma BigSum_replicate0 \\\\hlevels  {this : AddMonoid} {n : Nat} : BigSum (replicate {E} n zro) = zro ']<<<break>>>U (partialSum {A} (\\lam (_ : Nat) => A.zro) n)", "completion": "rewrite (\\peval partialSum _ _) (transportInv U (BigSum_replicate0 {A}) U0)"}
{"prompt": "['t : GroupTerm V']<<<break>>>[\"\\\\instance ProductDecSet \\\\hlevels  (A B : DecSet) : DecSet (\\\\Sigma A.E B.E) {\\n  | # => (#)\\n  | decideEq => \\\\lam (p : E {\\\\this}) (q : E {\\\\this}) => (\\\\case A.decideEq p.1 q.1 \\\\with {\\n    | yes e => \\\\case B.decideEq (transport {A.E} (\\\\lam (_ : A.E) => B.E) {p.1} {q.1} e p.2) q.2 \\\\with {\\n      | yes e' => yes {p = q} (path (\\\\lam (i : I) => (\\n        \\\\have arg => (e, e')\\n        \\\\in (arg.1 @ i, pathOver {\\\\lam (_ : I) => B.E} {p.2} {q.2} arg.2 @ i))))\\n      | no n => no {p = q} (\\\\lam (e' : p = q) =>\\n        n (transportInv {p.1 = q.1} (\\\\lam (x : p.1 = q.1) => transport {A.E} (\\\\lam (_ : A.E) => B.E) {p.1} {q.1} x p.2 = q.2) {e}\\n          {pmap {\\\\Sigma A.E B.E} {A.E} (\\\\lam (p0 : \\\\Sigma A.E B.E) => p0.1) {p} {q} e'}\\n          (prop-isProp {p.1 = q.1} e (pmap {\\\\Sigma A.E B.E} {A.E} (\\\\lam (p0 : \\\\Sigma A.E B.E) => p0.1) {p} {q} e'))\\n          (pmapd {\\\\Sigma A.E B.E} {\\\\lam (_ : \\\\Sigma A.E B.E) => B.E} (\\\\lam (p0 : \\\\Sigma A.E B.E) => p0.2) {p} {q} e')))\\n    }\\n    | no n => no {p = q} (\\\\lam (e : p = q) => n (pmap {\\\\Sigma A.E B.E} {A.E} (\\\\lam (p0 : \\\\Sigma A.E B.E) => p0.1) {p} {q} e))\\n  })\\n} => SigmaDecSet {A} (\\\\lam (_ : A.E) => B)\", '\\\\lemma group-diff \\\\hlevels  {A : DecSet} {P : Poset A.E} {l : List A.E} (_ : Sorted {P} l) :\\n  All2 {\\\\Sigma A.E Nat} (\\\\lam (p0 : \\\\Sigma A.E Nat) (p1 : \\\\Sigma A.E Nat) => p0.1 /= p1.1) (group {A} l) ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func group \\\\hlevels  {A2 : DecSet} (_ : List A.E) : List (\\\\Sigma A.E Nat) \\n  | {A}, nil => nil {\\\\Sigma A.E Nat}\\n  | {A}, a :: l => \\\\case group {A} l \\\\with {\\n    | nil => (a, 1) :: nil {\\\\Sigma A.E Nat}\\n    | (a', n) :: l' => \\\\case A.decideEq a a' \\\\with {\\n      | yes p => (a', suc n) :: l'\\n      | no n1 => (a, 1) :: (a', n) :: l'\\n    }\\n  }\", '\\\\instance LexicographicalProduct \\\\hlevels  (A B : LinearOrder.Dec) : LinearOrder.Dec (\\\\Sigma A.E B.E) {\\n  | < => \\\\lam (a : E {\\\\this}) (b : E {\\\\this}) => a.1 A.< b.1 || (\\\\Sigma (a.1 = b.1) (a.2 B.< b.2))\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (t : E {\\\\this}) (s : E {\\\\this}) => (\\\\case A.trichotomy t.1 s.1 \\\\with {\\n    | less t1<s1 => less {t} {s} (byLeft {t.1 A.< s.1} {\\\\Sigma (t.1 = s.1) (t.2 B.< s.2)} t1<s1)\\n    | greater t1>s1 => greater {t} {s} (byLeft {s.1 A.< t.1} {\\\\Sigma (s.1 = t.1) (s.2 B.< t.2)} t1>s1)\\n    | equals t1=s1 => \\\\case B.trichotomy t.2 s.2 \\\\with {\\n      | less t2<s2 => less {t} {s} (byRight {t.1 A.< s.1} {\\\\Sigma (t.1 = s.1) (t.2 B.< s.2)} (t1=s1, t2<s2))\\n      | equals t2=s2 =>\\n        equals {t} {s} (pmap2 {A.E} {B.E} {\\\\Sigma A.E B.E} (\\\\lam (p0 : A.E) (p1 : B.E) => (p0, p1)) {t.1} {s.1} t1=s1 {t.2} {s.2} t2=s2)\\n      | greater t2>s2 =>\\n        greater {t} {s} (byRight {s.1 A.< t.1} {\\\\Sigma (s.1 = t.1) (s.2 B.< t.2)} (inv {A.E} {t.1} {s.1} t1=s1, t2>s2))\\n    }\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma countVars-diff \\\\plevels  \\\\hlevels  {l : List (\\\\Sigma (\\\\Sigma Nat Bool) Nat)}\\n  (_ : AllC {\\\\Sigma (\\\\Sigma Nat Bool) Nat} (\\\\lam (p1 : \\\\Sigma (\\\\Sigma Nat Bool) Nat) (p2 : \\\\Sigma (\\\\Sigma Nat Bool) Nat) =>\\n    p1.1.1 = p2.1.1 -> \\\\Sigma (p1.1.2 = false) (p2.1.2 = true)) l)\\n  (_ : All2 {\\\\Sigma (\\\\Sigma Nat Bool) Nat}\\n    (\\\\lam (p0 : \\\\Sigma (\\\\Sigma Nat Bool) Nat) (p1 : \\\\Sigma (\\\\Sigma Nat Bool) Nat) => p0.1 /= p1.1) l) :\\n  All2 {\\\\Sigma Nat Nat} (\\\\lam (p0 : \\\\Sigma Nat Nat) (p1 : \\\\Sigma Nat Nat) => p0.1 /= p1.1) (countVars l) ', '\\\\func sort \\\\hlevels  {A2 : Dec} (_ : List A.E) : List A.E \\n  | {A}, nil => nil {A.E}\\n  | {A}, a :: xs => insert {A} a (sort {A} xs)', '\\\\lemma sort-sorted \\\\hlevels  {A : Dec} (xs : List A.E) : Sorted {A} (sort {A} xs) ', 'false', '\\\\instance BoolPoset \\\\hlevels  : LinearOrder.Dec Bool {\\n  | < => (BoolPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) =>\\n      <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (p0 : E {\\\\this}) (p1 : E {\\\\this}) => (\\\\case p0, p1 \\\\with {\\n    | true, true => equals {true} {true} (idp {Bool} {true})\\n    | true, false => greater {true} {false} false<true\\n    | false, true => less {false} {true} false<true\\n    | false, false => equals {false} {false} (idp {Bool} {false})\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\func toList \\\\plevels  \\\\hlevels  (_ : GroupTerm Nat) (_ : Bool) : List (\\\\Sigma Nat Bool) \\n  | var v, withInv => (v, withInv) :: nil {\\\\Sigma Nat Bool}\\n  | :ide, withInv => nil {\\\\Sigma Nat Bool}\\n  | :inv t, withInv => toList t (not withInv)\\n  | t1 :* t2, withInv => toList t1 withInv ++ toList t2 withInv', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\instance DecBool \\\\hlevels  : DecSet Bool {\\n  | # => (#)\\n  | decideEq => compare\\n} => \\\\new DecSet {\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data All2 {A : \\\\Type} (A -> A -> \\\\Prop) (List A) \\\\with\\n  | {A}, P, nil => all2-nil\\n  | {A}, P, x :: l => all2-cons (All {A} (P x) l) (All2 {A} P l)', '\\\\func countVars \\\\plevels  \\\\hlevels  (_ : List (\\\\Sigma (\\\\Sigma Nat Bool) Nat)) : List (\\\\Sigma Nat Nat) \\n  | nil => nil {\\\\Sigma Nat Nat}\\n  | _x :: nil => nil {\\\\Sigma Nat Nat}\\n  | ((x, b), n) :: ((y, c), m) :: l => \\\\case decideEq x y \\\\with {\\n    | yes p => (x, n \u2227 m) :: countVars l\\n    | no n => countVars (((y, c), m) :: l)\\n  }', '\\\\lemma sort-correct \\\\plevels  \\\\hlevels  {l : List (\\\\Sigma Nat Bool)} :\\nAllC {\\\\Sigma (\\\\Sigma Nat Bool) Nat} (\\\\lam (p1 : \\\\Sigma (\\\\Sigma Nat Bool) Nat) (p2 : \\\\Sigma (\\\\Sigma Nat Bool) Nat) =>\\n  p1.1.1 = p2.1.1 -> \\\\Sigma (p1.1.2 = false) (p2.1.2 = true))\\n  (group {ProductDecSet NatSemiring DecBool} (sort {LexicographicalProduct NatSemiring BoolPoset} l)) ']<<<break>>>All2 {\\Sigma Nat Nat} (\\lam (p0 : \\Sigma Nat Nat) (p1 : \\Sigma Nat Nat) => p0.1 /= p1.1)\n  (countVars (group {ProductDecSet NatSemiring DecBool} (sort {LexicographicalProduct NatSemiring BoolPoset} (toList t false))))", "completion": "countVars-diff sort-correct (group-diff $ sort-sorted (toList t false))"}
{"prompt": "['l : PFunc {V} {B}', 'V : RieszSpace', 'B : BooleanRing']<<<break>>>['| len : Nat', '| \\\\infixl 6 + E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', \"~-perm (EPerm {\\\\Sigma V.E B.E} l l')\", '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\lemma ~_+ \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} (f g : V.E -> V.E) {l : Array (\\\\Sigma V.E B.E)} :\\n  map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (f s.1, s.2)) l ++ map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (g s.1, s.2)) l ~ map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (f s.1 V.+ g s.1, s.2)) l ', '\\\\func inSF \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} (l : Array (\\\\Sigma V.E B.E)) : SFunc V B \\n  => in~ {Array (\\\\Sigma V.E B.E)} {(~)} l', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\", '\\\\type SFunc \\\\hlevels  (V : AddMonoid) (B : BottomDistributiveLattice) : \\\\Set => Quotient {Array (\\\\Sigma V.E B.E)} (~)', '| at (j : Fin len) : A j', \"\\\\lemma ~-sfequiv \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} {l l' : Array (\\\\Sigma V.E B.E)} (_ : l ~ l') :\\n  inSF {V} {B} l = inSF {V} {B} l' \", '| E : \\\\Set', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| negative E : E', \"\\\\func eperm-= {A1 : \\\\Type} {l1 l' : Array A1} (_ : l1 = l') : EPerm {A1} l1 l' \\n  | {A}, {l}, {l'}, idp => eperm-refl {A} {l}\"]<<<break>>>inSF {V} {B}\n  (map {\\Sigma V.E (E {B})} {\\Sigma V.E (E {B})} (\\lam (s : \\Sigma V.E (E {B})) => (abs {V} s.1, s.2)) l ++ map {\\Sigma V.E (E {B})} {\\Sigma V.E (E {B})} (\\lam (s : \\Sigma V.E (E {B})) => (V.negative (V.negative s.1), s.2)) l) = inSF {V} {B} (map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (abs {V} s.1 V.+ s.1, s.2)) l)", "completion": "~-sfequiv (~-trans (~_+ (abs {V}) (\\lam x => negative (negative x))) $ ~-perm $ eperm-= $ later $ exts (\\lam j => ext (pmap ((+) _) (negative-isInv {V}), idp)))"}
{"prompt": "['w : A.E', '|1-w|<1 : U {A.norm (A.ide - w)} ide', 'q : Rat', 'w<=1 : w A.<= A.ide', '|1-w|<q : U {A.norm (A.ide - w)} q', 'n : Nat', 'A : StoneC*Algebra']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\lemma norm_*q-ofPos \\\\hlevels  {this : RealBanachSpace} {q : Rat} (_ : zro <= q) {x : E} : norm (q *q x) = fromRat q * norm x ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma norm>=0 \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : zro <= X.norm x ', '| \\\\infix 4 <= E E : \\\\Prop', '| \\\\infixl 7 * E E : E', '\\\\lemma square-norm \\\\hlevels  {A : StoneC*Algebra} {w : A.E} (_ : w A.<= A.ide) (_ : A.norm (A.ide - w) <= ide) : A.norm (A.ide - w A.* w) <= ide ', '\\\\lemma <=_+-positive \\\\hlevels  {this : PosetAddMonoid} {a b : E} (_ : zro <= a) (_ : zro <= b) : zro <= a + b ', '| at (j : Fin len) : A j', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| norm_*_<= {x y : E} : norm (x Semigroup.* y) <= norm x ExUpperReal.* norm y', '| negative E : E', '| E : \\\\Set', 'var (Fin n)', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', 'rfunc \\\\hlevels  (_ : Nat) : Rat \\n  | 0 => zro\\n  | suc n => ratio (pos 1) 2 * (ide + rfunc n * rfunc n)', '\\\\lemma yfunc<=rfunc \\\\hlevels  {this : RealBanachAlgebra} {n : Nat} {s : E} : norm (yfunc n s.1) <= fromRat (rfunc n) ', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', '\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\lemma <=_* \\\\plevels  \\\\hlevels  {x x' y y' : ExUpperReal} (_ : x <= x') (_ : y <= y') : x * y <= x' * y' \", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func interpretNF \\\\hlevels  {G : CGroup} {n : Nat} (env : Fin n -> G.E) (l : Array Int n) : G.E \\n  => sBigProd {G} (toArray {G} l (\\\\new Array G.E l.len env))', '\\\\func zfunc \\\\hlevels  {this : RealBanachAlgebra} (n : Nat) (x : E) : E => ide - yfunc n x', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', 'yfunc \\\\hlevels  {this2 : RealBanachAlgebra} (_ : Nat) (_ : E) : E \\n  | {this}, 0, x => zro\\n  | {this}, suc n, x => ratio (pos 1) 2 *q (ide - x + yfunc n x * yfunc n x)', '| norm_+ {x y : E} : norm (x AddMonoid.+ y) <= norm x ExUpperReal.+ norm y', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', ':inverse (Term n)', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func normalize \\\\plevels  \\\\hlevels  {n4 : Nat} (_ : Term n4) : Array Int n4 \\n  | {n}, var v => singleAt {Int} {n} v (pos 1) (pos 0)\\n  | {n}, :ide => replicate {Int} n (pos 0)\\n  | {n}, :inverse t => map {Int} {Int} negative (normalize {n} t)\\n  | {n}, t :* s => mkArray {Int} {n} (\\\\lam (j : Fin n) => at {normalize {n} t} j + at {normalize {n} s} j)', '\\\\lemma <_<= \\\\plevels  \\\\hlevels  {x : ExUpperReal} {q : Rat} (_ : x.U q) : x <= fromRat q ', '\\\\lemma rfunc<=1 \\\\hlevels  {n : Nat} : rfunc n <= ide ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma +-rat \\\\plevels  \\\\hlevels  {x y : Rat} : fromRat x ExUpperReal.+ fromRat y = fromRat (x RatField.+ y) ', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\infixl 7 :* (_ _ : Term n)', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| ide : E', '| zro<=ide : zro <= ide', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| norm E : ExUpperReal', '\\\\lemma terms-equality \\\\hlevels  {A : AbGroup} (env : Array A.E) (t s : Term env.len)\\n  (_ : interpretNF {toCGroup A} {env.len} env.at (normalize {env.len} (t :* :inverse {env.len} s)) = A.zro) :\\n  interpret {toCGroup A} {env.len} env.at t = interpret {toCGroup A} {env.len} env.at s ', 'pos Nat', '| zro : E', '\\\\lemma *-rat \\\\plevels  \\\\hlevels  {x y : Rat} (_ : zro <= x) (_ : zro <= y) : fromRat x ExUpperReal.* fromRat y = fromRat (x RatField.* y) ', '\\\\instance ExUpperRealLattice \\\\hlevels  : CompleteLattice ExUpperReal {\\n  | <= => (ExUpperReal.<=)\\n  | meet => meet\\n  | join => join\\n  | top => top-impl\\n  | Join => ExUpperRealLattice.Join\\n  | Meet => ExUpperRealLattice.Meet\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '\\\\lemma rat_<=-dec \\\\plevels  \\\\hlevels  {r q : Rat} {so : So (rat_<=_Bool r q)} : r <= q ', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>A.norm (ratio (pos 1) 2 *q ((yfunc {A} n (w A.* w) A.+ (A.ide - w)) A.* (w - zfunc {A} n (w A.* w)))) <= fromRat (ratio (pos 1) 2 RatField.* (ide + q)) Semigroup.* A.norm (w - (A.ide A.+ A.negative (yfunc {A} n (w A.* w))))", "completion": "=_<= (norm_*q-ofPos {A} rat_<=-dec) <=\u2218 <=_* <=-refl\n  (norm_*_<= {A} <=\u2218 <=_* (transport ((<=) _) +-rat $ norm_+ {A} <=\u2218 <=_+ (yfunc<=rfunc {_} {_} {(w * w, square-norm {A} w<=1 $ <_<= |1-w|<1)} <=\u2218 <=-rat.1 rfunc<=1) (<_<= |1-w|<q))\n    (=_<= $ pmap norm abGroup)) <=\u2218 =_<= (inv *-assoc *> pmap (\\lam _x => _x * _) (*-rat rat_<=-dec $ <=_+-positive {RatField} zro<=ide $ <=-less $ norm>=0 |1-w|<q))"}
{"prompt": "['R : AddPointed', 's : \\\\Sigma (n : Nat) (degree<= {R} p n)', 'p : Poly R']<<<break>>>['suc Nat', '\\\\func degree< \\\\hlevels  {R : AddPointed} (p : Poly R) (n : Nat) : \\\\Prop => \\\\Pi {k : Nat} -> n <= k -> polyCoef {R} p k = R.zro', '\\\\lemma degree<=_degree< \\\\hlevels  {R : AddPointed} {p : Poly R} {n : Nat} (_ : degree<= {R} p n) : degree< {R} p (suc n) ']<<<break>>>degree< {R} p (suc s.1)", "completion": "degree<=_degree< s.2"}
{"prompt": "['i : I', 'x : Ob {C {\\\\this}}', 'L : Locale', 'arg : (\\n  \\\\have arg => (idp {L.E -> Ob {S.D}} {\\\\lam (X : L.E) => Functor.F {S.F} (func {id L} X)},\\n          path (\\\\lam (i : I) {X : L.E} {Y : L.E} (h : Hom X Y) =>\\n            pmap {Hom {C {S.F}} X Y} {Hom {S.D} (Functor.F {S.F} X) (Functor.F {S.F} Y)} (Func {S.F} {X} {Y}) {Func {X} {Y} h} {h}\\n              (prop-pi {Y L.<= X} {Func {X} {Y} h} {h}) @ i))\\n    \\\\in \\n          \\\\let | h1 => arg.1\\n               | _ => pathOver {\\\\lam (i : I) => \\\\Pi {X Y : Ob} -> Hom X Y -> Hom {S.D} ((@) h1 i X) ((@) h1 i Y)} {Func} {Func {S.F}} arg.2\\n          \\\\in \\\\new Functor (Precat.op {L}) S.D (Functor.F {VPresheaf.F {direct_image_locale {L} {L} (id L) S}}) {\\n                | Func => Func\\n                | Func-id => {?hidden}\\n                | Func-o => {?hidden}\\n              }) = (\\n    \\\\have arg => (idp {L.E -> Ob {S.D}} {\\\\lam (X : L.E) => Functor.F {S.F} (func {id L} X)},\\n            path (\\\\lam (i : I) {X : L.E} {Y : L.E} (h : Hom X Y) =>\\n              pmap {Hom {C {S.F}} X Y} {Hom {S.D} (Functor.F {S.F} X) (Functor.F {S.F} Y)} (Func {S.F} {X} {Y}) {Func {X} {Y} h} {h}\\n                (prop-pi {Y L.<= X} {Func {X} {Y} h} {h}) @ i))\\n      \\\\in \\n            \\\\let | h1 => arg.1\\n                 | _ => pathOver {\\\\lam (i : I) => \\\\Pi {X Y : Ob} -> Hom X Y -> Hom {S.D} ((@) h1 i X) ((@) h1 i Y)} {Func} {Func {S.F}} arg.2\\n            \\\\in \\\\new Functor (Precat.op {L}) S.D (Functor.F {S.F}) {\\n                  | Func => Func {S.F}\\n                  | Func-id => {?hidden}\\n                  | Func-o => {?hidden}\\n                })', 'S : VSheaf {\\n  | C => L\\n}']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\class VSheaf \\\\extends VPresheaf \\\\hlevels  {\\n  | isSheaf {x : Ob {C}} {s : Sieve {C} x} (isCover {C} x s) : Limit {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {D}\\n    (Comp {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n      (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C}} {D} VPresheaf.F\\n      (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F} apex) {\\n    | coneMap => \\\\lam (j : Ob {J}) => Func {VPresheaf.F} {apex} {Functor.F j} (coneMap j)\\n    | coneCoh => {?hidden}\\n  }\\n}', '\\\\type ObOver \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : \\\\hType => \\\\Sigma (y : C.Ob) (C.Hom y x)', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func subPrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} {X : \\\\hType} (f : X -> C.Ob) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => C.Hom (f x) (f y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => C.id (f x)\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} => (C.\u2218)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', \"\\\\lemma direct_image_locale \\\\hlevels  {L L' : Locale} (f : FrameHom L' L) (S : VSheaf {\\n  | C => L\\n}) : VSheaf S.D L' (Comp {Precat.op {L'}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {f}})) \", '| J : Precat', '\\\\instance SlicePrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : Precat (ObOver {C} x) {\\n  | Hom => \\\\lam (p0 : Ob {\\\\this}) (p1 : Ob {\\\\this}) => \\\\Sigma (h : C.Hom p0.1 p1.1) (p1.2 C.\u2218 h = p0.2)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (C.id p0.1, C.id-right {p0.1} {x} {p0.2})\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) => (p0.1 C.\u2218 p1.1,\\n    inv {C.Hom X.1 x} {Z.2 C.\u2218 p0.1 C.\u2218 p1.1} {Z.2 C.\u2218 (p0.1 C.\u2218 p1.1)} (C.o-assoc {X.1} {Y.1} {Z.1} {x} {Z.2} {p0.1} {p1.1}) *> pmap {C.Hom Y.1 x} {C.Hom X.1 x} (\\\\lam (_x : C.Hom Y.1 x) => _x C.\u2218 p1.1) {Z.2 C.\u2218 p0.1} {Y.2} p0.2 *> p1.2)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func map \\\\plevels obj >= hom \\\\hlevels  {C D : Precat} (F1 : Functor C D) {J1 : Precat} {G : Functor J1 C} (c : Cone {J1} {C} G) :\\nCone {J1} {D} (Comp {J1} {C} {D} F1 G) (F.F c.apex) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => F.Func {c.apex} {G.F j} (c.coneMap j)\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| S {y : Ob {C}} (Hom {C} y x) : \\\\Prop', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '| isSheaf {x : Ob {C}} {s : Sieve {C} x} (isCover {C} x s) : Limit {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {D}\\n  (Comp {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C}} {D} VPresheaf.F\\n    (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F} apex) {\\n  | coneMap => \\\\lam (j : Ob {J}) => Func {VPresheaf.F} {apex} {Functor.F j} (coneMap j)\\n  | coneCoh => {?hidden}\\n}', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", '| F (Ob {C}) : Ob {D}', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\class Sieve \\\\extends Presieve \\\\plevels obj >= hom \\\\hlevels  {\\n  | isSieve {z y : Ob {C}} (g : Hom {C} z y) {f : Hom {C} y x} (S {y} f) : S {z} (f \u2218 g)\\n}', '\\\\class Limit \\\\extends Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\\\new \\\\this {}) z)\\n  | limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex\\n  | limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j\\n  | limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g\\n}', '| D : Cat', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id (X : Ob) : Hom X X', '| Ob : \\\\hType', '| isCover (x : Ob) (Sieve x) : \\\\Prop', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func cone \\\\plevels obj >= hom \\\\hlevels  {this2 : Presieve} :\\nCone {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)} (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)) => p.1)}}\\n  {Precat.op {C}} (Functor.op {diagram}) x {\\n  | coneMap => \\\\lam (p0 : Ob {J {\\\\this}}) => p0.1.2\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func diagram \\\\plevels obj >= hom \\\\hlevels  {this1 : Presieve} : Functor (subPrecat {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)) => p.1)) Presieve.C\\n  (\\\\lam (X : Ob {Functor.C {\\\\this}}) => F (F X)) {\\n  | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) => Func {F X} {F Y} (Func {X} {Y} f)\\n} => Comp {subPrecat {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)) => p.1)} {SlicePrecat {Presieve.C} x} {Presieve.C}\\n  (forget {Presieve.C} x) (embedding {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : Ob) (S {y.1} y.2)) => p.1))']<<<break>>>\\Pi {s : Sieve {L} x} ->\nL.isCover x s -> Limit {Precat.op {subPrecat {SlicePrecat {L} x} {\\Sigma (y : ObOver {L} x) (s.S {y.1} y.2)}\n  (\\lam (p : \\Sigma (y : ObOver {L} x) (s.S {y.1} y.2)) => p.1)}} {S.D}\n  (Comp {Precat.op {subPrecat {SlicePrecat {L} x} {\\Sigma (y : ObOver {L} x) (s.S {y.1} y.2)}\n    (\\lam (p : \\Sigma (y : ObOver {L} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {L}} {S.D} (arg @ i)\n    (Functor.op {diagram {s}})) (F {arg @ i} x) {\n  | coneMap => \\lam (j : \\Sigma (y : ObOver {L} x) (s.S {y.1} y.2)) => Func {arg @ i} {x} {j.1.1} (coneMap j)\n  | coneCoh => {?hidden}\n}", "completion": "(@) (prop-dpi (\\lam i => ext_coe) (isSheaf {direct_image_locale {L} {L} (id L) S}) (isSheaf {\\new S {}})) i {x}"}
{"prompt": "['n : Nat', 'R : CRing', 'b : R.E']<<<break>>>['| contains_ide : contains (ide {S})', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func powers \\\\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (pow {M} a n = x))) \\n=> \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma pow_* \\\\hlevels  {this : Monoid} {a : E} {n m : Nat} : pow a (n * m) = pow (pow a n) m ', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '| \\\\infixl 7 * E E : E', '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', '\\\\func ~-pequiv {A : \\\\Type} {R : A -> A -> \\\\Type} {x y : A} (r : R x y) : in~ {A} {R} x = in~ {A} {R} y => path (~-equiv {A} {R} x y r)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| E : \\\\Set', '| contains (E {S}) : \\\\Prop', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a', 'in~ A']<<<break>>>in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (R.ide, R.ide,\n    map {\\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = R.ide)} {\\Sigma (n : Nat) (pow {R} b n = R.ide)} contains_ide\n      (\\lam (p : \\Sigma (n1 : Nat) (pow {R} (pow {R} b n) n1 = R.ide)) => (n Nat.* p.1, transportInv\n        {R.E} (\\lam (x : R.E) => x = R.ide) {pow {R} b (n Nat.* p.1)} {pow {R} (pow {R} b n) p.1} (pow_* {R} {b} {n} {p.1}) p.2))) = in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (R.ide, R.ide, contains_ide)", "completion": "~-pequiv idp"}
{"prompt": "['e : R.E', 's : toQPoly {R} (padd {R} p e) = in~ {Array R.E} {\\\\lam (p0 : Array R.E) (p1 : Array R.E) => p0 = p1 ++ R.zro :: nil} nil', 'p : Poly R', 'R : AddPointed']<<<break>>>['| zro : E', 'pzero', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', 'peq I', 'padd (Poly R) R.E', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| E : \\\\Set', '\\\\func toQPoly \\\\hlevels  {R3 : AddPointed} (_ : Poly R3) : QPoly R3 \\n  | {R}, pzero => in~ {Array R.E} {\\\\lam (p0 : Array R.E) (p1 : Array R.E) => p0 = p1 ++ R.zro :: nil} nil\\n  | {R}, padd p e => qadd {R} (toQPoly {R} p) e\\n  | {R}, peq i => ~-equiv {Array R.E} {\\\\lam (p0 : Array R.E) (p1 : Array R.E) => p0 = p1 ++ R.zro :: nil} (nil ++ R.zro :: nil) nil\\n    (idp {Array R.E} {nil ++ R.zro :: nil}) i', '\\\\lemma qadd_nil \\\\hlevels  {R : AddPointed} {p : QPoly R} {e : R.E}\\n  (_ : qadd {R} p e = in~ {Array R.E} {\\\\lam (p0 : Array R.E) (p1 : Array R.E) => p0 = p1 ++ R.zro :: nil} nil) :\\n  \\\\Sigma (p = in~ {Array R.E} {\\\\lam (p0 : Array R.E) (p1 : Array R.E) => p0 = p1 ++ R.zro :: nil} nil) (e = R.zro) ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func toQPoly-nil \\\\hlevels  {R : AddPointed} {p : Poly R} :\\n  toQPoly {R} p = in~ {Array R.E} {\\\\lam (p0 : Array R.E) (p1 : Array R.E) => p0 = p1 ++ R.zro :: nil} nil -> p = pzero {R} ']<<<break>>>padd {R} p e = pzero {R}", "completion": "\n  \\have t => qadd_nil s\n  \\in pmap2 padd (toQPoly-nil t.1) t.2 *> path peq"}
{"prompt": "[\"arg : \\\\Pi {s : Sort {T}} ->\\n\\\\Pi (x : E {F {G} j'} s) -> funcs {colimitMap j} {s} (funcs {Func {j} {j'} h} {s} x) = qapply {thExt} {s}\\n  (inr {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} s)} (j', x)))\\n  nil\", 'this : Cone {Precat.op {ModelCat.ColimitData.J}} {Precat.op {ModelPrecat ModelCat.ColimitData.T}}\\n  (Functor.op {ModelCat.ColimitData.G}) Colimit {\\n  | coneMap => colimitMap\\n  | coneCoh => {?hidden}\\n}', 'T3 : Sort {T} -> \\\\Set', 'T2 : \\\\Set', \"l : Hom {D {\\\\this}} (apex {\\\\this}) (F {G {\\\\this}} j')\", 'this : ColimitData', 'T1 : Sort {T} -> \\\\Set', \"j' : Ob {J {\\\\this}}\", 'r : Sort {T {\\\\this}}', 'i : I']<<<break>>>['| len : Nat', '| E (Sort {T}) : \\\\Set', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| Sort : \\\\Set', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| F (Ob {C}) : Ob {D}', \"\\\\data QTerm {this : Theory} Sort : \\\\Set \\n  | qinj (Term (\\\\lam (_ : Sort) => Empty) s)\\n  | qapply (f : Symb s) (DArray {len {domain {s} f}} (\\\\lam (j : Fin (len {domain {s} f})) => QTerm (at {domain {s} f} j)))\\n  | qquot {t t' : Term (\\\\lam (_ : Sort) => Empty) s} (isTheorem {\\\\lam (_ : Sort) => Empty} nil (equality {\\\\lam (_ : Sort) => Empty} {s} t t')) I\\n  | qmerge {f : Symb s} (DArray {len {domain {s} f}} (\\\\lam (j : Fin (len {domain {s} f})) => Term (\\\\lam (_ : Sort) => Empty) (at {domain {s} f} j))) I\", '| operation {r : Sort {T}} (h : Symb {T} r)\\n  (DArray {len {domain {T} {r} h}} (\\\\lam (j : Fin (len {domain {T} {r} h})) => E (at {domain {T} {r} h} j))) : E r', '| apex : Ob {D}', '| func-op {r : Sort {ModelHom.T}} (h : Symb {ModelHom.T} r) (d : DArray {len {domain {ModelHom.T} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {ModelHom.T} {r} h})) => E {Dom} (at {domain {ModelHom.T} {r} h} j))) : funcs {r} (operation {Dom} {r} h d) = operation {Cod} {r} h (\\\\new DArray {len {domain {Structure.T {Cod}} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => E {Cod} (at {domain {Structure.T {Cod}} {r} h} j))\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => funcs {at {domain {ModelHom.T} {r} h} j} (d.at j)))', '| G : Functor J D', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| T : Theory', '| domain {s : Sort} (Symb s) : Array Sort', '| at (j : Fin len) : A j', \"\\\\instance thExt {this1 : ColimitData} : Theory {\\n  | Sort => Sort {T}\\n  | Symb => \\\\lam (s : Sort) => Or (Symb {T} s) (Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s)))\\n  | domain => \\\\lam {s : Sort} (p0 : Symb s) => (\\\\case p0 \\\\with {\\n    | inl f => domain {T} {s} f\\n    | inr t => nil\\n  })\\n  | PredSymb => PredSymb {T}\\n  | predDomain => predDomain {T}\\n  | axioms => \\\\lam (S : Sequent) =>\\n  OneOf ((\\\\Sigma (S' : Sequent {T}) (axioms {T} S') (S = liftSequent S')) :: (\\\\Sigma (j : Ob {J}) (s : Sort {T}) (f : Symb {T} s)\\n    (vars : DArray {len {domain {T} {s} f}} (\\\\lam (i : Fin (len {domain {T} {s} f})) => E {F {G} j} (at {domain {T} {s} f} i)))\\n    (S = (\\\\lam (_ : Sort {\\\\this}) => Empty, emptyFin {Sort {T}}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Empty} {s}\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)\\n        (\\\\new DArray {len {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)}}\\n          (\\\\lam (j : Fin (len {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)})) =>\\n          Term (\\\\lam (_ : Sort {\\\\this}) => Empty)\\n            (at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} j))\\n          (\\\\lam (i : Fin (len {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)})) =>\\n          apply {\\\\lam (_ : Sort {\\\\this}) => Empty}\\n            {at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} i}\\n            (inr {Symb {T} (at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} i)}\\n              {Trunc0 (\\\\Sigma (j : Ob {J})\\n                (E {F {G} j} (at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} i)))}\\n              (in0 {\\\\Sigma (j : Ob {J})\\n                (E {F {G} j} (at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} i))}\\n                (j, vars.at i))) nil)))\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {s} (inr {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))}\\n        (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} s)} (j, operation {F {G} j} {s} f vars))) nil)))) :: (\\\\Sigma (j : Ob {J}) (P : PredSymb {T})\\n      (vars : DArray {len {predDomain {T} P}} (\\\\lam (i : Fin (len {predDomain {T} P})) => E {F {G} j} (at {predDomain {T} P} i)))\\n      (relation {F {G} j} P vars) (S = (\\\\lam (_ : Sort {\\\\this}) => Empty, emptyFin {Sort {T}}, nil,\\n        predicate {\\\\lam (_ : Sort {\\\\this}) => Empty} P (\\\\new DArray {len {predDomain {\\\\this} P}}\\n          (\\\\lam (j : Fin (len {predDomain {\\\\this} P})) => Term (\\\\lam (_ : Sort {\\\\this}) => Empty) (at {predDomain {\\\\this} P} j))\\n          (\\\\lam (i : Fin (len {predDomain {\\\\this} P})) => apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {at {predDomain {\\\\this} P} i}\\n            (inr {Symb {T} (at {predDomain {\\\\this} P} i)} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} (at {predDomain {\\\\this} P} i)))}\\n              (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} (at {predDomain {\\\\this} P} i))} (j, vars.at i))) nil))))) :: (\\\\Sigma (j j' : Ob {J}) (h : Hom {J} j j') (s : Sort {T}) (x : E {F {G} j} s)\\n        (S = (\\\\lam (_ : Sort {\\\\this}) => Empty, emptyFin {Sort {T}}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Empty} {s}\\n          (apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {s} (inr {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))}\\n            (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} s)} (j', funcs {Func {G} {j} {j'} h} {s} x))) nil)\\n          (apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {s}\\n            (inr {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} s)} (j, x))) nil)))) :: nil)\\n} => \\\\new Theory\", '| Symb Sort : \\\\Set', '| funcs {s : Sort {T}} (E {Dom} s) : E {Cod} s', '| G : Functor J (ModelPrecat T)', '| T : Signature', \"\\\\func Colimit {this1 : ColimitData} : Model ModelCat.ColimitData.T (QTerm {thExt}) {\\n  | operation => \\\\lam {r : Sort {Structure.T}} (h : Symb {Structure.T} r) =>\\n    qapply {thExt} {r} (inl {Symb {ModelCat.ColimitData.T} r} {Trunc0 (\\\\Sigma (j : Ob {J}) (Structure.E {F {G} j} r))} h)\\n  | relation => \\\\lam (P : PredSymb {Structure.T}) (args : DArray {len {predDomain {Structure.T} P}}\\n    (\\\\lam (j : Fin (len {predDomain {Structure.T} P})) => Structure.E (at {predDomain {Structure.T} P} j))) =>\\n  TruncP (\\\\Sigma (args' : DArray {len {predDomain {ModelCat.ColimitData.T} P}}\\n    (\\\\lam (i : Fin (len {predDomain {ModelCat.ColimitData.T} P})) => Term {thExt} (\\\\lam (_ : Sort) => Empty) (at {predDomain P} i)))\\n    (isTheorem {thExt} {\\\\lam (_ : Sort) => Empty} nil (predicate {thExt} {\\\\lam (_ : Sort) => Empty} P args'))\\n    (\\\\Pi (i : Fin (len {predDomain P})) -> qinj {thExt} {at {predDomain P} i} (args'.at i) = args.at i))\\n} => \\\\new Model {\\n  | isModel => {?hidden}\\n}\"]<<<break>>>\\Pi (h : Symb {T} r) ->\n  \\Pi (d : DArray {len {domain {T} {r} h}} (\\lam (j : Fin (len {domain {T} {r} h})) => E {F {G} j'} (at {domain {T} {r} h} j))) ->\n  (@) (\\case funcs {coneMap {\\this} j'}, arg \\with {\n    | f, a => path (\\lam (i : I) {s : Sort {T}} (e : E {F {G} j'} s) => a {s} e @ i)\n  }) i {r} (operation {F {G} j'} {r} h d) = operation {r} h\n    (\\new DArray {len {domain {T} {r} h}} (\\lam (j : Fin (len {domain {T} {r} h})) => QTerm {thExt} (at {domain {T} {r} h} j))\n      (\\lam (j : Fin (len {domain {T} {r} h})) => (@) (\\case funcs {coneMap {\\this} j'}, arg \\with {\n        | f, a => path (\\lam (i : I) {s : Sort {T}} (e : E {F {G} j'} s) => a {s} e @ i)\n      }) i {at {domain {T} {r} h} j} (d.at j)))", "completion": "(@) (prop-dpi (\\lam i => ext_coe) (func-op {l}) (func-op {colimitMap j'})) i {r}"}
{"prompt": "['x : Complex', 'r : Inv {RealField} x.im']<<<break>>>['\\\\func map {A B C2 D2 : \\\\Type} (_ : A -> C2) (_ : B -> D2) (_ : A || B) : C2 || D2 \\n  | {A}, {B}, {C}, {D}, f, g, byLeft a => byLeft {C} {D} (f a)\\n  | {A}, {B}, {C}, {D}, f, g, byRight b => byRight {C} {D} (g b)', '\\\\func negative (_ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 xReduced => rat (negative xNom) xDenom {?hidden} {?hidden}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma real_<_U \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : x < fromRat a <-> x.U a ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'negative \\\\plevels  \\\\hlevels  (x : Real) : Real \\n=> \\\\new Real (\\\\lam (a : Rat) => x.U (RatField.negative a)) (\\\\lam (a : Rat) => x.L (RatField.negative a)) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\lemma real_<_L \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : fromRat a < x <-> x.L a ', '\\\\field #0=>eitherPosOrNeg {x : E} (#0 x) : isPos x || isNeg x', '| L Rat : \\\\Prop', '| zro : E', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\lemma negative_L \\\\plevels  \\\\hlevels  {x : Real} {a : Rat} : L {RealAbGroup.negative x} a <-> x.U (RatField.negative a) ', '| at (j : Fin len) : A j', '| im : Real', '| re : Real', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)']<<<break>>>zro < at {x.re :: x.im :: nil} 1 || at {x.re :: x.im :: nil} 1 < zro", "completion": "map real_<_L.2 (\\lam c => real_<_U.2 $ negative_L.1 c) (#0=>eitherPosOrNeg {RealField} r)"}
{"prompt": "[\"-fx<=a' : negative {Cod} (func x) <= a' *q ide {Cod}\", 'this : OrderedC*AlgebraHom', 'x : E {Dom}', \"a'>0 : zro < a'\", \"a' : Rat\"]<<<break>>>['| ide : E', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\lemma *c_negative-right \\\\hlevels  {this : LModule} {r : E {R}} {a : E} : r *c negative a = negative (r *c a) ', '| \\\\infix 4 <= E E : \\\\Prop', '| Cod : BaseSet', '\\\\lemma func-*q \\\\hlevels  {A B : QModule} {f : AddGroupHom A B} {q : Rat} {a : A.E} : f.func (q *q a) = q *q f.func a ', '\\\\class OrderedC*AlgebraHom \\\\extends RingHom, PosetHom \\\\hlevels ', '\\\\lemma <=_*q-rotate_finv-left \\\\hlevels  {this : PosetQModule} {q : Rat} (_ : zro < q) {a b : E} (_ : a <= q *q b) : finv q *q a <= b ', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| negative E : E', '| func (E {Dom}) : E {Cod}', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', '| Dom : BaseSet', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\func toRatModule \\\\hlevels  {this1 : QModule} : LModule RatField E {\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | negative => negative\\n  | *c => (*q)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>negative {Cod} (func (finv a' *q x)) <= ide {Cod}", "completion": "=_<= (pmap negative func-*q *> inv (later (*c_negative-right {toRatModule}))) <=\u2218 <=_*q-rotate_finv-left a'>0 -fx<=a'"}
{"prompt": "['e : E {\\\\this}', 'x : S.E', 'S : TopSpace', 'J : \\\\Set', 'a : e.1 x', 'f : J -> E {\\\\this}', 'c : (f j).1 x', 'j : J']<<<break>>>['inP A', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (j : J) ((\u2227) e.1 (f j).1 x))", "completion": "inP (j, (a, c))"}
{"prompt": "['B : Ob', 'X : Ob', 'b : Hom X B', 'this : ToposPrecat']<<<break>>>['| apex : Ob {D}', '| id (X : Ob) : Hom X X', '| Hom Ob Ob : \\\\Set', '\\\\lemma beta2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : proj2 {x} {y} \u2218 pair {x} {y} {z} f g = g ', '\\\\func proj1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 0) => proj {Bprod x y} 0', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\func proj2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 1) => proj {Bprod x y} 1', '| Bprod (x y : Ob) : Product {Fin 2} (at {x :: y :: nil})', '\\\\func pair \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : Hom z (apex {Bprod x y}) \\n=> tupleMap {Bprod x y} {z} (\\\\lam (p0 : J {Bprod x y}) => (\\\\case p0 \\\\with {\\n  | zero => f\\n  | suc zero => g\\n}))']<<<break>>>proj2 {B} {B} \u2218 pair {B} {B} {apex {Bprod X B}} (b \u2218 proj1 {X} {B}) (id B \u2218 proj2 {X} {B}) = id B \u2218 proj2 {X} {B}", "completion": "beta2 {this} _ _"}
{"prompt": "['this : PreBanachSpace', 'x : E', 'b : Rat', '|x|<b : U {norm x} b']<<<break>>>['\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| U Rat : \\\\Prop', 'inP A', '| norm E : ExUpperReal', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (r : Rat) (U {norm x} r))", "completion": "inP (b, |x|<b)"}
{"prompt": "['this : LatticeAbGroup', 'z : E', 'y : E', 'x : E']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| <=-refl {x : E} : x <= x', '| negative-left {x : E} : negative x + x = zro', '| \\\\infix 4 <= E E : \\\\Prop', '| negative E : E', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| join-right {x y : E} : y <= x \u2228 y', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>x + (negative (y \u2228 z) + z) <= x + zro", "completion": "<=_+ {this} (<=-refl {this}) (<=_+ {this} (<=-refl {this}) (join-right {this}) <=\u2218 {this} =_<= (negative-left {this}))"}
{"prompt": "['delta>0 : zro < delta', 'Y : ExPseudoMetricSpace', 'X : ExPseudoMetricSpace', 'delta : Rat']<<<break>>>['\\\\instance UniformSpaceHasProduct \\\\hlevels  : HasProduct UniformSpace {\\n  | Product => ProductUniformSpace\\n} => \\\\new HasProduct', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| dist E E : ExUpperReal', '\\\\func Refines \\\\hlevels  {X : \\\\hType} (C D : Set (Set X)) : \\\\Prop => \\\\Pi {U : Set X} -> C U -> TruncP (\\\\Sigma (V : Set X) (D V) (U \u2286 V))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma metricUniform \\\\hlevels  {this : ExPseudoMetricSpace} {eps : Rat} (_ : zro < eps) :\\n  isUniform (\\\\lam (U1 : Set E) => TruncP (\\\\Sigma (x : E) (U1 = (\\\\lam (y : E) => U {dist x y} eps)))) ', '\\\\func Prod \\\\hlevels  {X Y : \\\\hType} (U : Set X) (V : Set Y) : Set (\\\\Sigma X Y) => \\\\lam (s : \\\\Sigma X Y) => \\\\Sigma (U s.1) (V s.2)', '\\\\lemma prodCover \\\\hlevels  {X Y : UniformSpace} {C : Set (Set X.E)} (_ : X.isUniform C) {D : Set (Set Y.E)} (_ : Y.isUniform D) :\\nisUniform {X \u2a2f Y} (\\\\lam (W : Set (E {X \u2a2f Y})) =>\\n  TruncP (\\\\Sigma (U : Set X.E) (C U) (V : Set Y.E) (D V) (W = (\\\\lam (s : \\\\Sigma X.E Y.E) => \\\\Sigma (U s.1) (V s.2))))) ', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| U Rat : \\\\Prop', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop']<<<break>>>TruncP (\\Sigma (C : Set (Set (E {X}))) (isUniform {X} C) (D : Set (Set (E {Y}))) (isUniform {Y} D)\n  (Refines {\\Sigma (E {X}) (E {Y})} (\\lam (W : Set (\\Sigma (E {X}) (E {Y}))) =>\n    TruncP (\\Sigma (U : Set (E {X})) (C U) (V : Set (E {Y})) (D V) (W = Prod {E {X}} {E {Y}} U V)))\n    (\\lam (W : Set (E {X \u2a2f Y})) => TruncP (\\Sigma (U1 : Set (E {X}))\n      ((\\lam (U1 : Set X.E) => TruncP (\\Sigma (x : X.E) (U1 = (\\lam (y : X.E) => U {X.dist x y} delta)))) U1)\n      (V : Set (E {Y})) ((\\lam (U1 : Set Y.E) => TruncP (\\Sigma (x : Y.E) (U1 = (\\lam (y : Y.E) => U {Y.dist x y} delta)))) V)\n      (W = (\\lam (s : \\Sigma (E {X}) (E {Y})) => \\Sigma (U1 s.1) (V s.2)))))))", "completion": "prodCover (metricUniform delta>0) (metricUniform delta>0)"}
{"prompt": "['env : Array M.E 6', 'r : x ~ y', 'M : CMonoid']<<<break>>>['| len : Nat', '| M : \\\\Set', '| interpret {n : Nat} (Fin n -> M) (Term n) : M', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'nil', '\\\\func CMonoidSolverModel \\\\hlevels  (M1 : CMonoid) : SolverModel M.E {\\n  | Term => MonoidSolverModel.Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => normalize\\n  | interpret => MonoidSolverModel.interpret {M1}\\n  | interpretNF => \\\\lam {n : Nat} (env : Fin n -> M {\\\\this}) (nf : NF {\\\\this} n) =>\\n    MonoidSolverModel.interpretNF {M1} {Fin n} env (sort {FinOrder n} nf)\\n} => \\\\new SolverModel {\\n  | interpretNF-consistent => {?hidden}\\n}', '\\\\infixl 7 :* (_ _ : Term n)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '\\\\lemma terms-equality \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s)) :\\n  interpret {env.len} env.at t = interpret {env.len} env.at s ', '\\\\lemma apply-axiom \\\\hlevels  {M : CMonoid} (env : Array M.E) (t s : Term env.len)\\n  (_ : interpret {M} {env.len} env.at t = interpret {M} {env.len} env.at s) (n : Nat) (add : List (Fin env.len)) :\\n  interpretNF {M} {Fin env.len} env.at (sort {FinOrder env.len} (iterr {List (Fin env.len)} ((++) (normalize {env.len} t)) n add)) = interpretNF {M} {Fin env.len} env.at (sort {FinOrder env.len} (iterr {List (Fin env.len)} ((++) (normalize {env.len} s)) n add)) ', 'var (Fin n)', '\\\\infixr 5 :: A (List A)']<<<break>>>interpret {env.len} env.at (var {env.len} 0 :* var {env.len} 1 :* (var {env.len} 2 :* var {env.len} 3)) = interpret {env.len} env.at (var {env.len} 4 :* var {env.len} 1 :* (var {env.len} 5 :* var {env.len} 3))", "completion": "terms-equality {CMonoidSolverModel M} env (var 0 :* var 1 :* (var 2 :* var 3)) (var 4 :* var 1 :* (var 5 :* var 3))\n  (apply-axiom env (var 0 :* var 2) (var 4 :* var 5) r 1 (1 :: 3 :: nil))"}
{"prompt": "['this : Nucleus', 'p : nucleus y <= y', 'x : E {L}', 'y : E {L}']<<<break>>>['| <=-refl {x : E} : x <= x', '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma eval \\\\hlevels  {this : Locale} {x y : E} : (x --> y) \u2227 x <= y ', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '\\\\lemma exponent \\\\hlevels  {this : Locale} {x y z : E} : x \u2227 y <= z <-> x <= y --> z ', '| nucleus-meet>= {x y : E {L}} : nucleus x \u2227 nucleus y <= nucleus (x \u2227 y)', '\\\\func \\\\infixr 5 --> \\\\hlevels  {this : Locale} (x y : E) : E => SJoin (\\\\lam (p0 : E) => p0 \u2227 x <= y)', '| nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y', '| L : Locale', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| nucleus-unit {x : E {L}} : x <= nucleus x']<<<break>>>nucleus (x --> y) <= x --> y", "completion": "exponent.1 (meet-monotone <=-refl (nucleus-unit {this}) <=\u2218 nucleus-meet>= {this} <=\u2218 nucleus-<= {this} eval <=\u2218 p)"}
{"prompt": "['x : B.E -> E', 'B : FinSet', 'f : A.E -> B.E', 'A : FinSet', 'this : AbMonoid', 'dec : \\\\Pi (b : B.E) -> Decide (TruncP (\\\\Sigma (a : A.E) (f a = b))) {\\n  | decide => {?hidden}\\n}']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| A : \\\\Type', '| \\\\infixl 6 + E E : E', '\\\\lemma dec_yes_reduce \\\\plevels  \\\\hlevels  {E : \\\\Prop} {d : Dec E} (e : E) : d = yes {E} e ', '\\\\lemma SigmaFin (S : FinSet) (Q : S.E -> FinSet) : FinSet (\\\\Sigma (i : S.E) (E {Q i})) {\\n  | finCard => FinSum {NatSemiring} {S} (\\\\lam (i : S.E) => finCard {Q i})\\n} ', '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', 'yes E', 'no (Not E)', '\\\\data Empty \\\\plevels  \\\\hlevels  ', 'inr B', '| E : \\\\Set', '| decide : Dec E', '| E : \\\\Prop', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma dec_no_reduce \\\\plevels  \\\\hlevels  {E : \\\\Prop} {d : Dec E} (q : Not E) : d = no {E} q ', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', 'FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1', '\\\\instance OrFin (S T : FinSet) : FinSet (Or S.E T.E) {\\n  | finCard => S.finCard + T.finCard\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case finEq {\\\\this} \\\\with {\\n    | inP e => \\\\case decideEq (e.ret x) (e.ret y) \\\\with {\\n      | yes q => yes {x = y} (isInj {symQEquiv {Fin (finCard {\\\\this})} {E {\\\\this}} (fromEquiv e)} {x} {y} q)\\n      | no q => no {x = y} (\\\\lam (p : x = y) => q (pmap {E {\\\\this}} {Fin (finCard {\\\\this})} e.ret {x} {y} p))\\n    }\\n  })\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\instance NotDecide \\\\plevels  \\\\hlevels  (A : Decide) : Decide (Not A.E) => \\\\new Decide {\\n  | decide => {?hidden}\\n}', '\\\\lemma FinSum_Or {this : AbMonoid} {A B : FinSet} {x : Or A.E B.E -> E} :\\n  FinSum {OrFin A B} x = FinSum {A} (\\\\lam (a : A.E) => x (inl {A.E} {B.E} a)) + FinSum {B} (\\\\lam (b : B.E) => x (inr {A.E} {B.E} b)) ', 'inl A', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| B : \\\\Type', '\\\\func DecFin {P : \\\\Prop} (d : Dec P) : FinSet P {\\n  | finCard => rec {Nat} {P} (\\\\lam (_ : P) => 1) (\\\\lam (_ : Not P) => 0) d\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case finEq {\\\\this} \\\\with {\\n    | inP e => \\\\case decideEq (e.ret x) (e.ret y) \\\\with {\\n      | yes q => yes {x = y} (isInj {symQEquiv {Fin (finCard {\\\\this})} {E {\\\\this}} (fromEquiv e)} {x} {y} q)\\n      | no q => no {x = y} (\\\\lam (p : x = y) => q (pmap {E {\\\\this}} {Fin (finCard {\\\\this})} e.ret {x} {y} p))\\n    }\\n  })\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}']<<<break>>>FinSum {OrFin (SigmaFin B1 (\\lam (b : B.E) => DecFin {TruncP (\\Sigma (a : A.E) (f1 a = b))} (decide {dec b})))\n  (SigmaFin B1 (\\lam (b : B.E) => DecFin {TruncP (\\Sigma (a : A.E) (f1 a = b)) -> Empty} decide))}\n  (\\lam (a : Or (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i))))\n    (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty))) =>\n  x (f {\\new QEquiv {BaseSet.E} {B.E} (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n    | inl s => s.1\n    | inr s => s.1\n  })) {\n    | ret => \\lam (b : B {\\this}) => (\\case decide {dec b} \\with {\n      | yes e => inl {BaseSet.E} {BaseSet.E} (b, e)\n      | no q => inr {BaseSet.E} {BaseSet.E} (b, q)\n    })\n    | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n      | inl s => transportInv {Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))}\n        (\\lam (x : Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))) => (\\case x \\with {\n          | yes e => inl {BaseSet.E} {BaseSet.E} (s.1, e)\n          | no q => inr {BaseSet.E} {BaseSet.E} (s.1, q)\n        }) = inl {BaseSet.E} {BaseSet.E} s) {decide {dec s.1}} {yes {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2}\n        (dec_yes_reduce {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} {decide {dec s.1}} s.2)\n        (idp {Or (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i))))\n          (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty))}\n          {\\case yes {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2 \\with {\n            | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, e)\n            | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, q)\n          }})\n      | inr s => transportInv {Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))}\n        (\\lam (x : Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))) => (\\case x \\with {\n          | yes e => inl {BaseSet.E} {BaseSet.E} (s.1, e)\n          | no q => inr {BaseSet.E} {BaseSet.E} (s.1, q)\n        }) = inr {BaseSet.E} {BaseSet.E} s) {decide {dec s.1}} {no {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2}\n        (dec_no_reduce {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} {decide {dec s.1}} s.2)\n        (idp {Or (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i))))\n          (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty))}\n          {\\case no {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2 \\with {\n            | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, e)\n            | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, q)\n          }})\n    })\n    | f_sec => \\lam (b : B {\\this}) => (\\case decide {dec b} \\with {\n      | yes e => idp {B.E} {\\case \\case yes {TruncP (\\Sigma (a : A.E) (f1 a = b))} e \\with {\n        | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, e)\n        | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, q)\n      } \\with {\n        | inl s => s.1\n        | inr s => s.1\n      }}\n      | no q => idp {B.E} {\\case \\case no {TruncP (\\Sigma (a : A.E) (f1 a = b))} q \\with {\n        | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, e)\n        | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, q)\n      } \\with {\n        | inl s => s.1\n        | inr s => s.1\n      }}\n    })\n  }} a)) = FinSum {SigmaFin B1 (\\lam (b : B.E) => DecFin {TruncP (\\Sigma (a : A.E) (f1 a = b))} (decide {dec b}))}\n  (\\lam (a : BaseSet.E) => (\\lam (a : Or (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i))))\n    (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty))) =>\n  x (f {\\new QEquiv {BaseSet.E} {B.E} (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n    | inl s => s.1\n    | inr s => s.1\n  })) {\n    | ret => \\lam (b : B {\\this}) => (\\case decide {dec b} \\with {\n      | yes e => inl {BaseSet.E} {BaseSet.E} (b, e)\n      | no q => inr {BaseSet.E} {BaseSet.E} (b, q)\n    })\n    | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n      | inl s => transportInv {Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))}\n        (\\lam (x : Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))) => (\\case x \\with {\n          | yes e => inl {BaseSet.E} {BaseSet.E} (s.1, e)\n          | no q => inr {BaseSet.E} {BaseSet.E} (s.1, q)\n        }) = inl {BaseSet.E} {BaseSet.E} s) {decide {dec s.1}} {yes {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2}\n        (dec_yes_reduce {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} {decide {dec s.1}} s.2)\n        (idp {Or (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i))))\n          (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty))}\n          {\\case yes {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2 \\with {\n            | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, e)\n            | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, q)\n          }})\n      | inr s => transportInv {Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))}\n        (\\lam (x : Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))) => (\\case x \\with {\n          | yes e => inl {BaseSet.E} {BaseSet.E} (s.1, e)\n          | no q => inr {BaseSet.E} {BaseSet.E} (s.1, q)\n        }) = inr {BaseSet.E} {BaseSet.E} s) {decide {dec s.1}} {no {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2}\n        (dec_no_reduce {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} {decide {dec s.1}} s.2)\n        (idp {Or (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i))))\n          (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty))}\n          {\\case no {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2 \\with {\n            | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, e)\n            | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, q)\n          }})\n    })\n    | f_sec => \\lam (b : B {\\this}) => (\\case decide {dec b} \\with {\n      | yes e => idp {B.E} {\\case \\case yes {TruncP (\\Sigma (a : A.E) (f1 a = b))} e \\with {\n        | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, e)\n        | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, q)\n      } \\with {\n        | inl s => s.1\n        | inr s => s.1\n      }}\n      | no q => idp {B.E} {\\case \\case no {TruncP (\\Sigma (a : A.E) (f1 a = b))} q \\with {\n        | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, e)\n        | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, q)\n      } \\with {\n        | inl s => s.1\n        | inr s => s.1\n      }}\n    })\n  }} a)) (inl {BaseSet.E} {BaseSet.E} a)) + FinSum {SigmaFin B1 (\\lam (b : B.E) => DecFin {TruncP (\\Sigma (a : A.E) (f1 a = b)) -> Empty} decide)}\n  (\\lam (b : BaseSet.E) => (\\lam (a : Or (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i))))\n    (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty))) =>\n  x (f {\\new QEquiv {BaseSet.E} {B.E} (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n    | inl s => s.1\n    | inr s => s.1\n  })) {\n    | ret => \\lam (b : B {\\this}) => (\\case decide {dec b} \\with {\n      | yes e => inl {BaseSet.E} {BaseSet.E} (b, e)\n      | no q => inr {BaseSet.E} {BaseSet.E} (b, q)\n    })\n    | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n      | inl s => transportInv {Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))}\n        (\\lam (x : Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))) => (\\case x \\with {\n          | yes e => inl {BaseSet.E} {BaseSet.E} (s.1, e)\n          | no q => inr {BaseSet.E} {BaseSet.E} (s.1, q)\n        }) = inl {BaseSet.E} {BaseSet.E} s) {decide {dec s.1}} {yes {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2}\n        (dec_yes_reduce {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} {decide {dec s.1}} s.2)\n        (idp {Or (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i))))\n          (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty))}\n          {\\case yes {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2 \\with {\n            | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, e)\n            | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, q)\n          }})\n      | inr s => transportInv {Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))}\n        (\\lam (x : Dec (TruncP (\\Sigma (a : A.E) (f1 a = s.1)))) => (\\case x \\with {\n          | yes e => inl {BaseSet.E} {BaseSet.E} (s.1, e)\n          | no q => inr {BaseSet.E} {BaseSet.E} (s.1, q)\n        }) = inr {BaseSet.E} {BaseSet.E} s) {decide {dec s.1}} {no {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2}\n        (dec_no_reduce {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} {decide {dec s.1}} s.2)\n        (idp {Or (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i))))\n          (\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty))}\n          {\\case no {TruncP (\\Sigma (a : A.E) (f1 a = s.1))} s.2 \\with {\n            | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, e)\n            | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n              {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (s.1, q)\n          }})\n    })\n    | f_sec => \\lam (b : B {\\this}) => (\\case decide {dec b} \\with {\n      | yes e => idp {B.E} {\\case \\case yes {TruncP (\\Sigma (a : A.E) (f1 a = b))} e \\with {\n        | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, e)\n        | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, q)\n      } \\with {\n        | inl s => s.1\n        | inr s => s.1\n      }}\n      | no q => idp {B.E} {\\case \\case no {TruncP (\\Sigma (a : A.E) (f1 a = b))} q \\with {\n        | yes e => inl {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, e)\n        | no q => inr {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)))}\n          {\\Sigma (i : B.E) (TruncP (\\Sigma (a : A.E) (f1 a = i)) -> Empty)} (b, q)\n      } \\with {\n        | inl s => s.1\n        | inr s => s.1\n      }}\n    })\n  }} a)) (inr {BaseSet.E} {BaseSet.E} b))", "completion": "FinSum_Or {_} {SigmaFin B (\\lam b => DecFin (decide {dec b}))} {SigmaFin B (\\lam b => DecFin (decide {NotDecide (dec b)}))}"}
{"prompt": "['n : Nat', 'k : Fin (suc n)', 'i : Fin (suc n)', 'pj : suc j /= suc i', 'pk : suc k /= suc i', 'j : Fin (suc n)', 'q : j < k']<<<break>>>['\\\\func newIndex \\\\plevels  \\\\hlevels  {n2 : Nat} {j1 i2 : Fin (suc n2)} (_ : i2 /= j1) : Fin n2 \\n  | {n}, {zero}, {zero}, p => absurd {Fin n} (p (idp {Fin (suc n)} {0}))\\n  | {suc n}, {zero}, {suc i}, p => i\\n  | {suc n}, {suc j}, {zero}, p => 0\\n  | {suc n}, {suc j}, {suc i}, p =>\\n    suc (newIndex {n} {j} {i} (\\\\lam (q : i = j) => p (pmap {Fin (suc n)} {Fin (suc (suc n))} (fsuc {suc n}) {i} {j} q)))', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'suc<suc (n < m)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\lemma newIndex_< \\\\plevels  \\\\hlevels  {n : Nat} {i j k : Fin (suc n)} {pj : j /= i} {pk : k /= i} (_ : j < k) :\\n  newIndex {n} {i} {j} pj < newIndex {n} {i} {k} pk ', '\\\\func fsuc \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : Fin (suc n) => suc x']<<<break>>>suc (newIndex {n} {i} {j} (\\lam (q : j = i) => pj (pmap {Fin (suc n)} {Fin (suc (suc n))} (fsuc {suc n}) {j} {i} q))) < suc (newIndex {n} {i} {k} (\\lam (q : k = i) => pk (pmap {Fin (suc n)} {Fin (suc (suc n))} (fsuc {suc n}) {k} {i} q)))", "completion": "suc<suc (newIndex_< q)"}
{"prompt": "['this : PosetQModule', 'q>=0 : zro <= q', 'q : Rat', 'a>=0 : zro <= a', 'a : E']<<<break>>>[\"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma rat*denom-left \\\\plevels  \\\\hlevels  {q : Rat} : fromInt (pos (ratDenom q)) * q = fromInt (ratNom q) ', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| E : \\\\Set', '\\\\func ratDenom \\\\plevels  \\\\hlevels  (_ : Rat) : Nat \\n  | rat nom d denom/=0 reduced => d', '\\\\lemma *n_>=0 \\\\hlevels  {this : PosetAddMonoid} {n : Nat} {a : E} (_ : zro <= a) : zro <= n *n a ', '| <=_*n-div {n : Nat} (n /= 0) {a : E} (zro <= n *n a) : zro <= a', '\\\\func ratNom \\\\plevels  \\\\hlevels  (_ : Rat) : Int \\n  | rat n denom denom/=0 reduced => n', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\lemma natUnit \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n * m = 1) : m = 1 ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma *q_*i \\\\hlevels  {this : QModule} {x : Int} {a : E} : fromInt x *q a = x *i a ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\lemma ratDenom/=0 \\\\plevels  \\\\hlevels  {x : Rat} : ratDenom x /= 0 ', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\lemma *q_*n \\\\hlevels  {this : QModule} {n : Nat} {a : E} : fromInt (pos n) *q a = n *n a ', '\\\\lemma conv \\\\plevels  \\\\hlevels  {x : Rat} (_ : fromInt (pos 0) <= x) : pos 0 <= ratNom x ', 'pos Nat', '| zro : E', '\\\\lemma *q-assoc \\\\hlevels  {this : QModule} {q r : Rat} {a : E} : q * r *q a = q *q (r *q a) ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\func \\\\infixl 7 *i \\\\hlevels  {this2 : AddGroup} (_ : Int) (_ : E) : E \\n  | {this}, pos n, a => n *n a\\n  | {this}, neg n, a => n *n negative a', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma ofPos \\\\plevels  \\\\hlevels  {x : Int} (_ : zro <= x) : pos (iabs x) = x ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\"]<<<break>>>zro <= q *q a", "completion": "<=_*n-div {this} ratDenom/=0 (transport ((<=) {this} 0)\n  (pmap (\\lam _x => _x *i {this} a) (ofPos $ conv q>=0) *> inv (*q_*i {this}) *> pmap (\\lam _x => _x *q {this} a) (inv rat*denom-left) *> *q-assoc {this} *> *q_*n {this})\n  (*n_>=0 {this} a>=0))"}
{"prompt": "['V : \\\\Pi (i : Fin U.len) -> \\\\Sigma (V : Set X.E) (C V) (U !! i \u2286 V)', 'x : X.E', 'j : Fin U.len', 'Ux : (!!) U j x']<<<break>>>[]<<<break>>>(V j).1 x", "completion": "(V j).3 Ux"}
{"prompt": "['M : CMonoid', \"x'|x : LDiv {M} x' x\", \"x' : E\", 'x : E', 'y : E']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '| inv : E {M}', '\\\\lemma product-right \\\\hlevels  {M : CMonoid} (z : M.E) {x y : M.E} (x|y : LDiv {M} x y) : LDiv {M} (x M.* z) (y M.* z) x|y.inv ']<<<break>>>LDiv {M} (x' M.* y) (x M.* y) x'|x.inv", "completion": "product-right y x'|x"}
{"prompt": "[\"p : d D.<= d'\", \"d' : D.E\", 'D : BottomJoinSemilattice', 'F : Functor D AddMonoidCat', 'd : D.E']<<<break>>>['| zro : E', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\instance AddMonoidLatticeColimit {D : BottomJoinSemilattice} (F1 : Functor D AddMonoidCat) :\\nAddMonoid (SetColimit {D} (Comp {D} {AddMonoidCat} {SetCat} forget F1)) {\\n  | zro => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, zro {F.F D.bottom})\\n  | + => (AddMonoidLatticeColimit.+)\\n} => \\\\new AddMonoid {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n}\", '\\\\instance AddMonoidCat : Cat AddMonoid {\\n  | Hom => AddMonoidHom\\n  | id => AddMonoidHom.id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new AddMonoidHom X Z {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n    | func-zro => {?hidden}\\n    | func-+ => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| func-zro : func (zro {Dom}) = zro {Cod}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| F (Ob {C}) : Ob {D}', \"\\\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D AddMonoidCat} (d : D.E) :\\nAddMonoidHom (F.F d) (AddMonoidLatticeColimit {D} F1) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) =>\\n  in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\\n} => \\\\new AddMonoidHom {\\n  | func-zro => {?hidden}\\n  | func-+ => {?hidden}\\n}\", '| Dom : BaseSet']<<<break>>>func {inMap {D} {F1} d' \u2218 F.Func {d} {d'} p} (zro {Dom {inMap {D} {F1} d' \u2218 F.Func {d} {d'} p}}) = zro {Cod {inMap {D} {F1} d' \u2218 F.Func {d} {d'} p}}", "completion": "func-zro {inMap {D} {F1} d' \u2218 F.Func {d} {d'} p}"}
{"prompt": "['n : Nat']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\lemma rfunc>=0 \\\\hlevels  {n : Nat} : zro <= rfunc n ', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma rfunc<=1 \\\\hlevels  {n : Nat} : rfunc n <= ide ', 'rfunc \\\\hlevels  (_ : Nat) : Rat \\n  | 0 => zro\\n  | suc n => ratio (pos 1) 2 * (ide + rfunc n * rfunc n)', '| <=_*_positive-left {x y z : E} (x <= y) (zro <= z) : x * z <= y * z', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>rfunc n * rfunc n <= ide * rfunc n", "completion": "<=_*_positive-left {RatField} rfunc<=1 rfunc>=0"}
{"prompt": "['r : GroupTerm V', 'res-r : \\\\Sigma (GroupTerm V) Bool', 'res-l : \\\\Sigma (GroupTerm V) Bool', 'fstLeafToRemoveInd : Nat', 'q : fstLeafToRemoveInd = count-leaves l', 'this : NatData', 'l : GroupTerm V']<<<break>>>['| \\\\infixl 7 * E E : E', '| G : Group', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func count-leaves \\\\hlevels  {this1 : NatData} (_ : GroupTerm V) : Nat \\n  | {this}, l :* r => count-leaves l + count-leaves r\\n  | {this}, :inv (var x) => 1\\n  | {this}, :inv g => 0\\n  | {this}, var x => 1\\n  | {this}, t => 0', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', \"\\\\func remove-pair \\\\hlevels  {this5 : NatData} (_ : GroupTerm V) (_ : Nat) : \\\\Sigma (GroupTerm V) Bool \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | less _x => \\n      \\\\let res-l => remove-pair l fstLeafToRemoveInd\\n      \\\\in \\\\case res-l.2 \\\\with {\\n            | true => (r, false)\\n            | false => (res-l.1 :* r, false)\\n          }\\n    | equals p => \\n      \\\\let | res-l => remove-pair l fstLeafToRemoveInd\\n           | res-r => remove-pair r 0\\n      \\\\in \\\\case res-l.2, res-r.2 \\\\with {\\n            | true, true => (:ide {Nat}, true)\\n            | true, false => res-r\\n            | false, true => res-l\\n            | false, false => (res-l.1 :* res-r.1, false)\\n          }\\n    | greater _x => \\n      \\\\let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l)\\n      \\\\in \\\\case res-r.2 \\\\with {\\n            | true => (l, false)\\n            | false => (l :* res-r.1, false)\\n          }\\n  }\\n  | {this}, :inv (var x), fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :inv g, fstLeafToRemoveInd => (:inv {V} g, false)\\n  | {this}, var x, fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :ide, fstLeafToRemoveInd => (:ide {Nat}, false)\", '\\\\func interpret \\\\hlevels  {this4 : GroupData} (_ : GroupTerm V) : E {G} \\n  | {this}, var x => f x\\n  | {this}, :ide => ide {G}\\n  | {this}, :inv t => inverse {G} (interpret t)\\n  | {this}, t :* s => interpret t * interpret s']<<<break>>>interpret res-l.1 * interpret res-r.1 = interpret (remove-pair l (count-leaves l)).1 * interpret (remove-pair r 0).1", "completion": "rewrite (inv q) idp"}
{"prompt": "[\"e : Iso {RingedLocalePrecat} {L} {L'}\"]<<<break>>>['| f# : NatTrans {op {L {Cod}}} {CRingCat} (F {R {Cod}}) (F {direct_image_locale {L {Dom}} {L {Cod}} f (R {Dom})})', '\\\\func FrameCat : Cat Locale {\\n  | Hom => FrameHom\\n  | id => \\\\lam (L : Ob {\\\\this}) => \\\\new FrameHom L L {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n  }\\n  | o => FrameCat.o\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| L : Locale', '\\\\instance CRingCat : Cat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {RingCat} {CRing} (\\\\new Embedding {CRing} {Ob} (\\\\lam (R : A {\\\\this}) => R) {\\n  | isEmb => \\\\lam (R S : A {\\\\this}) =>\\n  \\\\new Retraction {R = S} {f {\\\\this} R = f {\\\\this} S} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {R} {S}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new CRing (E {p @ i}) {\\n      | zro => zro {p @ i}\\n      | + => (+) {p @ i}\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*) {p @ i}\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | negative => negative {p @ i}\\n      | negative-left => {?hidden}\\n      | ide => ide {p @ i}\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef {p @ i}\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n    })\\n    | f_sec => idpe {R = S}\\n  }\\n})', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\class NatTrans \\\\plevels obj >= hom >= iobj >= ihom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F : Functor C D\\n  | G : Functor C D\\n  | trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)\\n  | natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X\\n}', '| f : FrameHom (L {Cod}) (L {Dom})', '| C : Precat', '\\\\func RingedLocalePrecat : Precat RingedLocale {\\n  | Hom => RingedLocaleHom\\n  | id => RingedLocalePrecat.id\\n  | o => RingedLocalePrecat.o\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func functor \\\\hlevels  {this2 : FrameHom} : Functor Dom Cod func {\\n  | Func => func-<=\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)', '| f_hinv : f \u2218 hinv = id {C} cod', '| hinv : Hom {C} cod dom', '| F : Functor (op {C}) D', '| f : Hom {C} dom cod', '| dom : Ob {C}', '| Cod : RingedLocale', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| R : VSheaf CRingCat L', '| F (Ob {C}) : Ob {D}', '| cod : Ob {C}', '\\\\func natTrans-inv {L1 M : RingedLocale} {e : Iso {RingedLocalePrecat} {L1} {M}}\\n  (f : NatTrans {Precat.op {L.L}} {CRingCat} (VPresheaf.F {L.R})\\n    (Comp {Precat.op {L.L}} {Precat.op {M.L}} {CRingCat} (VPresheaf.F {M.R}) (Functor.op {functor {RingedLocaleHom.f {e.hinv}}}))) :\\nNatTrans {Precat.op {M.L}} {CRingCat}\\n  (Comp {Precat.op {M.L}} {Precat.op {L.L}} {CRingCat} (VPresheaf.F {L.R}) (Functor.op {functor {RingedLocaleHom.f {e.f}}}))\\n  (VPresheaf.F {M.R}) {\\n  | trans => \\\\lam (x : Ob {C {\\\\this}}) =>\\n    homMap {Cod {e.f \u2218 e.hinv}} {Dom {e.f \u2218 e.hinv}} {e.f \u2218 e.hinv} {id M} e.f_hinv x \u2218 f.trans (func {RingedLocaleHom.f {e.f}} x)\\n} => \\\\new NatTrans {\\n  | natural => {?hidden}\\n}', '| Dom : RingedLocale', '| id (X : Ob) : Hom X X', '| Ob : \\\\hType', '| func (E {Dom}) : E {Cod}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\class RingedLocale {\\n  | L : Locale\\n  | R : VSheaf CRingCat L\\n}', '\\\\func homMap {L1 M : RingedLocale} {f1 g : RingedLocaleHom M L1} (p : f1 = g) (a : E {L.L}) :\\n  RingHom (Functor.F {VPresheaf.F {M.R}} (func {f.f} a)) (Functor.F {VPresheaf.F {M.R}} (func {g.f} a)) \\n=> Func {VPresheaf.F {M.R}} {func {f.f} a} {func {g.f} a} (=_<= {M.L} {func {g.f} a} {func {f.f} a}\\n  (inv {E {M.L}} {func {f.f} a} {func {g.f} a} (path (\\\\lam (i : I) => func {f {p @ i}} a))))', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>NatTrans {Precat.op {L {e.cod}}} {CRingCat}\n  (Comp {Precat.op {L {e.cod}}} {Precat.op {L {e.dom}}} {CRingCat} (VPresheaf.F {R {e.dom}})\n    (Functor.op {functor {RingedLocaleHom.f {e.f}}})) (VPresheaf.F {R {e.cod}}) {\n  | trans => \\lam (x : Ob {C {\\this}}) =>\n    homMap {Cod {e.f \u2218 e.hinv}} {Dom {e.f \u2218 e.hinv}} {e.f \u2218 e.hinv} {id e.cod} e.f_hinv x \u2218 trans {f# {e.hinv}} (func {RingedLocaleHom.f {e.f}} x)\n}", "completion": "natTrans-inv (f# {hinv {e}})"}
{"prompt": "['a2 : List (Fin (len {env}))', 'this : Data', 'a : \\\\Sigma (List (Fin (len {env}))) (E {C})', 'l : List (\\\\Sigma (List (Fin (len {env}))) (E {C}))', 'a3 : List (Fin (len {env}))', 'a1 : E {C}']<<<break>>>['| \\\\infixl 6 + E E : E', 'suc Nat', '| C : Semiring', 'nil', '\\\\func map {A1 B2 : \\\\Type} (_ : A1 -> B2) (_ : List A1) : List B2 \\n  | {A}, {B}, f, nil => nil {B}\\n  | {A}, {B}, f, a :: l => f a :: map {A} {B} f l', '| Cod : BaseSet', \"\\\\lemma interpretNF_map \\\\hlevels  {this : Data} {a1 : E {C}} {a2 a3 : List (Fin (len {env}))} {l : NF} :\\ninterpretNF' (map {\\\\Sigma (List (Fin (len {env}))) (E {C})} {\\\\Sigma (List (Fin (len {env}))) (E {C})}\\n  (\\\\lam (b : \\\\Sigma (List (Fin (len {env}))) (E {C})) => (a2 ++ b.1 ++ a3, a1 * b.2)) l) = func {alg} a1 * interpretNF {R} {Fin (len {env})} (at {env}) a2 * interpretNF' l * interpretNF {R} {Fin (len {env})} (at {env}) a3 \", '\\\\infixl 7 :* (_ _ : Term n)', '| \\\\infixl 7 * E E : E', '\\\\lemma interpretNF_++ \\\\hlevels  {M : Monoid} {V : \\\\Set} {env : V -> M.E} {t s : List V} :\\n  interpretNF {M} {V} env (t ++ s) = interpretNF {M} {V} env t M.* interpretNF {M} {V} env s ', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '\\\\lemma terms-equality \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s)) :\\n  interpret {env.len} env.at t = interpret {env.len} env.at s ', '| E : \\\\Set', \"\\\\func interpretNF' \\\\hlevels  {this3 : Data} (_ : NF) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => mulCoef x.2 x.1\\n  | {this}, x :: l => mulCoef x.2 x.1 + interpretNF' l\", \"\\\\lemma interpretNF_:: \\\\hlevels  {this : Data} {x : \\\\Sigma (List (Fin (len {env}))) (E {C})} {l : NF} :\\n  interpretNF' (x :: l) = func {alg} x.2 * interpretNF {R} {Fin (len {env})} (at {env}) x.1 + interpretNF' l \", 'var (Fin n)', '| alg : SemiringHom C R', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func MonoidSolverModel \\\\hlevels  (M1 : Monoid) : SubstSolverModel M.E {\\n  | Term => MonoidSolverModel.Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => \\\\lam {n : Nat} (t : SolverModel.Term {\\\\this} n) => normalize-aux {n} t (nil {Fin n})\\n  | interpret => MonoidSolverModel.interpret {M1}\\n  | interpretNF => \\\\lam {n : Nat} => MonoidSolverModel.interpretNF {M1} {Fin n}\\n  | nfVar => \\\\lam {n : Nat} (v : Fin n) => v :: nil {Fin n}\\n  | >>= => \\\\lam {m : Nat} {n : Nat} => (>>=)\\n} => \\\\new SubstSolverModel {\\n  | interpretNF-consistent => {?hidden}\\n  | >>=-consistent => {?hidden}\\n}', '| len : Nat', '| env : Array (E {R})', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| alg-comm (x : E {C}) (y : E {R}) : func {alg} x * y = y * func {alg} x', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| ldistr {x y z : E} : x * (y + z) = x * y + x * z', '\\\\func interpretNF \\\\hlevels  {M2 : Monoid} {V1 : \\\\Set} (_ : V1 -> M.E) (_ : List V1) : M.E \\n  | {M}, {V}, env, nil => M.ide\\n  | {M}, {V}, env, x :: nil => env x\\n  | {M}, {V}, env, x :: l => env x M.* interpretNF {M} {V} env l', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| R : Semiring', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| rdistr {x y z : E} : (x + y) * z = x * z + y * z', '\\\\lemma apply-axiom \\\\hlevels  {this : SubstSolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpret {env.len} env.at t = interpret {env.len} env.at s) (pattern : NF (suc env.len)) :\\n  interpretNF {env.len} env.at (pattern >>= fcase {NF env.len} {env.len} (normalize {env.len} t) (nfVar {env.len})) = interpretNF {env.len} env.at (pattern >>= fcase {NF env.len} {env.len} (normalize {env.len} s) (nfVar {env.len})) ', '| func (E {Dom}) : E {Cod}', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpretNF'\n((a2 ++ a.1 ++ a3, a1 * a.2) :: map {\\Sigma (List (Fin (len {env}))) (E {C})} {\\Sigma (List (Fin (len {env}))) (E {C})}\n  (\\lam (b : \\Sigma (List (Fin (len {env}))) (E {C})) => (a2 ++ b.1 ++ a3, a1 * b.2)) l) = func {alg} a1 * interpretNF {R} {Fin (len {env})} ((!!) env) a2 * interpretNF' (a :: l) * interpretNF {R} {Fin (len {env})} ((!!) env) a3", "completion": "rewrite (interpretNF_:: {this})\n  (rewrite (interpretNF_:: {this}) (rewrite interpretNF_++ (rewrite interpretNF_++ (rewrite (func-* {alg {this}})\n    (rewrite ldistr (rewrite rdistr (pmap2 (+) (monoid {alg-comm {this} a.2 (interpretNF (env {this}) a2)}) interpretNF_map)))))))"}
{"prompt": "['I : Ideal', 'c : E {I.S}', 'b : E {I.S}', 'a : E {I.S}', 'r : I.contains (b - c)']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| ideal-left {r a : E {S}} (contains a) : contains (r * a)', '| S : BaseSet', '| contains (E {S}) : \\\\Prop']<<<break>>>I.contains (a * (b - c))", "completion": "ideal-left {I} r"}
{"prompt": "[\"V'<=<V : V' <=< V\", 'V : Set Y.E', 'F : WeaklyCauchyFilter Y', \"V' : Set (E {F.S})\", 'X : CoverSpace', 'f : CoverMap X Y', 'Y : CoverSpace', \"FV' : F.F V'\"]<<<break>>>['| F (E {A}) : \\\\Prop', '| <=-refl {x : E} : x <= x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '| Cod : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| Dom : BaseSet']<<<break>>>TruncP (\\Sigma (V' V1 : Set Y.E) (f.func ^-1 V1 \u2286 f.func ^-1 V) (V' <=< V1) (F.F V'))", "completion": "inP (V', V, <=-refl, V'<=<V, FV')"}
{"prompt": "['a : Rat', 'b : Rat']<<<break>>>['true', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatData (a :: b :: zro :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 3} 0 :+ (var {E} {Fin 3} 1 :+ :negative {E} {Fin 3} (var {E} {Fin 3} 0))) <= interpret {\\new LinearRatData (a :: b :: zro :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 3} 1)", "completion": "solve<=Problem {\\new LinearRatData {\n  | R => RatField\n  | vars => a :: b :: zro :: nil\n}} nil (var 0 :+ (var 1 :+ :negative (var 0))) (var 1) (1 :: nil, 0, idp, idp {Bool} {true}) nil"}
{"prompt": "['a1 : Fin (len {vars})', 'this : LData']<<<break>>>['| meet-left {x y : E} : x \u2227 y <= x', '| L : TopMeetSemilattice', '| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', '| <=-refl {x : E} : x <= x', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y', '| vars : Array (E {M})']<<<break>>>vars !! a1 \u2227 vars !! a1 = vars !! a1", "completion": "<=-antisymmetric meet-left (meet-univ <=-refl <=-refl)"}
{"prompt": "['a : FrameHom M L']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| Join {J : \\\\Set} (J -> E) : E', '| func-Join {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\\\lam (j : J) => func (f j))', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>\\Pi {J : \\Set} ->\n  \\Pi {f : J -> E {a.Dom}} -> a.func (Join {a.Dom} {J} f) = Join {a.Cod} {J} (\\lam (j : J) => a.func (f j))", "completion": "func-Join {a}"}
{"prompt": "['env : Array G.E l.len', 'G : CGroup', 'l : Array Int']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func ipow \\\\hlevels  {this2 : Group} (_ : E) (_ : Int) : E \\n  | {this}, a, pos n => pow a n\\n  | {this}, a, neg n => pow (inverse a) n', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set']<<<break>>>Array G.E l.len (\\lam (j : Fin l.len) => ipow {G} (env.at j) (l.at j))", "completion": "\\lam j => ipow {G} (env j) (l j)"}
{"prompt": "['y>0 : zro < y', 'y : Real']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', '\\\\lemma pinv-right \\\\hlevels  {this : OrderedField} {x : E} (x>0 : zro < x) : x * pinv x {?hidden} = ide ', '| ide : E', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| E : \\\\Set', '\\\\func pinv \\\\hlevels  {this : OrderedField} (x : E) (\\\\property x>0 : zro < x) : E => inv {pos#0 {x} x>0}', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>y * pinv {RealField} y {?hidden} = ide", "completion": "pinv-right {RealField} y>0"}
{"prompt": "['X : CoverSpace', 'ph : IsRelativelyHausdorff {Z} {T} p', 'i : CoverMap X Y', 'g : ContMap Y T', 'sq : \\\\Pi (x : X.E) -> g.func (i.func x) = p (f.func x)', 'p : Z.E -> T.E', 'f : CauchyMap X Z', 'Z : CoverSpace', 'T : CoverSpace', 'Y : CoverSpace', 'this : CauchyMap Y Z {\\n  | func => \\\\lam (y : E {Dom {\\\\this}}) => (lift-contr {i.Dom} {i.Cod} {Z} {T} {p} pc ph {i} {f} {g} id sq y).1\\n  | func-cont => {?hidden}\\n  | func-cauchy => {?hidden}\\n}', 'pc : IsRelativelyComplete {Z} {T} p', 'id : IsDenseEmbedding {i}', 'F : CauchyFilter (Dom {\\\\this})']<<<break>>>['| <=<-right {U V W : E {A}} (U <= V) (R V W) : R U W', '| S : CoverSpace', '| X : \\\\Set', '| isCauchy (Set (Set E)) : \\\\Prop', 'inP A', '| Cod : BaseSet', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\lemma <=<-inter \\\\hlevels  {X : CoverSpace} {x : X.E} {U : Set X.E} (_ : single {X.E} x <=< U) :\\n  TruncP (\\\\Sigma (V : Set X.E) (single {X.E} x <=< V) (V <=< U)) ', '| isProper {U : Set X} (F U) : TruncP (\\\\Sigma (x : X) (U x))', '\\\\lemma <=<_<= \\\\hlevels  {X : PrecoverSpace} {V U : Set X.E} (_ : V <=< U) : V <= U ', '\\\\lemma <=<-cont \\\\hlevels  {X : PrecoverSpace} {Y : CoverSpace} {f : ContMap X Y} {x : X.E} {U : Set Y.E} (_ : single {Y.E} (f.func x) <=< U) :\\n  single {X.E} x <=< f.func ^-1 U ', '\\\\lemma relativelyCompleteAndSeparated \\\\hlevels  {X Y : CoverSpace} (p : X.E -> Y.E) (_ : IsRelativelyComplete {X} {Y} p) (_ : IsRelativelyHausdorff {X} {Y} p)\\n  (F1 : CauchyFilter X) {y : Y.E} (_ : F {pointCF {Y} y} \u2286 F {SetFilter-map {X.E} {Y.E} p F1}) :\\n  Contr (\\\\Sigma (x : X.E) (p x = y) (F {pointCF {X} x} \u2286 F.F)) ', '| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func ProperFilter-map \\\\hlevels  {X1 Y : \\\\Set} (f : X1 -> Y) (F1 : ProperFilter X1) :\\n  ProperFilter Y (\\\\lam (V : E {A {SetFilter-map {X1} {Y} f F1}}) => F.F (f ^-1 V)) => \\\\new ProperFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isProper => {?hidden}\\n}', '| E : \\\\Set', '\\\\lemma neighborhood \\\\hlevels  {X Y : CoverSpace} {p : X.E -> Y.E} {pc : IsRelativelyComplete {X} {Y} p} {ph : IsRelativelyHausdorff {X} {Y} p}\\n  {y : Y.E} (F1 : CauchyFilter X) {ys : F {pointCF {Y} y} \u2286 F {SetFilter-map {X.E} {Y.E} p F1}} {V U : Set X.E}\\n  (_ : V <=< U) (_ : F.F V) : single {X.E} center.1 <=< U ', '\\\\lemma single_<= \\\\hlevels  {X : \\\\Set} {a : X} {U : Set X} (_ : U a) : single {X} a \u2286 U ', '| A : TopMeetSemilattice', '| F (E {A}) : \\\\Prop', '| center : A', '| func-cauchy (F1 : CauchyFilter Dom) : CauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isProper => {?hidden}\\n}', '| filter-mono {a b : E {A}} (F a) (a <= b) : F b', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '\\\\class CauchyFilter \\\\extends WeaklyCauchyFilter, ProperFilter \\\\hlevels ', '| isCauchyFilter {C : Set (Set (E {S}))} (isCauchy {S} C) : TruncP (\\\\Sigma (U : Set (E {S})) (C U) (F U))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))', '\\\\lemma filter-lift \\\\hlevels  {X Y Z : CoverSpace} {i : CoverMap X Y} {f : CauchyMap X Z} (id : IsDenseEmbedding {i}) {y : Y.E} : CauchyFilter f.Cod\\n  (\\\\lam (V : E {A {SetFilter-map {E {f.Dom}} {E {f.Cod}} f.func (dense-filter-lift {X} {Y} i id (pointCF {Y} y))}}) =>\\n    F {dense-filter-lift {X} {Y} i id (pointCF {Y} y)} (f.func ^-1 V)) ', '\\\\func SetFilter-map \\\\hlevels  {X1 Y : \\\\Set} (f : X1 -> Y) (F1 : SetFilter X1) : SetFilter Y (\\\\lam (V : E {A {\\\\this}}) => F.F (f ^-1 V)) \\n=> \\\\new SetFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n}', '| filter-top : F (top {A})', '| func (E {Dom}) : E {Cod}', \"\\\\func dense-filter-lift \\\\hlevels  {X1 Y : CoverSpace} (f : CoverMap X1 Y) (fd : IsDenseEmbedding {f}) (F1 : CauchyFilter Y) :\\n  CauchyFilter X1 (\\\\lam (U : E {A {\\\\this}}) => TruncP (\\\\Sigma (V' V : Set Y.E) (f.func ^-1 V \u2286 U) (V' <=< V) (F.F V'))) \\n=> \\\\new CauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n}\", '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '| Dom : BaseSet', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}']<<<break>>>CauchyFilter (Cod {\\this})\n  (\\lam (V : E {A {SetFilter-map {E {Dom {\\this}}} {E {Cod {\\this}}} (func {\\this}) F1}}) => F.F (func {\\this} ^-1 V)) {\n  | filter-mono => {?hidden}\n  | filter-top => {?hidden}\n  | filter-meet => {?hidden}\n  | isCauchyFilter => {?hidden}\n  | isProper => {?hidden}\n}", "completion": "\\new CauchyFilter {\n  | isCauchyFilter => \\lam Cc => (\\scase isCauchyFilter {func-cauchy {f} (dense-filter-lift i id F)} (isRegular Cc) \\with {\n    | inP (U', inP (U, CU, U'<=<U), inP (V', V, q, V'<=<V, FV')) => inP (U, CU, filter-mono FV'\n      (\\lam {y} V'y => <=<_<= (neighborhood (filter-lift id) U'<=<U (\\case <=<-inter $ <=<-right (single_<= V'y) V'<=<V \\with {\n        | inP (V'', y<=<V'', V''<=<V) => inP $ later (V'', V, q, V''<=<V, y<=<V'')\n      })) idp))\n  })\n}"}
{"prompt": "[\"leaves-r : count-leaves l + count-leaves r -' count-leaves l = count-leaves r\", 'this : NatData', 'r : GroupTerm V', 'l : GroupTerm V', \"w : (remove-pair r (count-leaves l + count-leaves r -' count-leaves l)).2 = true\"]<<<break>>>['true', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| ide : E', \"\\\\func rp-returns-true-lemma-right \\\\hlevels  {this4 : NatData} (t1 : GroupTerm V) (_ : (remove-pair t1 (count-leaves t1)).2 = true) :\\n  \\\\Sigma (interpret t1 = interpret (get-leaf t1 (count-leaves t1))) (interpret (remove-pair t1 (count-leaves t1)).1 = ide {G}) \\n  | {this}, l :* r, p => \\n    \\\\let | _ => (rp-returns-true-lemma''' l r (count-leaves (l :* r)) p).1\\n         | p_r => (rp-returns-true-lemma''' l r (count-leaves (l :* r)) p).2\\n         | t-eq-l => (rp-returns-true-lemma''' l r (count-leaves (l :* r)) p).3\\n         | abs => transport {Nat} (\\\\lam (x : Nat) => x >= 1) {count-leaves r} {0} (cancel-left (count-leaves l) {count-leaves r} {0} t-eq-l)\\n           (rp-returns-true-lemma'' r 0 p_r)\\n         | abs' => <=-antisymmetric {0} {1} (zero<=_ {1}) abs\\n    \\\\in \\\\case abs' \\\\with {}\\n  | {this}, var v, p =>\\n    (idp {E {G}} {interpret (var {Nat} v)}, idp {E {G}} {interpret (remove-pair (var {Nat} v) (count-leaves (var {Nat} v))).1})\\n  | {this}, :ide, p =>\\n    (idp {E {G}} {interpret (:ide {Nat})}, idp {E {G}} {interpret (remove-pair (:ide {Nat}) (count-leaves (:ide {Nat}))).1})\\n  | {this}, :inv t, p => \\\\case t, p \\\\with {\\n    | var v, p => (idp {E {G}} {inverse {G} (interpret (var {Nat} v))},\\n      idp {E {G}} {interpret (remove-pair (:inv {Nat} (var {Nat} v)) (count-leaves (:inv {Nat} (var {Nat} v)))).1})\\n    | :ide, p1 => \\n      \\\\let | abs => rp-returns-true-lemma'' (:inv {V} (:ide {V})) (count-leaves (:ide {V})) p1\\n           | _ => <=-antisymmetric {0} {1} (zero<=_ {1}) abs\\n      \\\\in \\\\case inv {Bool} {(remove-pair (:inv {Nat} t) (count-leaves (:inv {Nat} t))).2} {true} p *> p *> inv {Bool} {(remove-pair (:inv {Nat} (:ide {Nat})) (count-leaves (:inv {Nat} (:ide {Nat})))).2} {true} p1 \\\\with {}\\n    | :inv g, p1 => \\n      \\\\let | abs => rp-returns-true-lemma'' (:inv {V} (:inv {V} g)) (count-leaves (:inv {V} g)) p1\\n           | _ => <=-antisymmetric {0} {1} (zero<=_ {1}) abs\\n      \\\\in \\\\case inv {Bool} {(remove-pair (:inv {Nat} t) (count-leaves (:inv {Nat} t))).2} {true} p *> p *> inv {Bool} {(remove-pair (:inv {Nat} (:inv {Nat} g)) (count-leaves (:inv {Nat} (:inv {Nat} g)))).2} {true} p1 \\\\with {}\\n    | t1 :* s, p1 => \\n      \\\\let | abs => rp-returns-true-lemma'' (:inv {V} (t1 :* s)) (count-leaves (t1 :* s)) p1\\n           | _ => <=-antisymmetric {0} {1} (zero<=_ {1}) abs\\n      \\\\in \\\\case inv {Bool} {(remove-pair (:inv {Nat} t) (count-leaves (:inv {Nat} t))).2} {true} p *> p *> inv {Bool} {(remove-pair (:inv {Nat} (t1 :* s)) (count-leaves (:inv {Nat} (t1 :* s)))).2} {true} p1 \\\\with {}\\n  }\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", \"\\\\func remove-pair \\\\hlevels  {this5 : NatData} (_ : GroupTerm V) (_ : Nat) : \\\\Sigma (GroupTerm V) Bool \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | less _x => \\n      \\\\let res-l => remove-pair l fstLeafToRemoveInd\\n      \\\\in \\\\case res-l.2 \\\\with {\\n            | true => (r, false)\\n            | false => (res-l.1 :* r, false)\\n          }\\n    | equals p => \\n      \\\\let | res-l => remove-pair l fstLeafToRemoveInd\\n           | res-r => remove-pair r 0\\n      \\\\in \\\\case res-l.2, res-r.2 \\\\with {\\n            | true, true => (:ide {Nat}, true)\\n            | true, false => res-r\\n            | false, true => res-l\\n            | false, false => (res-l.1 :* res-r.1, false)\\n          }\\n    | greater _x => \\n      \\\\let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l)\\n      \\\\in \\\\case res-r.2 \\\\with {\\n            | true => (l, false)\\n            | false => (l :* res-r.1, false)\\n          }\\n  }\\n  | {this}, :inv (var x), fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :inv g, fstLeafToRemoveInd => (:inv {V} g, false)\\n  | {this}, var x, fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :ide, fstLeafToRemoveInd => (:ide {Nat}, false)\", '| G : Group', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func count-leaves \\\\hlevels  {this1 : NatData} (_ : GroupTerm V) : Nat \\n  | {this}, l :* r => count-leaves l + count-leaves r\\n  | {this}, :inv (var x) => 1\\n  | {this}, :inv g => 0\\n  | {this}, var x => 1\\n  | {this}, t => 0', '\\\\infixl 6 :* (_ _ : GroupTerm V)', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '\\\\func interpret \\\\hlevels  {this4 : GroupData} (_ : GroupTerm V) : E {G} \\n  | {this}, var x => f x\\n  | {this}, :ide => ide {G}\\n  | {this}, :inv t => inverse {G} (interpret t)\\n  | {this}, t :* s => interpret t * interpret s']<<<break>>>interpret (remove-pair r (count-leaves r)).1 = ide {G}", "completion": "(rp-returns-true-lemma-right {this} r (rewrite (inv leaves-r) w)).2"}
{"prompt": "['R : SmithDomain', 'bv : IsBasis {V} lv', \"lu : Array U.E lu'.len\", \"lv : Array V.E lv'.len\", 'f : LinearMap {R} U V', 'c : Array (E {U.R}) lu.len', \"lv' : Array V.E\", 'U : LModule R', 'V : LModule R', \"lu' : Array U.E\"]<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '\\\\func DivPreoder \\\\hlevels  (M : CMonoid) : Preorder M.E {\\n  | <= => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => TruncP (LDiv {M} y x)\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', '\\\\lemma rank<=rows \\\\hlevels  {R : SmithDomain} {n m : Nat} {A : Matrix R.E n m} : rank {R} {n} {m} A <= n ', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func fin-inc_<= \\\\plevels  \\\\hlevels  {n m : Nat} (p : n <= m) (i : Fin n) : Fin m => toFin i {m} {?hidden}', '| at (j : Fin len) : A j', '\\\\lemma divQuotient_dec0 \\\\hlevels  {this : CRing.Dec} (a : DivQuotient this) : Set.Dec (a = in~ {E} {(~)} zro) ', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray', '\\\\func EquivRel \\\\hlevels  {this2 : Preorder} : Equivalence E {\\n  | ~ => \\\\lam (x : A {\\\\this}) (y : A {\\\\this}) => \\\\Sigma (x <= y) (y <= x)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', 'in~ A', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func rank \\\\hlevels  {R : SmithDomain} {n m : Nat} (A : Matrix R.E n m) : Nat => firstNonZero {R} (rank-array {R} {n} {m} A).1', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\lemma rank-array {R : SmithDomain} {n m : Nat} (A : Matrix R.E n m) :\\n\\\\level (\\\\Sigma (d : Array (DivQuotient R) (n \u2227 m)) (TruncP (\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n  (\\\\Pi (j : Fin (n \u2227 m)) -> d.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n    | less _x => n\\n    | equals p => n\\n    | greater _x => m\\n  }} {n} (meet-left {n} {m}) j)}\\n    (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n      | less _x => n\\n      | equals p => n\\n      | greater _x => m\\n    }} {m} (meet-right {n} {m}) j)))))) (\\\\lam (p0 : \\\\Sigma (d : Array (DivQuotient R) (n \u2227 m)) (TruncP (\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n  (\\\\Pi (j : Fin (n \u2227 m)) -> d.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n    | less _x => n\\n    | equals p => n\\n    | greater _x => m\\n  }} {n} (meet-left {n} {m}) j)}\\n    (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n      | less _x => n\\n      | equals p => n\\n      | greater _x => m\\n    }} {m} (meet-right {n} {m}) j))))))\\n  (p1 : \\\\Sigma (d : Array (DivQuotient R) (n \u2227 m)) (TruncP (\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n    (\\\\Pi (j : Fin (n \u2227 m)) -> d.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n      | less _x => n\\n      | equals p => n\\n      | greater _x => m\\n    }} {n} (meet-left {n} {m}) j)}\\n      (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n        | less _x => n\\n        | equals p => n\\n        | greater _x => m\\n      }} {m} (meet-right {n} {m}) j)))))) => (\\\\case p0, p1 \\\\with {\\n  | (d, inP (B, A~B, Bs, q)), (d', inP (B', A~B', B's, q')) => path (\\\\lam (i : I) => (\\n    \\\\have arg => path (\\\\lam (i : I) => (\\n            \\\\have arg => \\\\lam (j : Fin (n \u2227 m)) =>\\n                  q j *> ~-pequiv {R.E} {\\\\lam (x : R.E) (y : R.E) => \\\\Sigma (x <= y) (y <= x)} {at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n                    | less _x => n\\n                    | equals p => n\\n                    | greater _x => m\\n                  }} {n} (meet-left {n} {m}) j)}\\n                    (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n                      | less _x => n\\n                      | equals p => n\\n                      | greater _x => m\\n                    }} {m} (meet-right {n} {m}) j)} {at {at {B'} (toFin j {n} {?hidden})} (toFin j {m} {?hidden})} (smith-div-equiv\\n                  {R} {n} {m} {B'} {B} B's Bs (~-transitive {B'} {A} {B} (~-symmetric {A} {B'} A~B') A~B) (toFin j {n} {?hidden})\\n                    (toFin j {m} {?hidden})) *> inv {Quotient {R.E} (~)} {d'.at j} {in~ {R.E} {\\\\lam (x : R.E) (y : R.E) => \\\\Sigma (x <= y) (y <= x)}\\n                    (at {at {B'} (toFin j {n} {?hidden})} (toFin j {m} {?hidden}))} (q' j)\\n            \\\\in \\\\new Array (DivQuotient R) (n \u2227 m) (\\\\lam (j : Fin (n \u2227 m)) => arg j @ i)))\\n    \\\\in (arg @ i, prop-dpi (\\\\lam (i : I) => TruncP (\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n          (\\\\Pi (j : Fin (n \u2227 m)) -> at {arg @ i} j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n            | less _x => n\\n            | equals p => n\\n            | greater _x => m\\n          }} {n} (meet-left {n} {m}) j)}\\n            (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n              | less _x => n\\n              | equals p => n\\n              | greater _x => m\\n            }} {m} (meet-right {n} {m}) j)))))\\n          (inP {\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n            (\\\\Pi (j : Fin (n \u2227 m)) -> d.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n              | less _x => n\\n              | equals p => n\\n              | greater _x => m\\n            }} {n} (meet-left {n} {m}) j)}\\n              (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n                | less _x => n\\n                | equals p => n\\n                | greater _x => m\\n              }} {m} (meet-right {n} {m}) j)))} (B, A~B, Bs, q))\\n          (inP {\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n            (\\\\Pi (j : Fin (n \u2227 m)) -> d'.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n              | less _x => n\\n              | equals p => n\\n              | greater _x => m\\n            }} {n} (meet-left {n} {m}) j)}\\n              (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n                | less _x => n\\n                | equals p => n\\n                | greater _x => m\\n              }} {m} (meet-right {n} {m}) j)))} (B', A~B', B's, q')) @ i)))\\n})) \", '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '| zro : E', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma dec_decide \\\\plevels  \\\\hlevels  {E : \\\\Prop} (_ : Dec E) : Decide E ', '\\\\func toMatrix \\\\hlevels  {R : Ring} {U V : LModule R} {lv : Array V.E} (lu : Array U.E) (bv : IsBasis {V} lv) (f : LinearMap {R} U V) :\\n  Matrix R.E lu.len lv.len \\n  => mkMatrix {R.E} {lu.len} {lv.len} (\\\\lam (i : Fin lu.len) => at {basis-split {V} {lv} bv (f.func (lu.at i))})', '\\\\func find {A2 : \\\\Type} (P2 : A2 -> Decide) (l1 : Array A2) :\\nOr (\\\\Sigma (j : Fin l.len) (E {P2 (l.at j)}) (\\\\Pi {i : Fin l.len} -> i < j -> E {P2 (l.at i)} -> Empty))\\n  (\\\\Pi {j : Fin l.len} -> E {P2 (l.at j)} -> Empty) \\n  | {A}, P, nil => inr {\\\\Sigma (j : Fin 0) (E {P (at {nil} j)}) (\\\\Pi {i : Fin 0} -> i < j -> E {P (at {nil} i)} -> Empty)}\\n    {\\\\Pi {j : Fin 0} -> E {P (at {nil} j)} -> Empty} (\\\\lam {j : Fin 0} => (\\\\case j \\\\with {}))\\n  | {A}, P, :: {n} a l => \\\\case decide {P a} \\\\with {\\n    | yes e => inl {\\\\Sigma (j : Fin (suc l.len)) (E {P (at {a :: l} j)}) (\\\\Pi {i : Fin (suc l.len)} -> i < j -> E {P (at {a :: l} i)} -> Empty)}\\n      {\\\\Pi {j : Fin (suc l.len)} -> E {P (at {a :: l} j)} -> Empty}\\n      (0, e, \\\\lam {i : Fin (suc l.len)} (p0 : i < 0) => (\\\\case p0 \\\\with {}))\\n    | no q => \\\\case find {A} P l \\\\with {\\n      | inl e => inl {\\\\Sigma (j : Fin (suc l.len)) (E {P (at {a :: l} j)}) (\\\\Pi {i : Fin (suc l.len)} -> i < j -> E {P (at {a :: l} i)} -> Empty)}\\n        {\\\\Pi {j : Fin (suc l.len)} -> E {P (at {a :: l} j)} -> Empty}\\n        (suc e.1, e.2, \\\\lam {i : Fin (suc l.len)} => (\\\\case i \\\\with {\\n          | zero => \\\\lam (_ : 0 < suc e.1) => q\\n          | suc i => \\\\lam (p0 : suc i < suc e.1) => (\\\\case p0 \\\\with {\\n            | suc<suc p => e.3 {i} p\\n          })\\n        }))\\n      | inr p => inr {\\\\Sigma (j : Fin (suc l.len)) (E {P (at {a :: l} j)}) (\\\\Pi {i : Fin (suc l.len)} -> i < j -> E {P (at {a :: l} i)} -> Empty)}\\n        {\\\\Pi {j : Fin (suc l.len)} -> E {P (at {a :: l} j)} -> Empty} (\\\\lam {j : Fin (suc l.len)} => (\\\\case j \\\\with {\\n          | zero => q\\n          | suc j => p {j}\\n        }))\\n    }\\n  }']<<<break>>>Array R.E (\\case find {Quotient {E {R}} (~)}\n  (\\lam (a : Quotient {E {R}} (~)) => dec_decide {a = in~ {E {R}} {(~)} (zro {R})} (divQuotient_dec0 {R} a))\n  (rank-array {R} {lu'.len} {lv'.len} (toMatrix {R} {U} {V} {lv} lu bv f)).1 \\with {\n  | inl s => s.1\n  | inr _x => lu'.len \u2227 lv'.len\n})\n  (\\lam (j : Fin (\\case find {Quotient {R.E} (~)} (\\lam (a : Quotient {R.E} (~)) => dec_decide {a = in~ {R.E} {(~)} R.zro} (divQuotient_dec0 {R} a))\n    (rank-array {R} {lu'.len} {lv'.len} (toMatrix {R} {U} {V} {lv} lu bv f)).1 \\with {\n    | inl s => s.1\n    | inr _x => lu'.len \u2227 lv'.len\n  })) => c.at (fin-inc_<= {rank {R} {lu'.len} {lv'.len} (toMatrix {R} {U} {V} {lv} lu bv f)} {lu'.len}\n    (rank<=rows {R} {lu'.len} {lv'.len} {toMatrix {R} {U} {V} {lv} lu bv f}) j))", "completion": "mkArray (\\lam j => c (fin-inc_<= rank<=rows j))"}
{"prompt": "['Y : UniformSpace', \"C'u : Y.isUniform C'\", \"C' : Set (Set Y.E)\"]<<<break>>>['\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '| uniform-star {C : Set (Set E)} (isUniform C) : TruncP (\\\\Sigma (D : Set (Set E)) (isUniform D) (\\\\Pi {V : Set E} ->\\n  D V -> TruncP (\\\\Sigma (U : Set E) (C U) (\\\\Pi {W : Set E} -> D W -> \\\\Sigma (e : E) ((\u2227) V W e) -> W \u2286 U))))', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (D : Set (Set Y.E)) (Y.isUniform D) (\\Pi {V : Set Y.E} ->\n  D V -> TruncP (\\Sigma (U : Set Y.E) (C' U) (\\Pi {W : Set Y.E} -> D W -> \\Sigma (e : Y.E) ((\u2227) V W e) -> W \u2286 U))))", "completion": "uniform-star C'u"}
{"prompt": "['i : Fin (suc n)', 'q : Not (i = j)', 'j : Fin (suc n)', 'n : Nat']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', 'no (Not E)', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', 'suc Nat', '\\\\lemma fsuc/= \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : x /= y) : fsuc {n} x /= fsuc {n} y ', '\\\\lemma decideEq/=_reduce \\\\hlevels  {A : DecSet} {x y : A.E} (p : x /= y) : A.decideEq x y = no {x = y} p ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>decideEq (suc i) (suc j) = no {suc i = suc j} (fsuc/= {suc n} {i} {j} q)", "completion": "decideEq/=_reduce (fsuc/= q)"}
{"prompt": "['x : E', 'this : TopRieszSpace', 'q<=1 : q <= fromInt (pos 1)', 'y : E', 'q : Rat']<<<break>>>['\\\\lemma <=_*q-left \\\\hlevels  {this : PosetQModule} {q r : Rat} (_ : q <= r) {a : E} (_ : zro <= a) : q *q a <= r *q a ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| abs>=0 {x : E} : zro <= abs x', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', 'pos Nat']<<<break>>>q *q abs (x - y) <= fromInt (pos 1) *q abs (x - y)", "completion": "<=_*q-left {this} q<=1 (abs>=0 {this})"}
{"prompt": "['a : E', 'this : BooleanAlgebra', 'b : E']<<<break>>>['| meet-left {x y : E} : x \u2227 y <= x', '\\\\lemma \\\\infixr 9 =<= \\\\hlevels  {E1 : Preorder} {x y z : E.E} (_ : x = y) (_ : y E.<= z) : x E.<= z ', '\\\\lemma meet-comm \\\\hlevels  {this : MeetSemilattice} {x y : E} : x \u2227 y = y \u2227 x ', '| <=-refl {x : E} : x <= x', '| compl-meet {a : E} : a \u2227 compl a <= bottom', '| bottom : E', '| \\\\infix 4 <= E E : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| compl E : E']<<<break>>>compl a \u2227 compl b \u2227 a <= bottom", "completion": "meet-monotone {this} (meet-left {this}) (<=-refl {this}) <=\u2218 {this} meet-comm {this} =<= compl-meet {this}"}
{"prompt": "[\"null : X.dist x' p0.2 < fromRat (half eps)\", 'p0 : \\\\Sigma X.E X.E', \"x' : X.E\", 'null : \\\\Pi {x : Rat} -> fromRat (half x) + fromRat (half x) = fromRat x', 'null : ldist {X} x y = ldist {X} y x', 'null : X.dist x p0.1 < fromRat (half eps)', \"y_y' : \\\\Sigma X.E X.E\", 'eps : Rat', 'null : X.dist x p0.1 < fromRat (half eps)', \"null : ldist {X} x y' <= ldist {X} x x' + ldist {X} x' y'\", \"null : ldist {X} x' y' = ldist {X} y' x'\", \"null : X.dist x' p0.2 < fromRat (half eps)\", 'x : X.E', 'X : PseudoMetricSpace', \"null : ldist {X} y y' <= ldist {X} y x + ldist {X} x y'\", \"null : ldist {X} x x' <= ldist {X} x y + ldist {X} y x'\", \"null : ldist {X} y x' <= ldist {X} y y' + ldist {X} y' x'\", 'null : \\\\Pi {x : Rat} -> fromRat (half x) + fromRat (half x) = fromRat x']<<<break>>>['true', '\\\\lemma real_<_U \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : x < fromRat a <-> x.U a ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '| dist E E : ExUpperReal', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| negative E : E', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| E : \\\\Set', '| <_join-univ {x y z : E} (x < z) (y < z) : x \u2228 y < z', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'join \\\\plevels  \\\\hlevels  (x y : Real) : Real => \\\\new Real (L {InfRealAbMonoid.join x y}) (U {InfRealAbMonoid.join x y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', 'LessOrEquals', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\func half \\\\plevels  \\\\hlevels  (a : Rat) : Rat => a * ratio (pos 1) 2', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\func ldist \\\\hlevels  {X : PseudoMetricSpace} (x y : X.E) : Real => X.dist x y', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', '\\\\func RealNormedAbGroup \\\\hlevels  : NormedAbGroup Real {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', '| U Rat : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\infixl 6 + \\\\hlevels  (x y : Real) : Real => \\\\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>U {join (X.dist x x' - X.dist p0.1 p0.2) (negative (X.dist x x' - X.dist p0.1 p0.2))} eps", "completion": "real_<_U.1 (<_join-univ (linarith (real_<_U.2 xy<eps/2, real_<_U.2 x'y'<eps/2, half+half, ldist-triang {X} {x} {y} {x'}, ldist-triang {X} {y} {y'} {x'},\n  ldist-symm {X} {x'} {y'}))\n  (linarith (real_<_U.2 xy<eps/2, real_<_U.2 x'y'<eps/2, half+half, ldist-triang {X} {y} {x} {y'}, ldist-triang {X} {x} {x'} {y'},\n    ldist-symm {X} {x} {y})))"}
{"prompt": "['j : \\\\Sigma (x : P.E) (embed {P} x <= U)', 'k : \\\\Sigma (y : \\\\Sigma (y : P.E) (Cover1 {P} y j.1))\\n  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))', 'P : FramePres']<<<break>>>['\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))']<<<break>>>\\Sigma -> Cover {P} k.1.1 {\\Sigma} (\\lam (_ : \\Sigma) => j.1)", "completion": "\\lam _ => k.1.2"}
{"prompt": "['p : V <=< U', 'U : Set X.E', 'X : PrecoverSpace', 'V : Set X.E']<<<break>>>['| isCauchy (Set (Set E)) : \\\\Prop', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>X.isCauchy (\\lam (W : Set X.E) => \\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)", "completion": "unfolds p"}
{"prompt": "['S : StronglyRegularCoverSpace', 'V : Set (StronglyRegularCauchyFilter S)', 'DV : D V', 'D : Set (Set (E {Cod {\\\\this}}))']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func pointSCF \\\\hlevels  {S1 : StronglyRegularCoverSpace} (x : S.E) : StronglyRegularCauchyFilter S1 ((<=<) (single {S.E} x)) \\n=> \\\\new StronglyRegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isWeaklyProper => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isStronglyRegularFilter => {?hidden}\\n}', 'inP A', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\class StronglyRegularCauchyFilter \\\\extends WeaklyCauchyFilter \\\\hlevels  {\\n  | isStronglyRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V s<=< U) (F V))\\n}']<<<break>>>TruncP (\\Sigma (V1 : Set (StronglyRegularCauchyFilter S)) (D V1) (pointSCF {S} ^-1 V = pointSCF {S} ^-1 V1))", "completion": "inP (V, DV, idp)"}
{"prompt": "['A : StoneC*Algebra']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '| norm E : ExUpperReal', '\\\\lemma zfunc_pow>0 \\\\hlevels  {A : StoneC*Algebra} {w : A.E} (w<=1 : w A.<= A.ide) (|1-w|<1 : U {A.norm (A.ide - w)} ide) :\\n  func {zfunc-lim {A}} (w A.* w, square-norm {A} {w} w<=1 (<_<= {A.norm (A.ide - w)} {ide} |1-w|<1)) = w ', '| \\\\infixl 7 * E E : E', '\\\\lemma <_<= \\\\plevels  \\\\hlevels  {x : ExUpperReal} {q : Rat} (_ : x.U q) : x <= fromRat q ', '\\\\lemma square-norm \\\\hlevels  {A : StoneC*Algebra} {w : A.E} (_ : w A.<= A.ide) (_ : A.norm (A.ide - w) <= ide) : A.norm (A.ide - w A.* w) <= ide ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\instance ExUpperRealLattice \\\\hlevels  : CompleteLattice ExUpperReal {\\n  | <= => (ExUpperReal.<=)\\n  | meet => meet\\n  | join => join\\n  | top => top-impl\\n  | Join => ExUpperRealLattice.Join\\n  | Meet => ExUpperRealLattice.Meet\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '| U Rat : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func zfunc-lim \\\\hlevels  {this1 : RealBanachAlgebra} : CoverMap UnitBall this1 {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => value {limit {NatBSemilattice} (\\\\lam (p0 : E) => zfunc p0 x.1)}\\n    (funcConv-pointwise {NatBSemilattice} {UnitBall} (\\\\lam (n : E) (s : E) => zfunc n s.1) zfunc-funcConv {x})\\n} => funcLimit {NatBSemilattice} {UnitBall} (\\\\lam (n : E) (s : E) => zfunc n s.1) zfunc-funcConv', '\\\\func TopTransfer \\\\hlevels  {X : \\\\Set} {Y : TopSpace} (f : X -> Y.E) : TopSpace X {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) => TruncP (\\\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}']<<<break>>>\\Pi {s : E} -> \\Pi (p : U {A.norm (A.ide - s.1)} ide) ->\n  func {zfunc-lim {A}} (s.1 A.* s.1, square-norm {A} {s.1} s.2.1 (<_<= {A.norm (A.ide - s.1)} {ide} p)) = s.1", "completion": "\\lam {s} p => zfunc_pow>0 {A} s.2.1 p"}
{"prompt": "[\"SR : SubRing (Cod {mPolyEval {Fin d'} {S1} (polyCoef {S1} p) \u2218 mPoly-mapHom {Fin d'} {R} {S1} f}) (\\\\lam (y : E {S {\\\\this}}) =>\\n  TruncP (\\\\Sigma (x : E {Dom {mPolyEval {Fin d'} {S1} (polyCoef {S1} p) \u2218 mPoly-mapHom {Fin d'} {R} {S1} f}})\\n    (func {mPolyEval {Fin d'} {S1} (polyCoef {S1} p) \u2218 mPoly-mapHom {Fin d'} {R} {S1} f} x = y)))\", 'S : CRing']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\class SubRing \\\\extends SubPseudoRing, SubSemiring \\\\hlevels ', '\\\\func cStruct \\\\hlevels  {R : CRing} (S1 : SubRing R) : CRing (\\\\Sigma (x : E {S.S}) (S.contains x)) {\\n  | zro => (zro {S.S}, contains_zro {\\\\new S1 {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new S1 {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S.S} x.1, contains_negative {\\\\new S1 {}} {x.1} x.2)\\n  | ide => (ide {S.S}, S.contains_ide)\\n  | natCoef => natCoefImpl {ISemiring {S1}}\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func IAddMonoid \\\\hlevels  {this2 : SubAddMonoid} : AddMonoid (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro)\\n  | + => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\\n} => \\\\new AddMonoid {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n}', '| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)', '\\\\func ISemiring \\\\hlevels  {this2 : SubSemiring} : Semiring (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro {\\\\new this2 {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new this2 {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n  | ide => (ide {S}, contains_ide)\\n  | natCoef => natCoefImpl\\n} => \\\\new Semiring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\class CRing \\\\extends Ring, PseudoCRing, CSemiring \\\\hlevels ', '| contains_ide : contains (ide {S})', '| ide : E', '| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| contains_zro : contains (zro {S})', '\\\\class SubPseudoSemiring \\\\extends SubAddMonoid, SubSemigroup \\\\hlevels ', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func IAddGroup \\\\hlevels  {this2 : SubAddGroup} : AddGroup (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro)\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E {\\\\this}) => (negative {S} x.1, contains_negative {x.1} x.2)\\n} => \\\\new AddGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | negative-right => {?hidden}\\n}', '\\\\func natCoefImpl \\\\hlevels  {this2 : Semiring} (_ : Nat) : E \\n  | {this}, 0 => zro\\n  | {this}, suc n => natCoefImpl n + ide', '\\\\func ISemigroup \\\\hlevels  {this2 : SubSemigroup} : Semigroup (\\\\Sigma (x : E {S}) (contains x)) {\\n  | * => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n} => \\\\new Semigroup {\\n  | *-assoc => {?hidden}\\n}', '| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)', '| E : \\\\Set', '| negative E : E', '| S : BaseSet', '| contains (E {S}) : \\\\Prop']<<<break>>>CRing (\\Sigma (x : E {SR.S}) (SR.contains x)) {\n  | zro => (zro {SR.S}, contains_zro {\\new SR {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new SR {}} {x.1} {y.1} x.2 y.2)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, SR.contains_* {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {SR.S} x.1, contains_negative {\\new SR {}} {x.1} x.2)\n  | ide => (ide {SR.S}, SR.contains_ide)\n  | natCoef => natCoefImpl {ISemiring {SR}}\n}", "completion": "cStruct SR"}
{"prompt": "['j : Fin c.len', 'f2 : \\\\Pi (i : Fin c.len) -> \\\\Sigma (j : Fin d.len) ((c !! i).1 = (d !! j).1) ((c !! i).2 B.<= (d !! j).2)', 'd : PFunc {V} {B}', 'c : PFunc {V} {B}', 'B : BooleanRing']<<<break>>>['\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\type \\\\infix 4 <= \\\\hlevels  {R : Semigroup} (x y : R.E) : \\\\Prop => x R.* y = x']<<<break>>>(c !! j).2 <= (d !! (f2 j).1).2", "completion": "(f2 j).3"}
{"prompt": "['this : Dec']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infix 4 > E E : \\\\Prop', 'yes E', 'no (Not E)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\data Tri \\\\hlevels  {A : StrictPoset} (_ _ : A.E) \\n  | less (a A.< a')\\n  | equals (a = a')\\n  | greater (a A.> a')\", '| <-irreflexive {x : E} : Not (x < x)', '| E : \\\\Set', '\\\\field trichotomy (x y : E) : Tri x y', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>\\Pi (x : E) -> \\Pi (y : E) -> Dec (x = y)", "completion": "\\lam x y => (\\case trichotomy {this} x y \\with {\n  | less x<y => no (\\lam x=y => <-irreflexive {this} (transport (\\lam _x => _x < {this} y) x=y x<y))\n  | equals x=y => yes x=y\n  | greater y<x => no (\\lam x=y => <-irreflexive {this} (transport ((<) {this} y) x=y y<x))\n})"}
{"prompt": "['k : Ob {J {lim (j.1, j.2 <=\u2218 m.1.2)}}', 'g : J -> Ob', 's : Sieve {C {\\\\this}} U', 'm : \\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)', 'U : Ob {C {\\\\this}}', 'P : FramePres', 'J : \\\\Set', 'c : B {\\\\this}', 'j : Ob {J {D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= m.1.1)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= m.1.1)) => t.1)}}\\n  (limFunctor {P} {D} {F} m.1.1)}}', 'lem : \\\\Pi (j : \\\\Sigma (x : P.E) (embed {P} x <= U)) -> \\\\Pi (k : \\\\Sigma (y : \\\\Sigma (y : P.E) (Cover1 {P} y j.1))\\n  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) ->\\ns.S {embed {P} k.1.1} (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))']<<<break>>>['| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cover1 \\\\hlevels  {P : FramePres} (x y : P.E) : \\\\Prop => Cover {P} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => y)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', '| F (Ob {C}) : Ob {D}', '\\\\type ObOver \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : \\\\hType => \\\\Sigma (y : C.Ob) (C.Hom y x)', '| D : Precat', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\lemma prop-pi \\\\plevels  \\\\hlevels  {A : \\\\Prop} {a a' : A} : a = a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| G : Functor J D', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| E : \\\\Set', '| S {y : Ob {C}} (Hom {C} y x) : \\\\Prop', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x']<<<break>>>Func {c.G} {m} {((embed {P} k.1.1, \\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\n  (cover-trans {P} {x} {\\Sigma} {\\lam (_ : \\Sigma) => j.1} {\\Sigma} {\\lam (_ : \\Sigma) => k.1.1} z<=y (\\lam (_ : \\Sigma) => k.1.2))),\n  lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))}\n  (\\lam {x : P.E} (d : (embed {P} k.1.1, \\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\n    (cover-trans {P} {x} {\\Sigma} {\\lam (_ : \\Sigma) => j.1} {\\Sigma} {\\lam (_ : \\Sigma) => k.1.1} z<=y (\\lam (_ : \\Sigma) => k.1.2))).1.1 x) => j.2 {x}\n    (cover-trans {P} {x} {\\Sigma} {\\lam (_ : \\Sigma) => j.1} {\\Sigma} {\\lam (_ : \\Sigma) => k.1.1} d (\\lam (_ : \\Sigma) => k.1.2)),\n    prop-pi {((embed {P} k.1.1, \\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\n      (cover-trans {P} {x} {\\Sigma} {\\lam (_ : \\Sigma) => j.1} {\\Sigma} {\\lam (_ : \\Sigma) => k.1.1} z<=y (\\lam (_ : \\Sigma) => k.1.2))),\n      lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2)).1.1 PresentedFrame.<= U}\n      {m.1.2 \u2218 (\\lam {x : P.E} (d : (embed {P} k.1.1, \\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\n        (cover-trans {P} {x} {\\Sigma} {\\lam (_ : \\Sigma) => j.1} {\\Sigma} {\\lam (_ : \\Sigma) => k.1.1} z<=y (\\lam (_ : \\Sigma) => k.1.2))).1.1 x) => j.2 {x}\n        (cover-trans {P} {x} {\\Sigma} {\\lam (_ : \\Sigma) => j.1} {\\Sigma} {\\lam (_ : \\Sigma) => k.1.1} d (\\lam (_ : \\Sigma) => k.1.2)))}\n      {((embed {P} k.1.1, \\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\n        (cover-trans {P} {x} {\\Sigma} {\\lam (_ : \\Sigma) => j.1} {\\Sigma} {\\lam (_ : \\Sigma) => k.1.1} z<=y (\\lam (_ : \\Sigma) => k.1.2))),\n        lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2)).1.2}) \u2218 c.coneMap m = c.coneMap ((embed {P} k.1.1, \\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\n  (cover-trans {P} {x} {\\Sigma} {\\lam (_ : \\Sigma) => j.1} {\\Sigma} {\\lam (_ : \\Sigma) => k.1.1} z<=y (\\lam (_ : \\Sigma) => k.1.2))),\n  lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))", "completion": "coneCoh {c} (\\lam d => j.2 (cover-trans d (\\lam _ => k.1.2)), prop-pi)"}
{"prompt": "['h : \\\\Pi (x : E) -> TruncP (\\\\Sigma (V1 : Set E) (E1 V1) (\\\\Pi {y : E} -> V (x - y) -> V1 y))', 'x : E', 'this : TopRieszSpace', 'V : Set E', 'E : Set (Set (E {Cod {\\\\this}}))', 'q : Rat']<<<break>>>['\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (V1 : Set E) (E1 V1) (\\Pi {y : E} -> V (q *q x - y) -> V1 y))", "completion": "h (q *q {this} x)"}
{"prompt": "['this : NormalSubGroup', 'y : E {S}', 'x : E {S}', 'r : x ~ y']<<<break>>>[\"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", 'var V', 'nil', '| inverse E : E', '| \\\\infixl 7 * E E : E', '\\\\infixl 7 :* (_ _ : MonoidTerm V)', '| isNormal (g : E {S}) {h : E {S}} (contains h) : contains (conjugate {S} g h)', '| E : \\\\Set', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\func interpretNF \\\\hlevels  {this3 : MonoidData} (_ : List (Fin (len {vars}))) : E {M} \\n  | {this}, nil => ide {M}\\n  | {this}, x :: nil => at {vars} x\\n  | {this}, x :: l => at {vars} x * interpretNF l', '| contains (E {S}) : \\\\Prop', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| inverse-right {x : E} : x * inverse x = ide', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| ide-left {x : E} : ide * x = x', '| M : Monoid', '\\\\func normalize {V : \\\\Type} (t : MonoidTerm V) : List V => aux {V} t (nil {V})', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func interpret \\\\hlevels  {this3 : MonoidData} (_ : MonoidTerm (Fin (len {vars}))) : E {M} \\n  | {this}, var x => at {vars} x\\n  | {this}, :ide => ide {M}\\n  | {this}, t :* s => interpret t * interpret s', '\\\\lemma interpretNF_++ \\\\hlevels  {this : MonoidData} (l1 l2 : List (Fin (len {vars}))) : interpretNF (l1 ++ l2) = interpretNF l1 * interpretNF l2 ', '| ide : E', '| vars : Array (E {M})', '\\\\lemma normalize-consistent \\\\hlevels  {this : MonoidData} (t : MonoidTerm (Fin (len {vars}))) : interpret t = interpretNF (normalize {Fin (len {vars})} t) ', '| contains_inverse {x : E {S}} (contains x) : contains (inverse {S} x)', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| S : BaseSet', '\\\\infixr 5 :: A (List A)']<<<break>>>contains (inverse {S} (y * inverse {S} x))", "completion": "contains_inverse {this} (rewriteEq (inverse-right {S {this}} {x}, ide-left) in isNormal {this} x r)"}
{"prompt": "['R : GradedCRing', 'f : Hom {C {\\\\this}} a b', 'c : Ob {C {\\\\this}}', 'a : Ob {C {\\\\this}}', 'b : Ob {C {\\\\this}}', 'g : Hom {C {\\\\this}} b c']<<<break>>>['| \\\\infixl 6 + E E : E', 'suc Nat', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| isHomogen E Nat : \\\\Prop', '\\\\func powers \\\\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (pow {M} a n = x))) \\n=> \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ', '\\\\func shom \\\\hlevels  {R : GradedCRing} {a b : R.E} {ad bd : Nat} {ah : R.isHomogen a ad} {bh : R.isHomogen b bd} (n : Nat) (c : R.E)\\n  (cd : Nat) (ch : R.isHomogen c cd) (p : pow {R} b n = a R.* c) (bd*n=ad+cd : bd Semigroup.* n = ad + cd) :\\nRingHom (HomogenLocRing {R} (powers {R} a)) (HomogenLocRing {R} (powers {R} b)) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (smap {R} {a} {b} {ad} {bd} ah bh n c cd ch p bd*n=ad+cd x).1\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '\\\\lemma functorial \\\\hlevels  {R : GradedCRing} {a b : R.E} {ad bd : Nat} (ah : R.isHomogen a ad) (bh : R.isHomogen b bd) (_ : bd /= 0)\\n  (_ : Cover1 {SpecPres R} b a) :\\n\\\\level (\\\\Sigma (f : RingHom (HomogenLocRing {R} (powers {R} a)) (HomogenLocRing {R} (powers {R} b)))\\n  (TruncP (\\\\Sigma (t : \\\\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd))\\n    (shom {R} {a} {b} {ad} {bd} {ah} {bh} t.1 t.2 t.3 t.4 t.5 t.6 = f)))) (level {\\\\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd)}\\n    {RingHom (HomogenLocRing {R} (powers {R} a)) (HomogenLocRing {R} (powers {R} b))}\\n    {\\\\lam (a1 : \\\\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd)) =>\\n      shom {R} {a} {b} {ad} {bd} {ah} {bh} a1.1 a1.2 a1.3 a1.4 a1.5 a1.6} (shom-coh {R} {a} {b} {ad} {bd} {ah} {bh})) ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func suc/=0 \\\\plevels  \\\\hlevels  {n : Nat} (_ : suc n = 0) : Empty ', '\\\\lemma cover_spec \\\\hlevels  {R : GradedCRing} {x : Carrier R} {J : \\\\Set} {g : J -> Carrier R} (_ : Cover {ProjPres R} x {J} g) :\\n  Cover {SpecPres R} x.1 {J} (\\\\lam (j : J) => (g j).1) ', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func framePresSite \\\\hlevels  (P : FramePres) : SiteWithBasis P.E {\\n  | Hom => Cover1 {P}\\n  | id => <=-refl\\n  | o => \\\\lam {X Y Z : Ob} (f : Hom Y Z) (g : Hom X Y) => g <=\u2218 f\\n  | pullback => \\\\lam {x1 y1 z1 : P.E} (f1 : Cover1 {P} x1 z1) (g1 : Cover1 {P} y1 z1) => \\\\new Pullback {x1} {y1} {z1} f1 g1 (P.conj x1 y1) {\\n    | pbProj1 => cover-proj1 {P} {apex {\\\\this}} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x {\\\\this}} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {x1})\\n    | pbProj2 => cover-proj2 {P} {P.conj x1 y1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => y1} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {y1})\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {D {\\\\this}}} (p1 : Hom {D {\\\\this}} w (x {\\\\this})) (p2 : Hom {D {\\\\this}} w (y {\\\\this}))\\n      (_ : f {\\\\this} \u2218 p1 = g {\\\\this} \u2218 p2) => cover-prod {P} {w} {x1} {y1} p1 p2\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | isBasicCover => \\\\lam (x : Ob {\\\\this}) {J : \\\\Set} (g : J -> Ob) =>\\n  TruncP (\\\\Sigma (y : P.E) (Cover1 {P} x y) (g' : J -> P.E) (P.BasicCover {J} y g')\\n    (\\\\Pi (j : J) -> \\\\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (g j).1)))\\n} => \\\\new SiteWithBasis {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | basicCover-stable => {?hidden}\\n}\", '\\\\func HomogenLocRing \\\\hlevels  {R : GradedCRing} (S1 : SubMonoid R) : CRing (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro {\\\\new subRing {R} {S1} {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new subRing {R} {S1} {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S} x.1, contains_negative {\\\\new subRing {R} {S1} {}} {x.1} x.2)\\n  | ide => (ide {S}, contains_ide)\\n  | natCoef => natCoefImpl {ISemiring {subRing {R} {S1}}}\\n} => cStruct {LocRing {R} S1} (subRing {R} {S1})', '| E : \\\\Set', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func ProjPres \\\\hlevels  (R : GradedCRing) : FramePres (Carrier R) {\\n  | conj => h* {R}\\n  | BasicCover => Indexing {Or (\\\\Sigma (n : Nat) (a b : R.E) (R.isHomogen a (suc n)) (R.isHomogen b (suc n))) Nat}\\n    {\\\\Sigma (a : R.E) (n : Nat) (R.isHomogen a (suc n))}\\n    (\\\\lam (p0 : Or (\\\\Sigma (n : Nat) (a b : R.E) (R.isHomogen a (suc n)) (R.isHomogen b (suc n))) Nat) => (\\\\case p0 \\\\with {\\n      | inl (n, a, b, ah, bh) =>\\n        (Bool, (a R.+ b, n, R.homogen-+ {suc n} {a} {b} ah bh), \\\\lam (p0 : Bool) => if {Carrier R} p0 (a, n, ah) (b, n, bh))\\n      | inr n => (Empty, (R.zro, n, R.homogen-zro {suc n}), absurd {\\\\Sigma (a : R.E) (n : Nat) (R.isHomogen a (suc n))})\\n    }))\\n} => \\\\new FramePres', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>TruncP (\\Sigma (t : \\Sigma (n : Nat) (c1 : R.E) (cd : Nat) (R.isHomogen c1 cd) (pow {R} c.1 n = a.1 R.* c1) (suc c.2 * n = suc a.2 + cd))\n  (shom {R} {a.1} {c.1} {suc a.2} {suc c.2} {a.3} {c.3} t.1 t.2 t.3 t.4 t.5 t.6 = (functorial {R} {a.1} {c.1} {suc a.2} {suc c.2} a.3 c.3 (suc/=0 {c.2}) (cover_spec {R} {c} {\\Sigma} {\\lam (_ : \\Sigma) => a} (g \u2218 f))).1))", "completion": "(functorial a.3 c.3 suc/=0 (cover_spec (g \u2218 {op {framePresSite (ProjPres R)}} f))).2"}
{"prompt": "['q : Rat', 'y : E', 'x : E', 'this : RieszSpace']<<<break>>>['\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\func ratDenom \\\\plevels  \\\\hlevels  (_ : Rat) : Nat \\n  | rat nom d denom/=0 reduced => d', '\\\\lemma join_*n \\\\hlevels  {this : AbsAbGroup} {n : Nat} {x y : E} : n *n (x \u2228 y) = n *n x \u2228 n *n y ', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a']<<<break>>>ratDenom q *n (q *q x \u2228 q *q y) = ratDenom q *n (q *q x) \u2228 ratDenom q *n (q *q y)", "completion": "join_*n {this}"}
{"prompt": "['a^n=u12 : pow {R} a.1 n = u.1.2', 'm : Nat', 'n : Nat', 'a : Ob {C {\\\\this}}', 't : \\\\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b.1 n = a.1 R.* c) (suc b.2 * n = suc a.2 + cd)', 's : \\\\Sigma (y : R.E) (k : Nat) (yh : R.isHomogen y (suc a.2 * k)) ((x,\\n  inP {\\\\Sigma (y : SType {R} (powers {R} a.1)) (x = inl~ {R} {powers {R} a.1} y) (n : Nat) (R.isHomogen y.1 n) (R.isHomogen y.2 n)}\\n    u) = fromSType {R} {powers {R} a.1}\\n    (y, pow {R} a.1 k, inP {\\\\Sigma (n : Nat) (pow {R} a.1 n = pow {R} a.1 k)} (k, idp {R.E} {pow {R} a.1 k})) {suc a.2 * k}\\n    {?hidden} {?hidden})', 'u : \\\\Sigma (y : SType {R} (powers {R} a.1)) (x = inl~ {R} {powers {R} a.1} y) (n : Nat) (R.isHomogen y.1 n) (R.isHomogen y.2 n)', 'd : u.1.1 R.* pow {R} a.1 s.2 R.* pow {R} a.1 m = s.1 R.* u.1.2 R.* pow {R} a.1 m', 'R : GradedCRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| C : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', 'coef C', 'nil', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', ':zro', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '| negative E : E', '\\\\lemma pow_*-comm \\\\hlevels  {this : CMonoid} {a b : E} {n : Nat} : pow (a * b) n = pow a n * pow b n ', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '| zro : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'var V', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>s.1 R.* pow {R} t.2 s.2 R.* (pow {R} a.1 n R.* pow {R} t.2 n) R.* pow {R} (a.1 R.* t.2) m = u.1.1 R.* pow {R} t.2 n R.* pow {R} (a.1 R.* t.2) s.2 R.* pow {R} (a.1 R.* t.2) m", "completion": "rewrite pow_*-comm (rewrite pow_*-comm equation)"}
{"prompt": "['s : SType {R} (positiveSubset R)', 't : SType {R} (positiveSubset R)', 'p : in~ {SType {R} (positiveSubset R)}\\n  {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} s < meet {R} (in~ {SType {R} (positiveSubset R)}\\n  {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} s)\\n  (in~ {SType {R} (positiveSubset R)}\\n    {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} t)', 'R : OrderedCRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '| isPos E : \\\\Prop', '| *-comm {x y : E} : x * y = y * x', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| negative E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| *-assoc {x y z : E} : x * y * z = x * (y * z)']<<<break>>>R.isPos (s.1 R.* t.2 R.\u2227 (t.1 R.* s.2) R.* s.2 R.+ R.negative s.1 R.* t.2 R.* s.2)", "completion": "rewrite (inv *-assoc) (rewrite (*-comm {R} {s.2} {t.2}) (unfolds p))"}
{"prompt": "['X : Ob {C {\\\\this}}', 'A : Functor C E', 'c : C.Ob', 'f : Hom {C {\\\\this}} X Y', 'Y : Ob {C {\\\\this}}', 'C : Precat', 'E : CocompleteCat', 'p : Functor.F {X.F} c']<<<break>>>['\\\\func cone-in-induced \\\\hlevels  {C : Precat} {E : CocompleteCat} {A : Functor C E} {X Y : Ob} (f : Hom X Y) : Cone {J} {Precat.op {E}} G apex {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => trans {induced-natural {C} {E} {A} {X} {Y} f} j \u2218 coneMap (F j)\\n} => cone {Precat.op {E}} {L-limit {C} {E} {A} X} {L-limit {C} {E} {A} Y} {Functor.op {functorial {C} X Y f}}\\n  {induced-natural {C} {E} {A} {X} {Y} f}', '| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j', '| F (Ob {C}) : Ob {D}', '| D : Precat', '| apex : Ob {D}', '| limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| G : Functor J D', '\\\\func L-limit \\\\hlevels  {C : Precat} {E : CocompleteCat} {A : Functor C E} (P : Ob) :\\n  Limit {Precat.op {Precategory-of-elements {C} P}} {Precat.op {E}} (Functor.op {diagram-functor {C} {E} {A} P}) \\n  => E.colimit {Precategory-of-elements {C} P} (diagram-functor {C} {E} {A} P)', '| Ob : \\\\hType']<<<break>>>coneMap (c, p) \u2218 limMap {apex} (cone-in-induced {C} {E} {A} {X} {Y} f) = coneMap (c, p)", "completion": "limBeta {L-limit {C} {E} {A} X} (cone-in-induced {C} {E} {A} f) (c, p)"}
{"prompt": "['L : Locale', 'b : L.E', 'p : a <=< b', 'a : L.E']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func neg \\\\hlevels  {this : Locale} (x : E) : E => x --> bottom', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func \\\\infixr 5 --> \\\\hlevels  {this : Locale} (x y : E) : E => SJoin (\\\\lam (p0 : E) => p0 \u2227 x <= y)', '| bottom : E', '\\\\func Total {B : \\\\Type} (F : B -> \\\\Type) : \\\\Type => \\\\Sigma (b : B) (F b)', '| top : E', '| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\func Compl \\\\hlevels  {X : \\\\hType} (U : Set X) : Set X => \\\\lam (x : X) => Not (U x)', '\\\\lemma points-unit \\\\hlevels  {L : Locale} {a : L.E} : a L.<= points_* {L} (points^* {L} a) ', '| F (E {A}) : \\\\Prop', '\\\\lemma isProper \\\\hlevels  {this : CompleteFilter} (_ : F (bottom {A})) : Empty ', 'byLeft A', '\\\\func LocalePrecoverSpace \\\\hlevels  (L : Locale) : PrecoverSpace (CompleteFilter L) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    L.top L.<= L.Join {\\\\Sigma (s : Set (CompleteFilter L)) (C s)} (\\\\lam (s : \\\\Sigma (s : Set (E {\\\\this})) (C s)) => points_* {L} s.1)\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '| filter-mono {a b : E {A}} (F a) (a <= b) : F b', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Join {J : \\\\Set} (J -> E) : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\lemma eval \\\\hlevels  {this : Locale} {x y : E} : (x --> y) \u2227 x <= y ', '\\\\func points^* \\\\hlevels  {L : Locale} (a : L.E) : Set (CompleteFilter L) => \\\\lam (x : CompleteFilter L) => x.F a', 'byRight B', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\lemma points^*-points_* \\\\hlevels  {L : Locale} {a : L.E} {U : Set (CompleteFilter L)} (_ : points^* {L} a \u2286 U) : a L.<= points_* {L} U ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\type \\\\infix 4 s<=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => (W = Compl {X.E} V) || (W = U))', '| join-univ {x y z : E} (x <= z) (y <= z) : x \u2228 y <= z', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)']<<<break>>>points^* {L} a s<=< points^* {L} b", "completion": "unfolds (p <=\u2218 join-univ (points^*-points_* (\\lam xna xa => isProper $ filter-mono (filter-meet xna xa) (eval {L})) <=\u2218 Join-cond (later (_, byLeft idp)))\n  (points-unit <=\u2218 Join-cond (later (_, byRight idp))))"}
{"prompt": "['M : LModule R', 'this : LModule R1 (Array M.E n) {\\n  | zro => \\\\new Array M.E n (\\\\lam (_ : Fin n) => M.zro)\\n  | + => \\\\lam (f : E {\\\\this}) (g : E {\\\\this}) => \\\\new Array M.E n (\\\\lam (j : Fin n) => f.at j M.+ g.at j)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => \\\\lam (f : E {\\\\this}) => \\\\new Array M.E n (\\\\lam (j : Fin n) => M.negative (f.at j))\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c => \\\\lam (r : E {R {\\\\this}}) (f : E {\\\\this}) => \\\\new Array M.E n (\\\\lam (j : Fin n) => r M.*c f.at j)\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', 'x : E {\\\\this}']<<<break>>>['| len : Nat', '| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '| at (j : Fin len) : A j', '| zro-right {x : E} : x + zro = x', '| E : \\\\Set']<<<break>>>\\Pi (j : Fin (len {x + zro {\\this}})) -> x.at j + zro {M} = x.at j", "completion": "\\lam j => zro-right"}
{"prompt": "[\"x' : Rat\", 'B : Rat']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| M : Monoid', '| R : Semiring', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '| zro : E', '\\\\field mData : MonoidData {R} vars', '| E : \\\\Set', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>LinearRatData (zro :: B :: x' :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new LinearRatData {\n  | R => RatField\n  | vars => zro :: B :: x' :: nil\n}"}
{"prompt": "['this : DataExt', 'y : Y', 'this : EquivData (\\\\Sigma (q1 : Q x y0)\\n  (pbMap {x0} {y0} q0 *> inv {PushoutData {\\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)} {genBlakersMassey.POData.X} {Y}\\n    (\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.1)\\n    (\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.2)}\\n    {pinl {\\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)} {genBlakersMassey.POData.X} {Y}\\n      {\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.1}\\n      {\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.2} x}\\n    {pinr {\\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)} {genBlakersMassey.POData.X} {Y}\\n      {\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.1}\\n      {\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.2} y0} (pbMap {x} {y0} q1) *> pbMap {x} {y} q = p))\\n  (Fib {Q x0 y} {pinl {\\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)} {genBlakersMassey.POData.X} {Y}\\n    {\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.1}\\n    {\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.2} x0 = pinr {\\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)} {genBlakersMassey.POData.X} {Y}\\n    {\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.1}\\n    {\\\\lam (p0 : \\\\Sigma (x : genBlakersMassey.POData.X) (y : Y) (Q x y)) => p0.2} y} (pbMap {x0} {y}) p) {\\n  | isLocal => isLocal\\n  | localization => localization\\n  | M => \\\\lam (a : A {\\\\this}) =>\\n  \\\\new Connected (Join (\\\\Sigma (p : y0 = y) (transport {Y} (Q x) {y0} {y} p a.1 = q)) (\\\\Sigma (p : x = x0)\\n    (transport {genBlakersMassey.POData.X} (\\\\lam (_x : genBlakersMassey.POData.X) => Q _x y0) {x} {x0} p a.1 = q0))) {\\n    | connected => {?hidden}\\n  }\\n  | N => \\\\lam (b : B {\\\\this}) => \\\\new Connected (Join (\\\\Sigma (p : y = y0) (transport {Y} (Q x0) {y} {y0} p b.1 = q0))\\n    (\\\\Sigma (p : x0 = x) (transport {genBlakersMassey.POData.X} (\\\\lam (_x : genBlakersMassey.POData.X) => Q _x y) {x0} {x} p b.1 = q))) {\\n    | connected => {?hidden}\\n  }\\n  | f => \\\\lam (ad : \\\\Sigma (a : A {\\\\this}) (Connected.X {M {\\\\this} a})) => LR {x} {y} q p ad.1 ad.2\\n  | g => \\\\lam (bd : \\\\Sigma (b : B {\\\\this}) (Connected.X {N {\\\\this} b})) => RL {x} {y} q0 q p bd.1 bd.2\\n  | p => LRL {x} {y} q p\\n  | q => RLR {x} {y} q p\\n}', 'b : B {\\\\this}', 'q : Q x y', 'x : X']<<<break>>>['| Y : \\\\hType', '\\\\func Join (A B : \\\\Type) : \\\\hType \\n  => PushoutData {\\\\Sigma A B} {A} {B} (\\\\lam (p0 : \\\\Sigma A B) => p0.1) (\\\\lam (p0 : \\\\Sigma A B) => p0.2)', '| q0 : Q x0 y0', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| x0 : X', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"| ch {x x' : X} {y y' : Y} (q0 : Q x y) (q1 : Q x y') (q2 : Q x' y) : isConnectedType (Join (\\\\Sigma (p : y = y') (transport {Y} (Q x) {y} {y'} p q0 = q1))\\n  (\\\\Sigma (p : x = x') (transport {X} (\\\\lam (_x : X) => Q _x y) {x} {x'} p q0 = q2)))\", '| X : \\\\hType', '\\\\class Connected \\\\hlevels  {\\n  | U : Universe\\n  | X : \\\\hType\\n  | connected : isConnectedType {U} X\\n}', '| Q X Y : \\\\hType', '| y0 : Y']<<<break>>>Connected (Join (\\Sigma (p : y = y0) (transport {Y} (Q x0) {y} {y0} p b.1 = q0))\n  (\\Sigma (p : x0 = x) (transport {X} (\\lam (_x : X) => Q _x y) {x0} {x} p b.1 = q))) {\n  | connected => {?hidden}\n}", "completion": "\\new Connected {\n  | X => Join (\\Sigma (p : y = y0 {this}) (transport (Q {this} (x0 {this})) p b.1 = q0 {this}))\n    (\\Sigma (p : x0 {this} = x) (transport (\\lam _x => Q {this} _x y) p b.1 = q))\n  | connected => ch {this} b.1 (q0 {this}) q\n}"}
{"prompt": "['j : Fin n', 'n : Nat', 'R : CRing', 'A : Matrix R.E (suc n) (suc n)']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', 'suc Nat', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func determinant {R : CRing} {n : Nat} (M : Matrix R.E n n) : R.E => FinSum {R} {SymFin n}\\n  (\\\\lam (e : Sym n) => sign {R} {n} e R.* BigProd {R} (\\\\new Array R.E n (\\\\lam (j : Fin n) => at {at {M} (f {e} j)} j)))', '| ide : E', '| E : \\\\Set', '| negative E : E', '\\\\func minor {R : \\\\Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : Matrix R n m \\n  => map {Array R (suc m)} {Array R m} (\\\\lam (p0 : Array R (suc m)) => skip {R} {m} p0 j0) (skip {Array R (suc m)} {n} M i0)', '| zro_*-left {x : E} : zro * x = zro', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>R.zro R.* (pow {R} (R.negative R.ide) j R.* R.negative R.ide) R.* determinant {R} {n} (minor {R.E} {n} {n} A (suc j) 0) = R.zro", "completion": "rewrite zro_*-left zro_*-left"}
{"prompt": "['p : \\\\Pi (j : Fin (suc l.len)) -> R.isHomogen (at {a :: l} j) (suc n)', 'a : R.E', 'R : GradedCRing', 'l : Array R.E n', 'n : Nat', 'n : Nat']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '| at (j : Fin len) : A j', '| isHomogen E Nat : \\\\Prop', '| E : \\\\Set']<<<break>>>\\Pi (j : Fin l.len) -> R.isHomogen (at {a :: l} (suc j)) (suc n)", "completion": "\\lam j => p (suc j)"}
{"prompt": "['f : RingHom K E', 'lb : IsBasis {homLModule f} l', 'E : CRing', 'K : DiscreteField', 'l : Array E.E']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func corestrict \\\\hlevels  {this2 : SubRing} {R : Ring} (f : RingHom R S) (p : \\\\Pi (x : R.E) -> contains (f.func x)) : RingHom R IRing {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, p x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| R : Ring', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func homLModule \\\\hlevels  (f : RingHom) : LModule f.Dom (E {f.Cod}) {\\n  | zro => zro {f.Cod}\\n  | + => (+) {f.Cod}\\n  | negative => negative {f.Cod}\\n  | *c => \\\\lam (x : E {R {\\\\this}}) => (*) (f.func x)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '| zro : E', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infixl 7 *c (E {R}) E : E', '\\\\func embed \\\\hlevels  {this2 : SubRing} : RingHom IRing S {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\func IRing \\\\hlevels  {this : SubRing} : Ring (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro {\\\\new this {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new this {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S} x.1, contains_negative {\\\\new this {}} {x.1} x.2)\\n  | ide => (ide {S}, contains_ide)\\n  | natCoef => natCoefImpl {ISemiring}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\lemma func-BigSum \\\\hlevels  {this : AddMonoidHom} {l : Array (E {Dom})} :\\n  func (BigSum {Dom} l) = BigSum {Cod} (\\\\new Array (E {Cod}) l.len (\\\\lam (j : Fin l.len) => func (l.at j))) ', '\\\\func max \\\\hlevels  {R : Ring} : SubRing R (\\\\lam (_ : E {S}) => \\\\Sigma) => \\\\new SubRing {\\n  | contains_zro => {?hidden}\\n  | contains_+ => {?hidden}\\n  | contains_* => {?hidden}\\n  | contains_negative => {?hidden}\\n  | contains_ide => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>\\Pi (c : Array (E {R}) (len {map {E.E} {\\Sigma E.E (\\Sigma)} (\\lam (p0 : E.E) => (p0, ())) l})) ->\nBigSum {homLModule (corestrict {max {E1}} {K} f (\\lam (_ : K.E) => ()))}\n  (\\new Array E (len {map {E.E} {\\Sigma E.E (\\Sigma)} (\\lam (p0 : E.E) => (p0, ())) l})\n    (\\lam (j : Fin (len {map {E.E} {\\Sigma E.E (\\Sigma)} (\\lam (p0 : E.E) => (p0, ())) l})) =>\n      c.at j *c at {map {E.E} {\\Sigma E.E (\\Sigma)} (\\lam (p0 : E.E) => (p0, ())) l} j)) = zro ->\n  \\Pi (j : Fin (len {map {E.E} {\\Sigma E.E (\\Sigma)} (\\lam (p0 : E.E) => (p0, ())) l})) -> c.at j = zro {R}", "completion": "\\lam c p j => lb.1 c (inv (func-BigSum {embed} {\\lam j => (f (c j) * l j, ())}) *> pmap (\\lam p0 => p0.1) p) j"}
{"prompt": "['I : DirectedSet', 'N : I.E']<<<break>>>['byLeft A', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'byRight B', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\func precover \\\\hlevels  {I : DirectedSet} : PrecoverSpace I.E {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n  \\\\Sigma (TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (N : I.E) (\\\\Pi {n : I.E} -> N I.<= n -> U n)))\\n    (\\\\Pi (n : I.E) -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (C V) (V n)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}']<<<break>>>isCauchy (\\lam (V : Set E) => (V = (I.<=) N) || (\\Sigma (n : I.E) (V = single {I.E} n)))", "completion": "(inP (_, byLeft idp, N, \\lam p => p), \\lam n => inP (single n, byRight (n, idp), idp))"}
{"prompt": "['n : Nat', 'x : E {\\\\this}']<<<break>>>['suc Nat', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ']<<<break>>>x < suc n", "completion": "fin_< x"}
{"prompt": "['R : CRing', 'd : Nat', 'n : Nat', 'a : Array R.E n']<<<break>>>['pzero', '| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| at (j : Fin len) : A j', '| ide : E', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', 'padd (Poly R) R.E', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>Array (Poly R) n\n  (\\lam (j : Fin n) => padd {R} (pzero {R}) (a.at j) + pow {PolyRing R} (padd {R} ide R.zro) (pow {NatSemiring} d j))", "completion": "\\lam j => padd pzero (a j) + pow (padd 1 0) (pow d j)"}
{"prompt": "['A : BoundedExPseudoNormedAbGroup', 'y0b : Rat', 'y0y<1 : U {B.dist y0 y} ide', \"y' : B.E\", 'x0x<1 : U {A.dist x0 x} ide', 'y : B.E', 'x : A.E', 'lem : \\\\Pi {X : ExPseudoNormedAbGroup} -> \\\\Pi {x1 x2 : X.E} -> U {X.norm (x1 - x2)} ide -> X.norm x2 <= X.norm x1 + ide', \"yy'<gamma : U {B.dist y y'} (gamma \u2227 ide)\", 'x0 : A.E', 'B : BoundedExPseudoNormedAbGroup', 'gamma : Rat', '|y0|<y0b : U {B.norm y0} y0b', 'y0 : B.E', '|x0|<x0b : U {A.norm x0} x0b', 'x0b : Rat']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| dist E E : ExUpperReal', '| norm-dist {x y : E} : dist x y = norm (x - y)', '\\\\lemma U_<= \\\\plevels  \\\\hlevels  {this : ExUpperReal} {q r : Rat} (_ : U q) (_ : q <= r) : U r ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma +-rat \\\\plevels  \\\\hlevels  {x y : Rat} : fromRat x ExUpperReal.+ fromRat y = fromRat (x RatField.+ y) ', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma <_+-left \\\\plevels  \\\\hlevels  {x y : ExUpperReal} (_ : x < y) {z : Rat} : x + fromRat z < y + fromRat z ', '\\\\type \\\\infix 4 < \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => TruncP (\\\\Sigma (q : Rat) (x.U q) (fromRat q <= y))', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', '\\\\lemma <-rat \\\\plevels  \\\\hlevels  {x : ExUpperReal} {y : Rat} : x < fromRat y <-> x.U y ', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '| \\\\infix 4 < E E : \\\\Prop', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\lemma <_+ \\\\plevels  \\\\hlevels  {x y x' y' : ExUpperReal} (_ : x < x') (_ : y < y') : x + y < x' + y' \", '| U Rat : \\\\Prop', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '| meet-right {x y : E} : x \u2227 y <= y', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>A.norm x AddMonoid.+ B.norm y' < fromRat (x0b RatField.+ ide RatField.+ (y0b RatField.+ ide RatField.+ ide))", "completion": "<=_+ (lem x0x<1) (lem (U_<= yy'<gamma meet-right) <=\u2218 <=_+ (lem y0y<1) <=-refl) <\u2218r transport ((<) _) +-rat\n  (<_+ (transport ((<) _) +-rat $ <_+-left $ <-rat.2 |x0|<x0b) $ transport ((<) _) +-rat $ <_+-left $ transport ((<) _) +-rat $ <_+-left $ <-rat.2 |y0|<y0b)"}
{"prompt": "['q : b.1 M.+ a.2 M.+ e M.<= b.2 M.+ a.1 M.+ e', 'b : \\\\Sigma (_ y : M.E) (S.contains y)', 'e : E {S.S}', 'd : E {S.S}', 'M : PosetAbMonoid', 'a : \\\\Sigma (_ y : M.E) (S.contains y)', 'p : a.1 M.+ b.2 M.+ d M.<= a.2 M.+ b.1 M.+ d']<<<break>>>['| M : \\\\Set', '| \\\\infixl 6 + E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| <=-refl {x : E} : x <= x', '\\\\func AbMonoidSolverModel \\\\hlevels  (A : AbMonoid) : SolverModel E {\\n  | Term => Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => normalize\\n  | interpret => interpret {toCMonoid A}\\n  | interpretNF => \\\\lam {n : Nat} (env : Fin n -> M {\\\\this}) (nf : NF {\\\\this} n) => interpretNF {toCMonoid A} {Fin n} env (sort {FinOrder n} nf)\\n} => CMonoidSolverModel (toCMonoid A)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| interpretNF {n : Nat} (Fin n -> M) (NF n) : M', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\infixl 7 :* (_ _ : Term n)', '| at (j : Fin len) : A j', '\\\\lemma terms-equality \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s)) :\\n  interpret {env.len} env.at t = interpret {env.len} env.at s ', '| normalize {n : Nat} (Term n) : NF n', '| E : \\\\Set', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y', 'var (Fin n)', \"\\\\func transport2 {A B : \\\\Type} (C : A -> B -> \\\\Type) {a a' : A} {b b' : B} (_ : a = a') (_ : b = b') (_ : C a b) : C a' b' \\n  | {A}, {B}, C, {a}, {a'}, {b}, {b'}, idp, idp, c => c\", '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>a.1 M.+ b.2 M.+ (d M.+ e) = b.1 M.+ a.2 M.+ (d M.+ e)", "completion": "<=-antisymmetric (transport2 ((<=) {M}) abMonoid abMonoid $ <=_+ p $ <=-refl {M} {e})\n  (transport2 ((<=) {M}) abMonoid abMonoid $ <=_+ q $ <=-refl {M} {d})"}
{"prompt": "['d : DArray {len {predDomain {T {\\\\this}} P}}\\n  (\\\\lam (j : Fin (len {predDomain {T {\\\\this}} P})) => E {Dom {\\\\this}} (at {predDomain {T {\\\\this}} P} j))', 'j : Ob {J {\\\\this}}', 'h : relation {Dom {\\\\this}} P d', 'P : PredSymb {T {\\\\this}}', 'G : Functor J this']<<<break>>>['| len : Nat', '| E (Sort {T}) : \\\\Set', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| at (j : Fin len) : A j', '| predDomain PredSymb : Array Sort', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| F (Ob {C}) : Ob {D}', '| T : Signature', '| relation (P : PredSymb {T})\\n  (DArray {len {predDomain {T} P}} (\\\\lam (j : Fin (len {predDomain {T} P})) => E (at {predDomain {T} P} j))) : \\\\Prop']<<<break>>>relation {G.F j} P (\\new DArray {len {predDomain {T {G.F j}} P}}\n  (\\lam (j1 : Fin (len {predDomain {T {G.F j}} P})) => E {G.F j} (at {predDomain {T {G.F j}} P} j1))\n  (\\lam (k : Fin (len {predDomain {T {G.F j}} P})) => (d.at k).1 j))", "completion": "h j"}
{"prompt": "['U : E {Cod {\\\\this}} -> \\\\Prop', 'L : UniformLocale', 'a : L.E', 'Ua : U a']<<<break>>>['\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '\\\\lemma completion_embed {L : UniformLocale} {a : L.E} : func {completionLocale {L}} (embed {CompletionPres L} a) = a ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func CompletionPres \\\\hlevels  (L : UniformLocale) : FramePres L.E {\\n  | conj => (L.\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U)) :: L.E :: nil} j)} {L.E}\\n    (\\\\lam (p0 : \\\\Sigma (j : Fin 4) (at {L.E :: L.E :: (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U)) :: L.E :: nil} j)) =>\\n    (\\\\case p0 \\\\with {\\n      | (zero, a) => (\\\\Sigma, a, \\\\lam (_ : \\\\Sigma) => L.top)\\n      | (suc zero, a) => (IsPositive {L} a, a, \\\\lam (_ : IsPositive {L} a) => a)\\n      | (suc (suc zero), U) => (\\\\Sigma (x : L.E) (U.1 x), L.top, \\\\lam (p0 : \\\\Sigma (x : L.E) (U.1 x)) => p0.1)\\n      | (suc (suc (suc zero)), a) => (\\\\Sigma (b : L.E) (b <=u a), a, \\\\lam (p0 : \\\\Sigma (b : L.E) (b <=u a)) => p0.1)\\n    }))\\n} => \\\\new FramePres', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func completionLocale {L : UniformLocale} : FrameHom (PresentedFrame (CompletionPres L)) L {\\n  | func => \\\\lam (U : E {Dom {\\\\this}}) =>\\n    L.Join {\\\\Sigma (x : E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : E) (U.1 x)) => func {presentation {L}} j.1)\\n} => adjointMap {CompletionPres L} {L} (presentation {L})']<<<break>>>U (func {completionLocale {L}} (embed {CompletionPres L} a))", "completion": "transportInv U completion_embed Ua"}
{"prompt": "['x : E {L {\\\\this}}', 'L : Locale', 'J : \\\\Set', 'g : J -> E {\\\\this}', 'p : \\\\Sigma (n : Nucleus {L}) (\\\\Pi (j : J) -> \\\\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)', 'y : E {L {\\\\this}}']<<<break>>>['\\\\class Nucleus \\\\hlevels  {\\n  | L : Locale\\n  | nucleus (E {L}) : E {L}\\n  | nucleus-meet {x y : E {L}} : nucleus (x \u2227 y) = nucleus x \u2227 nucleus y\\n  | nucleus-meet>= {x y : E {L}} : nucleus x \u2227 nucleus y <= nucleus (x \u2227 y)\\n  | nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y\\n  | nucleus-unit {x : E {L}} : x <= nucleus x\\n  | nucleus-join>= {x : E {L}} : nucleus (nucleus x) <= nucleus x\\n  | nucleus-join {x : E {L}} : nucleus (nucleus x) = nucleus x\\n}', '| meet-left {x y : E} : x \u2227 y <= x', '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop', '| Meet {J : \\\\Set} (J -> E) : E', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| Meet-cond {J : \\\\Set} (j : J) {f : J -> E} : Meet {J} f <= f j', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>L.Meet {\\Sigma (n : Nucleus {L}) (\\Pi (j : J) -> \\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)}\n  (\\lam (p : \\Sigma (n : Nucleus {L}) (\\Pi (j : J) -> \\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)) => nucleus {p.1} x) L.\u2227 L.Meet {\\Sigma (n : Nucleus {L}) (\\Pi (j : J) -> \\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)}\n  (\\lam (p : \\Sigma (n : Nucleus {L}) (\\Pi (j : J) -> \\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)) => nucleus {p.1} y) L.<= nucleus {p.1} x", "completion": "meet-left <=\u2218 Meet-cond p"}
{"prompt": "['r : E {R {\\\\this}}', 'B : LModule R', 'x : E {Dom {\\\\this}}', 'c : R.E', 'R : CRing', 'f : LinearMap {R} A B']<<<break>>>['| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}']<<<break>>>c R.* r B.*c f.func x = r R.* c B.*c f.func x", "completion": "rewrite (*-comm {R}) idp"}
{"prompt": "['M : MeetSemilatticeAbMonoid', 'a : \\\\Sigma (_ y : M.E) (S.contains y)', 'b : \\\\Sigma (_ y : M.E) (S.contains y)']<<<break>>>['| \\\\infixl 6 + E E : E', '| meet-left {x y : E} : x \u2227 y <= x', '| <=-refl {x : E} : x <= x', '| \\\\infix 4 <= E E : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>(a.1 M.+ b.2) M.\u2227 (a.2 M.+ b.1) M.+ a.2 M.<= a.1 M.+ b.2 M.+ a.2", "completion": "<=_+ meet-left <=-refl"}
{"prompt": "['S : PrecoverSpace X', 'T : PrecoverSpace X', 'h2 : S.isCauchy = T.isCauchy', 'X : \\\\Set']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Path (\\lam (i : I) => \\Pi {C : Set (Set X)} -> (@) h2 i C -> \\Pi (x : X) -> TruncP (\\Sigma (U : Set X) (C U) (U x)))\n  S.cauchy-cover T.cauchy-cover", "completion": "prop-dpi (\\lam i => ext_coe) (cauchy-cover {S}) (cauchy-cover {T})"}
{"prompt": "['this : SubRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\func IRing \\\\hlevels  {this : SubRing} : Ring (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro {\\\\new this {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new this {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S} x.1, contains_negative {\\\\new this {}} {x.1} x.2)\\n  | ide => (ide {S}, contains_ide)\\n  | natCoef => natCoefImpl {ISemiring}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| S : BaseSet', '| Dom : BaseSet', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ']<<<break>>>RingHom IRing S {\n  | func => \\lam (p0 : E {Dom {\\this}}) => p0.1\n  | func-+ => {?hidden}\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "completion": "\\new RingHom {\n  | Dom => IRing {this}\n  | Cod => S {this}\n  | func => \\lam p0 => p0.1\n  | func-+ => idp\n  | func-ide => idp\n  | func-* => idp\n}"}
{"prompt": "['env : Array A.E 9', 'lem2 : \\\\Pi (z : A.E) -> \\\\Pi (w : A.E) -> \\\\Pi (c : Real) -> \\\\Pi (d : A.E) -> z A.* (c *c d * w) = z A.* (d * (c *c w))', 'x : \\\\Sigma Real A.E', \"lem1 : x.1 * y.1 *r s.1 A.* s'.1 = x.1 *r s.1 A.* (y.1 *r s'.1)\", 'y : \\\\Sigma Real A.E', 's : \\\\Sigma (y : A.E) (A.norm y <= ide)', 'A : StoneC*PseudoAlgebra', \"s' : \\\\Sigma (y : A.E) (A.norm y <= ide)\"]<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', \"\\\\func ringInterpretNF' \\\\hlevels  {R3 : Ring} {env2 : Array R.E} (_ : NF Int env.len) : R.E \\n  | {R}, {env}, nil => R.zro\\n  | {R}, {env}, x :: nil => ringMulCoef {R} {env} x.2 x.1\\n  | {R}, {env}, x :: l => ringMulCoef {R} {env} x.2 x.1 R.+ ringInterpretNF' {R} {env} l\", 'nil', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func normalize \\\\hlevels  {n7 : Nat} {C7 : Dec} (_ : Term C.E n7) : NF C.E n7 \\n  | {n}, {C}, var v => (v :: nil {Fin n}, C.ide) :: nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, coef c => (nil {Fin n}, c) :: nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, :zro => nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, :ide => (nil {Fin n}, C.ide) :: nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, :negative t =>\\n  map {\\\\Sigma (List (Fin n)) C.E} {\\\\Sigma (List (Fin n)) C.E} (\\\\lam (s : \\\\Sigma (List (Fin n)) C.E) => (s.1, C.negative s.2))\\n    (normalize {n} {C} t)\\n  | {n}, {C}, t :+ s => normalize {n} {C} t ++ normalize {n} {C} s\\n  | {n}, {C}, t :* s =>\\n    remove0 {n} {C} {\\\\new C {}} (collapse {n} {C} (multiply {n} {C} (normalize {n} {C} t) (normalize {n} {C} s)))', '\\\\func NF \\\\hlevels  (C : \\\\Set) (n : Nat) : \\\\Set => List (\\\\Sigma (List (Fin n)) C)', '\\\\func sortMonomials \\\\hlevels  {n : Nat} {C : \\\\Set} (l : NF C n) : List (\\\\Sigma (List (Fin n)) C) \\n=> map {\\\\Sigma (List (Fin n)) C} {\\\\Sigma (List (Fin n)) C} (\\\\lam (s : \\\\Sigma (List (Fin n)) C) => (sort {FinOrder n} s.1, s.2))\\n  l', '\\\\func interpret \\\\hlevels  {R6 : Ring} (env4 : Array R.E) (_ : Term Int env.len) : R.E \\n  | {R}, env, coef c => intCoef {R} c\\n  | {R}, env, var c => env.at c\\n  | {R}, env, :zro => R.zro\\n  | {R}, env, :ide => R.ide\\n  | {R}, env, :negative t => R.negative (interpret {R} env t)\\n  | {R}, env, t :+ s => interpret {R} env t R.+ interpret {R} env s\\n  | {R}, env, t :* s => interpret {R} env t R.* interpret {R} env s', '| E : \\\\Set', '\\\\infixl 7 :* (_ _ : Term C n)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', 'var (Fin n)', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func multiply \\\\hlevels  {n2 : Nat} {C2 : Monoid} (_ _ : NF C.E n2) : NF C.E n2 \\n  | {n}, {C}, l1, nil => nil {\\\\Sigma (List (Fin n)) C.E}\\n  | {n}, {C}, l1, l2 => multiply' {n} {C} l1 l2 (nil {\\\\Sigma (List (Fin n)) C.E})\", '\\\\data Term \\\\hlevels  \\\\Set Nat \\n  | var (Fin n)\\n  | coef C\\n  | :zro\\n  | :ide\\n  | :negative (Term C n)\\n  | \\\\infixl 6 :+ (_ _ : Term C n)\\n  | \\\\infixl 7 :* (_ _ : Term C n)', 'pos Nat', ':negative (Term C n)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', \"\\\\func ringInterpretNF \\\\hlevels  {R : Ring} (env : Array R.E) (l : NF Int env.len) : R.E \\n=> ringInterpretNF' {R} {env} (remove0 {env.len} {IntRing} {IntRing}\\n  (collapse {env.len} {IntRing} (sort {LexicographicalProduct (LexicographicalList (FinOrder env.len)) IntRing} l)))\", \"\\\\lemma apply-axioms \\\\hlevels  {R : CRing} (env : Array R.E)\\n  (l : Array (\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)))\\n  (add : NF Int env.len) : ringInterpretNF {R} env (sortMonomials\\n  {env.len} {Int} (Big {List (\\\\Sigma (List (Fin env.len)) Int)} {List (\\\\Sigma (List (Fin env.len)) Int)} (++) add\\n    (map {\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)}\\n      {List (\\\\Sigma (List (Fin env.len)) Int)}\\n      (\\\\lam (s : \\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)) =>\\n        multiply {env.len} {IntRing} s.1 (normalize {env.len} {IntRing} (s.2 :+ :negative {E} {env.len} s.3))) l))) = ringInterpretNF' {R} {env} add \", '\\\\infixl 6 :+ (_ _ : Term C n)', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>ringInterpretNF {A} env (sortMonomials {env.len} {Int}\n  (Big {List (\\Sigma (List (Fin env.len)) Int)} {List (\\Sigma (List (Fin env.len)) Int)} (++) (nil {\\Sigma (List (Fin 9)) Int})\n    (map {\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {A} env t = interpret {A} env s)}\n      {List (\\Sigma (List (Fin env.len)) Int)}\n      (\\lam (s : \\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {A} env t = interpret {A} env s)) =>\n        multiply {env.len} {IntRing} s.1 (normalize {env.len} {IntRing} (s.2 :+ :negative {E} {env.len} s.3)))\n      (((nil {Fin 9}, pos 1) :: nil {\\Sigma (List (Fin 9)) Int}, var {Int} {env.len} 0 :* var {Int} {env.len} 6,\n        var {Int} {env.len} 7 :* var {Int} {env.len} 8, lem1) :: ((nil {Fin 9}, pos 1) :: nil {\\Sigma (List (Fin 9)) Int},\n          var {Int} {env.len} 6 :* (var {Int} {env.len} 1 :* var {Int} {env.len} 5),\n          var {Int} {env.len} 6 :* (var {Int} {env.len} 4 :* var {Int} {env.len} 7), lem2 s'.1 s.1 x.1 y.2) :: ((nil {Fin 9}, pos 1) :: nil {\\Sigma (List (Fin 9)) Int},\n            var {Int} {env.len} 5 :* (var {Int} {env.len} 2 :* var {Int} {env.len} 6),\n            var {Int} {env.len} 5 :* (var {Int} {env.len} 3 :* var {Int} {env.len} 8), lem2 s.1 s'.1 y.1 x.2) :: nil)))) = ringInterpretNF' {A} {env} (nil {\\Sigma (List (Fin 9)) Int})", "completion": "apply-axioms env\n  (((nil, 1) :: nil, var 0 :* var 6, var 7 :* var 8, lem1) :: ((nil, 1) :: nil, var 6 :* (var 1 :* var 5), var 6 :* (var 4 :* var 7), lem2 s'.1 s.1 x.1 y.2) :: ((nil, 1) :: nil, var 5 :* (var 2 :* var 6), var 5 :* (var 3 :* var 8), lem2 s.1 s'.1 y.1 x.2) :: nil)\n  nil"}
{"prompt": "['A : Nat -> \\\\Prop', 't : A', 'n : Nat']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', 'suc Nat', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '| \\\\infix 4 <= E E : \\\\Prop', '| <-irreflexive {x : E} : Not (x < x)', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '| \\\\infix 4 < E E : \\\\Prop', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '\\\\func divMod \\\\plevels  \\\\hlevels  (_ _ : Nat) : \\\\Sigma Nat Nat ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func \\\\infixl 8 mod \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n mod m', \"\\\\func dec<_<= \\\\hlevels  {A : Dec} (a a' : A.E) : Or (a A.< a') (a' <= a) => \\\\case A.trichotomy a a' \\\\with {\\n  | less a<a' => inl {a A.< a'} {a' <= a} a<a'\\n  | equals a=a' => inr {a A.< a'} {a' <= a} (transportInv {A.E} ((<=) a') {a} {a'} a=a' (A.<-irreflexive {a'}))\\n  | greater a'<a => inr {a A.< a'} {a' <= a} (A.<=-less {a'} {a} a'<a)\\n}\", '\\\\lemma mod_< \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < m) : n mod m = n ', '\\\\lemma <-transitive {n m k : Nat} (_ : n < m) (_ : m < k) : n < k ', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>\\Pi (k : Nat) -> A k -> t.1 <= k", "completion": "\\lam k Ak => (\\case dec<_<= k t.1 \\with {\n  | inl k<t1 => \n    \\have s => mod_< $ <-transitive k<t1 (fin_< t.1)\n    \\in absurd $ <-irreflexive $ k<t1 <\u2218l transport ((<=) t.1) s (t.3 (k mod suc n) (transportInv A s Ak))\n  | inr t1<=k => t1<=k\n})"}
{"prompt": "['this : Ideal']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '\\\\class CGroup \\\\extends Group, CancelCMonoid \\\\hlevels  {\\n  | inverse-right => \\\\lam {x : E} => *-comm {x} {inverse x} *> inverse-left {x}\\n}', '| E : \\\\Set', '| negative E : E', '| S : BaseSet', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}']<<<break>>>CGroup (E {S}) {\n  | ide => zro {S}\n  | * => (+) {S}\n  | inverse => negative {S}\n}", "completion": "toCGroup S"}
{"prompt": "['M : LModule R', 'm : M.E', 'R : Ring', 'a : \\\\Sigma (x : Kernel f) (func {KerLModuleHom {R} {M} {N} f} x = m)', 'f : LinearMap {R} M N', 'N : LModule R']<<<break>>>['| zro : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Cod : BaseSet', '\\\\func KerLModuleHom \\\\hlevels  {R1 : Ring} {A B : LModule R1} (f : LinearMap {R1} A B) : LinearMap {R1} (KerLModule {R1} {A} {B} f) A {\\n  | func => \\\\lam (p0 : E {Dom {KerPointedHom f}}) => p0.1\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}']<<<break>>>f.func m = N.zro", "completion": "rewrite (inv a.2) (rewrite a.1.2 idp)"}
{"prompt": "['W : Set X.E', 'X : StronglyRegularCoverSpace', \"U' : Set X.E\", 'U : Set X.E', \"p : W = Compl {X.E} U'\"]<<<break>>>['byLeft A', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| filter-mono {a b : E {A}} (F a) (a <= b) : F b', '| X : \\\\Set', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\func mkSet \\\\hlevels  {X : StronglyRegularCoverSpace} (U : Set X.E) : Set (StronglyRegularCauchyFilter X) \\n  => \\\\lam (F1 : StronglyRegularCauchyFilter X) => F.F U', '\\\\data Empty \\\\plevels  \\\\hlevels  ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| bottom : E', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)', '| E : \\\\Set', '| isWeaklyProper : Not (F bottom)', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func Compl \\\\hlevels  {X : \\\\hType} (U : Set X) : Set X => \\\\lam (x : X) => Not (U x)', '\\\\class StronglyRegularCauchyFilter \\\\extends WeaklyCauchyFilter \\\\hlevels  {\\n  | isStronglyRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V s<=< U) (F V))\\n}']<<<break>>>TruncP (\\Sigma (V : Set (StronglyRegularCauchyFilter X))\n  ((V = Compl {StronglyRegularCauchyFilter X} (mkSet {X} U')) || (V = mkSet {X} U)) (mkSet {X} W \u2286 V))", "completion": "inP (_, byLeft idp, rewrite p (\\lam {F} FnU' FU' =>\n  unfolds FnU' at FnU' $ unfolds FU' at FU' $ isWeaklyProper {F} $ filter-mono (filter-meet FnU' FU') (\\lam s => absurd $ s.1 s.2)))"}
{"prompt": "['f : Hom {C {\\\\this}} X Y', 'this : RingHom (F {\\\\this} X) (F {\\\\this} Y) {\\n  | func => f.funcs {()}\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}']<<<break>>>['| len : Nat', '| E (Sort {T}) : \\\\Set', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| Dom : Model T', '| T : Theory', '| operation {r : Sort {T}} (h : Symb {T} r)\\n  (DArray {len {domain {T} {r} h}} (\\\\lam (j : Fin (len {domain {T} {r} h})) => E (at {domain {T} {r} h} j))) : E r', '| func-op {r : Sort {ModelHom.T}} (h : Symb {ModelHom.T} r) (d : DArray {len {domain {ModelHom.T} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {ModelHom.T} {r} h})) => E {Dom} (at {domain {ModelHom.T} {r} h} j))) : funcs {r} (operation {Dom} {r} h d) = operation {Cod} {r} h (\\\\new DArray {len {domain {Structure.T {Cod}} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => E {Cod} (at {domain {Structure.T {Cod}} {r} h} j))\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => funcs {at {domain {ModelHom.T} {r} h} j} (d.at j)))', '| domain {s : Sort} (Symb s) : Array Sort', '| at (j : Fin len) : A j', '| Cod : Model T', '| E : \\\\Set', '| funcs {s : Sort {T}} (E {Dom} s) : E {Cod} s', '| Dom : BaseSet', '| T : Signature']<<<break>>>\\Pi {x : BaseSet.E {SetHom.Dom {\\this}}} -> \\Pi {y : BaseSet.E {SetHom.Dom {\\this}}} ->\n  f.funcs {()} (operation {f.Dom} {()} 2 (x :: y :: nil)) = operation {f.Cod} {()} 2 (\\new DArray {len {domain {Structure.T {f.Cod}} {()} 2}}\n    (\\lam (j : Fin (len {domain {Structure.T {f.Cod}} {()} 2})) => Structure.E {f.Cod} (at {domain {Structure.T {f.Cod}} {()} 2} j))\n    (\\lam (j : Fin (len {domain {Structure.T {f.Cod}} {()} 2})) => f.funcs {at {domain {f.T} {()} 2} j} (at {x :: y :: nil} j)))", "completion": "\\lam {x} {y} => func-op {f} 2 (x :: y :: nil)"}
{"prompt": "['this : Locale (\\\\Sigma (x : L.E) (y : M.E) (f.func x = g.func y)) {\\n  | <= => \\\\lam (P : E {\\\\this}) (Q : E {\\\\this}) => \\\\Sigma (P.1 L.<= Q.1) (P.2 M.<= Q.2)\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet => \\\\lam (P : E {\\\\this}) (Q : E {\\\\this}) => (P.1 L.\u2227 Q.1, P.2 M.\u2227 Q.2,\\n    f.func-meet {P.1} {Q.1} *> pmap2 {K.E} {K.E} {K.E} (K.\u2227) {f.func P.1} {g.func P.2} P.3 {f.func Q.1} {g.func Q.2} Q.3 *> inv {K.E} {g.func (P.2 M.\u2227 Q.2)} {g.func P.2 K.\u2227 g.func Q.2} (g.func-meet {P.2} {Q.2}))\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top => (L.top, M.top, f.func-top *> inv {K.E} {g.func M.top} {K.top} g.func-top)\\n  | top-univ => {?hidden}\\n  | Join => \\\\lam {J : \\\\Set} (F : J -> E {\\\\this}) => (L.Join {J} (\\\\lam (j : J) => (F j).1), M.Join {J} (\\\\lam (j : J) => (F j).2),\\n    f.func-Join {J} {\\\\lam (j : J) => (F j).1} *> pmap {J -> K.E} {K.E} (K.Join {J}) {\\\\lam (j : J) => f.func (F j).1} {\\\\lam (j : J) => g.func (F j).2}\\n      (path (\\\\lam (i : I) (j : J) => (F j).3 @ i)) *> inv {K.E} {g.func (M.Join {J} (\\\\lam (j : J) => (F j).2))} {K.Join {J} (\\\\lam (j : J) => g.func (F j).2)}\\n      (g.func-Join {J} {\\\\lam (j : J) => (F j).2}))\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', 'f : J -> E {\\\\this}', 'J : \\\\Set', 'M : Locale', 'L : Locale', 'j : J']<<<break>>>['| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '| \\\\infix 4 <= E E : \\\\Prop']<<<break>>>f j <= Join {\\this} {J} f", "completion": "(Join-cond j, Join-cond j)"}
{"prompt": "['c : Contr S', 'U : ReflUniverse', 'Z : Local {U}', 'X : \\\\hType']<<<break>>>['| center : A', '| A : \\\\Type', \"| inL Localization.S : Local.S {S'}\", \"| contraction (a' : A) : center = a'\", '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| S : \\\\hType', \"\\\\func lift \\\\hlevels  {this : Localization} {Z : Local {U}} (f : Localization.S -> Z.S) (x' : Local.S {S'}) : Z.S => sec {local-univ Z} f x'\", '\\\\func \\\\infixr 8 o {A B C : \\\\Type} (g : B -> C) (f : A -> B) : \\\\Pi (x : A) -> C => \\\\lam (x : A) => g (f x)', \"| S' : Local {U}\", '\\\\lemma conv \\\\plevels  \\\\hlevels  {A B : \\\\Prop} (_ : A = B) (_ : B) : A ', '| localization (A : \\\\hType) : Localization A', '| B : \\\\Type', '\\\\class Equiv \\\\extends Section, Retraction', '\\\\lemma localDesc (M Z : \\\\Type) : isLocal Z = Equiv {Z} {M -> Z} (\\\\lam (z : A {\\\\this}) (_ : M) => z) ', \"\\\\func const \\\\hlevels  {this : Localization} {Z : Local {U}} (z : Z.S) (x' : Local.S {S'}) : lift {Z} (\\\\lam (_ : Localization.S) => z) x' = z \\n=> remove_inL {Z} (lift {Z} (\\\\lam (_ : Localization.S) => z)) (\\\\lam (_ : Local.S {S'}) => z)\\n  (lift-prop {Z} (\\\\lam (_ : Localization.S) => z)) x'\", \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func lift-prop \\\\hlevels  {this : Localization} {Z : Local {U}} (f : Localization.S -> Z.S) (x : Localization.S) : lift {Z} f (inL x) = f x \\n  => path (\\\\lam (i : I) => (@) (f_sec {local-univ Z} f) i x)']<<<break>>>\\Sigma -> Equiv {\\Sigma -> Z.S} {X -> Z.S} (\\lam (_x : A {\\this}) => _x o (\\lam (_ : X) => ()))", "completion": "conv (localDesc X Z) (\\new QEquiv {\n  | ret => \\lam g => lift g (center {c})\n  | ret_f => \\lam z => const z (center {c})\n  | f_sec => \\lam g => path (\\lam i x => (pmap (lift g) (contraction {c} (inL x)) *> lift-prop g x) @ i)\n})"}
{"prompt": "[\"a' : E {f.Dom}\", \"p : f.func a = f.func a'\", 'f : AddGroupHom', 'a : E {f.Dom}']<<<break>>>['| zro : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ']<<<break>>>f.func a - f.func a' = zro {f.Cod}", "completion": "toZero p"}
{"prompt": "['A : \\\\Type', 'pB : \\\\Pi (a : A) -> B a ofHLevel_-2+ 0', 'B : A -> \\\\Type', 'pA : A ofHLevel_-2+ 0']<<<break>>>['\\\\lemma sigma-Contr {A : \\\\Type} (B : A -> \\\\Type) (_ : Contr A) (_ : \\\\Pi (a : A) -> Contr (B a)) : Contr (\\\\Sigma (a : A) (B a)) ', \"\\\\class Contr {\\n  | A : \\\\Type\\n  | center : A\\n  | contraction (a' : A) : center = a'\\n}\"]<<<break>>>Contr (\\Sigma (a : A) (B a))", "completion": "sigma-Contr B pA pB"}
{"prompt": "['x<=x0b+1 : x <= fromRat (x0b + fromInt (pos 1))', 'y0b>0 : zro < y0b', 'eps : Rat', 'x0b>0 : zro < x0b', 'gamma-m : fromRat (y0b + fromInt (pos 1) + fromInt (pos 1) + (x0b + fromInt (pos 1) + fromInt (pos 1))) * fromRat gamma <= fromRat (half eps)', 'eps>0 : zro < eps', \"y' : E\", 'y0b : Rat', 'gamma : Rat', 'y<=y0b+1 : y <= fromRat (y0b + fromInt (pos 1))', \"x' : E\", 'x0b : Rat', 'y : E', \"yy'<gamma : \\\\Sigma (a : Rat) (a < gamma \u2227 fromInt (pos 1)) (zro <= a) (y <= y' + fromRat a) (y' <= y + fromRat a)\", \"xx'<gamma : \\\\Sigma (a : Rat) (a < gamma \u2227 fromInt (pos 1)) (zro <= a) (x <= x' + fromRat a) (x' <= x + fromRat a)\", 'x : E']<<<break>>>['true', '\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '\\\\lemma half<id \\\\plevels  \\\\hlevels  {a : Rat} (_ : fromInt (pos 0) < a) : half a < a ', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| dist E E : ExUpperReal', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\instance UpperRealSemigroup \\\\hlevels  : CSemigroup UpperReal {\\n  | * => (UpperRealSemigroup.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\lemma ldistr_<= \\\\plevels  \\\\hlevels  {x y z : ExUpperReal} : x * (y + z) <= x * y + x * z ', '| \\\\infixl 7 * E E : E', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma rdistr_<= \\\\plevels  \\\\hlevels  {x y z : ExUpperReal} : (x + y) * z <= x * z + y * z ', '| E : \\\\Set', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance RatNormed \\\\hlevels  : NormedAbGroup Rat {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | negative => RatField.negative\\n  | norm => \\\\lam (a : E {\\\\this}) => Real.fromRat (abs {RatField} a)\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| len : Nat', '\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\lemma <=_* \\\\plevels  \\\\hlevels  {x x' y y' : ExUpperReal} (_ : x <= x') (_ : y <= y') : x * y <= x' * y' \", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| meet-right {x y : E} : x \u2227 y <= y', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'inP A', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\lemma *-ex \\\\plevels  \\\\hlevels  {x y : UpperReal} : x UpperRealSemigroup.* y = x ExUpperReal.* y ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '| *-comm {x y : E} : x * y = y * x', '\\\\lemma +-rat \\\\plevels  \\\\hlevels  {x y : Rat} : fromRat x ExUpperReal.+ fromRat y = fromRat (x RatField.+ y) ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\lemma half>0 \\\\plevels  \\\\hlevels  {a : Rat} (_ : fromInt (pos 0) < a) : fromInt (pos 0) < half a ', ':zro', '\\\\func half \\\\plevels  \\\\hlevels  (a : Rat) : Rat => a * ratio (pos 1) 2', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\lemma rdistr \\\\plevels  \\\\hlevels  {x y z : ExUpperReal} (_ : zro <= x) (_ : zro <= y) : (x + y) * z = x * z + y * z ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\infixl 7 * \\\\hlevels  (x y : UpperReal) : UpperReal \\n=> \\\\new UpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | U-inh => {?hidden}\\n}', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\instance UpperRealMetric \\\\hlevels  : CompleteExMetricSpace UpperReal {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => ExUpperRealMetric.dist\\n} => \\\\new CompleteExMetricSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | isComplete => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n}', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '| U Rat : \\\\Prop', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>U {dist (x * y) (x' * y')} eps", "completion": "unfold (rewrite (*-ex, *-ex) $ inP (half eps, half<id eps>0, <=-less $ half>0 eps>0,\n  <=_* <=-refl yy'<gamma.4 <=\u2218 ldistr_<= <=\u2218 <=_+ (<=_* xx'<gamma.4 <=-refl <=\u2218 rdistr_<=) <=-refl <=\u2218 =_<= +-assoc <=\u2218 <=_+ <=-refl\n    (<=_+ (=_<= *-comm <=\u2218 <=_* (transport ((<=) _) +-rat $ yy'<gamma.5 <=\u2218 <=_+ y<=y0b+1 (<=-rat.1 $ <=-less yy'<gamma.2 <=\u2218 meet-right))\n      (<=-rat.1 $ <=-less xx'<gamma.2 <=\u2218 meet-left))\n      (<=_* (x<=x0b+1 <=\u2218 <=-rat.1 linarith) (<=-rat.1 $ <=-less yy'<gamma.2 <=\u2218 meet-left)) <=\u2218 gamma-m),\n  <=_* <=-refl yy'<gamma.5 <=\u2218 ldistr_<= <=\u2218 <=_+ (<=_* xx'<gamma.5 <=-refl <=\u2218 rdistr_<=) <=-refl <=\u2218 =_<= +-assoc <=\u2218 <=_+ <=-refl (<=_+ (=_<= *-comm <=\u2218 <=_* (y<=y0b+1 <=\u2218 <=-rat.1 linarith) (<=-rat.1 $ <=-less xx'<gamma.2 <=\u2218 meet-left))\n    (<=_* (transport ((<=) _) +-rat $ xx'<gamma.5 <=\u2218 <=_+ x<=x0b+1 (<=-rat.1 $ <=-less xx'<gamma.2 <=\u2218 meet-right))\n      (<=-rat.1 $ <=-less yy'<gamma.2 <=\u2218 meet-left)) <=\u2218 gamma-m)))"}
{"prompt": "[\"q : \\\\Pi (b : E) -> Not (\\\\Pi (j : Fin l'.len) -> l'.at j = l.at (b.f j))\", 'l : Array A.E', \"l' : Array A.E\", 'A : DecSet']<<<break>>>[\"\\\\func eperm_equiv {A4 : \\\\Type} {l5 l'2 : Array A4} (_ : EPerm {A4} l5 l'2) :\\n  \\\\Sigma (e : Equiv {Fin l'.len} {Fin l.len}) (\\\\Pi (j : Fin l'.len) -> l'.at j = l.at (e.f j)) \\n  | {A}, {nil}, {nil}, eperm-nil => (idEquiv {Fin 0}, \\\\lam (p0 : Fin 0) => (\\\\case p0 \\\\with {}))\\n  | {A}, {:: {n} x l3}, {:: {n} y l4}, eperm-:: p q => \\n    \\\\have (e, f) => eperm_equiv {A} {l3} {l4} q\\n    \\\\in (aux {n} {n} e, \\\\lam (p0 : Fin (suc l4.len)) => (\\\\case p0 \\\\with {\\n          | zero => inv {A} {at {x :: l3} (\\\\case 0 \\\\with {\\n            | zero => 0\\n            | suc j => suc (f {e} j)\\n          })} {at {y :: l4} 0} p\\n          | suc j => f j\\n        }))\\n  | {A}, {:: {suc n} x (x' :: l)}, {:: {suc n} y (y' :: l')}, eperm-swap p1 p2 q =>\\n  transport {Array A} (\\\\lam (l'' : Array A) => \\\\Sigma (e : Equiv {Fin (suc (suc l''.len))} {Fin (suc (suc l.len))})\\n    (\\\\Pi (j : Fin (suc (suc l''.len))) -> at {y :: y' :: l''} j = at {x :: x' :: l} (e.f j))) {l} {l'} q\\n    (transposition1 {suc n} 0, \\\\lam (p0 : Fin (suc (suc l.len))) => (\\\\case p0 \\\\with {\\n      | zero => transportInv {Fin (suc (suc n))} (\\\\lam (x1 : Fin (suc (suc n))) => y = (x :: x' :: l) !! x1)\\n        {f {transposition {suc (suc n)} {0} {1} (id/=suc {0})} 0} {1} (transposition1-left {suc n} {0})\\n        (inv {A} {(x :: x' :: l) !! 1} {y} p2)\\n      | suc zero => transportInv {Fin (suc (suc n))} (\\\\lam (x1 : Fin (suc (suc n))) => y' = (x :: x' :: l) !! x1)\\n        {f {transposition {suc (suc n)} {0} {1} (id/=suc {0})} 1} {0} (transposition1-right {suc n} {0})\\n        (inv {A} {(x :: x' :: l) !! 0} {y'} p1)\\n      | suc (suc j) => transportInv {Fin (suc (suc n))} (\\\\lam (x1 : Fin (suc (suc n))) => l !! j = (x :: x' :: l) !! x1)\\n        {f {transposition {suc (suc n)} {0} {1} (id/=suc {0})} (suc (suc j))} {suc (suc j)}\\n        (transposition1_/= {suc n} {0} {suc (suc j)} (\\\\lam (p0 : suc (suc j) = 0) => (\\\\case p0 \\\\with {}))\\n          (\\\\lam (p0 : suc (suc j) = 1) => (\\\\case p0 \\\\with {}))) (idp {A} {l !! j})\\n    }))\\n  | {A}, {l}, {l'}, eperm-trans {l1} p1 p2 => \\n    \\\\have | (e1, f1) => eperm_equiv {A} {l} {l1} p1\\n          | (e2, f2) => eperm_equiv {A} {l1} {l'} p2\\n    \\\\in (transEquiv {Fin l'.len} {Fin l.len} {Fin l.len} e2 e1, \\\\lam (j : Fin l'.len) => f2 j *> f1 (f {e2} j))\", '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| E : \\\\Set', \"\\\\data EPerm {A : \\\\Type} (_ _ : Array A) \\\\with\\n  | {A}, nil, nil => eperm-nil\\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)\"]<<<break>>>EPerm {A.E} l l' -> Empty", "completion": "\\lam e => q (eperm_equiv e).1 (eperm_equiv e).2"}
{"prompt": "['gcd=0 : gcd.res = D.zro', 'dec : Dec D.E {\\n  | zro => D.zro\\n  | + => (D.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (D.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => D.negative\\n  | negative-left => {?hidden}\\n  | ide => D.ide\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => D.natCoef\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | #0 => D.#0\\n  | #0-zro => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zro#ide => {?hidden}\\n  | #0-* => {?hidden}\\n  | *-comm => {?hidden}\\n}', 'D : GCDDomain', 'gcd : GCD {dec} x y']<<<break>>>['| len : Nat', '| M : \\\\Set', '| interpret {n : Nat} (Fin n -> M) (Term n) : M', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| res : E {M}', ':zro', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', 'nil', 'var (Fin n)', '| inv : E {M}', '\\\\infixl 7 :* (_ _ : Term C n)', '\\\\lemma apply-axiom \\\\hlevels  {R : CSemiring} (env1 : Array R.E) (t s : Term Nat env.len)\\n  (_ : interpret {SemiringData {R} env1} t = interpret {SemiringData {R} env1} s) (mul add : NF Nat env.len) :\\ninterpretNF {SemiringData {R} env1}\\n  (sortMonomials {len {env}} {E {C}} (multiply {len {env}} {C} mul (normalize {len {env}} {C} {D} t)) ++ add) = interpretNF {SemiringData {R} env1}\\n  (sortMonomials {len {env}} {E {C}} (multiply {len {env}} {C} mul (normalize {len {env}} {C} {D} s)) ++ add) ', '| res|val1 : LDiv {M} res val1', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '\\\\lemma terms-equality \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s)) :\\n  interpret {env.len} env.at t = interpret {env.len} env.at s ', '| E : \\\\Set', '\\\\func CSemiringSolverModel \\\\hlevels  (R : CSemiring) : SolverModel R.E {\\n  | Term => SemiringSolverModel.Term Nat\\n  | NF => SemiringSolverModel.NF Nat\\n  | normalize => \\\\lam {n : Nat} => SemiringSolverModel.normalize {n} {NatSemiring} {NatSemiring}\\n  | interpret => \\\\lam {n : Nat} (env1 : Fin n -> M {\\\\this}) =>\\n    SemiringSolverModel.Data.interpret {SemiringData {R} (\\\\new Array (M {\\\\this}) n env1)}\\n  | interpretNF => \\\\lam {n : Nat} (env : Fin n -> M {\\\\this}) (nf : SolverModel.NF {\\\\this} n) =>\\n    SemiringSolverModel.Data.interpretNF {SemiringData {R} (\\\\new Array (M {\\\\this}) n env)} (sortMonomials {n} {Nat} nf)\\n} => \\\\new SolverModel {\\n  | interpretNF-consistent => {?hidden}\\n}', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {2} (at {gcd.res :: inv {gcd.res|val1} :: nil}) (var {Nat} {2} 0 :* var {Nat} {2} 1) = interpret {2} (at {gcd.res :: inv {gcd.res|val1} :: nil}) (:zro {Nat} {2})", "completion": "\n  \\let env : DArray {2} (\\lam _ => D.E) => gcd.res :: inv {gcd.res|val1} :: nil\n  \\in terms-equality\n        {CSemiringSolverModel D} env (var 0 :* var 1) :zro (apply-axiom env (var 0) :zro gcd=0 ((1 :: nil, 1) :: nil) nil)"}
{"prompt": "['x : Bool', 'y : Bool']<<<break>>>['\\\\field trichotomy (x y : E) : Tri x y', '\\\\instance BoolPoset \\\\hlevels  : LinearOrder.Dec Bool {\\n  | < => (BoolPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) =>\\n      <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (p0 : E {\\\\this}) (p1 : E {\\\\this}) => (\\\\case p0, p1 \\\\with {\\n    | true, true => equals {true} {true} (idp {Bool} {true})\\n    | true, false => greater {true} {false} false<true\\n    | false, true => less {false} {true} false<true\\n    | false, false => equals {false} {false} (idp {Bool} {false})\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\data Tri \\\\hlevels  {A : StrictPoset} (_ _ : A.E) \\n  | less (a A.< a')\\n  | equals (a = a')\\n  | greater (a A.> a')\"]<<<break>>>Tri {BoolPoset} x y", "completion": "trichotomy x y"}
{"prompt": "['b : E {A {\\\\this}}', 'p : a <= b', 'f : \\\\Pi {n : Nat} -> N <= n -> a n', 'N : Nat']<<<break>>>['\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| \\\\infix 4 <= E E : \\\\Prop']<<<break>>>\\Pi {n : Nat} -> N <= n -> b n", "completion": "\\lam q => p $ f q"}
{"prompt": "['R : CRing', 'n : Nat', 'a : E {P {\\\\this}}']<<<break>>>['\\\\lemma cover_pow \\\\hlevels  {R : CRing} {x : R.E} (n : Nat) : Cover1 {SpecPres R} x (pow {R} x n) ', 'suc Nat', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', '\\\\func SpecPres \\\\hlevels  (R : CRing) : FramePres R.E {\\n  | conj => (R.*)\\n  | BasicCover => Indexing {Maybe (\\\\Sigma R.E R.E)} {R.E} (\\\\lam (p0 : Maybe (\\\\Sigma R.E R.E)) => (\\\\case p0 \\\\with {\\n    | just (a, b) => (Bool, a R.+ b, \\\\lam (p0 : Bool) => if {R.E} p0 a b)\\n    | nothing => (Empty, R.zro, absurd {R.E})\\n  }))\\n} => \\\\new FramePres', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>Cover {SpecPres R} a {\\Sigma} (\\lam (_ : \\Sigma) => pow {R} a (suc n))", "completion": "cover_pow (suc n)"}
{"prompt": "['x : X.E', 'd<a : U {X.dist x y} a', 'a : Rat', 'X : ExPseudoMetricSpace', 'y : X.E']<<<break>>>['| <=-refl {x : E} : x <= x', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| dist E E : ExUpperReal', '| U Rat : \\\\Prop', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma +_U_<= \\\\plevels  \\\\hlevels  {x y : ExUpperReal} {a : Rat} :\\n  U {x ExUpperReal.+ y} a <-> TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b RatField.+ c <= a)) ', 'inP A', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)']<<<break>>>U {X.dist x y ExUpperReal.+ X.dist x y} (a RatField.+ a)", "completion": "+_U_<=.2 (inP (a, d<a, a, d<a, <=-refl))"}
{"prompt": "['e : Embedding {X} {C.Ob}', 'X : \\\\hType', 'C : Cat']<<<break>>>['| Hom Ob Ob : \\\\Set', '| id (X : Ob) : Hom X X', '| f A : B', '\\\\func subPrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} {X : \\\\hType} (f : X -> C.Ob) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => C.Hom (f x) (f y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => C.id (f x)\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} => (C.\u2218)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| Ob : \\\\hType', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\class Precat \\\\plevels obj >= hom \\\\hlevels  {\\n  | Ob : \\\\hType\\n  | Hom Ob Ob : \\\\Set\\n  | id (X : Ob) : Hom X X\\n  | \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z\\n  | id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f\\n  | id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f\\n  | o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)\\n}']<<<break>>>Precat X {\n  | Hom => \\lam (x : Ob {\\this}) (y : Ob {\\this}) => C.Hom (e.f x) (e.f y)\n  | id => \\lam (x : Ob {\\this}) => C.id (e.f x)\n  | o => \\lam {X Y Z : Ob {\\this}} => (C.\u2218)\n}", "completion": "subPrecat e"}
{"prompt": "['|x-y|<3/4eps : abs {RealAbGroup} (x - y) < eps * fromRat (ratio (pos 3) 4)', 'x : Real', 'y : Real', 'eps : Real']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\lemma abs>=id \\\\hlevels  {this : LatticeAbGroup} {x : E} : x <= abs x ', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat']<<<break>>>x - y < eps * fromRat (ratio (pos 3) 4)", "completion": "abs>=id {RealAbGroup} <\u2218r |x-y|<3/4eps"}
{"prompt": "[\"V' : E {\\\\this} -> \\\\Prop\", 'F : RegularCauchyFilter this', 'X : CompleteCoverSpace', 'S : Set X.E']<<<break>>>['| X : \\\\Set', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '\\\\func Total {X : \\\\Type} (U : Set X) : \\\\Type => \\\\Sigma (x : X) (\\\\property (U x))', '\\\\func extend {X : \\\\Type} {U : Set X} (V : Set (Total {X} U)) : Set X => \\\\lam (x : X) => \\\\Sigma (Ux : U x) (V (x, Ux))']<<<break>>>(\\lam (s : Total {X.E} S) => extend {X.E} {S} V' s.1) \u2286 V'", "completion": "\\lam s => transport V' (ext idp) s.2"}
{"prompt": "['a-overt : IsOvert {locale {open {L} a}}', 'a : L.E', 'U : L.E -> \\\\Prop', 'uU : L.isUniform U', 'L : PreuniformLocale']<<<break>>>['\\\\func wclosed-image \\\\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\\\lam (x : E {L {\\\\this}}) => Meet {Dom}\\n  {\\\\Sigma (j : Nucleus {Dom}) (\\\\Pi {P : \\\\Prop} -> \\\\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\\n  (\\\\lam (j : \\\\Sigma (j : Nucleus {Dom}) (\\\\Pi {P : \\\\Prop} -> \\\\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\\n    nucleus {j.1} x)) => \\\\new Nucleus {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func map \\\\hlevels  {this2 : Nucleus} : FrameHom L locale {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (nucleus x, nucleus-join>= {x})\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}', '\\\\class Nucleus \\\\hlevels  {\\n  | L : Locale\\n  | nucleus (E {L}) : E {L}\\n  | nucleus-meet {x y : E {L}} : nucleus (x \u2227 y) = nucleus x \u2227 nucleus y\\n  | nucleus-meet>= {x y : E {L}} : nucleus x \u2227 nucleus y <= nucleus (x \u2227 y)\\n  | nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y\\n  | nucleus-unit {x : E {L}} : x <= nucleus x\\n  | nucleus-join>= {x : E {L}} : nucleus (nucleus x) <= nucleus x\\n  | nucleus-join {x : E {L}} : nucleus (nucleus x) = nucleus x\\n}', '\\\\func nucleus-star \\\\hlevels  {L1 : Locale} (j : Nucleus {L1}) (U : L.E -> \\\\Prop) : L.E \\n  => SJoin {L1} (\\\\lam (y : L.E) => \\\\Sigma (U y) (IsPositive {locale {j}} (j.nucleus y, j.nucleus-join>= {y})))', '\\\\lemma wclosure>=nucleus-star {L : PreuniformLocale} {j : Nucleus {L}} (_ : IsOvert {locale {j}}) {U : L.E -> \\\\Prop} (_ : L.isUniform U) :\\n  open {L} (nucleus-star {L} j U) <= wclosed-image {map {j}} ', \"\\\\instance NucleusFrame (L1 : Locale) : Locale (Nucleus {L1}) {\\n  | <= => \\\\lam (j : E {\\\\this}) (j' : E {\\\\this}) => \\\\Pi {x : L.E} -> j.nucleus x L.<= j'.nucleus x\\n  | meet => NucleusFrame.meet {L1}\\n  | top => \\\\new Nucleus {L1} (\\\\lam (_ : E {L {\\\\this}}) => L.top) {\\n    | nucleus-meet => {?hidden}\\n    | nucleus-meet>= => {?hidden}\\n    | nucleus-<= => {?hidden}\\n    | nucleus-unit => {?hidden}\\n    | nucleus-join>= => {?hidden}\\n    | nucleus-join => {?hidden}\\n  }\\n  | Join => \\\\lam {J : \\\\Set} (g : J -> E {\\\\this}) => \\\\new Nucleus {L1} (\\\\lam (x : E {L {\\\\this}}) =>\\n    L.Meet {\\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j : J) -> \\\\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)}\\n      (\\\\lam (p : \\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j : J) -> \\\\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)) => nucleus {p.1} x)) {\\n    | nucleus-meet => {?hidden}\\n    | nucleus-meet>= => {?hidden}\\n    | nucleus-<= => {?hidden}\\n    | nucleus-unit => {?hidden}\\n    | nucleus-join>= => {?hidden}\\n    | nucleus-join => {?hidden}\\n  }\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma star_open \\\\hlevels  {L : Locale} (a : L.E) (U : L.E -> \\\\Prop) : nucleus-star {L} (open {L} a) U = star {L} a U ', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\func open \\\\hlevels  {this2 : Locale} (a : E) : Nucleus ((-->) a) => \\\\new Nucleus {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}', '\\\\func star \\\\hlevels  {L : Locale} (x : L.E) (U : L.E -> \\\\Prop) : L.E => SJoin {L} (\\\\lam (y : L.E) => \\\\Sigma (U y) (IsPositive {L} (x L.\u2227 y)))']<<<break>>>open {L} (star {L} a U) <= wclosed-image {map {open {L} a}}", "completion": "=_<= (pmap open $ inv $ star_open a U) <=\u2218 wclosure>=nucleus-star a-overt uU"}
{"prompt": "['E : CRing', 'a : E {S {\\\\this}}']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '| ide : E', '| zro-right {x : E} : x + zro = x', '| E : \\\\Set']<<<break>>>(E.zro E.+ E.ide) E.* a E.+ E.zro = (E.zro E.+ E.ide) E.* a", "completion": "zro-right {_} {(E.zro E.+ E.ide) E.* a}"}
{"prompt": "['k>0 : 0 < k', 'k : Nat', 'n : Nat', 'inj : IsInj {Fin (suc k)} {Fin n} l.at', 'l : Array (Fin n) (suc k)']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', 'suc Nat', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', 'inr B', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Index {A : \\\\Type} (x : A) (l : Array A) : \\\\Type => \\\\Sigma (i : Fin l.len) (l.at i = x)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', 'index-dec \\\\hlevels  {A : DecSet} (l : Array A.E) (a : A.E) : Or (Index {A.E} a l) (Not (Index {A.E} a l)) \\n=> \\\\case find {A.E} (\\\\lam (p0 : A.E) => EqualityDecide A p0 a) l \\\\with {\\n  | inl p => inl {Index {A.E} a l} {Not (Index {A.E} a l)} (p.1, p.2)\\n  | inr q => inr {Index {A.E} a l} {Not (Index {A.E} a l)} (\\\\lam (p : Index {A.E} a l) => q {p.1} p.2)\\n}', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'inl A', '\\\\func divMod \\\\plevels  \\\\hlevels  (_ _ : Nat) : \\\\Sigma Nat Nat ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 8 mod \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n mod m', 'suc<suc (n < m)', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma mod_< \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < m) : n mod m = n ']<<<break>>>(\\case index-dec {FinFin n} l (l.at 0) \\with {\n  | inl p => l !! (suc p.1 mod suc k)\n  | inr n => l !! 0\n}) = l !! 0 -> Empty", "completion": "cases (index-dec l (l 0)) (\\case  \\with {\n  | inl r => \\lam q => (\\case inv (rewrite (inj r.2) in inj q) *> {Nat} mod_< (suc<suc k>0) \\with {})\n  | inr r => absurd $ r (0, idp)\n})"}
{"prompt": "['r : E {R {\\\\this}}', 'q : E {R {\\\\this}}', 'l : Array (\\\\Sigma V.E B.E)', 'V : QModule', 'B : BottomDistributiveLattice']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| *c-rdistr {r s : E {R}} {a : E} : (r + s) *c a = r *c a + s *c a', '\\\\func toRatModule \\\\hlevels  {this1 : QModule} : LModule RatField E {\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | negative => negative\\n  | *c => (*q)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>\\Pi (i : I) -> Array (\\Sigma V.E B.E) l.len\n  (\\lam (i1 : Fin l.len) => (\\lam (s : \\Sigma V.E B.E) => (*c-rdistr {q} {r} {s.1} @ i, s.2)) (l.at i1))", "completion": "\\lam i => map (\\lam s => (*c-rdistr {toRatModule {V}} {q} {r} {s.1} i, s.2)) l"}
{"prompt": "['this : LinearData', 'p : Array Equation n', 'q : hasNegative (e :: p) (k :: c) = true', 'e : Equation', 'c : Array Nat p.len', 'k : Nat']<<<break>>>['\\\\lemma toOr \\\\plevels  \\\\hlevels  {x y : Bool} (_ : x or y = true) : (x = true) || (y = true) ', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', 'true', '\\\\func \\\\infixl 3 and \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => y\\n  | false, y => false', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isLess \\\\hlevels  {this : LinearData} (_ : Operation) : Bool \\n  | {this}, Less => true\\n  | {this}, o => false', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c']<<<break>>>(isLess e.2 and isSuc k = true) || (hasNegative p c = true)", "completion": "toOr q"}
{"prompt": "['n : Nat', 'env : Array B.E n', 'B : BooleanRing', 's : Term n', 't : Term n']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\lemma interpretNF_++ {B : BooleanRing} {n : Nat} {env : Array B.E n} {l l' : NF n} :\\n  interpretNF' {B} {n} env (l ++ l') = interpretNF' {B} {n} env l B.+ interpretNF' {B} {n} env l' \", '\\\\func normalize {n5 : Nat} (_ : Term n5) : NF n5 \\n  | {n}, var j => singleAt {Bool} {n} j true false :: nil {Array Bool n}\\n  | {n}, :zro => nil {Array Bool n}\\n  | {n}, :negative t => normalize {n} t\\n  | {n}, t :+ s => normalize {n} t ++ normalize {n} s\\n  | {n}, t :* s => multiply {n} (normalize {n} t) (normalize {n} s)', \"\\\\func interpretNF' \\\\hlevels  {B3 : BooleanRing} {n2 : Nat} (_ : Array B.E n2) (_ : NF n2) : B.E \\n  | {B}, {n}, env, nil => B.zro\\n  | {B}, {n}, env, x :: nil => interpretMonomial {B} {n} env x\\n  | {B}, {n}, env, x :: l => interpretMonomial {B} {n} env x B.+ interpretNF' {B} {n} env l\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys']<<<break>>>interpretNF' {B} {len {env}} env (normalize {n} t ++ normalize {n} s) = interpretNF' {B} {len {env}} env (normalize {n} t) B.+ interpretNF' {B} {len {env}} env (normalize {n} s)", "completion": "interpretNF_++ {B}"}
{"prompt": "['q : p = BigProd {PolyRing K} (map {K.E} {Poly K} (\\\\lam (a : K.E) => padd {K} ide (K.negative a)) l)', 'l : Array K.E', 'K : CRing', 'p : Poly K']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func BigProd \\\\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l', '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| ide : E', 'inP A', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', 'padd (Poly R) R.E', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '| at (j : Fin len) : A j', '| E : \\\\Set', '| negative E : E']<<<break>>>TruncP (\\Sigma (l : Array K.E l.len) (p = BigProd {PolyRing K} (map {K.E} {Poly K} (\\lam (a : K.E) => padd {K} ide (K.negative a)) l)))", "completion": "inP (\\new l, q)"}
{"prompt": "['a : R.E', 'R : CRing', 'x : SType {R} (powers {R} a)', 'b : R.E', 'a|b : LDiv {R} a b']<<<break>>>['\\\\lemma aux \\\\hlevels  {R : CRing} {a b : R.E} (a|b : LDiv {R} a b) (x : SType {R} (powers {R} a)) :\\n\\\\Sigma (b1 : E) (TruncP (\\\\Sigma (a1 : \\\\Sigma (n : Nat) (pow {R} a n = x.2)) (in~ {SType {R} (powers {R} b)}\\n  {\\\\lam (a : SType {R} (powers {R} b)) (b : SType {R} (powers {R} b)) => a.1 R.* b.2 = b.1 R.* a.2}\\n  (x.1 R.* pow {R} a|b.inv a1.1, pow {R} a|b.inv a1.1 R.* pow {R} a a1.1,\\n    inP {\\\\Sigma (n : Nat) (pow {R} b n = pow {R} a|b.inv a1.1 R.* pow {R} a a1.1)} (a1.1,\\n      transport {R.E} (\\\\lam (x : E {a|b.M}) => pow {R} x a1.1 = pow {R} a|b.inv a1.1 R.* pow {R} a a1.1) {a R.* a|b.inv} {b}\\n        a|b.inv-right (pow_*-comm {R} {a} {a|b.inv} {a1.1} *> R.*-comm {pow {R} a a1.1} {pow {R} a|b.inv a1.1}))) = b1))) ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func powers \\\\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (pow {M} a n = x))) \\n=> \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', 'inP A', '| inv : E {M}', '| inv-right : val * inv = elem', '\\\\instance LocRing \\\\hlevels  {R : CRing} (S : SubMonoid R) : CRing (Type {R} {S}) {\\n  | zro => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.zro, R.ide, S.contains_ide)\\n  | + => ++ {R} {S}\\n  | * => ** {R} {S}\\n  | negative => neg {R} {S}\\n  | ide => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.ide, R.ide, S.contains_ide)\\n  | natCoef => \\\\lam (n : Nat) => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2}\\n    (R.natCoef n, R.ide, S.contains_ide)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '| M : Monoid', '\\\\lemma pow_*-comm \\\\hlevels  {this : CMonoid} {a b : E} {n : Nat} : pow (a * b) n = pow a n * pow b n ', '\\\\func SType \\\\hlevels  {R : CRing} (S : SubMonoid R) : \\\\Set => \\\\Sigma (_ y : R.E) (S.contains y)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| contains (E {S}) : \\\\Prop', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a', 'in~ A']<<<break>>>TruncP (\\Sigma (a1 : \\Sigma (n : Nat) (pow {R} a n = x.2)) (in~ {SType {R} (powers {R} b)}\n  {\\lam (a : SType {R} (powers {R} b)) (b : SType {R} (powers {R} b)) => a.1 R.* b.2 = b.1 R.* a.2}\n  (x.1 R.* pow {R} a|b.inv a1.1, pow {R} a|b.inv a1.1 R.* pow {R} a a1.1,\n    inP {\\Sigma (n : Nat) (pow {R} b n = pow {R} a|b.inv a1.1 R.* pow {R} a a1.1)} (a1.1,\n      transport {R.E} (\\lam (x : E {a|b.M}) => pow {R} x a1.1 = pow {R} a|b.inv a1.1 R.* pow {R} a a1.1) {a R.* a|b.inv} {b}\n        a|b.inv-right (pow_*-comm {R} {a} {a|b.inv} {a1.1} *> R.*-comm {pow {R} a a1.1} {pow {R} a|b.inv a1.1}))) = (aux {R} {a} {b} a|b x).1))", "completion": "(aux {R} a|b x).2"}
{"prompt": "['fc : ContMap X (PartialTopSpace Y) {\\n  | func => f\\n}', 'c : U (func {\\\\this} x)', 'f : X.E -> Partial Y.E', 'U : E {Cod {\\\\this}} -> \\\\Prop', 'x : \\\\Sigma (x : X.E) (\\\\property (isDefined {f x}))', 'X : TopSpace']<<<break>>>['| value isDefined : E', '| isDefined : \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '\\\\func Total {X : \\\\Type} (U : Set X) : \\\\Type => \\\\Sigma (x : X) (\\\\property (U x))']<<<break>>>(^-1) (\\lam (p0 : Total {X.E} (\\lam (x : X.E) => isDefined {f x})) => p0.1)\n  (\\lam (x : X.E) => \\Sigma (p : isDefined {fc.func x}) (U (value {fc.func x} p))) x", "completion": "(x.2, c)"}
{"prompt": "['n : Nat', 'x : Fin n', 'q : \\\\Pi (j : Fin (suc l.len)) -> suc i < j -> f {at {e :: l} j} (f {at {e :: l} (suc i)} x) = f {at {e :: l} (suc i)} x', 'i : Fin l.len', 'l : Array (Sym n1) n', 'p : \\\\Pi (j : Fin (suc l.len)) -> j < suc i -> f {at {e :: l} j} x = x']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func BigProd \\\\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l', 'suc Nat', '| f A : B', '\\\\lemma BigProd-unique \\\\plevels  \\\\hlevels  {n : Nat} {l : Array (Sym n)} {x : Fin n} (i : Fin l.len) (_ : \\\\Pi (j : Fin l.len) -> j < i -> f {l.at j} x = x)\\n  (_ : \\\\Pi (j : Fin l.len) -> i < j -> f {l.at j} (f {l.at i} x) = f {l.at i} x) :\\n  f {BigProd {SymmetricGroup n} l} x = f {l.at i} x ', 'suc<suc (n < m)', '| at (j : Fin len) : A j', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\instance SymmetricGroup \\\\hlevels  (n : Nat) : Group (Sym n) {\\n  | ide => idEquiv {Fin n}\\n  | * => transEquiv {Fin n} {Fin n} {Fin n}\\n  | inverse => \\\\lam (e : E {\\\\this}) => symQEquiv {Fin n} {Fin n} (fromEquiv e)\\n} => \\\\new Group {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | inverse-right => {?hidden}\\n}']<<<break>>>f {BigProd {SymmetricGroup n} l} x = f {l.at i} x", "completion": "BigProd-unique i (\\lam j s => p (suc j) (suc<suc s)) (\\lam j s => q (suc j) (suc<suc s))"}
{"prompt": "['a : L.E', 'L : Locale', 'x : L.E']<<<break>>>['\\\\lemma meet-comm \\\\hlevels  {this : MeetSemilattice} {x y : E} : x \u2227 y = y \u2227 x ', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>x \u2227 a <= a \u2227 x", "completion": "=_<= meet-comm"}
{"prompt": "['e : Iso']<<<break>>>['| **-*c {g : E {G}} {e : E} {c : E {R}} : g ** (c *c e) = c *c g ** e', '| \\\\infixl 6 + E E : E', '| ide_*c {a : E} : ide {R} *c a = a', '| \\\\infixl 8 ** (E {G}) E : E', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', '| id-action {e : E} : ide {G} ** e = e', '| zro-right {x : E} : x + zro = x', '| *c-rdistr {r s : E {R}} {a : E} : (r + s) *c a = r *c a + s *c a', '| R : Ring', '| cod : Ob {C}', '| **-assoc {m n : E {G}} {e : E} : m ** (n ** e) = (m * n) ** e', '| zro : E', '| G : Group', \"| **-ldistr {g : E {G}} {e e' : E} : g ** (e + e') = g ** e + g ** e'\", '| zro-left {x : E} : zro + x = x', '| negative-left {x : E} : negative x + x = zro', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| negative E : E', '| +-comm {x y : E} : x + y = y + x', '| *c-ldistr {r : E {R}} {a b : E} : r *c (a + b) = r *c a + r *c b', \"\\\\class LinRepres \\\\extends LModule, GroupAction \\\\hlevels  {\\n  | **-ldistr {g : E {G}} {e e' : E} : g ** (e + e') = g ** e + g ** e'\\n  | **-*c {g : E {G}} {e : E} {c : E {R}} : g ** (c *c e) = c *c g ** e\\n}\", \"| *c-assoc {r r' : E {R}} {a : E} : r * r' *c a = r *c (r' *c a)\"]<<<break>>>LinRepres (R {e.cod}) (G {e.cod}) (E {e.cod}) {\n  | zro => zro {e.cod}\n  | + => (+) {e.cod}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative => negative {e.cod}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | *c => (*c) {e.cod}\n  | *c-assoc => {?hidden}\n  | *c-ldistr => {?hidden}\n  | *c-rdistr => {?hidden}\n  | ide_*c => {?hidden}\n  | ** => (**) {e.cod}\n  | **-assoc => {?hidden}\n  | id-action => {?hidden}\n  | **-ldistr => {?hidden}\n  | **-*c => {?hidden}\n}", "completion": "cod {e}"}
{"prompt": "['l : PFunc {V} {B}', \"f : \\\\Pi (i : Fin l.len) -> \\\\Sigma (j : Fin (suc n)) ((l !! i).1 = ((a :: l') !! j).1) ((l !! i).2 B.<= ((a :: l') !! j).2)\", 'D : \\\\Pi (i : Fin l.len) -> Dec ((f i).1 = 0)', \"r : SFRefines {V} {B} l (a :: l')\", 'V : PosetQModule', 'lr : IsReduced {V} {B} l', 'a : \\\\Sigma V.E B.E', 'B : BooleanRing', 'n : Nat', 'indices : Array (Fin l.len) l.len (\\\\lam (i : Fin l.len) => i)', \"l' : Array (\\\\Sigma V.E B.E) n\", \"l'r : IsReduced {V} {B} (a :: l')\"]<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func element {A1 : \\\\Type} {P1 : A1 -> \\\\Prop} {D1 : \\\\Pi (a : A1) -> Dec (P1 a)} {l1 : Array A1} {j1 : Fin l.len}\\n  (_ : Not (P1 (l.at j1))) : Index {A1} (l.at j1) (remove {A1} {P1} D1 l1) \\n  | {A}, {P}, {D}, {:: {n} a l}, {j}, p => \\\\case j, p \\\\with {\\n    | zero, p => \\\\case D a \\\\with {\\n      | yes e => absurd {\\\\Sigma (i : Fin (len {\\\\case yes {P a} e \\\\with {\\n        | yes p => remove {A} {P} D l\\n        | no n => a :: remove {A} {P} D l\\n      }}))\\n        (at {\\\\case yes {P a} e \\\\with {\\n          | yes p => remove {A} {P} D l\\n          | no n => a :: remove {A} {P} D l\\n        }} i = a)} (p e)\\n      | no q => (0, idp {A} {at {\\\\case no {P a} q \\\\with {\\n        | yes p => remove {A} {P} D l\\n        | no n => a :: remove {A} {P} D l\\n      }} 0})\\n    }\\n    | suc j, p => \\\\case D a \\\\with {\\n      | yes e => element {A} {P} {D} {l} {j} p\\n      | no q => \\n        \\\\let t => element {A} {P} {D} {l} {j} p\\n        \\\\in (suc t.1, t.2)\\n    }\\n  }', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\lemma no-repeats {A : \\\\Type} {l : Array A} (_ : \\\\Pi {i j : Fin l.len} -> l.at i = l.at j -> i = j) {P : A -> \\\\Prop}\\n  {D : \\\\Pi (a : A) -> Dec (P a)} {i j : Fin (len {remove {A} {P} D l})}\\n  (_ : at {remove {A} {P} D l} i = at {remove {A} {P} D l} j) : i = j ', '| at (j : Fin len) : A j', '\\\\lemma ~-zros-left \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} {l : Array (\\\\Sigma V.E B.E)}\\n  (_ : \\\\Pi (i : Fin l.len) -> (l.at i).1 = V.zro) : l ~ nil ', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\func element {A : \\\\Type} {P : A -> \\\\Prop} {D : \\\\Pi (a : A) -> Dec (P a)} {l : Array A} {j : Fin l.len} (p : P (l.at j)) :\\n  Index {A} (l.at j) (keep {A} {P} D l) => transportInv {Array A} (Index {A} (l !! j)) {keep {A} {P} D l}\\n  {remove {A} {\\\\lam (a : A) => P a -> Empty} (\\\\lam (a : A) => NotDec {P a} (D a)) l} (keep=remove {A} {P} {D} {l})\\n  (element {A} {\\\\lam (a : A) => P a -> Empty} {\\\\lam (a : A) => NotDec {P a} (D a)} {l} {j} (\\\\lam (q : P (l.at j) -> Empty) => q p))', '| len : Nat', '| <=-refl {x : E} : x <= x', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\lemma /=-sym {A : \\\\Type} {a a' : A} (_ : a /= a') : a' /= a \", \"~-zro-left {b : B.E} (l = (V.zro, b) :: l')\", \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func preimage {A2 : \\\\Type} {P2 : A2 -> \\\\Prop} {D2 : \\\\Pi (a : A2) -> Dec (P2 a)} {l1 : Array A2}\\n  (i2 : Fin (len {remove {A2} {P2} D2 l1})) : \\\\Sigma (j : Fin l.len) (at {remove {A2} {P2} D2 l1} i2 = l.at j) \\n  | {A}, {P}, {D}, {nil}, i => (i, idp {A} {at {remove {A} {P} D nil} i})\\n  | {A}, {P}, {D}, {:: {n} a l}, i => \\\\case D a, i \\\\with {\\n    | yes e, i => \\n      \\\\let t => preimage {A} {P} {D} {l} i\\n      \\\\in (suc t.1, t.2)\\n    | no q, zero => (0, idp {A} {(\\\\case no {P a} q \\\\with {\\n      | yes p => remove {A} {P} D l\\n      | no n => a :: remove {A} {P} D l\\n    }) !! 0})\\n    | no q, suc i => \\n      \\\\let t => preimage {A} {P} {D} {l} i\\n      \\\\in (suc t.1, t.2)\\n  }', '\\\\lemma BigJoin-cond \\\\hlevels  {this : BottomJoinSemilattice} {l : Array E} (j : Fin l.len) : l.at j <= BigJoin l ', '\\\\func keep {A2 : \\\\Type} {P1 : A2 -> \\\\Prop} (_ : \\\\Pi (a : A2) -> Dec (P1 a)) (_ : Array A2) : Array A2 \\n  | {A}, {P}, D, nil => nil\\n  | {A}, {P}, D, :: {n} a l => \\\\case D a \\\\with {\\n    | yes p => a :: keep {A} {P} D l\\n    | no n => keep {A} {P} D l\\n  }', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y', '| meet-right {x y : E} : x \u2227 y <= y', '\\\\lemma no-element {A : \\\\Type} {P : A -> \\\\Prop} (D : \\\\Pi (a : A) -> Dec (P a)) {l : Array A} {i : Fin (len {remove {A} {P} D l})}\\n  (_ : P (at {remove {A} {P} D l} i)) : Empty ', '| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', 'suc Nat', \"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', 'inP A', '\\\\lemma no-repeats {A : \\\\Type} {l : Array A} (_ : \\\\Pi {i j : Fin l.len} -> l.at i = l.at j -> i = j) {P : A -> \\\\Prop}\\n  {D : \\\\Pi (a : A) -> Dec (P a)} {i j : Fin (len {keep {A} {P} D l})}\\n  (_ : at {keep {A} {P} D l} i = at {keep {A} {P} D l} j) : i = j ', '\\\\lemma fsuc/=0 \\\\plevels  \\\\hlevels  {n : Nat} {x : Fin n} : fsuc {n} x /= 0 ', '\\\\func remove {A2 : \\\\Type} {P1 : A2 -> \\\\Prop} (_ : \\\\Pi (a : A2) -> Dec (P1 a)) (_ : Array A2) : Array A2 \\n  | {A}, {P}, D, nil => nil\\n  | {A}, {P}, D, :: {n} a l => \\\\case D a \\\\with {\\n    | yes p => remove {A} {P} D l\\n    | no n => a :: remove {A} {P} D l\\n  }', \"\\\\lemma ~_++ \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} {l l' r r' : Array (\\\\Sigma V.E B.E)} (_ : l ~ l') (_ : r ~ r') :\\n  l ++ r ~ l' ++ r' \", '| bottom : E', '\\\\lemma ~-+s-left \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l : PFunc {V} {B}} (_ : IsReduced {V} {B} l) {x : \\\\Sigma V.E B.E}\\n  (_ : \\\\Pi (i : Fin l.len) -> (l.at i).1 = x.1)\\n  (_ : BigJoin {B} (map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) l) = x.2) : l ~ x :: nil ', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\lemma BigJoin-univ \\\\hlevels  {this : BottomJoinSemilattice} {l : Array E} {x : E} (_ : \\\\Pi (j : Fin l.len) -> l.at j <= x) : BigJoin l <= x ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'byLeft A', \"\\\\lemma SFRefines_~ \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l l' : PFunc {V} {B}} (_ : IsReduced {V} {B} l) (_ : IsReduced {V} {B} l')\\n  (_ : SFRefines {V} {B} l l') : l ~ l' \", '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\lemma reduced-tail \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {x : \\\\Sigma V.E B.E} {l : PFunc {V} {B}} (_ : IsReduced {V} {B} (x :: l)) :\\n  IsReduced {V} {B} l ', '\\\\func fpredP \\\\plevels  \\\\hlevels  {n1 : Nat} (j1 : Fin (suc n1)) (_ : j1 /= 0) : Fin n1 \\n  | {n}, zero, j/=0 => absurd {Fin n} (j/=0 (idp {Fin (suc n)} {0}))\\n  | {n}, suc j, j/=0 => j', '\\\\lemma satisfies {A : \\\\Type} {P : A -> \\\\Prop} (D : \\\\Pi (a : A) -> Dec (P a)) {l : Array A} {i : Fin (len {keep {A} {P} D l})} :\\n  P (at {keep {A} {P} D l} i) ', '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'byRight B', '| zro : E', '\\\\lemma fsuc_fpredP \\\\plevels  \\\\hlevels  {n : Nat} {x : Fin (suc n)} (p : x /= 0) : fsuc {n} (fpredP {n} x p) = x ', \"~-sym (l' ~ l)\", '\\\\lemma BigJoin-ldistr \\\\hlevels  {this : BottomDistributiveLattice} {l : Array E} {x : E} :\\n  x \u2227 BigJoin l = BigJoin (\\\\new Array E l.len (\\\\lam (j : Fin l.len) => x \u2227 l.at j)) ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| bottom-univ {x : E} : bottom <= x']<<<break>>>map {Fin l.len} {\\Sigma V.E B.E} l.at\n  (keep {Fin l.len} {\\lam (a : Fin l.len) => (f a).1 = 0} D (\\new Array (Fin l.len) l.len (\\lam (i : Fin l.len) => i))) ++ map {Fin l.len} {\\Sigma V.E B.E} l.at (remove {Fin l.len} {\\lam (a : Fin l.len) => (f a).1 = 0} D indices) ~ ((((a :: l') !! 0).1, a.2) :: nil) ++ l'", "completion": "~_++ (\\case r.1 0 \\with {\n  | byLeft a=0 =>\n    ~-trans (~-zros-left (\\lam i => later $ (f _).2 *> rewrite (satisfies D) a=0)) $ ~-sym $ ~-zro-left $ pmap (\\lam x => (x, a.2) :: nil) a=0\n  | byRight p => ~-+s-left {V} {B} (\\lam i/=j => lr (\\lam q => i/=j $ later $ no-repeats (\\lam p => later p) q))\n    (\\lam i => (f _).2 *> rewrite (satisfies D) idp) $ <=-antisymmetric (BigJoin-univ {B} (\\lam j => (f _).3 <=\u2218 rewrite (satisfies D) <=-refl)) $ meet-univ <=-refl p <=\u2218 =_<= (BigJoin-ldistr {B}) <=\u2218 BigJoin-univ {B} (\\lam i => later (\\case D i \\with {\n    | yes e => \n      \\have (k, ki) => element {_} {_} {D} {indices} e\n      \\in meet-right <=\u2218 later (rewrite ki <=-refl) <=\u2218 BigJoin-cond {B} {map (\\lam j => (l j).2) _} k\n    | no q => meet-monotone {B} <=-refl (f i).3 <=\u2218 =_<= (l'r {0} $ /=-sym q) <=\u2218 bottom-univ\n  }))\n})\n  (SFRefines_~ {V} {B} (\\lam i/=j => lr (\\lam q => i/=j $ later $ no-repeats (\\lam p => later p) q)) (reduced-tail {V} {B} l'r)\n    (\\lam j => (\\case r.1 (suc j) \\with {\n      | byLeft p => byLeft p\n      | byRight p => byRight $ meet-univ <=-refl p <=\u2218 =_<= (BigJoin-ldistr {B}) <=\u2218 BigJoin-univ {B} (\\lam i => later (\\case D i \\with {\n        | yes e => meet-monotone {B} <=-refl (f i).3 <=\u2218 =_<= (later $ rewrite e $ l'r fsuc/=0) <=\u2218 bottom-univ\n        | no q => \n          \\have (k, ki) => element {_} {_} {D} {indices} q\n          \\in later (rewrite ki meet-right) <=\u2218 BigJoin-cond {B} {map (\\lam j => (l j).2) _} k\n      }))\n    }),\n      \\lam i' => later (\n        \\let | (i, i'=i) => preimage i'\n             | fi/=0 : (f i).1 /= 0 => rewriteI i'=i (no-element D)\n        \\in inP (fpredP (f i).1 fi/=0, (f _).2 *> later (rewrite {1} (i'=i, inv $ fsuc_fpredP fi/=0) idp),\n              rewrite i'=i $ (f i).3 <=\u2218 later (rewriteI {1} (fsuc_fpredP fi/=0) <=-refl)))))"}
{"prompt": "['a1 : Fin (len {vars})', 'l1 : List (Fin (len {vars}))', 'this : CMonoidData']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', '| M : Monoid', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '\\\\lemma cons \\\\hlevels  {this : MonoidData} (x : Fin (len {vars})) (l : List (Fin (len {vars}))) :\\n  interpretNF (x :: l) = at {vars} x * interpretNF l ', '| E : \\\\Set', '\\\\func interpretNF \\\\hlevels  {this3 : MonoidData} (_ : List (Fin (len {vars}))) : E {M} \\n  | {this}, nil => ide {M}\\n  | {this}, x :: nil => at {vars} x\\n  | {this}, x :: l => at {vars} x * interpretNF l', '| vars : Array (E {M})', '\\\\infixr 5 :: A (List A)']<<<break>>>interpretNF (a1 :: l1) = at {vars} a1 * interpretNF l1", "completion": "cons {this} _ _"}
{"prompt": "['x : E', 'this : CGroup']<<<break>>>['| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', '| E : \\\\Set', '| inverse E : E']<<<break>>>x * inverse x = inverse x * x", "completion": "*-comm {this}"}
{"prompt": "['P : \\\\Prop', 'p0 : func {map {j}} x <= pHat {locale {j}} P', 'x : E {j.L}', 'j : Nucleus']<<<break>>>['\\\\func pHat \\\\hlevels  {this : Locale} (P : \\\\Prop) : E => Join {P} (\\\\lam (_ : P) => top)', '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop', '| L : Locale', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| nucleus-unit {x : E {L}} : x <= nucleus x']<<<break>>>x <= j.nucleus (pHat {j.L} P)", "completion": "nucleus-unit <=\u2218 p0"}
{"prompt": "['this : Theory', 't2 : Term (\\\\lam (_ : Sort) => Empty) s', 'p : isTheorem {\\\\lam (_ : Sort) => Empty} nil (equality {\\\\lam (_ : Sort) => Empty} {s} t1 t2)', 't : Term (\\\\lam (_ : Sort) => Empty) s', 's : Sort', 't1 : Term (\\\\lam (_ : Sort) => Empty) s']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\lemma transitivity {this : Theory} {V : Sort -> \\\\Set} {phi : Array (Formula V)} {s : Sort} {t1 t2 t3 : Term V s}\\n  (_ : isTheorem {V} phi (equality {V} {s} t1 t2)) (_ : isTheorem {V} phi (equality {V} {s} t2 t3)) :\\n  isTheorem {V} phi (equality {V} {s} t1 t3) ', 'equality {s : S.Sort} (Term {S} V s) (Term {S} V s)', '| Sort : \\\\Set', '\\\\data Formula \\\\hlevels  {S : Signature} (S.Sort -> \\\\Set) \\n  | equality {s : S.Sort} (Term {S} V s) (Term {S} V s)\\n  | predicate (P : S.PredSymb) (DArray {len {S.predDomain P}} (\\\\lam (j : Fin (len {S.predDomain P})) => Term {S} V (at {S.predDomain P} j)))', \"\\\\data isTheorem {this : Theory} {V : Sort -> \\\\Set} (Array (Formula V)) (Formula V) : \\\\Prop \\\\with\\n  | {this}, {V}, phi, equality {s} a b => refl (a = b)\\n  | {this}, {V}, phi, psi => assumption (j : Fin phi.len) (psi = phi.at j)\\n  | {this}, {V}, phi, psi =>\\n    substPres (U : Sort -> \\\\Set) (chi : Formula U) (rho rho' : \\\\Pi {s : Sort} -> U s -> Term V s) (\\\\Pi {s : Sort} -> \\\\Pi (u : U s) -> isTheorem {V} phi (equality {V} {s} (rho {s} u) (rho' {s} u))) (isTheorem {V} phi (substF {U} {V} chi rho)) (psi = substF {U} {V} chi rho')\\n  | {this}, {V}, phi, psi =>\\n    axiom (a : Sequent) (axioms a) (rho : \\\\Pi {s : Sort} -> a.1 s -> Term V s) (\\\\Pi (j : Fin (len {a.3})) -> isTheorem {V} phi (substF {a.1} {V} (a.3 !! j) rho)) (psi = substF {a.1} {V} a.4 rho)\"]<<<break>>>isTheorem {\\lam (_ : Sort) => Empty} nil (equality {\\lam (_ : Sort) => Empty} {s} t t1) ->\n  isTheorem {\\lam (_ : Sort) => Empty} nil (equality {\\lam (_ : Sort) => Empty} {s} t t2)", "completion": "\\lam p0 => transitivity {this} p0 p"}
{"prompt": "['n : Nat', 'i : Fin n', 'f : Fin n -> A.E', 'j : Fin n', 'A : DecSet', 'p : \\\\Sigma (i /= j) (f i = f j)']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', 'yes E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'inP A', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Dec (TruncP (\\Sigma (j : Fin n) (i /= j) (f i = f j)))", "completion": "yes (inP (j, p.1, p.2))"}
{"prompt": "['g : RingHom K E', 'S : CRing', 'K : DiscreteField', 'E : CRing', 'h : RingHom E S']<<<break>>>['| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func \\\\infixl 8 compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {R S T : Ring} (g : RingHom S T) (f : RingHom R S) : RingHom R T {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ']<<<break>>>RingHom K S {\n  | func => \\lam (x : E {Dom {\\this}}) => func {h} (g.func x)\n}", "completion": "h \u2218 g"}
{"prompt": "['s : contains {\\\\this} x', 'x : E {S {\\\\this}}', 'V : SubLModule R M']<<<break>>>['| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)', '| negative E : E', '| S : BaseSet', '| contains (E {S}) : \\\\Prop']<<<break>>>V.contains (negative {V.S} x)", "completion": "contains_negative s.2"}
{"prompt": "['this : PrecoverSpace']<<<break>>>['| cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D', '| cauchy-open {S : Set E} : isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| isOpen (Set E) : \\\\Prop', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>\\Pi {U V : Set E} -> isOpen U -> isOpen V -> isOpen (U \u2227 V)", "completion": "\\lam Uo Vo => (cauchy-open {this}).2 $ later (\\lam {x} p0 => (\n  \\let (Ux, Vx) => p0\n  \\in cauchy-refine {this} (cauchy-glue {this} ((cauchy-open {this}).1 Uo Ux) (\\lam _ => (cauchy-open {this}).1 Vo Vx))\n        (\\lam p0 => (\\case \\elim p0 \\with {\n          | inP (U', V', Uc, Vc, W=U'V') => inP (U' \u2227 V', \\lam p0 {y} p1 => (\n            \\let | (U'x, V'x) => p0\n                 | (U'y, V'y) => p1\n            \\in (Uc U'x U'y, Vc V'x V'y)), =_<= W=U'V')\n        }))))"}
{"prompt": "['Y : RegularPreuniformSpace', 'X : RegularPreuniformSpace', 'D : Set (Set X.E)']<<<break>>>['| <=-refl {x : E} : x <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func \\\\infix 4 <=* \\\\hlevels  {X : PreuniformSpace} (V U : Set X.E) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (star {X.E} V C \u2286 U))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {V : Set X.E} ->\nTruncP (\\Sigma (U : Set X.E) (D U) (V <=* U)) -> (\\lam (V : Set X.E) => TruncP (\\Sigma (U : Set (\\Sigma X.E Y.E))\n  (TruncP (\\Sigma (V' : Set X.E) (U = (\\lam (s : \\Sigma X.E Y.E) => s.1) ^-1 V') (U : Set X.E) (D U) (V' <=* U)))\n  ((\\lam (p0 : \\Sigma X.E Y.E) => p0.1) ^-1 V \u2286 U))) V", "completion": "\\lam {V} p0 => (\\case \\elim p0 \\with {\n  | inP (U, DU, V<=*U) => inP $ later (_, inP (V, idp, U, DU, V<=*U), <=-refl)\n})"}
{"prompt": "['p : Prime {NatSemiring} (suc n)', 'n : Nat']<<<break>>>['\\\\lemma ide-isInv \\\\hlevels  {M : Monoid} : Inv {M} M.ide ', 'suc Nat', '\\\\lemma nonZero>0 \\\\plevels  \\\\hlevels  {n : Nat} (_ : n /= 0) : 0 < n ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", 'suc<suc (n < m)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '| notInv : Not (Inv {M} e)']<<<break>>>1 < suc n", "completion": "suc<suc (nonZero>0 (\\lam n=0 => notInv {p} (transportInv (\\lam x => Inv (suc x)) n=0 ide-isInv)))"}
{"prompt": "['y : E {\\\\this}', 'x : E {\\\\this}', 'this : DiscreteField', 'q : Not (y = zro)']<<<break>>>['| zro : E', '\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', 'no (Not E)', '| finv E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| zro-right {x : E} : x + zro = x', '| E : \\\\Set']<<<break>>>y * (\\case no {y = zro} q \\with {\n  | yes p => (zro, x)\n  | no n => (finv y * x, zro)\n}).1 + zro = y * (\\case no {y = zro} q \\with {\n| yes p => (zro, x)\n| no n => (finv y * x, zro)\n}).1", "completion": "zro-right {this}"}
{"prompt": "['this : QPseudoAlgebra', 'this : PseudoAlgebra RatField E {\\n  | zro => zro\\n  | + => (+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => negative\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c => (*q)\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | * => (*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | *c-comm-right => {?hidden}\\n}']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\lemma *q-comm-right \\\\hlevels  {this : QPseudoAlgebra} {r : Rat} {a b : E} : r *q (a * b) = a * (r *q b) ', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| E : \\\\Set', '| R : Ring']<<<break>>>\\Pi {r : E {R {\\this}}} -> \\Pi {a : E {\\this}} -> \\Pi {b : E {\\this}} -> r *q (a * b) = a * (r *q b)", "completion": "\\lam {r} {a} {b} => *q-comm-right {this}"}
{"prompt": "['N : \\\\hType', 'Y-conn : isConnectedType {nullTypeUniverse N} Y', 'X-local : isLocal X', 'Y : \\\\hType', 'M : \\\\hType', 'X : \\\\hType']<<<break>>>['| A : \\\\Type', '\\\\data PushoutData {A B C : \\\\Type} (A -> B) (A -> C) \\n  | pinl B\\n  | pinr C\\n  | pglue A I', '\\\\func nullTypeUniverse (M : \\\\Type) : Modality {\\n  | isLocal => \\\\lam (Z : \\\\hType) => \\\\Sigma -> Equiv {\\\\Sigma -> Z} {M -> Z} (\\\\lam (_x : A {\\\\this}) => _x o (\\\\lam (_ : M) => ()))\\n  | localization => \\\\lam (A1 : \\\\hType) => \\\\new Localization {famUniverse {\\\\new Family {\\n    | J => \\\\Sigma\\n    | X => \\\\lam (_ : \\\\Sigma) => M\\n    | Y => \\\\lam (_ : J {\\\\this}) => \\\\Sigma\\n    | F => \\\\lam (j : J {\\\\this}) (_ : X {\\\\this} j) => ()\\n  }}} A1 (\\\\new Local {U {\\\\this}} (LData {famHat {\\\\new Family {\\n    | J => \\\\Sigma\\n    | X => \\\\lam (_ : \\\\Sigma) => M\\n    | Y => \\\\lam (_ : J {\\\\this}) => \\\\Sigma\\n    | F => \\\\lam (j : J {\\\\this}) (_ : X {\\\\this} j) => ()\\n  }}} A1) {\\n    | local => {?hidden}\\n  }) {\\n    | inL => alpha {famHat {\\\\new Family {\\n      | J => \\\\Sigma\\n      | X => \\\\lam (_ : \\\\Sigma) => M\\n      | Y => \\\\lam (_ : J {\\\\this}) => \\\\Sigma\\n      | F => \\\\lam (j : J {\\\\this}) (_ : X {\\\\this} j) => ()\\n    }}} {A1}\\n    | local-univ => {?hidden}\\n  }\\n} => nullFamUniverse {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => M)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma connected_local_join-left \\\\hlevels  (X Y M N : \\\\hType) (_ : isConnectedType {nullTypeUniverse M} X) (_ : isLocal Y) : isLocal Y ', '\\\\func Equiv-to-= {A B : \\\\Type} (e : Equiv {A} {B}) : A = B => QEquiv-to-= {A} {B} (fromEquiv e)', '| isLocal \\\\hType : \\\\Prop', '\\\\func Join-sym (A B : \\\\Type) : QEquiv {Join A B} {Join B A} (flip {A} {B}) {\\n  | ret => flip {B} {A}\\n  | ret_f => flip-flip {A} {B}\\n  | f_sec => flip-flip {B} {A}\\n} => \\\\new QEquiv', '\\\\class Equiv \\\\extends Section, Retraction', '\\\\func \\\\infixr 8 o {A B C : \\\\Type} (g : B -> C) (f : A -> B) : \\\\Pi (x : A) -> C => \\\\lam (x : A) => g (f x)']<<<break>>>\\Sigma -> Equiv {\\Sigma -> X} {PushoutData {\\Sigma M Y} {M} {Y} (\\lam (p0 : \\Sigma M Y) => p0.1) (\\lam (p0 : \\Sigma M Y) => p0.2) -> X}\n  (\\lam (_x : A {\\this}) =>\n    _x o (\\lam (_ : PushoutData {\\Sigma M Y} {M} {Y} (\\lam (p0 : \\Sigma M Y) => p0.1) (\\lam (p0 : \\Sigma M Y) => p0.2)) => ()))", "completion": "rewriteI (Equiv-to-= (Join-sym Y M)) (connected_local_join-left Y X N M Y-conn (rewriteI (Equiv-to-= (Join-sym M N)) X-local))"}
{"prompt": "['this : Locale', 'this : Nucleus ((\u2228) a) {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}', 'a : E']<<<break>>>['| <=-refl {x : E} : x <= x', '| join-univ {x y z : E} (x <= z) (y <= z) : x \u2228 y <= z', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| L : Locale', '| join-left {x y : E} : x <= x \u2228 y']<<<break>>>\\Pi {x : E {L {\\this}}} -> a \u2228 (a \u2228 x) <= a \u2228 x", "completion": "\\lam {x} => join-univ {this} (join-left {this}) (<=-refl {this})"}
{"prompt": "['b : B', 'A : \\\\Prop', 'B : \\\\Prop']<<<break>>>['\\\\func Join (A B : \\\\Type) : \\\\hType \\n  => PushoutData {\\\\Sigma A B} {A} {B} (\\\\lam (p0 : \\\\Sigma A B) => p0.1) (\\\\lam (p0 : \\\\Sigma A B) => p0.2)', '\\\\lemma isProp=>isContr {A : \\\\Type} (_ : isProp A) (_ : A) : Contr A ', '\\\\lemma prop-isProp \\\\plevels  \\\\hlevels  {A : \\\\Prop} : isProp A ', '| A : \\\\Type', \"\\\\class Contr {\\n  | A : \\\\Type\\n  | center : A\\n  | contraction (a' : A) : center = a'\\n}\", '\\\\lemma Join_Contr (A1 : \\\\Type) (B : Contr) : Contr (Join A1 B.A) ']<<<break>>>Contr (Join A1 A)", "completion": "Join_Contr A (isProp=>isContr prop-isProp b)"}
{"prompt": "['r : E {R {\\\\this}}', 'f : LinearMap {R} A B', 'this : LinearMap {R1} A (ImageLModule {R1} {A} {B} f) {\\n  | func => \\\\lam (a : E {Dom {ImageAddPointedLeftHom f}}) =>\\n    (f.func a, inP {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', 'x : E {Dom {\\\\this}}']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| \\\\infixl 7 *c (E {R}) E : E', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '| Dom : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (a : E {f.Dom}) (f.func a = (r *c func {\\this} x).1))", "completion": "(r *c (f.func x, inP {\\Sigma (a : E {f.Dom}) (f.func a = f.func x)} (x, idp {E {f.Cod}} {f.func x}))).2"}
{"prompt": "['L : UniformLocale', 'a : L.E', 'j : \\\\Sigma (x : L.E) ((embed {CompletionPres L} a).1 x)']<<<break>>>['\\\\func presentation {L : UniformLocale} : FramePresHom (CompletionPres L) (F L) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new FramePresHom {\\n  | func-conj => {?hidden}\\n  | func-basicCover => {?hidden}\\n  | func-image => {?hidden}\\n}', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', '\\\\lemma map \\\\hlevels  {F : FramePresPrehom} {x : E {F.Dom}} {J : \\\\Set} {g : J -> E {F.Dom}} (_ : Cover {F.Dom} x {J} g) :\\n  Cover {F.Cod} (F.func x) {J} (\\\\lam (j : J) => F.func (g j)) ', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}']<<<break>>>Cover {Cod {presentation {L}}} (func {presentation {L}} j.1) {\\Sigma} (\\lam (_ : \\Sigma) => func {presentation {L}} a)", "completion": "map {presentation} j.2"}
{"prompt": "['this : AddMonoidHom R R {\\n  | func => (R.*) a.1\\n  | func-zro => {?hidden}\\n  | func-+ => {?hidden}\\n}', 'a : \\\\Sigma R.E M.E', 'R : Semiring']<<<break>>>['| ldistr {x y z : E} : x * (y + z) = x * y + x * z', '| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '| E : \\\\Set', '| Dom : BaseSet']<<<break>>>\\Pi {x : E {Dom {\\this}}} -> \\Pi {y : E {Dom {\\this}}} -> a.1 * (x + y) = a.1 * x + a.1 * y", "completion": "\\lam {x} {y} => ldistr"}
{"prompt": "['b : ExUpperReal', 'a : Rat']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| finv E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| E : \\\\Set', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| *-assoc {x y z : E} : x * y * z = x * (y * z)']<<<break>>>fromRat a * fromRat (finv a) * b = fromRat a * (fromRat (finv a) * b)", "completion": "*-assoc {ExUpperRealSemigroup}"}
{"prompt": "['this : Cone {J} {Cone.D} G z {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => limMap {lim1 j} {z} (cone1 j)\\n  | coneCoh => {?hidden}\\n}', 'cone : \\\\Pi (j : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) ->\\nCone {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D} (G {lim1 j}) z {\\n  | coneMap => \\\\lam (k : Ob {J {\\\\this}}) =>\\n  extend-proj {P} {D} {F} k.1.1 D.\u2218 c.coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n    lem j (k.1, k.2))\\n  | coneCoh => {?hidden}\\n}', 'z : Ob {D {\\\\this}}', 'P : FramePres', 'lim : \\\\Pi (j : \\\\Sigma (x : P.E) (embed {P} x <= U)) ->\\nLimit {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D}\\n  (Comp {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n      (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}}\\n    {Precat.op {framePresSite P}} {D} F.F\\n    (Functor.op {diagram {genSieve {P} j.1 {\\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)} (\\\\lam (p0 : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) => p0.2)}}))\\n  (Functor.F {F.F} apex) {\\n  | coneMap => \\\\lam (j1 : Ob {J}) => Func {F.F} {apex} {Functor.F j1} (coneMap j1)\\n}', 'J : \\\\Set', 'c : B {\\\\this}', 'F : VSheaf D (framePresSite P)', 'g : J -> Ob', 's : Sieve {C {\\\\this}} U', 'U : Ob {C {\\\\this}}', 'lem : \\\\Pi (j : \\\\Sigma (x : P.E) (embed {P} x <= U)) -> \\\\Pi (k : \\\\Sigma (y : \\\\Sigma (y : P.E) (Cover1 {P} y j.1))\\n  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) ->\\ns.S {embed {P} k.1.1} (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))', 'D : CompleteCat']<<<break>>>['\\\\func framePresPreorder \\\\hlevels  (P : FramePres) : Preorder P.E {\\n  | <= => Cover1 {P}\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func limFunctor \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\\nFunctor (Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})\\n  D (\\\\lam (X : Ob {C {\\\\this}}) => Functor.F {F.F} (Functor.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => Func {F.F} {Functor.F X} {Functor.F Y} (Func {X} {Y} f)\\n} => Comp {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  {Precat.op {framePresSite P}} {D} F.F\\n  (Functor.op {embedding {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cover1 \\\\hlevels  {P : FramePres} (x y : P.E) : \\\\Prop => Cover {P} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => y)', '| limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', '\\\\type ObOver \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : \\\\hType => \\\\Sigma (y : C.Ob) (C.Hom y x)', '| D : Precat', '\\\\func coe (A : I -> \\\\Type) (a : A left) (i : I) : A i ', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', \"\\\\lemma prop-pi \\\\plevels  \\\\hlevels  {A : \\\\Prop} {a a' : A} : a = a' \", '| J : Precat', \"\\\\func framePresSite \\\\hlevels  (P : FramePres) : SiteWithBasis P.E {\\n  | Hom => Cover1 {P}\\n  | id => <=-refl\\n  | o => \\\\lam {X Y Z : Ob} (f : Hom Y Z) (g : Hom X Y) => g <=\u2218 f\\n  | pullback => \\\\lam {x1 y1 z1 : P.E} (f1 : Cover1 {P} x1 z1) (g1 : Cover1 {P} y1 z1) => \\\\new Pullback {x1} {y1} {z1} f1 g1 (P.conj x1 y1) {\\n    | pbProj1 => cover-proj1 {P} {apex {\\\\this}} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x {\\\\this}} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {x1})\\n    | pbProj2 => cover-proj2 {P} {P.conj x1 y1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => y1} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {y1})\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {D {\\\\this}}} (p1 : Hom {D {\\\\this}} w (x {\\\\this})) (p2 : Hom {D {\\\\this}} w (y {\\\\this}))\\n      (_ : f {\\\\this} \u2218 p1 = g {\\\\this} \u2218 p2) => cover-prod {P} {w} {x1} {y1} p1 p2\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | isBasicCover => \\\\lam (x : Ob {\\\\this}) {J : \\\\Set} (g : J -> Ob) =>\\n  TruncP (\\\\Sigma (y : P.E) (Cover1 {P} x y) (g' : J -> P.E) (P.BasicCover {J} y g')\\n    (\\\\Pi (j : J) -> \\\\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (g j).1)))\\n} => \\\\new SiteWithBasis {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | basicCover-stable => {?hidden}\\n}\", '\\\\func extend-proj \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (y : P.E) :\\n  D.Hom (Functor.F (embed {P} y)) (Functor.F {F.F} y) \\n=> coneMap {D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= embed {P} y)}\\n  (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= embed {P} y)) => t.1)}} (limFunctor {P} {D} {F} (embed {P} y))}\\n  (y, \\\\lam {x : P.E} (d : (embed {P} y).1 x) => d)', '\\\\func lim \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\\nLimit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  {D} (limFunctor {P} {D} {F} b) \\n=> D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  (limFunctor {P} {D} {F} b)', '| C : Precat', '| E : \\\\Set', '| S {y : Ob {C}} (Hom {C} y x) : \\\\Prop', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', \"\\\\func pathOver {A : I -> \\\\Type} {a : A left} {a' : A right} (p : coe A a right = a') : Path A a a' \\n  => concat {A} {a} {coe A a right} {a'} (idpOver A a) p\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '\\\\lemma genSieve \\\\hlevels  {P : FramePres} (a : P.E) {J : \\\\Set} (g : J -> P.E) : Sieve {framePresPreorder P} a\\n  (\\\\lam {b : Ob {C {\\\\this}}} (_ : Hom {C {\\\\this}} b (x {\\\\this})) => TruncP (\\\\Sigma (j : J) (Cover1 {P} b (g j)))) ', '| limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'right', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '\\\\func embedding \\\\plevels obj >= hom \\\\hlevels  {C1 : Precat} {X : \\\\hType} (f : X -> C.Ob) : FullyFaithfulFunctor (subPrecat {C1} {X} f) C1 f {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (h : Hom {C {\\\\this}} X Y) => h\\n} => \\\\new FullyFaithfulFunctor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n}', '\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| apex : Ob {D}', '| D : Precat', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func cone \\\\plevels obj >= hom \\\\hlevels  {this2 : Presieve} :\\nCone {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)} (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)) => p.1)}}\\n  {Precat.op {C}} (Functor.op {diagram}) x {\\n  | coneMap => \\\\lam (p0 : Ob {J {\\\\this}}) => p0.1.2\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x']<<<break>>>\\Pi {j : Ob {J {\\this}}} ->\n  \\Pi {j' : Ob {J {\\this}}} -> \\Pi (h : Hom {J {\\this}} j j') -> Func {j} {j'} h D.\u2218 coneMap {\\this} j = coneMap {\\this} j'", "completion": "\\lam {j} {j'} h => limUnique {lim j'}\n  (\\lam k => inv o-assoc *> pmap (\\lam _x => _x \u2218 _) (inv Func-o) *> limBeta {lim j} (cone j) ((k.1.1, k.1.2 <=\u2218 {framePresPreorder P} h), k.2) *> path (\\lam i => extend-proj k.1.1 \u2218 coneMap {c} ((embed k.1.1, prop-pi i), pathOver prop-pi i)) *> inv (limBeta {lim j'} (cone j') k))"}
{"prompt": "['Cc : X.isCauchy C', 'fc : IsConvergent {I} {X} f', 'C : Set (Set X.E)', 'I : DirectedSet', 'X : CoverSpace']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Cod : BaseSet', '\\\\func regPrecoverSpace \\\\hlevels  {X : PrecoverSpace} : PrecoverMap X (RegPrecoverSpace X) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new PrecoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\func precover \\\\hlevels  {I : DirectedSet} : PrecoverSpace I.E {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n  \\\\Sigma (TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (N : I.E) (\\\\Pi {n : I.E} -> N I.<= n -> U n)))\\n    (\\\\Pi (n : I.E) -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (C V) (V n)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '| Dom : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>isCauchy {Dom {regPrecoverSpace {precover {I}}}} (\\lam (U : Set (E {Dom {regPrecoverSpace {precover {I}}}})) =>\n  TruncP (\\Sigma (V : Set (E {Cod {regPrecoverSpace {precover {I}}}})) (TruncP (\\Sigma (V1 : Set X.E) (C V1) (V = fc.func ^-1 V1)))\n    (U = func {regPrecoverSpace {precover {I}}} ^-1 V)))", "completion": "func-cover {regPrecoverSpace} (func-cover {fc} Cc)"}
{"prompt": "['n : Nat', 'n : Nat', 'l : Array (Sym n) n1', 'p : \\\\Pi (j : Fin (suc l.len)) -> f {(e :: l) !! j} i = i', 'e : Sym n', 'i : Fin n']<<<break>>>['| len : Nat', '\\\\type Sym \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => Equiv {Fin n} {Fin n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '| f A : B', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ']<<<break>>>\\Pi (j : Fin l.len) -> f {(e :: l) !! suc j} i = i", "completion": "\\lam j => p (suc j)"}
{"prompt": "['Vy : V y', 'Ux : U x', 'X : ExPseudoMetricSpace', 'y : F.X', 'r : Rat', 'h : \\\\Pi {x : F.X} -> U1 x -> \\\\Pi {y : F.X} -> V y -> U {X.dist x y} r', 'x : F.X']<<<break>>>['| U Rat : \\\\Prop', '| dist E E : ExUpperReal']<<<break>>>U {X.dist x y} r", "completion": "h Ux Vy"}
{"prompt": "['i : I', 'this : PreuniformLocale (E {t.2 @ i}) {\\n  | <= => (<=) {t.2 @ i}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet => (\u2227) {t.2 @ i}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top => top {t.2 @ i}\\n  | top-univ => {?hidden}\\n  | Join => Join {t.2 @ i}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n  | uniform-overt => {?hidden}\\n  | isUniform => isUniform {t.2 @ i}\\n  | isCovering => {?hidden}\\n  | isDownset => {?hidden}\\n  | top-uniform => {?hidden}\\n  | meet-uniform => {?hidden}\\n  | <=-uniform => {?hidden}\\n  | star-uniform => {?hidden}\\n}', 't : \\\\Sigma (p : E {e.dom} = E {e.cod}) (Path (\\\\lam (i : I) => PreuniformLocale (p @ i)) (\\\\new e.dom {}) (\\\\new e.cod {}))\\n  (\\\\Pi (x : E {e.dom}) -> transport {\\\\Type} (\\\\lam (Z : \\\\Type) => Z) {E {e.dom}} {E {e.cod}} p x = func {e.f} x)']<<<break>>>['| isUniform (E -> \\\\Prop) : \\\\Prop', '| <=-uniform {U V : E -> \\\\Prop} (isUniform U) (\\\\Pi {x : E} -> U x -> V x) (\\\\Pi {x y : E} -> V y -> x <= y -> V x) : isUniform V', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set']<<<break>>>\\Pi {U : E {\\this} -> \\Prop} -> \\Pi {V : E {\\this} -> \\Prop} -> isUniform {t.2 @ i} U ->\n  (\\Pi {x : E {t.2 @ i}} -> U x -> V x) -> (\\Pi {x y : E {t.2 @ i}} -> V y -> x <= y -> V x) -> isUniform {t.2 @ i} V", "completion": "\\lam {U} {V} => <=-uniform {t.2 @ i}"}
{"prompt": "['h : A {\\\\this}', 'z : Ob {D {\\\\this}}', 'P : FramePres', 'lim : \\\\Pi (j : \\\\Sigma (x : P.E) (embed {P} x <= U)) ->\\nLimit {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D}\\n  (Comp {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n      (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}}\\n    {Precat.op {framePresSite P}} {D} F.F\\n    (Functor.op {diagram {genSieve {P} j.1 {\\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)} (\\\\lam (p0 : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) => p0.2)}}))\\n  (Functor.F {F.F} apex) {\\n  | coneMap => \\\\lam (j1 : Ob {J}) => Func {F.F} {apex} {Functor.F j1} (coneMap j1)\\n}', 'J : \\\\Set', 'F : VSheaf D (framePresSite P)', 'this : Limit {Precat.op {subPrecat {SlicePrecat {PresentedFrame P} U} {\\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)) => p.1)}} {D}\\n  (Comp {Precat.op {subPrecat {SlicePrecat {PresentedFrame P} U} {\\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)) => p.1)}} {Precat.op {PresentedFrame P}} {D}\\n    (extend {P} {D} {F}) (Functor.op {diagram {s}})) (Functor.F apex) {\\n  | coneMap => \\\\lam (j : Ob {J}) => Func {apex} {Functor.F j} (coneMap j)\\n  | coneCoh => {?hidden}\\n  | isLimit => {?hidden}\\n  | limMap => limMap-impl\\n  | limBeta => {?hidden}\\n  | limUnique => {?hidden}\\n}', 'g : J -> Ob', 's : Sieve {C {\\\\this}} U', 'U : Ob {C {\\\\this}}', \"this : QEquiv {Hom {Cone.D {\\\\this}} z (apex {\\\\this})} {Cone {J {\\\\this}} {Cone.D {\\\\this}} (G {\\\\this}) z}\\n  (conePullback {J {\\\\this}} {Cone.D {\\\\this}} {G {\\\\this}} (\\\\new this14 {}) z) {\\n  | ret => \\\\lam (c : B {\\\\this}) => (\\n    \\\\have cone1 => \\\\lam (j : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) =>\\n          \\\\new Cone {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n            (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n            (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n              (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D} (G {lim1 j}) z {\\n            | coneMap => \\\\lam (k : Ob {J {\\\\this}}) =>\\n            extend-proj {P} {D} {F} k.1.1 D.\u2218 c.coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n              (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n              lem j (k.1, k.2))\\n            | coneCoh => {?hidden}\\n          }\\n    \\\\in limMap {z} (\\\\new Cone {J} {Cone.D} G z {\\n          | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => limMap {lim1 j} {z} (cone1 j)\\n          | coneCoh => {?hidden}\\n        }))\\n  | ret_f => \\\\lam (h : A {\\\\this}) =>\\n  limUnique {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n    (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} (limFunctor {P} {D} {F} U)} {z}\\n    {ret {\\\\this} (conePullback\\n      {Precat.op {subPrecat {SlicePrecat {PresentedFrame P} U} {\\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)}\\n        (\\\\lam (p : \\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)) => p.1)}} {D}\\n        {Comp {Precat.op {subPrecat {SlicePrecat {PresentedFrame P} U} {\\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)}\\n          (\\\\lam (p : \\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)) => p.1)}} {Precat.op {PresentedFrame P}} {D}\\n          (extend {P} {D} {F}) (Functor.op {diagram {s}})} (\\\\new this14 {}) z h)} {h}\\n    (\\\\lam (j : Ob {J {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n      (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} (limFunctor {P} {D} {F} U)}}) =>\\n    limBeta {z} (\\\\new Cone {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n      (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} {D} (limFunctor {P} {D} {F} U) z {\\n      | coneMap => \\\\lam (j : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => limMap {lim1 j} {z}\\n        (\\\\new Cone {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n          (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n          (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n            (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D}\\n          (Comp {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n            (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n            (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n              (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}}\\n            {Precat.op {framePresSite P}} {D} F.F\\n            (Functor.op {diagram {genSieve {P} j.1 {\\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)} (\\\\lam (p0 : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) => p0.2)}}))\\n          z {\\n          | coneMap => \\\\lam (k : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n            (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) =>\\n          extend-proj {P} {D} {F} k.1.1 D.\u2218 coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n            (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n            lem j (k.1, k.2))\\n          | coneCoh => {?hidden}\\n        })\\n      | coneCoh => {?hidden}\\n    }) j *> limUnique {lim1 j} {z} {limMap {lim1 j} {z}\\n      (\\\\new Cone {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n        (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n        (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n          (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D}\\n        (Comp {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n          (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n          (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n            (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}}\\n          {Precat.op {framePresSite P}} {D} F.F\\n          (Functor.op {diagram {genSieve {P} j.1 {\\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)} (\\\\lam (p0 : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) => p0.2)}}))\\n        z {\\n        | coneMap => \\\\lam (k : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n          (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) =>\\n        extend-proj {P} {D} {F} k.1.1 D.\u2218 coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n          lem j (k.1, k.2))\\n        | coneCoh => {?hidden}\\n      })}\\n      {coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n        (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} (limFunctor {P} {D} {F} U)} j D.\u2218 h}\\n      (\\\\lam (k : Ob {J {lim1 j}}) => limBeta {lim1 j} {z}\\n        (\\\\new Cone {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n          (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n          (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n            (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D}\\n          (Comp {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n            (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n            (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n              (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}}\\n            {Precat.op {framePresSite P}} {D} F.F\\n            (Functor.op {diagram {genSieve {P} j.1 {\\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)} (\\\\lam (p0 : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) => p0.2)}}))\\n          z {\\n          | coneMap => \\\\lam (k : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n            (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) =>\\n          extend-proj {P} {D} {F} k.1.1 D.\u2218 coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n            (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n            lem j (k.1, k.2))\\n          | coneCoh => {?hidden}\\n        }) k *> inv {D.Hom z (Functor.F {F.F} k.1.1)}\\n        {extend-proj {P} {D} {F} k.1.1 D.\u2218 coneMap {\\\\this} ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n          lem j (k.1, k.2)) D.\u2218 h}\\n        {extend-proj {P} {D} {F} k.1.1 D.\u2218 coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n          lem j (k.1, k.2))}\\n        (D.o-assoc {z} {apex} {apex} {Functor.F {F.F} k.1.1} {extend-proj {P} {D} {F} k.1.1}\\n          {coneMap {\\\\this} ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n            (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n            lem j (k.1, k.2))} {h}) *> pmap {D.Hom apex (Functor.F {F.F} k.1.1)} {D.Hom z (Functor.F {F.F} k.1.1)}\\n        (\\\\lam (_x : D.Hom apex (Functor.F {F.F} k.1.1)) => _x D.\u2218 h)\\n        {extend-proj {P} {D} {F} k.1.1 D.\u2218 Func {U} {embed {P} k.1.1} (coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n          lem j (k.1, k.2)))}\\n        {Func {j} {(k.1.1, \\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n          k.1.2 D.\u2218 coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n          (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} (limFunctor {P} {D} {F} U)} j}\\n        (extend-proj-nat'\\n        {P} {D} {F} {k.1.1} {U} (coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n          lem j (k.1, k.2))) *> inv {D.Hom apex (Functor.F {F.F} k.1.1)} {Func {j} {(k.1.1, \\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n          k.1.2 D.\u2218 coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n          (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} (limFunctor {P} {D} {F} U)} j}\\n          {coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n            (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} (limFunctor {P} {D} {F} U)}\\n            (k.1.1, coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n              (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n              lem j (k.1, k.2)))}\\n          (coneCoh {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n            (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} (limFunctor {P} {D} {F} U)} {j}\\n            {(k.1.1, \\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n              (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n            k.1.2)) *> D.o-assoc {z} {apex} {Functor.F {F.F} j.1} {Functor.F {F.F} k.1.1}\\n        {Func {j} {(k.1.1, \\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n          k.1.2}\\n        {coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n          (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} (limFunctor {P} {D} {F} U)} j} {h}))\\n  | f_sec => \\\\lam (c : B {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => \\\\lam (m : \\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)) =>\\n          limUnique {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)}\\n            (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)) => t.1)}} (limFunctor {P} {D} {F} m.1.1)} {z} {coneMap m}\\n            {c.coneMap m}\\n            (\\\\lam (j : Ob {J {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)}\\n              (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)) => t.1)}} (limFunctor {P} {D} {F} m.1.1)}}) =>\\n            inv {D.Hom z (Functor.F {F.F} j.1)}\\n              {coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)}\\n                (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)) => t.1)}} (limFunctor {P} {D} {F} m.1.1)} j D.\u2218 coneMap {\\\\this} m D.\u2218 sec {\\\\this} c}\\n              {coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)}\\n                (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)) => t.1)}} (limFunctor {P} {D} {F} m.1.1)} j D.\u2218 coneMap m}\\n              (D.o-assoc {z} {apex} {apex {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)}\\n                (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)) => t.1)}} (limFunctor {P} {D} {F} m.1.1)}}\\n                {Functor.F {F.F} j.1}\\n                {coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)}\\n                  (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)) => t.1)}} (limFunctor {P} {D} {F} m.1.1)} j}\\n                {coneMap {\\\\this} m} {sec {\\\\this} c}) *> pmap {D.Hom apex (Functor.F {F.F} j.1)} {D.Hom z (Functor.F {F.F} j.1)}\\n              (\\\\lam (_x : D.Hom apex (Functor.F {F.F} j.1)) => _x D.\u2218 sec {\\\\this} c)\\n              {coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)}\\n                (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)) => t.1)}} (limFunctor {P} {D} {F} m.1.1)} (j.1, j.2) D.\u2218 Func {U} {m.1.1} m.1.2}\\n              {coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n                (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} (limFunctor {P} {D} {F} U)} (j.1, j.2 <=\u2218 m.1.2)}\\n              (extend-proj-nat'' {P} {D} {F} {m.1.1} {U} m.1.2 {j.1} j.2) *> limBeta {z} (\\\\new Cone {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)}\\n              (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => t.1)}} {D} (limFunctor {P} {D} {F} U) z {\\n              | coneMap => \\\\lam (j : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= U)) => limMap {lim1 j} {z}\\n                (\\\\new Cone {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n                  (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D}\\n                  (Comp {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n                    (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                      (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}}\\n                    {Precat.op {framePresSite P}} {D} F.F\\n                    (Functor.op {diagram {genSieve {P} j.1 {\\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)} (\\\\lam (p0 : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) => p0.2)}}))\\n                  z {\\n                  | coneMap => \\\\lam (k : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) =>\\n                  extend-proj {P} {D} {F} k.1.1 D.\u2218 c.coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => j.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                    lem j (k.1, k.2))\\n                  | coneCoh => {?hidden}\\n                })\\n              | coneCoh => {?hidden}\\n            }) (j.1, j.2 <=\u2218 m.1.2) *> limUnique {lim1 (j.1, j.2 <=\u2218 m.1.2)} {z} {limMap {lim1 (j.1, j.2 <=\u2218 m.1.2)} {z}\\n              (\\\\new Cone {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n                (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D}\\n                (Comp {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n                  (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}}\\n                  {Precat.op {framePresSite P}} {D} F.F\\n                  (Functor.op {diagram {genSieve {P} j.1 {\\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)} (\\\\lam (p0 : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) => p0.2)}}))\\n                z {\\n                | coneMap => \\\\lam (k : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) =>\\n                extend-proj {P} {D} {F} k.1.1 D.\u2218 c.coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                  lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))\\n                | coneCoh => {?hidden}\\n              })}\\n              {coneMap {D.limit {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)}\\n                (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x Preorder.<= m.1.1)) => t.1)}} (limFunctor {P} {D} {F} m.1.1)} j D.\u2218 c.coneMap m}\\n              (\\\\lam (k : Ob {J {lim1 (j.1, j.2 <=\u2218 m.1.2)}}) => limBeta {lim1 (j.1, j.2 <=\u2218 m.1.2)} {z}\\n                (\\\\new Cone {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n                  (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}} {D}\\n                  (Comp {Precat.op {subPrecat {SlicePrecat {framePresPreorder P} j.1} {\\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))}\\n                    (\\\\lam (p : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                      (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) => p.1)}}\\n                    {Precat.op {framePresSite P}} {D} F.F\\n                    (Functor.op {diagram {genSieve {P} j.1 {\\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)} (\\\\lam (p0 : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) => p0.2)}}))\\n                  z {\\n                  | coneMap => \\\\lam (k : \\\\Sigma (y : ObOver {framePresPreorder P} j.1)\\n                    (TruncP (\\\\Sigma (j : \\\\Sigma (j : J1) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) =>\\n                  extend-proj {P} {D} {F} k.1.1 D.\u2218 c.coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                    lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))\\n                  | coneCoh => {?hidden}\\n                }) k *> pmap {D.Hom z apex} {D.Hom z (Functor.F {F.F} k.1.1)}\\n                ((D.\u2218) {z} {apex} {Functor.F {F.F} k.1.1} (extend-proj {P} {D} {F} k.1.1))\\n                {c.coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                  lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))}\\n                {Func {m} {((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                  lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))}\\n                  (\\\\lam {x : P.E} (d : (embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).1.1 x) => j.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)),\\n                    prop-pi {(embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                      (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).1 PresentedFrame.<= U}\\n                      {m.1.2 \u2218 (\\\\lam {x : P.E} (d : (embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).1.1 x) => j.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n                      {(embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).2}) D.\u2218 c.coneMap m}\\n                (inv {D.Hom z apex} {Func {m} {((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                  lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))}\\n                  (\\\\lam {x : P.E} (d : (embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).1.1 x) => j.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)),\\n                    prop-pi {(embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                      (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).1 PresentedFrame.<= U}\\n                      {m.1.2 \u2218 (\\\\lam {x : P.E} (d : (embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).1.1 x) => j.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n                      {(embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).2}) D.\u2218 c.coneMap m}\\n                  {c.coneMap ((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                    lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))}\\n                  (c.coneCoh {m} {((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                    lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))}\\n                    (\\\\lam {x : P.E} (d : (embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                      (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).1.1 x) => j.2 {x}\\n                      (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)),\\n                      prop-pi {(embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).1 PresentedFrame.<= U}\\n                        {m.1.2 \u2218 (\\\\lam {x : P.E} (d : (embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).1.1 x) => j.2 {x}\\n                          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n                        {(embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))).2}))) *> inv {D.Hom z (Functor.F {F.F} k.1.1)}\\n                {extend-proj {P} {D} {F} k.1.1 D.\u2218 Func {m} {((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                  lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))}\\n                  (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)),\\n                    prop-pi {embed {P} k.1.1 PresentedFrame.<= U} {m.1.2 \u2218 (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n                      (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n                      {\\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))}) D.\u2218 c.coneMap m}\\n                {extend-proj {P} {D} {F} k.1.1 D.\u2218 (Func {m} {((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                  lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))}\\n                  (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)),\\n                    prop-pi {embed {P} k.1.1 PresentedFrame.<= U} {m.1.2 \u2218 (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n                      (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n                      {\\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))}) D.\u2218 c.coneMap m)}\\n                (D.o-assoc {z} {apex} {apex} {Functor.F {F.F} k.1.1} {extend-proj {P} {D} {F} k.1.1}\\n                  {Func {m} {((embed {P} k.1.1, \\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                    (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))),\\n                    lem (j.1, j.2 <=\u2218 m.1.2) (k.1, k.2))}\\n                    (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n                      (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)),\\n                      prop-pi {embed {P} k.1.1 PresentedFrame.<= U} {m.1.2 \u2218 (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n                        (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n                        {\\\\lam {x : P.E} (z<=y : (embed {P} k.1.1).1 x) => (<=\u2218) j.2 m.1.2 {x}\\n                          (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} z<=y (\\\\lam (_ : \\\\Sigma) => k.1.2))})}\\n                  {c.coneMap m}) *> pmap {D.Hom apex (Functor.F {F.F} k.1.1)} {D.Hom z (Functor.F {F.F} k.1.1)}\\n                (\\\\lam (_x : D.Hom apex (Functor.F {F.F} k.1.1)) => _x D.\u2218 c.coneMap m)\\n                {coneMap (k.1.1, \\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => d) D.\u2218 Func {m.1.1} {embed {P} k.1.1} (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n                  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))}\\n                {Func {F.F} {j.1} {k.1.1} k.1.2 D.\u2218 coneMap j}\\n                (coneMap-nat {P} {D} {F} {embed {P} k.1.1} {m.1.1} (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n                  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))\\n                  {(k.1.1, \\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => d)} {j} k.1.2) *> D.o-assoc {z} {apex} {Functor.F {F.F} j.1} {Functor.F {F.F} k.1.1} {Func {F.F} {j.1} {k.1.1} k.1.2} {coneMap j} {c.coneMap m}))\\n    \\\\in \\n          \\\\let h1 => path (\\\\lam (i : I) (j : \\\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)) => arg j @ i)\\n          \\\\in \\\\new Cone {J {\\\\this}} {Cone.D {\\\\this}} (G {\\\\this}) z {\\n                | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => arg j @ i\\n                | coneCoh => {?hidden}\\n              }))\\n}\", 'lem : \\\\Pi (j : \\\\Sigma (x : P.E) (embed {P} x <= U)) -> \\\\Pi (k : \\\\Sigma (y : \\\\Sigma (y : P.E) (Cover1 {P} y j.1))\\n  (TruncP (\\\\Sigma (j : \\\\Sigma (j : J) (x : P.E) ((g j).1.1 x)) (Cover1 {P} y.1 j.2)))) ->\\ns.S {embed {P} k.1.1} (\\\\lam {x : P.E} (d : (embed {P} k.1.1).1 x) => j.2 {x}\\n  (cover-trans {P} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => k.1.1} d (\\\\lam (_ : \\\\Sigma) => k.1.2)))', 'D : CompleteCat']<<<break>>>[\"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '| limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j', '| D : Precat', '| ret B : A', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', \"\\\\lemma prop-pi \\\\plevels  \\\\hlevels  {A : \\\\Prop} {a a' : A} : a = a' \", \"\\\\func framePresSite \\\\hlevels  (P : FramePres) : SiteWithBasis P.E {\\n  | Hom => Cover1 {P}\\n  | id => <=-refl\\n  | o => \\\\lam {X Y Z : Ob} (f : Hom Y Z) (g : Hom X Y) => g <=\u2218 f\\n  | pullback => \\\\lam {x1 y1 z1 : P.E} (f1 : Cover1 {P} x1 z1) (g1 : Cover1 {P} y1 z1) => \\\\new Pullback {x1} {y1} {z1} f1 g1 (P.conj x1 y1) {\\n    | pbProj1 => cover-proj1 {P} {apex {\\\\this}} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x {\\\\this}} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {x1})\\n    | pbProj2 => cover-proj2 {P} {P.conj x1 y1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => y1} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {y1})\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {D {\\\\this}}} (p1 : Hom {D {\\\\this}} w (x {\\\\this})) (p2 : Hom {D {\\\\this}} w (y {\\\\this}))\\n      (_ : f {\\\\this} \u2218 p1 = g {\\\\this} \u2218 p2) => cover-prod {P} {w} {x1} {y1} p1 p2\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | isBasicCover => \\\\lam (x : Ob {\\\\this}) {J : \\\\Set} (g : J -> Ob) =>\\n  TruncP (\\\\Sigma (y : P.E) (Cover1 {P} x y) (g' : J -> P.E) (P.BasicCover {J} y g')\\n    (\\\\Pi (j : J) -> \\\\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (g j).1)))\\n} => \\\\new SiteWithBasis {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | basicCover-stable => {?hidden}\\n}\", '| J : Precat', '\\\\func extend-proj \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (y : P.E) :\\n  D.Hom (Functor.F (embed {P} y)) (Functor.F {F.F} y) \\n=> coneMap {D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= embed {P} y)}\\n  (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= embed {P} y)) => t.1)}} (limFunctor {P} {D} {F} (embed {P} y))}\\n  (y, \\\\lam {x : P.E} (d : (embed {P} y).1 x) => d)', '| E : \\\\Set', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '\\\\lemma genSieve \\\\hlevels  {P : FramePres} (a : P.E) {J : \\\\Set} (g : J -> P.E) : Sieve {framePresPreorder P} a\\n  (\\\\lam {b : Ob {C {\\\\this}}} (_ : Hom {C {\\\\this}} b (x {\\\\this})) => TruncP (\\\\Sigma (j : J) (Cover1 {P} b (g j)))) ', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| limit {J : Precat} (G : Functor J \\\\this) : Limit {J} G', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x', '\\\\func framePresPreorder \\\\hlevels  (P : FramePres) : Preorder P.E {\\n  | <= => Cover1 {P}\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', '\\\\func limFunctor \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\\nFunctor (Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})\\n  D (\\\\lam (X : Ob {C {\\\\this}}) => Functor.F {F.F} (Functor.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => Func {F.F} {Functor.F X} {Functor.F Y} (Func {X} {Y} f)\\n} => Comp {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  {Precat.op {framePresSite P}} {D} F.F\\n  (Functor.op {embedding {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})', '\\\\func Cover1 \\\\hlevels  {P : FramePres} (x y : P.E) : \\\\Prop => Cover {P} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => y)', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', '\\\\type ObOver \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : \\\\hType => \\\\Sigma (y : C.Ob) (C.Hom y x)', '\\\\func coe (A : I -> \\\\Type) (a : A left) (i : I) : A i ', '| limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', \"\\\\lemma extend-proj-nat \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} {y z : P.E} (h : Cover1 {P} y z)\\n  (h' : embed {P} y <= embed {P} z) :\\n  extend-proj {P} {D} {F} y D.\u2218 Func {embed {P} z} {embed {P} y} h' = Func {F.F} {z} {y} h D.\u2218 extend-proj {P} {D} {F} z \", '\\\\func subPrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} {X : \\\\hType} (f : X -> C.Ob) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => C.Hom (f x) (f y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => C.id (f x)\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} => (C.\u2218)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func lim \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\\nLimit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  {D} (limFunctor {P} {D} {F} b) \\n=> D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  (limFunctor {P} {D} {F} b)', '\\\\instance SlicePrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : Precat (ObOver {C} x) {\\n  | Hom => \\\\lam (p0 : Ob {\\\\this}) (p1 : Ob {\\\\this}) => \\\\Sigma (h : C.Hom p0.1 p1.1) (p1.2 C.\u2218 h = p0.2)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (C.id p0.1, C.id-right {p0.1} {x} {p0.2})\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) => (p0.1 C.\u2218 p1.1,\\n    inv {C.Hom X.1 x} {Z.2 C.\u2218 p0.1 C.\u2218 p1.1} {Z.2 C.\u2218 (p0.1 C.\u2218 p1.1)} (C.o-assoc {X.1} {Y.1} {Z.1} {x} {Z.2} {p0.1} {p1.1}) *> pmap {C.Hom Y.1 x} {C.Hom X.1 x} (\\\\lam (_x : C.Hom Y.1 x) => _x C.\u2218 p1.1) {Z.2 C.\u2218 p0.1} {Y.2} p0.2 *> p1.2)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| S {y : Ob {C}} (Hom {C} y x) : \\\\Prop', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", \"\\\\lemma extend-proj-nat' \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} {y : P.E} {V : E} (h' : embed {P} y <= V) :\\nextend-proj {P} {D} {F} y D.\u2218 Func {V} {embed {P} y} h' = coneMap {D.limit {op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= V)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= V)) => t.1)}}\\n  (limFunctor {P} {D} {F} V)} (y, h') \", '| F : Functor (op {C}) D', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", \"\\\\func pathOver {A : I -> \\\\Type} {a : A left} {a' : A right} (p : coe A a right = a') : Path A a a' \\n  => concat {A} {a} {coe A a right} {a'} (idpOver A a) p\", \"\\\\class Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | J : Precat\\n  | D : Precat\\n  | G : Functor J D\\n  | apex : Ob {D}\\n  | coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)\\n  | coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\\n}\", '| limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'right', '\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '\\\\class Limit \\\\extends Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\\\new \\\\this {}) z)\\n  | limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex\\n  | limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j\\n  | limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g\\n}', '\\\\func embedding \\\\plevels obj >= hom \\\\hlevels  {C1 : Precat} {X : \\\\hType} (f : X -> C.Ob) : FullyFaithfulFunctor (subPrecat {C1} {X} f) C1 f {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (h : Hom {C {\\\\this}} X Y) => h\\n} => \\\\new FullyFaithfulFunctor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n}', '| apex : Ob {D}', '\\\\func conePullback \\\\plevels obj >= hom \\\\hlevels  {J1 : Precat} {D1 : Precat} {F1 : Functor J1 D1} (C : Cone {J1} {D1} F1) (z : D.Ob) (f : D.Hom z C.apex) :\\nCone {J1} {D1} F1 z {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => C.coneMap j D.\u2218 f\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| Ob : \\\\hType', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func extend \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} :\\nFunctor (op {PresentedFrame P}) D (\\\\lam (b : Ob {C {\\\\this}}) => apex) {\\n  | Func => \\\\lam {a : Ob {C {\\\\this}}} {b : Ob {C {\\\\this}}} (b<=a : Hom {C {\\\\this}} a b) => limMap {apex} (cone {P} {D} {F} {a} {b} b<=a)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func cone \\\\plevels obj >= hom \\\\hlevels  {this2 : Presieve} :\\nCone {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)} (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)) => p.1)}}\\n  {Precat.op {C}} (Functor.op {diagram}) x {\\n  | coneMap => \\\\lam (p0 : Ob {J {\\\\this}}) => p0.1.2\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func diagram \\\\plevels obj >= hom \\\\hlevels  {this1 : Presieve} : Functor (subPrecat {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)) => p.1)) Presieve.C\\n  (\\\\lam (X : Ob {Functor.C {\\\\this}}) => F (F X)) {\\n  | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) => Func {F X} {F Y} (Func {X} {Y} f)\\n} => Comp {subPrecat {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)) => p.1)} {SlicePrecat {Presieve.C} x} {Presieve.C}\\n  (forget {Presieve.C} x) (embedding {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : Ob) (S {y.1} y.2)) => p.1))']<<<break>>>ret {\\this} (conePullback\n  {Precat.op {subPrecat {SlicePrecat {PresentedFrame P} U} {\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)}\n    (\\lam (p : \\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)) => p.1)}} {D1}\n    {Comp {Precat.op {subPrecat {SlicePrecat {PresentedFrame P} U} {\\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)}\n      (\\lam (p : \\Sigma (y : ObOver {PresentedFrame P} U) (s.S {y.1} y.2)) => p.1)}} {Precat.op {PresentedFrame P}} {D1}\n      (extend {P} {D1} {F}) (Functor.op {diagram {s}})} (\\new this1 {}) z h) = h", "completion": "limUnique (\\lam j => limBeta {lim (apex {cone {s}})} _ j *> limUnique {lim j} (\\lam k => later $ limBeta {lim j} _ k *> inv o-assoc *> pmap (\\lam _x => _x \u2218 h)\n  (extend-proj-nat' _ *> inv (coneCoh {_} {j} {later (k.1.1, \\lam d => j.2 (cover-trans d (\\lam _ => k.1.2)))} $ later k.1.2)) *> o-assoc))"}
{"prompt": "['Ux : U x', 'X : \\\\Set', 'x : X', 'U : Set (E {\\\\this})', 'CU : C U', 'C : Set (Set (E {\\\\this}))', 'this : CompletelyRegularCoverSpace X {\\n  | isOpen => \\\\lam (_ : Set E) => \\\\Sigma\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) => \\\\Pi (x : X) -> TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (U x))\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isCompletelyRegular => {?hidden}\\n}']<<<break>>>['| R (E {A}) (E {A}) : \\\\Prop', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| A : TopMeetSemilattice', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', \"\\\\type \\\\infix 4 <=<c \\\\hlevels  {this : RatherBelow} (V U : E {A}) : \\\\Prop \\n=> TruncP (\\\\Sigma (R' : E {A} -> E {A} -> \\\\Prop) (\\\\Pi {V U : E {A}} -> R' V U -> R V U)\\n  (\\\\Pi {V U : E {A}} -> R' V U -> TruncP (\\\\Sigma (W : E {A}) (R' V W) (R' W U))) (R' V U))\", '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '\\\\lemma single_<= \\\\hlevels  {X : \\\\Set} {a : X} {U : Set X} (_ : U a) : single {X} a \u2286 U ']<<<break>>>TruncP (\\Sigma (U : Set (E {\\this})) (TruncP (\\Sigma (U1 : Set (E {\\this})) (C U1) (U <=<c U1))) (U x))", "completion": "inP (U, inP (U, CU, inP ((=), \\lam p => rewrite p (\\lam x => inP (single x, \\lam p0 => (\n  \\let (y, (Uy, x=y)) => p0\n  \\in rewrite x=y $ single_<= Uy), idp)), \\lam p => inP (_, idp, p), idp)), Ux)"}
{"prompt": "['z : E {\\\\this}', 'y : E {\\\\this}', 'U : LModule R', 'x : E {\\\\this}']<<<break>>>['| \\\\infixl 6 + E E : E', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Cod : BaseSet', '| Dom : BaseSet']<<<break>>>\\Pi (e : U.E) -> func {z} (x.func e + y.func e) = func {z} (x.func e) + func {z} (y.func e)", "completion": "\\lam _ => func-+"}
{"prompt": "['R : AddGroup', 'M : \\\\Set']<<<break>>>['\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class AbMonoid \\\\extends AddMonoid \\\\hlevels  {\\n  | +-comm {x y : E} : x + y = y + x\\n}', '\\\\type MonoidSet \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : \\\\Set => Quotient {Array (\\\\Sigma R.E M)} (~)', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '| E : \\\\Set', '\\\\instance MonoidAbMonoid \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : AbMonoid (MonoidSet M R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M)} {(~)} nil\\n  | + => (MonoidAbMonoid.+)\\n} => \\\\new AbMonoid {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n}', \"\\\\func + {M3 : \\\\Set} {R3 : AddMonoid} (_ _ : MonoidSet M3 R3) : MonoidSet M3 R3 \\n  | {M}, {R}, in~ l, in~ l' => in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l')\\n  | {M}, {R}, in~ l, ~-equiv l1 l2 r i =>\\n  monoidSet-ext {M} {R} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l1)} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l2)}\\n    (~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l ++ l1} {l1 ++ l}\\n      (~-perm {M} {R} {l ++ l1} {l1 ++ l} (eperm-++-comm {\\\\Sigma R.E M} {l} {l1})) *> ~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l1 ++ l} {l2 ++ l} (~_++-left {M} {R} {l1} {l2} {l} r) *> ~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l2 ++ l} {l ++ l2}\\n      (~-perm {M} {R} {l2 ++ l} {l ++ l2} (eperm-++-comm {\\\\Sigma R.E M} {l2} {l}))) @ i\\n  | {M}, {R}, ~-equiv l1 l2 r i, in~ l' =>\\n  monoidSet-ext {M} {R} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l1 ++ l')} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l2 ++ l')}\\n    (~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l1 ++ l'} {l2 ++ l'} (~_++-left {M} {R} {l1} {l2} {l'} r)) @ i\", 'in~ A']<<<break>>>AbMonoid (MonoidSet M R) {\n  | zro => in~ {Array (\\Sigma (E {R}) M)} {(~)} nil\n  | + => (+)\n}", "completion": "MonoidAbMonoid _ _"}
{"prompt": "['i : Fin (suc n)', 'n : Nat']<<<break>>>['\\\\lemma <_suc_<= \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < suc m) : n <= m ', 'suc Nat', \"\\\\lemma <=_exists \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n <= m) : n + (m -' n) = m \", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ']<<<break>>>i + (n -' i) = n", "completion": "<=_exists (<_suc_<= $ fin_< i)"}
{"prompt": "['i : Fin (suc n)', 'this : EuclideanDomain', 'b : E -> \\\\Sigma (x : E) (#0 x)']<<<break>>>['| zro : E', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\lemma apartNonZero \\\\hlevels  {this : With#} {x : E} (_ : #0 x) : x /= zro ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set']<<<break>>>(b i).1 = zro -> Empty", "completion": "apartNonZero {this} (b i).2"}
{"prompt": "['y0 : E']<<<break>>>['| zro : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma U-inh_>0 \\\\plevels  \\\\hlevels  {this : UpperReal} : TruncP (\\\\Sigma (q : Rat) (U q) (zro < q)) ', '| U Rat : \\\\Prop', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>TruncP (\\Sigma (q : Rat) (y0.U q) (zro < q))", "completion": "U-inh_>0 {y0}"}
{"prompt": "['S : VSheaf CRingCat L', 'a : L.E', 'this : RingedLocaleHom\\n(\\\\new RingedLocale (Locale.restrict {L1} a) (VSheaf.restrict {L1} a S)) (\\\\new RingedLocale L1 S) (map {L1} {a})\\n  (\\\\new NatTrans {Precat.op {L {Cod {\\\\this}}}} {CRingCat} (VPresheaf.F {R {Cod {\\\\this}}})\\n    (VPresheaf.F {direct_image_locale {L {Dom {\\\\this}}} {L {Cod {\\\\this}}} (f {\\\\this}) (R {Dom {\\\\this}})}) {\\n    | trans => \\\\lam (b : Ob {C {\\\\this}}) => Func {S.F} {b} {(func {map {L1} {a}} b).1} (L.meet-left {b} {a})\\n    | natural => {?hidden}\\n  })', 'L : Locale']<<<break>>>[\"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '| L : Locale', '\\\\func restrict \\\\hlevels  {this2 : Locale} (a : E) : Locale (\\\\Sigma (b : E) (b <= a)) {\\n  | <= => \\\\lam (p : E {\\\\this}) (q : E {\\\\this}) => p.1 <= q.1\\n  | meet => \\\\lam (p : E {\\\\this}) (q : E {\\\\this}) => (p.1 \u2227 q.1, meet-left {p.1} {q.1} <=\u2218 p.2)\\n  | top => (a, <=-refl {a})\\n  | Join => \\\\lam {J : \\\\Set} (g : J -> E {\\\\this}) =>\\n    (Join {J} (\\\\lam (j : J) => (g j).1), Join-univ {J} {\\\\lam (j : J) => (g j).1} {a} (\\\\lam (j : J) => (g j).2))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\instance CRingCat : Cat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {RingCat} {CRing} (\\\\new Embedding {CRing} {Ob} (\\\\lam (R : A {\\\\this}) => R) {\\n  | isEmb => \\\\lam (R S : A {\\\\this}) =>\\n  \\\\new Retraction {R = S} {f {\\\\this} R = f {\\\\this} S} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {R} {S}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new CRing (E {p @ i}) {\\n      | zro => zro {p @ i}\\n      | + => (+) {p @ i}\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*) {p @ i}\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | negative => negative {p @ i}\\n      | negative-left => {?hidden}\\n      | ide => ide {p @ i}\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef {p @ i}\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n    })\\n    | f_sec => idpe {R = S}\\n  }\\n})', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func functor \\\\hlevels  {this2 : Locale} {a : E} : Functor (restrict a) this2 (\\\\lam (x : Ob {C {\\\\this}}) => x.1) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (p : Hom {C {\\\\this}} X Y) => p\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', \"\\\\lemma prop-pi \\\\plevels  \\\\hlevels  {A : \\\\Prop} {a a' : A} : a = a' \", '\\\\class NatTrans \\\\plevels obj >= hom >= iobj >= ihom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F : Functor C D\\n  | G : Functor C D\\n  | trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)\\n  | natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X\\n}', '\\\\func map \\\\hlevels  {this4 : Locale} {a : E} : FrameHom this4 (restrict a) {\\n  | func => \\\\lam (b : E {Dom {\\\\this}}) => (b \u2227 a, meet-right {b} {a})\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}', \"\\\\lemma direct_image_locale \\\\hlevels  {L L' : Locale} (f : FrameHom L' L) (S : VSheaf {\\n  | C => L\\n}) : VSheaf S.D L' (Comp {Precat.op {L'}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {f}})) \", '| f : FrameHom (L {Cod}) (L {Dom})', '| C : Precat', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)', '\\\\func functor \\\\hlevels  {this2 : FrameHom} : Functor Dom Cod func {\\n  | Func => func-<=\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', '| Cod : RingedLocale', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| R : VSheaf CRingCat L', '| F (Ob {C}) : Ob {D}', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| Dom : RingedLocale', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| func (E {Dom}) : E {Cod}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>NatTrans {Precat.op {L {Cod {\\this}}}} {CRingCat} (VPresheaf.F {R {Cod {\\this}}})\n  (VPresheaf.F {direct_image_locale {L {Dom {\\this}}} {L {Cod {\\this}}} (f {\\this}) (R {Dom {\\this}})}) {\n  | trans => \\lam (b : Ob {C {\\this}}) => Func {S.F} {b} {(func {map {L1} {a}} b).1} (L.meet-left {b} {a})\n  | natural => {?hidden}\n}", "completion": "\\new NatTrans {\n  | trans => \\lam b => Func {F {S}} meet-left\n  | natural => \\lam h => inv (Func-o {F {S}}) *> pmap (Func {F {S}}) prop-pi *> Func-o {F {S}}\n}"}
{"prompt": "['a : Nat', 'acc : List Nat', 'G : Graph Nat', 'n : Nat', 'c : InList {Nat} a (collect G acc l (suc n))', 'l : List Nat']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\func makeStep \\\\plevels  \\\\hlevels  (_ : Graph Nat) (_ : List Nat) (_ : List Nat) : List Nat \\n  | G, ex, nil => nil {Nat}\\n  | G, ex, i :: l => \\n    \\\\let! s => step1 G ex i\\n    \\\\in s ++ makeStep G (union {NatSemiring} s ex) l', \"\\\\lemma collect->collect' \\\\plevels  \\\\hlevels  {G : Graph Nat} {acc l : List Nat} {n a : Nat} (_ : InList {Nat} a (collect G acc l n)) :\\n  InList {Nat} a (acc ++ collect' G l n) \", \"\\\\func collect' \\\\plevels  \\\\hlevels  (_ : Graph Nat) (_ : List Nat) (_ : Nat) : List Nat \\n  | G, l, 0 => nil {Nat}\\n  | G, l, suc n => makeStep' G l ++ collect' G (makeStep' G l) n\", \"\\\\func union \\\\hlevels  {A1 : DecSet} (_ _ : List A.E) : List A.E \\n  | {A}, nil, l' => l'\\n  | {A}, a :: l, l' => if {List A.E} (contains {A} l' a) (union {A} l l') (a :: union {A} l l')\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\data InList {A : \\\\Type} A (List A) : \\\\Prop \\\\with\\n  | {A}, a, a' :: l => here (a = a')\\n  | {A}, a, a' :: l => there (InList {A} a l)\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\lemma InList_++ {A : \\\\Type} {a : A} {l l' : List A} (_ : InList {A} a (l ++ l')) : InList {A} a l || InList {A} a l' \"]<<<break>>>InList {Nat} a (union {NatSemiring} (makeStep G acc l) acc) || InList {Nat} a (collect' G (makeStep G acc l) n)", "completion": "InList_++ (collect->collect' c)"}
{"prompt": "['x : E', 'n : Nat', 'this : RealPreBanachSpace']<<<break>>>[\"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| norm-double {x : E} : norm x ExUpperReal.+ norm x <= norm (x AddMonoid.+ x)', '\\\\lemma steps \\\\hlevels  {X : ExPseudoNormedAbGroup} (_ : \\\\Pi {x : X.E} -> X.norm x + X.norm x <= X.norm (x X.+ x)) {k : Nat} {x : X.E} :\\n  pow {NatSemiring} 2 k *n X.norm x = X.norm (pow {NatSemiring} 2 k *n x) ', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>pow {NatSemiring} 2 n *n norm x = norm (pow {NatSemiring} 2 n *n x)", "completion": "steps (norm-double {this})"}
{"prompt": "['R : Ring', 'x : E {\\\\this}', 'z : E {\\\\this}', 'y : E {\\\\this}', 'n : Nat']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma PairsFinSet (n : Nat) : FinSet (\\\\Sigma (i j : Nat) (\\\\property (i + j = n))) {\\n  | finCard => suc n\\n} ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', 'FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1', '| E : \\\\Set', '\\\\lemma FinSum_+ {this : AbMonoid} {J : FinSet} {x : J.E -> E} {y : J.E -> E} :\\n  FinSum {J} (\\\\lam (j : J.E) => x j + y j) = FinSum {J} x + FinSum {J} y ']<<<break>>>FinSum {R} {PairsFinSet n} (\\lam (j : E {PairsFinSet n}) =>\n  (\\lam (s : \\Sigma (i j : Nat) (\\property (i + j = n))) => x s.1 R.* z s.2) j R.+ (\\lam (s : \\Sigma (i j : Nat) (\\property (i + j = n))) => y s.1 R.* z s.2) j) = FinSum {R} {PairsFinSet n} (\\lam (s : \\Sigma (i j : Nat) (\\property (i + j = n))) => x s.1 R.* z s.2) R.+ FinSum {R} {PairsFinSet n} (\\lam (s : \\Sigma (i j : Nat) (\\property (i + j = n))) => y s.1 R.* z s.2)", "completion": "FinSum_+ {R}"}
{"prompt": "['Y : ExPseudoNormedAbGroup', 'Mp : \\\\Pi (n : Nat) -> \\\\Pi (x : X) -> Y.norm (f n x) <= M n', 'j : Nat', 'M : Series ExUpperReal', 'f : Nat -> X -> Y.E', 'x : X']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| norm E : ExUpperReal']<<<break>>>Y.norm (f j x) <= M j", "completion": "Mp j x"}
{"prompt": "['L : UniformLocale', 'a : L.E', 'j : \\\\Sigma (x : L.E) ((embed {CompletionPres L} a).1 x)']<<<break>>>['\\\\func presentation {L : UniformLocale} : FramePresHom (CompletionPres L) (F L) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new FramePresHom {\\n  | func-conj => {?hidden}\\n  | func-basicCover => {?hidden}\\n  | func-image => {?hidden}\\n}', '\\\\lemma locale_cover {L : Locale} {x : L.E} {J : \\\\Set} {g : J -> L.E} (_ : Cover {F L} x {J} g) : x L.<= L.Join {J} g ', '| Join {J : \\\\Set} (J -> E) : E', '\\\\lemma map \\\\hlevels  {F : FramePresPrehom} {x : E {F.Dom}} {J : \\\\Set} {g : J -> E {F.Dom}} (_ : Cover {F.Dom} x {J} g) :\\n  Cover {F.Cod} (F.func x) {J} (\\\\lam (j : J) => F.func (g j)) ', '| \\\\infix 4 <= E E : \\\\Prop', '| func (E {Dom}) : E {Cod}']<<<break>>>func {presentation {L}} j.1 L.<= L.Join {\\Sigma} (\\lam (_ : \\Sigma) => func {presentation {L}} a)", "completion": "locale_cover (map {presentation} j.2)"}
{"prompt": "['j : Fin l.len', \"p : (l !! j).1 = (l' !! k).1\", 'v : V.E', \"q : (l !! j).2 B.<= (l' !! k).2\", 'c : B.E', 'l : PFunc {V} {B}', \"l' : PFunc {V} {B}\", 'b : B.E', \"k : Fin l'.len\", 'a : B.E', 'V : PosetQModule', 'B : BooleanRing']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', 'inP A', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (j1 : Fin (suc l'.len)) ((((v, a) :: (v, b) :: l) !! suc (suc j)).1 = (((v, c) :: l') !! j1).1)\n  ((((v, a) :: (v, b) :: l) !! suc (suc j)).2 B.<= (((v, c) :: l') !! j1).2))", "completion": "inP (suc k, p, q)"}
{"prompt": "['l : Array (\\\\Sigma R.E E)', 'J : \\\\Set', \"r : l ~ l'\", \"l' : Array (\\\\Sigma R.E E)\", 'R : CRing', 'd : Nat']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\type PermSet \\\\hlevels  (A : \\\\Set) : \\\\Set => Quotient {Array A} (EPerm {A})', '\\\\func inMS~ \\\\hlevels  {M : \\\\Set} {R : AddMonoid} (l : Array (\\\\Sigma R.E M)) : Quotient {Array (\\\\Sigma R.E M)} (~) \\n  => in~ {Array (\\\\Sigma R.E M)} {(~)} l', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', \"\\\\func permSet-length \\\\hlevels  {A1 : \\\\Set} (_ : PermSet A1) : Nat \\n  | {A}, in~ l => l.len\\n  | {A}, ~-equiv l l' e i => EPerm_len {A} {l} {l'} e @ i\", '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func ~-pequiv {A : \\\\Type} {R : A -> A -> \\\\Type} {x y : A} (r : R x y) : in~ {A} {R} x = in~ {A} {R} y => path (~-equiv {A} {R} x y r)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", 'in~ A']<<<break>>>TruncP (\\Sigma (l'1 : Array (\\Sigma R.E E)) (inMS~ {PermSet J} {R} l' = inMS~ {PermSet J} {R} l'1)\n  (\\Pi (j : Fin l'.len) -> permSet-length {J} (l'1 !! j).2 < d)) ->\nTruncP (\\Sigma (l' : Array (\\Sigma R.E (PermSet J))) (inMS~ {PermSet J} {R} l = inMS~ {PermSet J} {R} l')\n  (\\Pi (j : Fin l'.len) -> permSet-length {J} (l' !! j).2 < d))", "completion": "\\lam p0 => map p0 (\\lam s => (s.1, ~-pequiv r *> s.2, s.3))"}
{"prompt": "['y : ExUpperReal', 'x : ExUpperReal', 'a : Rat']<<<break>>>['| U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'inP A', 'join \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal => \\\\new ExUpperReal (\\\\lam (a : Rat) => \\\\Sigma (x.U a) (y.U a)) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| join-left {x y : E} : x <= x \u2228 y', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma U_<= \\\\plevels  \\\\hlevels  {this : ExUpperReal} {q r : Rat} (_ : U q) (_ : q <= r) : U r ', '\\\\lemma <->refl \\\\plevels  \\\\hlevels  {P : \\\\Prop} : P <-> P ', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"| U-closed {q q' : Rat} (U q) (q < q') : U q'\", '| U Rat : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| join-right {x y : E} : y <= x \u2228 y', '| <_join-univ {x y z : E} (x < z) (y < z) : x \u2228 y < z']<<<break>>>U {join x y} a <-> (\\Sigma (x.U a) (y.U a))", "completion": "rewrite (\\peval join x y) <->refl"}
{"prompt": "['R : CRing', 'bez_diag : at {(\\\\Sigma (IsStrictBezout {R}) (IsKaplansky R)) :: (\\\\Sigma (IsStrictBezout {R}) (\\\\Pi (A : Matrix R.E 2 2) ->\\n  at {at {A} 1} 0 = R.zro -> IsCoprimeArray {R} (at {at {A} 0} 0 :: at {at {A} 0} 1 :: at {at {A} 1} 1 :: nil) ->\\n    TruncP (\\\\Sigma (B : Matrix R.E 2 2) (IsDiagonal {R} {2} {2} B) (A M~ B)))) :: (\\\\Pi {n m : Nat} ->\\n    n <= m -> m <= 2 -> \\\\Pi (A : Matrix R.E n m) -> TruncP (\\\\Sigma (B : Matrix R.E n m) (IsDiagonal {R} {n} {m} B) (A M~ B))) :: (\\\\Pi {n m : Nat} -> \\\\Pi (A : Matrix R.E n m) -> TruncP (\\\\Sigma (B : Matrix R.E n m) (IsSmith {R} {n} {m} B) (A M~ B))) :: nil}\\n    1', 'A : Matrix R.E 2 2']<<<break>>>['| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '| ide : E', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (s t u v : R.E) (at {at {A} 0} 0 R.* u = at {at {A} 1} 0 R.* v) (s R.* u R.+ t R.* v = R.ide))", "completion": "bez (A 0 0) (A 1 0)"}
{"prompt": "['J : Precat', 'h1 : (\\\\lam (e : Z.E) => (\\n  \\\\have arg => \\\\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\\\this} (conePullback {J} {G} (\\\\new this1 {}) Z f1)} e).1 j}\\n  \\\\in \\n        \\\\let _ => path (\\\\lam (i : I) (j : J.Ob) => arg j @ i)\\n        \\\\in ((func {ret {\\\\this} (conePullback {J} {G} (\\\\new this1 {}) Z f1)} e).1, (func {ret {\\\\this} (f {\\\\this} f1)} e).2))) = (\\\\lam (e : Z.E) => (\\n  \\\\have arg => \\\\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\\\this} (conePullback {J} {G} (\\\\new this1 {}) Z f1)} e).1 j}\\n  \\\\in \\n        \\\\let _ => path (\\\\lam (i : I) (j : J.Ob) => arg j @ i)\\n        \\\\in ((func {ret {\\\\this} (conePullback {J} {G} (\\\\new this1 {}) Z f1)} e).1, (f.func e).2)))', 'f : A {\\\\this}', 'this : Limit {J1} G1 (limit-obj {J1} G1) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => \\\\new FrameHom (apex {\\\\this}) (F {G {\\\\this}} j) {\\n    | func => \\\\lam (P : E {Dom {\\\\this}}) => P.1 j\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n  }\\n  | coneCoh => {?hidden}\\n  | isLimit => {?hidden}\\n  | limMap => limMap-impl\\n  | limBeta => {?hidden}\\n  | limUnique => {?hidden}\\n}', 'G : Functor J this', \"this : QEquiv {Hom {D {\\\\this}} Z (apex {\\\\this})} {Cone {J {\\\\this}} {D {\\\\this}} (G {\\\\this}) Z}\\n  (conePullback {J {\\\\this}} {D {\\\\this}} {G {\\\\this}} (\\\\new this3 {}) Z) {\\n  | ret => \\\\lam (c : B {\\\\this}) => \\\\new FrameHom Z (apex {\\\\this}) {\\n    | func => \\\\lam (z : E {Dom {\\\\this}}) => (\\\\lam (j : J.Ob) => func {c.coneMap j} z,\\n      \\\\lam {j j' : J.Ob} (h : J.Hom j j') => path (\\\\lam (i : I) => func {c.coneCoh {j} {j'} h @ i} z))\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n  }\\n  | ret_f => \\\\lam (f1 : A {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => \\\\lam (z : Z.E) => path (\\\\lam (i : I) => (\\n            \\\\have arg => \\\\lam (j : J.Ob) => idp {E {G.F j}} {(func {ret {\\\\this} (conePullback {J1} {G1} (\\\\new this3 {}) Z f1)} z).1 j}\\n            \\\\in \\n                  \\\\let h1 => path (\\\\lam (i : I) (j : J.Ob) => arg j @ i)\\n                  \\\\in (\\\\lam (j : J.Ob) => arg j @ i,\\n                        prop-dpi (\\\\lam (i : I) => \\\\Pi {j j' : J.Ob} -> \\\\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} ((@) h1 i j) = (@) h1 i j')\\n                          (func {ret {\\\\this} (f {\\\\this} f1)} z).2 (f.func z).2 @ i)))\\n    \\\\in \\n          \\\\let h1 => path (\\\\lam (i : I) (e : Z.E) => arg e @ i)\\n          \\\\in \\\\new FrameHom Z (apex {\\\\this}) {\\n                | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                | func-<= => {?hidden}\\n                | func-top => {?hidden}\\n                | func-top>= => {?hidden}\\n                | func-meet => {?hidden}\\n                | func-meet>= => {?hidden}\\n                | func-Join => {?hidden}\\n                | func-Join>= => {?hidden}\\n              }))\\n  | f_sec => \\\\lam (c : B {\\\\this}) => idp {Cone {J1} G1 Z {\\n    | coneMap => \\\\lam (j : J.Ob) => coneMap {\\\\this} j \u2218 sec {\\\\this} c\\n  }} {conePullback {J1} {G1} (\\\\new this3 {}) Z (sec {\\\\this} c)}\\n}\", 'Z : Ob {D {\\\\this}}']<<<break>>>['| apex : Ob {D}', '| ret B : A', '| f A : B', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| func-top>= : top {Cod} <= func (top {Dom})', '| top : E', '| Ob : \\\\hType', '| \\\\infix 4 <= E E : \\\\Prop', '| F (Ob {C}) : Ob {D}']<<<break>>>Path (\\lam (i : I) => \\Pi (j : J.Ob) -> (top {apex {\\this}}).1 j <= ((@) h1 i Z.top).1 j)\n  (func-top>= {ret {\\this} (f {\\this} f1)}) f.func-top>=", "completion": "prop-dpi (\\lam i => ext_coe) (func-top>= {\\new FrameHom Z (limit-obj {J} G) {\n  | func => \\lam (z : Z.E) => (\\lam (j : J.Ob) => func {coneMap j} z,\n    \\lam {j j' : J.Ob} (h : J.Hom j j') => path (\\lam (i : I) => func {coneCoh {j} {j'} h @ i} z))\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}) (func-top>= {f})"}
{"prompt": "['B : Rat', '-a<=c : A.negative a A.<= c', 'c : A.E', '|a|<B : U {A.norm a} B', 'a : A.E', 'A : StoneC*Algebra']<<<break>>>['| zro : E', '\\\\lemma finv>0 {this : DiscreteOrderedField} {x : E} (_ : zro < x) : zro < finv x ', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| finv E : E', '\\\\type \\\\infix 4 <= \\\\hlevels  {R : Ring} (x y : R.E) : \\\\Prop => IsSquare {R} (y - x)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma norm>=0 \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : zro <= X.norm x ', '\\\\lemma <=_*q-right \\\\hlevels  {this : PosetQModule} {q : Rat} (_ : zro <= q) {a b : E} (_ : a <= b) : q *q a <= q *q b ', '| negative E : E', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2']<<<break>>>finv B *q A.negative a <= finv B *q c", "completion": "<=_*q-right {A} (<=-less $ finv>0 {RatField} $ norm>=0 |a|<B) -a<=c"}
{"prompt": "['n : Nat']<<<break>>>['| \\\\infixl 6 + E E : E', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma PairsFinSet (n : Nat) : FinSet (\\\\Sigma (i j : Nat) (\\\\property (i + j = n))) {\\n  | finCard => suc n\\n} ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| E : \\\\Set', '\\\\class FinSet \\\\extends KFinSet, Choice, DecSet {\\n  | finEq : TruncP (Equiv {Fin finCard} {E})\\n  | #-comparison => \\\\lam (x : E) (y : E) (z : E) (x/=z : x # z) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => byRight {x # y} {y # z} (\\\\lam (y=z : y = z) => x/=z (x=y *> y=z))\\n    | no x/=y => byLeft {x # y} {y # z} x/=y\\n  })\\n  | #-symmetric => /=-sym {E}\\n  | # => (/=)\\n  | nonEqualApart => \\\\lam {x y : E} (p : x /= y) => p\\n  | tightness => \\\\lam {x : E} {y : E} (x//=y : Not (x # y)) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => x=y\\n    | no x/=y => absurd {x = y} (x//=y x/=y)\\n  })\\n  | finSurj => map {Equiv {Fin finCard} {E}} {\\\\Sigma (f : Fin finCard -> E) (IsSurj {Fin finCard} {E} f)} finEq\\n    (\\\\lam (e : Equiv {Fin finCard} {E}) => (e.f, isSurjMap {ESEquiv.fromEquiv e}))\\n  | #-irreflexive => \\\\lam {x : E} (p : x # x) => p (idp {E} {x})\\n  | choice => \\\\lam {B : E -> \\\\Set} => (\\\\scase finEq \\\\with {\\n    | inP e => transport {\\\\Type} (\\\\lam (x : \\\\Type) => \\\\Pi {A : x -> \\\\Set} -> (\\\\Pi (i : x) -> TruncP (A i)) -> TruncP (\\\\Pi (i : x) -> A i))\\n      {Fin finCard} {E} (Equiv-to-= {Fin finCard} {E} e) (finiteAC {finCard}) {B}\\n  })\\n}']<<<break>>>\\Pi (s : E) -> FinSet (\\Sigma (i j : Nat) (\\property (i + j = s.2))) {\n  | finCard => suc s.2\n}", "completion": "\\lam (s : PairsFinSet n) => PairsFinSet s.2"}
{"prompt": "['l : GroupTerm V', 'r : GroupTerm V', 'this : NatData', 'fstLeafToRemoveInd : Nat', 'ind=1 : fstLeafToRemoveInd = 1', 'p : (remove-pair (l :* r) fstLeafToRemoveInd).2 = true']<<<break>>>['true', '| \\\\infix 4 > E E : \\\\Prop', '\\\\field trichotomy (x y : E) : Tri x y', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\data GroupTerm \\\\Type \\n  | var V\\n  | :ide\\n  | :inv (GroupTerm V)\\n  | \\\\infixl 6 :* (_ _ : GroupTerm V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\data Tri \\\\hlevels  {A : StrictPoset} (_ _ : A.E) \\n  | less (a A.< a')\\n  | equals (a = a')\\n  | greater (a A.> a')\", \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", \"\\\\func remove-pair \\\\hlevels  {this5 : NatData} (_ : GroupTerm V) (_ : Nat) : \\\\Sigma (GroupTerm V) Bool \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | less _x => \\n      \\\\let res-l => remove-pair l fstLeafToRemoveInd\\n      \\\\in \\\\case res-l.2 \\\\with {\\n            | true => (r, false)\\n            | false => (res-l.1 :* r, false)\\n          }\\n    | equals p => \\n      \\\\let | res-l => remove-pair l fstLeafToRemoveInd\\n           | res-r => remove-pair r 0\\n      \\\\in \\\\case res-l.2, res-r.2 \\\\with {\\n            | true, true => (:ide {Nat}, true)\\n            | true, false => res-r\\n            | false, true => res-l\\n            | false, false => (res-l.1 :* res-r.1, false)\\n          }\\n    | greater _x => \\n      \\\\let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l)\\n      \\\\in \\\\case res-r.2 \\\\with {\\n            | true => (l, false)\\n            | false => (l :* res-r.1, false)\\n          }\\n  }\\n  | {this}, :inv (var x), fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :inv g, fstLeafToRemoveInd => (:inv {V} g, false)\\n  | {this}, var x, fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :ide, fstLeafToRemoveInd => (:ide {Nat}, false)\", '| \\\\infix 4 < E E : \\\\Prop', ':ide', '| V : \\\\Set', 'false', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func count-leaves \\\\hlevels  {this1 : NatData} (_ : GroupTerm V) : Nat \\n  | {this}, l :* r => count-leaves l + count-leaves r\\n  | {this}, :inv (var x) => 1\\n  | {this}, :inv g => 0\\n  | {this}, var x => 1\\n  | {this}, t => 0', '\\\\infixl 6 :* (_ _ : GroupTerm V)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| E : \\\\Set']<<<break>>>(\\case trichotomy 1 (count-leaves l) \\with {\n  | less _x => \n    \\let res-l => remove-pair l 1\n    \\in \\case res-l.2 \\with {\n          | true => (r, false)\n          | false => (res-l.1 :* r, false)\n        }\n  | equals p => \n    \\let | res-l => remove-pair l 1\n         | res-r => remove-pair r 0\n    \\in \\case res-l.2, res-r.2 \\with {\n          | true, true => (:ide {Nat}, true)\n          | true, false => res-r\n          | false, true => res-l\n          | false, false => (res-l.1 :* res-r.1, false)\n        }\n  | greater _x => \n    \\let res-r => remove-pair r (1 -' count-leaves l)\n    \\in \\case res-r.2 \\with {\n          | true => (l, false)\n          | false => (l :* res-r.1, false)\n        }\n}).2 = true", "completion": "rewriteI ind=1 p"}
{"prompt": "['B : Rat', 'eps>0 : zro < eps', 'eps : Rat']<<<break>>>['\\\\lemma finv>0 {this : DiscreteOrderedField} {x : E} (_ : zro < x) : zro < finv x ', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\lemma <_*_positive_positive \\\\hlevels  {this : OrderedSemiring} {x y : E} (_ : zro < x) (_ : zro < y) : zro < x * y ', 'pos Nat', '| zro : E', '| \\\\infixl 7 * E E : E', '| finv E : E', '| zro<ide : zro < ide', '\\\\func join (_ _ : Rat) : Rat \\n  | rat n1 d1 denom/=0 reduced, rat n2 d2 denom/=0 reduced => \\\\case dec<_<= {IntRing} (n1 * pos d2) (n2 * pos d1) \\\\with {\\n    | inl x<y => rat n2 d2 {?hidden} {?hidden}\\n    | inr y<=x => rat n1 d1 {?hidden} {?hidden}\\n  }', '| join-right {x y : E} : y <= x \u2228 y', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)']<<<break>>>zro < finv (join B (fromInt (pos 1))) * eps", "completion": "<_*_positive_positive {RatField} (finv>0 {RatField} $ zro<ide <\u2218l join-right) eps>0"}
{"prompt": "['R : CRing', 'a : E.E', 'SR : \\\\Pi (x : R.E) -> S.contains (f.func x)', 'E : CRing', 'l : Array E', 'S : SubRing E', 'Sa : S.contains a', 'Sg : IsGenerated {homLModule (corestrict {S} {R} f SR)} l', 'f : RingHom R E']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma finiteAC {n : Nat} {A : Fin n -> \\\\Type} (_ : \\\\Pi (i : Fin n) -> TruncP (A i)) : TruncP (\\\\Pi (i : Fin n) -> A i) ', '| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)', '\\\\func corestrict \\\\hlevels  {this2 : SubRing} {R : Ring} (f : RingHom R S) (p : \\\\Pi (x : R.E) -> contains (f.func x)) : RingHom R IRing {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, p x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func homLModule \\\\hlevels  (f : RingHom) : LModule f.Dom (E {f.Cod}) {\\n  | zro => zro {f.Cod}\\n  | + => (+) {f.Cod}\\n  | negative => negative {f.Cod}\\n  | *c => \\\\lam (x : E {R {\\\\this}}) => (*) (f.func x)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| S : BaseSet', '| contains (E {S}) : \\\\Prop']<<<break>>>TruncP (\\Pi (i : Fin l.len) -> \\Sigma (c : Array R.E l.len)\n  ((a E.* (l.at i).1, S.contains_* {a} {(l.at i).1} Sa (l.at i).2) = BigSum {homLModule (corestrict {S} {R} f SR)}\n    (\\new Array (\\Sigma (x : E.E) (S.contains x)) l.len (\\lam (i : Fin l.len) => c.at i *c l.at i))))", "completion": "finiteAC (\\lam j => Sg (a * (l j).1, contains_* Sa (l j).2))"}
{"prompt": "['this : Cat AddGroup {\\n  | Hom => AddGroupHom\\n  | id => AddGroupHom.id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new AddGroupHom X Z {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n    | func-+ => {?hidden}\\n  }\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}']<<<break>>>['\\\\class AddGroupHom \\\\extends AddMonoidHom \\\\hlevels  {\\n  | func-zro => cancel-left {Cod} (func (zro {Dom})) {func (zro {Dom})} {zro {Cod}}\\n    (inv {E {Cod}} {func (zro {Dom} + zro {Dom})} {func (zro {Dom}) + func (zro {Dom})} (func-+ {zro {Dom}} {zro {Dom}}) *> pmap {E {Dom}} {E {Cod}} func {zro {Dom} + zro {Dom}} {zro {Dom}} (zro-right {Dom} {zro {Dom}}) *> inv {E {Cod}} {func (zro {Dom}) + zro {Cod}} {func (zro {Dom})} (zro-right {Cod} {func (zro {Dom})}))\\n}', '\\\\func id \\\\hlevels  {G : AddGroup} : AddGroupHom G G {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new AddGroupHom {\\n  | func-+ => {?hidden}\\n}', '| Ob : \\\\hType', '| E : \\\\Set', '| Dom : BaseSet']<<<break>>>\\Pi (o : Ob {\\this}) -> AddGroupHom o o {\n  | func => \\lam (x : E {Dom {\\this}}) => x\n}", "completion": "\\lam _ => id"}
{"prompt": "[\"E' : Equalizer {D} {x} {y} f g\", 'E : Equalizer {D} {x} {y} f g', 'D : Precat', 'x : D.Ob']<<<break>>>['| D : Precat', '| g : Hom {D} X Y', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| eql : Hom {D} apex X', '| H V V : \\\\Set', '\\\\func eqMap \\\\plevels obj >= hom \\\\hlevels  {this : Equalizer} {Z : Ob {D}} (h : Hom {D} Z X) (p : f \u2218 h = g \u2218 h) : Hom {D} Z apex => ret {isEqualizer Z} (h, p)', '| equal : f \u2218 eql = g \u2218 eql', '\\\\class HData \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | V : \\\\Set\\n  | f V : Ob {C}\\n  | H V V : \\\\Set\\n  | g {x y : V} (H x y) : Hom {C} (f x) (f y)\\n}', '| ret B : A', ':nil (a = b)', '| apex : Ob {D}', '\\\\func interpretNF \\\\plevels obj >= hom \\\\hlevels  {this3 : HData} {a3 b2 : V} (_ : CatNF {V} a3 b2 H) : Hom {C} (f a3) (f b2) \\n  | {this}, {a}, {b}, :nil idp => id {C} (f a)\\n  | {this}, {a}, {b}, :cons {c} h (:nil idp) => g {a} {b} h\\n  | {this}, {a}, {b}, :cons {c} h t => g {c} {b} h \u2218 interpretNF {a} {c} t', '| V : \\\\Set', '\\\\lemma eqBeta \\\\plevels obj >= hom \\\\hlevels  {this : Equalizer} {Z : Ob {D}} (h : Hom {D} Z X) (p : f \u2218 h = g \u2218 h) : eql \u2218 eqMap {Z} h p = h ', 'var (H a b)', '| C : Precat', \"\\\\lemma interpretNF_++ \\\\plevels obj >= hom \\\\hlevels  {this : HData} {a b c : V} (h : CatNF {V} b c H) (h' : CatNF {V} a b H) :\\n  interpretNF {a} {c} (h :++ h') = interpretNF {b} {c} h \u2218 interpretNF {a} {b} h' \", \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| X : Ob {D}', '\\\\func normalize {V : \\\\Type} {a b : V} {H : V -> V -> \\\\Type} (t : CatTerm {V} a b H) : CatNF {V} a b H \\n  => aux {V} {a} {a} {b} {H} t (:nil {V} {a} {a} {H} (idp {V} {a}))', '| Hom Ob Ob : \\\\Set', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', ':o (c : V) (CatTerm {V} c b H) (CatTerm {V} a c H)', '\\\\func interpret \\\\plevels obj >= hom \\\\hlevels  {this3 : HData} {a3 b2 : V} (_ : CatTerm {V} a3 b2 H) : Hom {C} (f a3) (f b2) \\n  | {this}, {a}, {b}, var h => g {a} {b} h\\n  | {this}, {a}, {b}, :id idp => id {C} (f a)\\n  | {this}, {a}, {b}, :o c t s => interpret {c} {b} t \u2218 interpret {a} {c} s', '\\\\infixl 7 :cons {c : V} (H c b) (CatNF {V} a c H)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| isEqualizer (Z : Ob {D}) : Equiv {Hom {D} Z apex} {\\\\Sigma (h : Hom {D} Z X) (f \u2218 h = g \u2218 h)} (\\\\lam (h : A {\\\\this}) => (eql \u2218 h,\\n  inv {Hom {D} Z Y} {f \u2218 eql \u2218 h} {f \u2218 (eql \u2218 h)} (o-assoc {D} {Z} {apex} {X} {Y} {f} {eql} {h}) *> pmap {Hom {D} apex Y} {Hom {D} Z Y} (\\\\lam (_x : Hom {D} apex Y) => _x \u2218 h) {f \u2218 eql} {g \u2218 eql} equal *> o-assoc {D} {Z} {apex} {X} {Y} {g} {eql} {h}))', '| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '\\\\lemma normalize-consistent \\\\plevels obj >= hom \\\\hlevels  {this : HData} {a b : V} (t : CatTerm {V} a b H) :\\n  interpret {a} {b} t = interpretNF {a} {b} (normalize {V} {a} {b} {H} t) ', '| Y : Ob {D}', '| id (X : Ob) : Hom X X', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| f : Hom {D} X Y']<<<break>>>interpret {\\new HData {D1} {Fin 3} (\\lam (j : Fin 3) => (\\case j \\with {\n  | zero => E.apex\n  | suc zero => E'.X\n  | suc (suc zero) => E'.apex\n}))\n  (\\lam (i : V {\\this}) (j : V {\\this}) => (\\case i, j \\with {\n    | zero, suc (suc zero) => Fin 1\n    | suc (suc zero), zero => Fin 1\n    | suc (suc zero), suc zero => Fin 1\n    | v, v => Fin 0\n  }))\n  (\\lam {i : V {\\this}} {j : V {\\this}} (k : H {\\this} i j) => (\\case i, j, k \\with {\n    | zero, suc (suc zero), zero => ret {E'.isEqualizer E.apex} (E.eql, E.equal)\n    | suc (suc zero), zero, zero => ret {E.isEqualizer E'.apex} (E'.eql, E'.equal)\n    | suc (suc zero), suc zero, zero => E'.eql\n  }))} {2} {1} (:o {Fin 3} {2} {1} {\\lam (i : Fin 3) (j : Fin 3) => (\\case i, j \\with {\n  | zero, suc (suc zero) => Fin 1\n  | suc (suc zero), zero => Fin 1\n  | suc (suc zero), suc zero => Fin 1\n  | f, f => Fin 0\n})} 2 (var {Fin 3} {2} {1} {\\lam (i : Fin 3) (j : Fin 3) => (\\case i, j \\with {\n  | zero, suc (suc zero) => Fin 1\n  | suc (suc zero), zero => Fin 1\n  | suc (suc zero), suc zero => Fin 1\n  | f, f => Fin 0\n})} 0)\n  (:o {Fin 3} {2} {2} {\\lam (i : Fin 3) (j : Fin 3) => (\\case i, j \\with {\n    | zero, suc (suc zero) => Fin 1\n    | suc (suc zero), zero => Fin 1\n    | suc (suc zero), suc zero => Fin 1\n    | f, f => Fin 0\n  })} 0 (var {Fin 3} {0} {2} {\\lam (i : Fin 3) (j : Fin 3) => (\\case i, j \\with {\n    | zero, suc (suc zero) => Fin 1\n    | suc (suc zero), zero => Fin 1\n    | suc (suc zero), suc zero => Fin 1\n    | f, f => Fin 0\n  })} 0)\n    (var {Fin 3} {2} {0} {\\lam (i : Fin 3) (j : Fin 3) => (\\case i, j \\with {\n      | zero, suc (suc zero) => Fin 1\n      | suc (suc zero), zero => Fin 1\n      | suc (suc zero), suc zero => Fin 1\n      | f, f => Fin 0\n    })} 0))) = E'.eql \u2218 D.id E'.apex", "completion": "\n  \\let d => \\new HData {D} (\\lam (j : Fin 3) => (\\case j \\with {\n         | 0 => E.apex\n         | 1 => E'.X\n         | 2 => E'.apex\n       }))\n         (\\lam i j => (\\case i, j \\with {\n           | 0, 2 => Fin 1\n           | 2, 0 => Fin 1\n           | 2, 1 => Fin 1\n           | _, _ => Fin 0\n         }))\n         (\\lam {i} {j} k => (\\case \\elim i, \\elim j, k \\with {\n           | 0, 2, 0 => ret {E'.isEqualizer E.apex} (E.eql, E.equal)\n           | 2, 0, 0 => ret {E.isEqualizer E'.apex} (E'.eql, E'.equal)\n           | 2, 1, 0 => E'.eql\n         }))\n  \\in transportInv (\\lam x0 => substitution_meta)\n        ((normalize-consistent {_} {2} {1} (:o {V {d}} {2} {1} {H {d}} 2 (var 0) (:o {V {d}} {2} {2} {H {d}} 0 (var 0) (var 0))) *> interpretNF_++ (0 :cons {V {d}} {0} {1} {H {d}} {2} (0 :cons {V {d}} {0} {2} {H {d}} {0} :nil idp))\n          (0 :cons {V {d}} {2} {0} {H {d}} {2} :nil idp) *> pmap (\\lam occurVar => occurVar \u2218 interpretNF (0 :cons {V {d}} {2} {0} {H {d}} {2} :nil idp))\n          (inv (normalize-consistent {d} {0} {1} (:o {V {d}} {0} {1} {H {d}} 2 (var 0) (var 0))))) *> pmap (\\lam (occurVar : Hom {E'.D} E.apex E'.X) => occurVar \u2218 interpretNF (0 :cons {V {d}} {2} {0} {H {d}} {2} :nil idp))\n          (eqBeta {E'} {E.apex} E.eql E.equal)) (eqBeta {E} _ _ *> inv id-right)"}
{"prompt": "[\"g : \\\\Pi {x' : X.E} -> U (x - x') -> UBall {Y} V (f x) (f x - f x')\", 'x : X.E', 'X : TopAbGroup', 'U : Set X.E', 'V : Set Y.E', 'f : X.E -> Y.E', 'Y : TopAbGroup']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class CGroupData \\\\extends NatData \\\\hlevels ', '\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '\\\\lemma simplify-correct \\\\hlevels  {this : CGroupData} (t : GroupTerm V) : interpret t = interpret (simplify t) ', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| zro : E', '| V : \\\\Set', 'var V', '\\\\infixl 6 :* (_ _ : GroupTerm V)', ':inv (GroupTerm V)', \"\\\\func UBall \\\\hlevels  {this : TopAbGroup} (U : Set E) (x : E) : Set E => \\\\lam (x' : E) => U (x - x')\", '| at (j : Fin len) : A j', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| zro-left {x : E} : zro + x = x', '| E : \\\\Set', '| negative E : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>UBall {X} U x \u2286 f ^-1 V", "completion": "\\lam u => simplify in g u"}
{"prompt": "['V : LModule R', 'bv : IsBasis {V} lv', 'R : Ring', 'lv : Array V.E n']<<<break>>>['| len : Nat', '\\\\func id \\\\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => a\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '\\\\lemma toMatrix_ide \\\\hlevels  {R : Ring} {U : LModule R} {l : Array U.E} (lb : IsBasis {U} l) : toMatrix {R} {U} {U} {l} l lb (id {R} {U}) = ide ', '| ide : E', '\\\\func toMatrix \\\\hlevels  {R : Ring} {U V : LModule R} {lv : Array V.E} (lu : Array U.E) (bv : IsBasis {V} lv) (f : LinearMap {R} U V) :\\n  Matrix R.E lu.len lv.len \\n  => mkMatrix {R.E} {lu.len} {lv.len} (\\\\lam (i : Fin lu.len) => at {basis-split {V} {lv} bv (f.func (lu.at i))})', '| E : \\\\Set', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '\\\\instance MatrixRing \\\\hlevels  (R : Ring) (n : Nat) : Ring (Matrix R.E n n) {\\n  | zro => \\\\new Array (Array R.E n) n (\\\\lam (_ : Fin n) => \\\\new Array R.E n (\\\\lam (_ : Fin n) => R.zro))\\n  | + => \\\\lam (M : E) (N : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => at {at {M} i} j R.+ at {at {N} i} j)\\n  | * => (product)\\n  | negative => \\\\lam (M : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => R.negative (at {at {M} i} j))\\n  | ide => ide {R} {n}\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}']<<<break>>>toMatrix {R} {V} {V} {lv} lv bv (id {R} {V}) = ide", "completion": "toMatrix_ide bv"}
{"prompt": "['x|y : RDiv {M} x y']<<<break>>>['| inv-left : inv * val = elem', '| \\\\infixl 7 * E E : E', '| val : E {M}', '| elem : E {M}', '| E : \\\\Set', '| M : Monoid', '| inv : E {M}']<<<break>>>x|y.inv * x|y.val = x|y.elem", "completion": "inv-left {x|y}"}
{"prompt": "['X : StronglyRegularCoverSpace', 'W<=<V : W s<=< V', 'W : Set X.E', 'V : Set X.E', 'Y : StronglyRegularCoverSpace']<<<break>>>['| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '\\\\type \\\\infix 4 s<=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => (W = Compl {X.E} V) || (W = U))', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\lemma proj1 \\\\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) X {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} ', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\lemma s<=<_^-1 \\\\hlevels  {X Y : PrecoverSpace} (f : PrecoverMap X Y) {U V : Set Y.E} (_ : U s<=< V) : f.func ^-1 U s<=< f.func ^-1 V ']<<<break>>>func {proj1 {X} {Y}} ^-1 W s<=< func {proj1 {X} {Y}} ^-1 V", "completion": "s<=<_^-1 proj1 W<=<V"}
{"prompt": "['R : CRing', 'n : Nat', 'a : E {P {\\\\this}}', 'y : R.E']<<<break>>>['| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| E : \\\\Set', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>LDiv {R} a (a R.* (y R.+ pow {R} a n)) (y R.+ pow {R} a n) {\n  | inv-right => {?hidden}\n}", "completion": "\\new LDiv {\n  | inv => y + pow a n\n  | inv-right => idp\n}"}
{"prompt": "['C : Precat', 'T : \\\\Set', 'D : Cat', 'e : Iso {FunctorPrecat {C} {D}}']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\func coe (A : I -> \\\\Type) (a : A left) (i : I) : A i ', '\\\\instance FunctorPrecat \\\\hlevels  {C1 D1 : Precat} : Precat (Functor C1 D1) {\\n  | Hom => NatTrans {C1} {D1}\\n  | id => \\\\lam (F : Ob {\\\\this}) => \\\\new NatTrans {C1} {D1} F F {\\n    | trans => \\\\lam (X : Ob {C {\\\\this}}) => D.id (F.F X)\\n    | natural => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (b : Hom {\\\\this} Y Z) (a : Hom {\\\\this} X Y) => \\\\new NatTrans {C1} {D1} X Z {\\n    | trans => \\\\lam (X1 : Ob {C {\\\\this}}) => b.trans X1 D.\u2218 a.trans X1\\n    | natural => {?hidden}\\n  }\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func mapIso \\\\hlevels  {C1 D : Precat} (e : Iso {FunctorPrecat {C1} {D}}) (X : C.Ob) : Iso {D} {F {e.dom} X} {F {e.cod} X} (trans {e.f} X) {\\n  | hinv => trans {e.hinv} X\\n} => \\\\new Iso {\\n  | hinv_f => {?hidden}\\n  | f_hinv => {?hidden}\\n}', '\\\\class NatTrans \\\\plevels obj >= hom >= iobj >= ihom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F : Functor C D\\n  | G : Functor C D\\n  | trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)\\n  | natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X\\n}', '| C : Precat', '\\\\lemma transport_Hom_iso \\\\plevels obj >= hom \\\\hlevels  {this : Cat} (e1 e2 : Iso) {g : Hom e1.dom e2.dom} {f1 : Hom e1.cod e2.cod} (_ : g >> e2.f = e1.f >> f1) :\\n  coe (\\\\lam (i : I) => Hom (isotoid {e1.dom} {e1.cod} (\\\\new e1 {}) @ i) (isotoid {e2.dom} {e2.cod} (\\\\new e2 {}) @ i)) g right = f1 ', '| C : Precat', '| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)', '| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X', '\\\\func isotoid \\\\plevels obj >= hom \\\\hlevels  {this : Cat} {a b : Ob} (e : Iso {a} {b}) : a = b => ret {univalence {a} {b}} e', '| Hom Ob Ob : \\\\Set', \"\\\\func Jl {A : \\\\Type} {a : A} (B : \\\\Pi (a' : A) -> a = a' -> \\\\Type) (_ : B a (idp {A} {a})) {a' : A} (p : a = a') : B a' p \\n  | {A}, {a}, B, b, {a'}, idp => b\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| f : Hom {C} dom cod', '| dom : Ob {C}', \"\\\\func pathOver {A : I -> \\\\Type} {a : A left} {a' : A right} (p : coe A a right = a') : Path A a a' \\n  => concat {A} {a} {coe A a right} {a'} (idpOver A a) p\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| cod : Ob {C}', 'right', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id (X : Ob) : Hom X X', '\\\\class Functor \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F (Ob {C}) : Ob {D}\\n  | Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)\\n  | Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)\\n  | Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| D : Precat', '\\\\lemma transport_iso \\\\plevels obj >= hom \\\\hlevels  {this : Cat} (e : Iso) :\\n  transport {Ob} (Hom e.dom) {e.dom} {e.cod} (isotoid {e.dom} {e.cod} (\\\\new e {})) (id e.dom) = e.f ', '| Ob : \\\\hType', '| Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)']<<<break>>>transport {Ob} (Hom e.dom) {e.dom} {e.cod} (path (\\lam (i : I) => (\n  \\have arg => (\\lam (X : C.Ob) => isotoid {D1} {F {e.dom} X} {F {e.cod} X} (mapIso {C1} {D1} e X),\n          \\lam {X : C.Ob} {Y : C.Ob} (h : C.Hom X Y) =>\n          transport_Hom_iso {D1} (mapIso {C1} {D1} e X) (mapIso {C1} {D1} e Y) {Func {e.dom} {X} {Y} h} {Func {e.cod} {X} {Y} h}\n            (natural {e.f} {X} {Y} h))\n    \\in \n          \\let | T1 => \\lam (x1 : C.Ob -> D.Ob) (x2 : C.Ob) (x3 : C.Ob) => D.Hom (x1 x2) (x1 x3)\n               | T2 => C.Ob\n               | T3 => C.Ob\n               | T4 => C.Hom\n               | h1 => path (\\lam (i : I) (o : C.Ob) => arg.1 o @ i)\n               | l => e.dom\n               | h2 => pathOver {\\lam (i : I) => \\Pi {X Y : C.Ob} -> C.Hom X Y -> D.Hom ((@) h1 i X) ((@) h1 i Y)} {l.Func} {Func {e.cod}}\n                 (\\case F {e.cod}, h1, Func {e.cod}, arg.2 \\with {\n                   | r1, idp, f, a => path (\\lam (i : I) {X : C.Ob} {Y : C.Ob} (y3 : T4 X Y) => a {X} {Y} y3 @ i)\n                 })\n          \\in \\new Functor C1 D1 (\\lam (o : Ob {C {\\this}}) => arg.1 o @ i) {\n                | Func => h2 @ i\n                | Func-id => {?hidden}\n                | Func-o => {?hidden}\n              }))) (id e.dom) = e.f", "completion": "\n  \\let f => id e.dom\n  \\in Jl (\\lam a'' q => (\n        \\let T => (\\lam (G : Ob) => NatTrans {C} {D} e.dom G) a''\n        \\in \\Pi (s' : T) -> transport (\\lam x => substitution_meta) q (trans {f}) = trans {s'} ->\n              transport (\\lam (G : Ob) => NatTrans {C} {D} e.dom G) q f = {T} s')) (\\lam _ h => ext h) (path (\\lam (i : I) => (\n        \\have arg => (\\lam (X : C.Ob) => isotoid {D1} {F {e.dom} X} {F {e.cod} X} (mapIso {C1} {D1} e X),\n                \\lam {X : C.Ob} {Y : C.Ob} (h : C.Hom X Y) =>\n                transport_Hom_iso {D1} (mapIso {C1} {D1} e X) (mapIso {C1} {D1} e Y) {Func {e.dom} {X} {Y} h} {Func {e.cod} {X} {Y} h}\n                  (natural {e.f} {X} {Y} h))\n          \\in \n                \\let | T1 => \\lam (x1 : C.Ob -> D.Ob) (x2 : C.Ob) (x3 : C.Ob) => D.Hom (x1 x2) (x1 x3)\n                     | T2 => C.Ob\n                     | T3 => C.Ob\n                     | T4 => C.Hom\n                     | h1 => path (\\lam (i : I) (o : C.Ob) => arg.1 o @ i)\n                     | l => e.dom\n                     | _ => pathOver {\\lam (i : I) => \\Pi {X Y : C.Ob} -> C.Hom X Y -> D.Hom (arg.1 X @ i) (arg.1 Y @ i)} {l.Func} {Func {e.cod}}\n                       (\\case F {e.cod}, h1, Func {e.cod}, arg.2 \\with {\n                         | r1, idp, f, a => path (\\lam (i : I) {X : C.Ob} {Y : C.Ob} (y3 : T4 X Y) => a {X} {Y} y3 @ i)\n                       })\n                \\in \\new Functor C1 D1 (\\lam (o : C.Ob) => arg.1 o @ i) {\n                      | Func => concat {\\lam (i : I) => \\Pi {X Y : C.Ob} -> C.Hom X Y -> D.Hom (arg.1 X @ i) (arg.1 Y @ i)} {l.Func}\n                        {coe (\\lam (i : I) => \\Pi {X Y : C.Ob} -> C.Hom X Y -> D.Hom (arg.1 X @ i) (arg.1 Y @ i)) l.Func right} {Func {e.cod}}\n                        (idpOver (\\lam (i : I) => \\Pi {X Y : C.Ob} -> C.Hom X Y -> D.Hom (arg.1 X @ i) (arg.1 Y @ i)) l.Func)\n                        (\\case F {e.cod}, h1, Func {e.cod}, arg.2 \\with {\n                          | r1, idp, f, a => path (\\lam (i : I) {X : C.Ob} {Y : C.Ob} (y3 : T4 X Y) => a {X} {Y} y3 @ i)\n                        }) @ i\n                      | Func-id => {?hidden}\n                      | Func-o => {?hidden}\n                    }))) e.f (simp_coe (\\lam X => transport_iso (mapIso e X)))"}
{"prompt": "['J : DecSet', 'j : J.E', \"l' : Array (\\\\Sigma R.E J.E)\", 'R : Semiring', 'l : Array (\\\\Sigma R.E J.E) n']<<<break>>>['\\\\func count \\\\hlevels  {R : Semiring} {J : DecSet} (l : Array (\\\\Sigma R.E J.E)) (j : J.E) : R.E \\n=> BigSum {R} (map {\\\\Sigma R.E J.E} {R.E} (\\\\lam (p0 : \\\\Sigma R.E J.E) => p0.1)\\n  (keep {\\\\Sigma R.E J.E} {\\\\lam (s : \\\\Sigma R.E J.E) => j = s.2} (\\\\lam (s : \\\\Sigma R.E J.E) => J.decideEq j s.2) l))', '| \\\\infixl 6 + E E : E', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '| E : \\\\Set', \"\\\\lemma count_++ \\\\hlevels  {R : Semiring} {J : DecSet} {l l' : Array (\\\\Sigma R.E J.E)} {j : J.E} :\\n  count {R} {J} (l ++ l') j = count {R} {J} l j R.+ count {R} {J} l' j \"]<<<break>>>count {R} {J} (l ++ l') j = count {R} {J} l j R.+ count {R} {J} l' j", "completion": "count_++ {R} {J}"}
{"prompt": "['S : FinSet', 'T : FinSet']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', '\\\\lemma ret_inl-lem \\\\plevels  \\\\hlevels  {n m : Nat} (i : Fin n) : f {n} {m} (fin-inc {n} {m} i) = inl {Fin n} {Fin m} i ', '\\\\func ret_f {n2 m3 : Nat} (i2 : Fin (n2 AddMonoid.+ m3)) : ret {n2} {m3} (f {n2} {m3} i2) = i2 \\n  | {0}, {m}, i => idp {Fin (0 AddMonoid.+ m)} {i}\\n  | {suc n}, {m}, zero => idp {Fin (suc n AddMonoid.+ m)} {0}\\n  | {suc n}, {m}, suc i => \\\\case f {n} {m} i, idp {Or (Fin n) (Fin m)} {f {n} {m} i} \\\\with {\\n    | inl s, p => \\n      \\\\have q => inv {Fin (n AddMonoid.+ m)} {ret {n} {m} (f {n} {m} i)} {fin-inc {n} {m} s}\\n              (pmap {Or (Fin n) (Fin m)} {Fin (n AddMonoid.+ m)} (ret {n} {m}) {f {n} {m} i} {inl {Fin n} {Fin m} s} p) *> ret_f {n} {m} i\\n      \\\\in \\\\case n, i, s, q \\\\with {\\n            | suc n, i, s, q =>\\n              pmap {Fin (suc n AddMonoid.+ m)} {Fin (suc (suc n AddMonoid.+ m))} (fsuc {suc n AddMonoid.+ m}) {fin-inc {suc n} {m} s} {i} q\\n          }\\n    | inr t, p => pmap {Fin (n AddMonoid.+ m)} {Fin (suc (n AddMonoid.+ m))} suc {fin-raise {m} {n} t} {i}\\n      (inv {Fin (n AddMonoid.+ m)} {ret {n} {m} (f {n} {m} i)} {fin-raise {m} {n} t}\\n        (pmap {Or (Fin n) (Fin m)} {Fin (n AddMonoid.+ m)} (ret {n} {m}) {f {n} {m} i} {inr {Fin n} {Fin m} t} p) *> ret_f {n} {m} i)\\n  }', '| finCard : Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma ret_inr-lem \\\\plevels  \\\\hlevels  {n m : Nat} (t : Fin m) : f {n} {m} (fin-raise {m} {n} t) = inr {Fin n} {Fin m} t ', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| B : \\\\Type', '\\\\func f {n2 m3 : Nat} (_ : Fin (n2 AddMonoid.+ m3)) : Or (Fin n2) (Fin m3) \\n  | {0}, {m}, i => inr {Fin 0} {Fin m} i\\n  | {suc n}, {m}, zero => inl {Fin (suc n)} {Fin m} 0\\n  | {suc n}, {m}, suc i => map {Fin n} {Fin m} {Fin (suc n)} {Fin m} (f {n} {m} i) (fsuc {n}) (id {Fin m})', '\\\\func aux {n m : Nat} : QEquiv {Fin (n + m)} {Or (Fin n) (Fin m)} (f {n} {m}) {\\n  | ret => ret {n} {m}\\n  | ret_f => ret_f {n} {m}\\n  | f_sec => \\\\lam (p0 : B {\\\\this}) => (\\\\case p0 \\\\with {\\n    | inl s => ret_inl-lem {n} {m} s\\n    | inr t => ret_inr-lem {n} {m} t\\n  })\\n} => \\\\new QEquiv', '\\\\func ret {n2 m2 : Nat} (_ : Or (Fin n2) (Fin m2)) : Fin (n2 + m2) \\n  | {n}, {m}, inl s => fin-inc {n} {m} s\\n  | {n}, {m}, inr t => fin-raise {m} {n} t']<<<break>>>QEquiv {Fin (S.finCard + T.finCard)} {Or (Fin S.finCard) (Fin T.finCard)} (f {S.finCard} {T.finCard}) {\n  | ret => ret {S.finCard} {T.finCard}\n  | ret_f => ret_f {S.finCard} {T.finCard}\n  | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n    | inl s => ret_inl-lem {S.finCard} {T.finCard} s\n    | inr t => ret_inr-lem {S.finCard} {T.finCard} t\n  })\n}", "completion": "aux {finCard {S}} {finCard {T}}"}
{"prompt": "[\"g : LinearMap {R} (ArrayLModule {R} l'.len (RingLModule R)) U {\\n  | func => \\\\lam (c : E {Dom {\\\\this}}) => BigSum {U} (\\\\new Array U.E l'.len (\\\\lam (j : Fin l'.len) => c.at j U.*c l'.at j))\\n}\", 'gf=id : \\\\Pi (x : U.E) -> g.func (f.func x) = x', 'e : U.E', 'U : LModule R', \"f : LinearMap {R} (\\\\new FinModule R U.E {\\n  | zro => U.zro\\n  | + => (U.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => U.negative\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c => (U.*c)\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | isFinModule => {?hidden}\\n}) (ArrayLModule {R} l'.len (RingLModule R))\"]<<<break>>>['| E : \\\\Set', '| func (E {Dom}) : E {Cod}']<<<break>>>g.func (f.func e) = e", "completion": "gf=id e"}
{"prompt": "['arg : (\\n  \\\\have _ => idp {L.E} {(p0.2 j).1.1}\\n  \\\\in ((p0.2 j).1.1, (p0.2 j).1.2)) = (\\n  \\\\have _ => idp {L.E} {(p0.2 j).1.1}\\n  \\\\in ((p0.2 j).1.1, (p0.2 j).2 L.<=\u2218 x.2))', 'j : J', 'L : Locale', 'x : Ob {C {\\\\this}}', 'i : I', 'J_g_x<=g_sg : \\\\Sigma (J : \\\\Set) (g : J -> ObOver {restrict {L} a} x) (isBasicCover x {J} g) (\\\\Pi (j : J) -> s.S {(g j).1} (g j).2)']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| \\\\infix 4 <= E E : \\\\Prop']<<<break>>>(arg @ i).1 L.<= x.1", "completion": "prop-dpi (\\lam i => ext_coe) (g j).2 (((g j).1.1, (g j).2 L.<=\u2218 x.2), (g j).2).2 @ i"}
{"prompt": "['lem : \\\\Pi {y : E} -> y + y <= a *q ide -> y <= ratio (pos 1) 2 * a *q ide', 'this : OrderedC*Algebra', '-x-x<=a : negative (x + x) <= a *q ide', 'a : Rat', 'x : E {\\\\this}']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', 'pos Nat', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| negative E : E', '| E : \\\\Set', '\\\\lemma negative_+ \\\\hlevels  {this : AddGroup} {x y : E} : negative (x + y) = negative y - x ']<<<break>>>negative x <= ratio (pos 1) 2 * a *q ide", "completion": "lem (transport (\\lam _x => _x <= {this} _) (negative_+ {this}) -x-x<=a)"}
{"prompt": "['f : FrameHom (PresentedFrame P) L', 'g : FrameHom (PresentedFrame P) L', 'h1 : f.func = g.func', 'P : FramePres', 'L : Locale']<<<break>>>['| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>Path (\\lam (i : I) => \\Pi {x y : E} -> (@) h1 i (x \u2227 y) = (@) h1 i x L.\u2227 (@) h1 i y) f.func-meet g.func-meet", "completion": "prop-dpi (\\lam i => ext_coe) (func-meet {f}) (func-meet {g})"}
{"prompt": "['q : (d !! (f1 i).1).1 = V.zro', 'Pe : Equiv {Fin P.finCard} {P.E}', 'V : PosetQModule', 'f1 : \\\\Pi (i : Fin b.len) -> \\\\Sigma (j : Fin d.len) ((b !! i).1 = (d !! j).1) ((b !! i).2 B.<= (d !! j).2)', 'b : PFunc {V} {B}', 'i : Fin b.len', 'd : PFunc {V} {B}', 'P : FinSet (\\\\Sigma (i : E) E) {\\n  | finCard => FinSum {NatSemiring} {ProdFin (FinFin b.len) (FinFin c.len)} (\\\\lam (i : E) => finCard)\\n}', 'c : PFunc {V} {B}', 'B : BooleanRing']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'byLeft A', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| finCard : Nat', '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| zro : E', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| \\\\infixl 7 * E E : E', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>((b !! i).1 = V.zro) || (b !! i).2 B.<= BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (\\new Array (\\Sigma V.E B.E) P.finCard\n  (\\lam (j : Fin P.finCard) => ((b.at (Pe.f j).1.1).1, (b.at (Pe.f j).1.1).2 B.* (c.at (Pe.f j).1.2).2))))", "completion": "byLeft ((f1 i).2 *> q)"}
{"prompt": "['this : OrderedC*Algebra', 'b : E', 'a : E']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| \\\\infixl 7 * E E : E', '\\\\lemma negative<=0 \\\\hlevels  {this : PosetAddGroup} {x : E} (_ : zro <= x) : negative x <= zro ', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma *q_>=0 \\\\hlevels  {this : PosetQModule} {q : Rat} (_ : zro <= q) {a : E} (_ : zro <= a) : zro <= q *q a ', '\\\\lemma zro<=ide \\\\hlevels  {this : OrderedC*Algebra} : zro <= ide ', '| negative E : E', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| <=-refl {x : E} : x <= x', '| ide : E', '| zro-right {x : E} : x + zro = x', '\\\\func norm {this1 : OrderedC*Algebra} (a : E) :\\n  ExUpperReal (\\\\lam (q : Rat) => TruncP (\\\\Sigma (r : Rat) (r < q) (zro < r) (a <= r *q ide) (negative a <= r *q ide))) \\n=> \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', '| c*-square-positive {a : E} : zro <= a * a', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| U Rat : \\\\Prop', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>norm (a * a) <= norm (a * a + b * b)", "completion": "\\lam {d} p0 => (\\case \\elim p0 \\with {\n  | inP (c, c<d, c>0, aa+bb<=c, _) => inP (c, c<d, c>0,\n    =_<= (inv (zro-right {this})) <=\u2218 {this} <=_+ {this} (<=-refl {this}) (c*-square-positive {this}) <=\u2218 {this} aa+bb<=c,\n    negative<=0 {this} (c*-square-positive {this}) <=\u2218 {this} *q_>=0 {this} (<=-less c>0) (zro<=ide {this}))\n})"}
{"prompt": "['Y : TopSpace', 'this : TopSpace (\\\\Sigma X.E Y.E) {\\n  | isOpen => \\\\lam (W : Set (E {\\\\this})) =>\\n  \\\\Pi {s : E {\\\\this}} -> W s -> TruncP (\\\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\\n    (\\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)))\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}', 'X : TopSpace']<<<break>>>['| top : E', '| isOpen (Set E) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| open-top : isOpen top', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {s : E {\\this}} -> top s -> TruncP (\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\n  (\\Pi {x : X.E} -> U x -> \\Pi {y : Y.E} -> V y -> top (x, y)))", "completion": "\\lam _ => inP (top, open-top, (), top, open-top, (), \\lam _ _ => ())"}
{"prompt": "['this : PseudoMetricSpace', 'x : E', 'eps : Rat']<<<break>>>['| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| U Rat : \\\\Prop', '| dist E E : ExUpperReal', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'inP A', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'pos Nat']<<<break>>>TruncP (\\Sigma (U1 : Set E)\n  ((\\lam (U1 : Set E) => TruncP (\\Sigma (x : E) (U1 = (\\lam (y : E) => U {dist x y} (eps * ratio (pos 1) 8))))) U1)\n  (\\Pi {y : E} -> U {dist x y} (eps * ratio (pos 1) 8) -> U1 y))", "completion": "inP (later (_, inP (x, idp), \\lam d => d))"}
{"prompt": "['R : CRing', 'this : RingHom (MPoly (Fin (suc n)) R) (PolyRing (MPoly (Fin n) R)) {\\n  | func => f {n} {R}\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', 'n : Nat']<<<break>>>[\"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", 'suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| Cod : BaseSet', 'padd (Poly R) R.E', '\\\\type PermSet \\\\hlevels  (A : \\\\Set) : \\\\Set => Quotient {Array A} (EPerm {A})', \"\\\\data EPerm {A : \\\\Type} (_ _ : Array A) \\\\with\\n  | {A}, nil, nil => eperm-nil\\n  | {A}, :: {n} x l1, :: {n} y l2 => eperm-:: (x = y) (EPerm {A} l1 l2)\\n  | {A}, :: {suc n} x (x' :: l1), :: {suc n} y (y' :: l2) => eperm-swap (x = y') (x' = y) (l1 = l2)\\n  | {A}, l1, l2 => eperm-trans {l : Array A} (EPerm {A} l1 l) (EPerm {A} l l2)\", 'pzero', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '| at (j : Fin len) : A j', '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', \"\\\\func pairs {A1 B1 C2 : \\\\Type} (_ : A1 -> B1 -> C2) (_ : Array A1) (_ : Array B1) : Array C2 \\n  | {A}, {B}, {C}, f, nil, l' => nil\\n  | {A}, {B}, {C}, f, :: {n} a l, l' => map {B} {C} (f a) l' ++ pairs {A} {B} {C} f l l'\", '| E : \\\\Set', '\\\\func func \\\\hlevels  {M : Monoid} {R : Semiring} (s t : \\\\Sigma R.E M.E) : \\\\Sigma R.E M.E => (s.1 R.* t.1, s.2 M.* t.2)', '\\\\func MPoly \\\\hlevels  (J : \\\\Set) (R1 : CRing) : CAlgebra R1 (MonoidSet E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E E)} {(~)} nil\\n  | + => (+)\\n  | negative => negative {E} {R1}\\n  | *c => \\\\lam (x : E {R}) => (Semigroup.*) (func {monoidRingHom {PermSetMonoid J} {R1}} x)\\n  | * => (MonoidSemiring.*)\\n  | ide => in~ {Array (\\\\Sigma R.E E)} {(~)} ((R.ide, ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring (PermSetMonoid J) R1}\\n  | coefMap => coefMap-impl\\n} => MonoidAlgebra (PermSetMonoid J) R1', 'in~ A', '| len : Nat', '\\\\instance MonoidAlgebra \\\\hlevels  (M : CMonoid) (R1 : CRing) : CAlgebra R1 (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | negative => negative {M.E} {R1}\\n  | *c => \\\\lam (x : E {R}) => (Semigroup.*) (func {monoidRingHom {M} {R1}} x)\\n  | * => (MonoidSemiring.*)\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | coefMap => coefMap-impl\\n} => homAlgebra {R1} {\\\\new CRing (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (MonoidSemiring.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => negative {M.E} {R1}\\n  | negative-left => {?hidden}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}} (monoidRingHom {M} {R1})', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| ide-left {x : E} : ide * x = x', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\"]<<<break>>>padd {MonoidAlgebra (PermSetMonoid (Fin n)) R} (pzero {MonoidAlgebra (PermSetMonoid (Fin n)) R}) (in~ {Array (\\Sigma R.E E)} {(~)} ((R.ide R.* R.ide, in~ {Array (Fin n)} {EPerm {Fin n}} nil) :: nil)) = ide {Cod {\\this}}", "completion": "transport (\\lam x0 => substitution_meta) (inv (path ((@) (R.ide-left {R.ide})))) idp"}
{"prompt": "['N : \\\\Set', 'g : AddMonoidHom']<<<break>>>['\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class AbMonoid \\\\extends AddMonoid \\\\hlevels  {\\n  | +-comm {x y : E} : x + y = y + x\\n}', '\\\\type MonoidSet \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : \\\\Set => Quotient {Array (\\\\Sigma R.E M)} (~)', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '| Cod : BaseSet', '| E : \\\\Set', '\\\\instance MonoidAbMonoid \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : AbMonoid (MonoidSet M R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M)} {(~)} nil\\n  | + => (MonoidAbMonoid.+)\\n} => \\\\new AbMonoid {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n}', \"\\\\func + {M3 : \\\\Set} {R3 : AddMonoid} (_ _ : MonoidSet M3 R3) : MonoidSet M3 R3 \\n  | {M}, {R}, in~ l, in~ l' => in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l')\\n  | {M}, {R}, in~ l, ~-equiv l1 l2 r i =>\\n  monoidSet-ext {M} {R} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l1)} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l2)}\\n    (~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l ++ l1} {l1 ++ l}\\n      (~-perm {M} {R} {l ++ l1} {l1 ++ l} (eperm-++-comm {\\\\Sigma R.E M} {l} {l1})) *> ~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l1 ++ l} {l2 ++ l} (~_++-left {M} {R} {l1} {l2} {l} r) *> ~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l2 ++ l} {l ++ l2}\\n      (~-perm {M} {R} {l2 ++ l} {l ++ l2} (eperm-++-comm {\\\\Sigma R.E M} {l2} {l}))) @ i\\n  | {M}, {R}, ~-equiv l1 l2 r i, in~ l' =>\\n  monoidSet-ext {M} {R} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l1 ++ l')} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l2 ++ l')}\\n    (~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l1 ++ l'} {l2 ++ l'} (~_++-left {M} {R} {l1} {l2} {l'} r)) @ i\", 'in~ A']<<<break>>>AbMonoid (MonoidSet N g.Cod) {\n  | zro => in~ {Array (\\Sigma (E {g.Cod}) N)} {(~)} nil\n  | + => (+)\n}", "completion": "MonoidAbMonoid N (Cod {g})"}
{"prompt": "['q>0 : zro < q', 'a : E', 'this : PosetQModule', 'q : Rat', 'qa>=0 : zro <= q *q a']<<<break>>>['| zro : E', '\\\\lemma finv>0 {this : DiscreteOrderedField} {x : E} (_ : zro < x) : zro < finv x ', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\lemma *q_>=0 \\\\hlevels  {this : PosetQModule} {q : Rat} (_ : zro <= q) {a : E} (_ : zro <= a) : zro <= q *q a ', '| finv E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2']<<<break>>>zro <= finv q *q (q *q a)", "completion": "*q_>=0 {this} (<=-less $ finv>0 {RatField} q>0) qa>=0"}
{"prompt": "['n : Nat', 'y : R.E', 'x : R.E', 'R : CRing']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', 'suc Nat', '| natCoef Nat : E', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func \\\\infixl 6 - \\\\plevels  \\\\hlevels  (_ _ : Nat) : Int \\n  | 0, m => neg m\\n  | n, 0 => pos n\\n  | suc n, suc m => n - m', '\\\\func binom \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | n, 0 => 1\\n  | 0, i => 0\\n  | suc n, suc i => binom n i + binom n (suc i)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>Array R.E (suc (suc n))\n  (\\lam (i : Fin (suc (suc n))) => R.natCoef (binom n i) R.* (pow {R} x i R.* pow {R} y (iabs (suc n - i))))", "completion": "\\new DArray {suc (suc n)} (\\lam _ => R) (\\lam i => natCoef (binom n i) * (pow x i * pow y (iabs (suc n - i))))"}
{"prompt": "['this : AbGroup', 'n : Nat', 'b : E', 'a : E']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\lemma *n-ldistr \\\\hlevels  {this : AbMonoid} {n : Nat} {a b : E} : n *n (a + b) = n *n a + n *n b ', '| negative E : E', '| E : \\\\Set', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a']<<<break>>>n *n (a + negative b) = n *n a + n *n negative b", "completion": "*n-ldistr {this}"}
{"prompt": "['Y : CoverSpace', 'X : \\\\Set', 'f : X -> Y.E', 'C : Set (Set (E {\\\\this}))']<<<break>>>['| cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))', '\\\\func PrecoverTransfer \\\\hlevels  {X : \\\\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>isCauchy C -> \\Pi {D : Set E -> Set (Set E)} -> (\\Pi {U : Set E} -> C U -> isCauchy (D U)) ->\n  isCauchy (\\lam (U : Set E) => TruncP (\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))", "completion": "cauchy-glue {PrecoverTransfer f}"}
{"prompt": "['c : E {C}', 'this : AlgData', 'm : List (Fin (len {vars {mData}}))', 'a : \\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})', 'l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 6 + E E : E', '| C : Semiring', '| R : Semiring', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\func collapse1 \\\\hlevels  {this2 : AlgData} (_ : List (Fin (len {vars {mData}}))) (_ : E {C})\\n  (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n  | {this}, m, c, nil => (m, c) :: nil {\\\\Sigma (List (Fin (len {vars}))) (E {C})}\\n  | {this}, m, c, a' :: l => \\\\case decideEq m a'.1 \\\\with {\\n    | yes p => collapse1 a'.1 (c + a'.2) l\\n    | no n => (m, c) :: collapse1 a'.1 a'.2 l\\n  }\", '\\\\lemma cons \\\\hlevels  {this : BaseData} (x : \\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))\\n  (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  interpretRingNF (x :: l) = func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l ', '| \\\\infixl 7 * E E : E', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '| alg : SemiringHom C R', '\\\\func interpretNF \\\\hlevels  {this3 : MonoidData} (_ : List (Fin (len {vars}))) : E {M} \\n  | {this}, nil => ide {M}\\n  | {this}, x :: nil => at {vars} x\\n  | {this}, x :: l => at {vars} x * interpretNF l', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma collapse1-consistent \\\\hlevels  {this : AlgData} (m : List (Fin (len {vars {mData}}))) (c : E {C})\\n  (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  func {alg} c * interpretNF {mData} m + interpretRingNF l = interpretRingNF (collapse1 m c l) ', '\\\\instance LexicographicalList \\\\hlevels  (A : LinearOrder.Dec) : LinearOrder.Dec (List A.E) {\\n  | < => (<L)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case LinearOrder.Dec.trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y}\\n      (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => LexicographicalList.trichotomy {A}\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| vars : Array (E {M})', '\\\\field mData : MonoidData {R} vars', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| rdistr {x y z : E} : (x + y) * z = x * z + y * z', '| func (E {Dom}) : E {Cod}', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>func {alg} c * interpretNF {mData} m + interpretRingNF (a :: l) = interpretRingNF (\\case decideEq m a.1 \\with {\n  | yes p => collapse1 a.1 (c + a.2) l\n  | no n => (m, c) :: collapse1 a.1 a.2 l\n})", "completion": "\\case decideEq m a.1 \\as d : case_return_arg_1_1 \\return (\\lam (l1 : List (\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) =>\n  func {alg} c * interpretNF {mData} m + interpretRingNF (a :: l) = interpretRingNF l1) case_return_arg_1 \\with {\n  | yes p => rewrite (cons {this}) $ inv +-assoc *> pmap (\\lam _x => _x + interpretRingNF {this} l)\n    (pmap (\\lam p0 => alg {this} c * interpretNF {mData {this}} p0 + _) p *> inv (pmap (\\lam _x => _x * _) (func-+ {alg {this}}) *> rdistr)) *> collapse1-consistent a.1 (c + a.2) l\n  | no _ => repeat {2} (rewrite (cons {this})) (pmap ((+) _) (collapse1-consistent a.1 a.2 l))\n}"}
{"prompt": "[]<<<break>>>['\\\\func squeeze \\\\plevels  \\\\hlevels  (i j : I) : I ', '| A : \\\\Type', 'left', \"\\\\class Contr {\\n  | A : \\\\Type\\n  | center : A\\n  | contraction (a' : A) : center = a'\\n}\"]<<<break>>>Contr I left (\\lam (i : A {\\this}) => path (squeeze i))", "completion": "\\new Contr {\n  | A => I\n  | center => left\n  | contraction => \\lam i => path (squeeze i)\n}"}
{"prompt": "['this : CatEquiv', 'Y : Ob {C {\\\\this}}']<<<break>>>['| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| hinv : Hom {C} cod dom', '| LAdj : Functor D C', '| D : Precat', '| f : Hom {C} dom cod', '\\\\func Func-iso \\\\plevels obj >= hom \\\\hlevels  {this1 : Functor} (e : Iso {C}) : Iso {D} {F e.dom} {F e.cod} (Func {e.dom} {e.cod} e.f) {\\n  | hinv => Func {e.cod} {e.dom} e.hinv\\n} => \\\\new Iso {\\n  | hinv_f => {?hidden}\\n  | f_hinv => {?hidden}\\n}', '| dom : Ob {C}', '\\\\class Iso \\\\extends SplitMono \\\\plevels obj >= hom \\\\hlevels  {\\n  | f_hinv : f \u2218 hinv = id {C} cod\\n}', '| F (Ob {C}) : Ob {D}', '| cod : Ob {C}', '\\\\field eta-iso {X : Ob {D}} : Iso {D} {X} {F (F {LAdj} X)} (trans {eta} X)']<<<break>>>Iso {D {LAdj}} {F {LAdj} (dom {eta-iso {Y}})} {F {LAdj} (cod {eta-iso {Y}})}\n  (Func {LAdj} {dom {eta-iso {Y}}} {cod {eta-iso {Y}}} (f {eta-iso {Y}})) {\n  | hinv => Func {LAdj} {cod {eta-iso {Y}}} {dom {eta-iso {Y}}} (hinv {eta-iso {Y}})\n}", "completion": "Func-iso {LAdj {this}} (eta-iso {this})"}
{"prompt": "['this : Dec', 'ac : \\\\Pi (i : Nat) -> TruncP (LDiv {DivQuotientMonoid this} (a (suc i)) (a i))', \"f : MonoidHom (DivQuotientMonoid (cStruct subMonoid)) (DivQuotientMonoid this) {\\n  | func => Quotient.map {E} {E} (func {embedMonoid {subMonoid}}) {(~)} {(~)} (\\\\lam {a a' : E} (p : a ~ a') =>\\n    (TruncP.map {LDiv {cStruct subMonoid} a' a} {LDiv (func {embedMonoid {subMonoid}} a') (func {embedMonoid {subMonoid}} a)} p.1\\n      (func-LDiv {embedMonoid {subMonoid}} {a'} {a}),\\n      TruncP.map {LDiv {cStruct subMonoid} a a'} {LDiv (func {embedMonoid {subMonoid}} a) (func {embedMonoid {subMonoid}} a')} p.2\\n        (func-LDiv {embedMonoid {subMonoid}} {a} {a'})))\\n}\", 'n : Nat', 'q : Not (TruncP (\\\\Sigma (e : E) (a (suc e) = in~ {E} {(~)} zro)))', 'a : Nat -> E', 'r : \\\\Pi (n : Nat) -> Not (TruncP (\\\\Sigma (j : Fin (suc (suc n))) (a (suc j) = in~ {E} {(~)} zro))) ->\\n  \\\\Sigma (x : DivQuotient nonZeroCMonoid) (f.func x = a (suc n))']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func DivPreoder \\\\hlevels  (M : CMonoid) : Preorder M.E {\\n  | <= => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => TruncP (LDiv {M} y x)\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', '| zro#ide : #0 ide', '| \\\\infix 8 #0 E : \\\\Prop', \"\\\\func map \\\\hlevels  {M N : CMonoid} (f : MonoidHom M N) : MonoidHom (DivQuotientMonoid M) (DivQuotientMonoid N) {\\n  | func => Quotient.map {M.E} {N.E} f.func {(~)} {(~)}\\n    (\\\\lam {a a' : M.E} (p : a ~ a') => (TruncP.map {LDiv {M} a' a} {LDiv {N} (f.func a') (f.func a)} p.1 (func-LDiv {f} {a'} {a}),\\n      TruncP.map {LDiv {M} a a'} {LDiv {N} (f.func a) (f.func a')} p.2 (func-LDiv {f} {a} {a'})))\\n} => \\\\new MonoidHom {\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}\", 'suc Nat', 'inP A', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\func nonZeroCMonoid \\\\hlevels  {this1 : IntegralDomain} : CancelCMonoid (\\\\Sigma (x : E) (#0 x)) {\\n  | ide => (ide, zro#ide)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, #0-* {x.1} {y.1} x.2 y.2)\\n} => \\\\new CancelCMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | cancel_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', 'no (Not E)', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '\\\\func EquivRel \\\\hlevels  {this2 : Preorder} : Equivalence E {\\n  | ~ => \\\\lam (x : A {\\\\this}) (y : A {\\\\this}) => \\\\Sigma (x <= y) (y <= x)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', \"\\\\func transport2 {A B : \\\\Type} (C : A -> B -> \\\\Type) {a a' : A} {b b' : B} (_ : a = a') (_ : b = b') (_ : C a b) : C a' b' \\n  | {A}, {B}, C, {a}, {a'}, {b}, {b'}, idp, idp, c => c\", 'in~ A', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\instance DivQuotientMonoid \\\\hlevels  (M : CMonoid) : OrderedCMonoid (DivQuotient M) {\\n  | <= => (<=C)\\n  | ide => inD {M} M.ide\\n  | * => (*')\\n} => \\\\new OrderedCMonoid {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | <=_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| ide : E', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\func embedMonoid \\\\hlevels  {this2 : SubMonoid} : MonoidHom IMonoid S {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} => \\\\new MonoidHom {\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func subMonoid \\\\hlevels  {this1 : Domain} : SubMonoid this1 #0 => \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma divQuotient_LDiv \\\\hlevels  {this : IntegralDomain} {x y : DivQuotient nonZeroCMonoid} :\\nTruncP (LDiv {DivQuotientMonoid this} (func {map {nonZeroCMonoid} (embedMonoid {subMonoid})} x)\\n  (func {map {nonZeroCMonoid} (embedMonoid {subMonoid})} y)) <-> TruncP (LDiv {DivQuotientMonoid nonZeroCMonoid} x y) ', '| func (E {Dom}) : E {Cod}']<<<break>>>(\\lam (x : Dec (TruncP (\\Sigma (e : E) (a (suc e) = in~ {E} {(~)} zro)))) =>\nTruncP (LDiv {DivQuotientMonoid nonZeroCMonoid} (r (suc n) q).1 (\\case x \\with {\n  | yes e => in~ {E} {(~)} (ide, zro#ide)\n  | no q => (r n q).1\n}))) (no {TruncP (\\Sigma (e : Fin (suc (suc n))) (a (suc e) = in~ {E} {(~)} zro))} q)", "completion": "\\case ac (suc n) \\with {\n  | inP d => (divQuotient_LDiv {this}).1 $ inP $ transport2 LDiv (inv (r (suc n) q).2) (inv (r n (\\lam p => q p)).2) d\n}"}
{"prompt": "['this : CatEquiv']<<<break>>>['\\\\field epsilon-iso {Y : Ob {C}} : Iso {C} {F {LAdj} (F Y)} {Y} (trans {epsilon} Y)', '| LAdj : Functor D C', '| Ob : \\\\hType', '| C : Precat', '\\\\class Iso \\\\extends SplitMono \\\\plevels obj >= hom \\\\hlevels  {\\n  | f_hinv : f \u2218 hinv = id {C} cod\\n}', '| F (Ob {C}) : Ob {D}', '| epsilon : NatTrans {C} {C} (Comp {C} {D} {C} LAdj (\\\\new \\\\this {})) (Id {C})', '| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)']<<<break>>>\\Pi {Y : Ob {C}} -> Iso {C} {F {LAdj} (F Y)} {Y} (trans {epsilon} Y)", "completion": "epsilon-iso {this}"}
{"prompt": "['i : Fin (suc n)', 'i=j : i = j', 'm : Nat', 'j : Fin (suc m)']<<<break>>>['suc Nat', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '| E : \\\\Set', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ']<<<break>>>i < suc m", "completion": "rewrite i=j (fin_< j)"}
{"prompt": "['this : FrameHom']<<<break>>>['\\\\data Empty \\\\plevels  \\\\hlevels  ', '| Join {J : \\\\Set} (J -> E) : E', '| func-Join {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\\\lam (j : J) => func (f j))', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ']<<<break>>>func (Join {Dom} {Empty} (absurd {E {Dom}})) = Join {Cod} {Empty} (\\lam (j : Empty) => func (absurd {E {Dom}} j))", "completion": "func-Join {this}"}
{"prompt": "['n : Nat']<<<break>>>[\"\\\\lemma <=_exists \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n <= m) : n + (m -' n) = m \", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\lemma id<pow2 \\\\plevels  \\\\hlevels  {n : Nat} : n < pow {NatSemiring} 2 n ', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>n + (pow {NatSemiring} 2 n -' n) = pow {NatSemiring} 2 n", "completion": "<=_exists (<=-less {NatSemiring} id<pow2)"}
{"prompt": "['r : x ~ y', 'x : \\\\Sigma (_ y : M.E) (S.contains y)', 'y : \\\\Sigma (_ y : M.E) (S.contains y)', 'M : PosetAbMonoid', 'a : \\\\Sigma (_ y : M.E) (S.contains y)', 'S : SubAddMonoid M']<<<break>>>['| M : \\\\Set', '| \\\\infixl 6 + E E : E', '| interpretNF {n : Nat} (Fin n -> M) (NF n) : M', '\\\\lemma apply-axiom \\\\hlevels  {A : AbMonoid} (env : Array A.E) (t s : Term env.len)\\n  (_ : interpret {toCMonoid A} {env.len} env.at t = interpret {toCMonoid A} {env.len} env.at s) (n : Nat)\\n  (add : List (Fin env.len)) : interpretNF {toCMonoid A} {Fin env.len} env.at\\n  (sort {FinOrder env.len} (iterr {List (Fin env.len)} ((++) (normalize {env.len} t)) n add)) = interpretNF {toCMonoid A} {Fin env.len} env.at\\n  (sort {FinOrder env.len} (iterr {List (Fin env.len)} ((++) (normalize {env.len} s)) n add)) ', 'nil', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '\\\\infixl 7 :* (_ _ : Term n)', '| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)', '| at (j : Fin len) : A j', '\\\\lemma terms-equality \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s)) :\\n  interpret {env.len} env.at t = interpret {env.len} env.at s ', '| normalize {n : Nat} (Term n) : NF n', '| E : \\\\Set', 'var (Fin n)', '| contains (E {S}) : \\\\Prop', \"\\\\func transport2 {A B : \\\\Type} (C : A -> B -> \\\\Type) {a a' : A} {b b' : B} (_ : a = a') (_ : b = b') (_ : C a b) : C a' b' \\n  | {A}, {B}, C, {a}, {a'}, {b}, {b'}, idp, idp, c => c\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| <=-refl {x : E} : x <= x', '\\\\func AbMonoidSolverModel \\\\hlevels  (A : AbMonoid) : SolverModel E {\\n  | Term => Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => normalize\\n  | interpret => interpret {toCMonoid A}\\n  | interpretNF => \\\\lam {n : Nat} (env : Fin n -> M {\\\\this}) (nf : NF {\\\\this} n) => interpretNF {toCMonoid A} {Fin n} env (sort {FinOrder n} nf)\\n} => CMonoidSolverModel (toCMonoid A)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| S : BaseSet', '\\\\infixr 5 :: A (List A)', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>TruncP (\\Sigma (c : E {S.S}) (S.contains c) (y.1 M.+ a.2 M.+ c M.<= y.2 M.+ a.1 M.+ c)) ->\n  TruncP (\\Sigma (c : E {S.S}) (S.contains c) (x.1 M.+ a.2 M.+ c M.<= x.2 M.+ a.1 M.+ c))", "completion": "\\lam p0 => (\\case \\elim p0 \\with {\n  | inP (c, Sc, q) =>\n    inP (y.2 + c, contains_+ {S} y.3 Sc, transport2 ((<=) {M}) (abMonoid {r}) abMonoid $ <=_+ q $ <=-refl {M} {x.2})\n})"}
{"prompt": "['this : Product', 'f : B {\\\\this}', 'p0 : J', 'Z : Ob {D}']<<<break>>>['| D : Precat', '| proj (j : J) : Hom {D} apex (G j)', '| apex : Ob {D}', '| Hom Ob Ob : \\\\Set', '| tupleBeta {Z : Ob {D}} {f : \\\\Pi (j : J) -> Hom {D} Z (G j)} {j : J} : proj j \u2218 tupleMap {Z} f = f j', '| G J : Ob {D}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| tupleMap {Z : Ob {D}} (\\\\Pi (j : J) -> Hom {D} Z (G j)) : Hom {D} Z apex']<<<break>>>proj p0 \u2218 tupleMap {Z} f = f p0", "completion": "tupleBeta {Z} {f} p0"}
{"prompt": "['n : Nat', 'p : neg (suc m) = (divMod x (pos (suc n))).2', 'm : Nat', 'x : Int']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| <=-refl {x : E} : x <= x', 'suc Nat', '\\\\lemma pos_iabs \\\\plevels  \\\\hlevels  {x y : Nat} (_ : y <= x) : pos (iabs (x - y)) = x - y ', '| divMod E E : \\\\Sigma E E', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| \\\\infix 4 <= E E : \\\\Prop', 'neg Nat  {\\n  | 0 => pos 0\\n}', '\\\\func \\\\infixl 6 - \\\\plevels  \\\\hlevels  (_ _ : Nat) : Int \\n  | 0, m => neg m\\n  | n, 0 => pos n\\n  | suc n, suc m => n - m', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\lemma signum_neg/=1 \\\\plevels  \\\\hlevels  {n : Nat} (_ : signum (neg n) = pos 1) : Empty ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\lemma intMod<right \\\\plevels  \\\\hlevels  (x : Int) (n : Nat) : iabs (divMod x (pos (suc n))).2 < suc n ', '\\\\instance IntEuclidean \\\\hlevels  : EuclideanRingData Int {\\n  | zro => pos 0\\n  | + => (+)\\n  | * => (IntRing.*)\\n  | ide => pos 1\\n  | natCoef => pos\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => iabs\\n  | divMod => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\n    \\\\let! (d, m) => Nat.divMod (iabs x) (iabs y)\\n    \\\\in (pos d Semigroup.* signum y Semigroup.* signum x, pos m Semigroup.* signum x))\\n  | negative => negative\\n} => \\\\new EuclideanRingData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n  | negative-left => {?hidden}\\n}', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>pos (iabs (suc n - iabs (neg (suc m)))) <= pos n", "completion": "transportInv\n(\\lam _x => _x <= pos n) (pos_iabs (<=-less (transportInv (\\lam _x => _x < suc n) (pmap iabs p) (intMod<right x n))))\n  (<=_+ {IntRing} {pos n} {n} {neg m} {0} <=-refl (\\lam p0 => signum_neg/=1 p0))"}
{"prompt": "['M : \\\\Set', \"l'' : Array (\\\\Sigma R.E M)\", 'R : AddGroup']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func func \\\\hlevels  {M : \\\\Set} {R : AddGroup} (s : \\\\Sigma R.E M) : \\\\Sigma R.E M => (R.negative s.1, s.2)', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>Array (\\Sigma R.E M) l''.len (\\lam (i : Fin l''.len) => func {M} {R} (l''.at i))", "completion": "map func l''"}
{"prompt": "['d : Rat']<<<break>>>['| \\\\infixl 7 * E E : E', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| ide-right {x : E} : x * ide = x']<<<break>>>d * ide {RatField} <= d", "completion": "=_<= ide-right"}
{"prompt": "[\"p : V = mkSet {X} V'\", 'F : RegularCauchyFilter X', 'V : Set (RegularCauchyFilter X)', 'X : UniformSpace', 'VF : V F', \"V' : Set X.E\"]<<<break>>>[\"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\func mkSet \\\\hlevels  {X : CoverSpace} (U : Set X.E) : Set (RegularCauchyFilter X) => \\\\lam (F1 : RegularCauchyFilter X) => F.F U']<<<break>>>mkSet {X} V' F", "completion": "rewrite p VF"}
{"prompt": "['a1 : L.E', 'L : Locale', 'a2 : L.E', 'M : Locale']<<<break>>>['\\\\func FrameUnitalReflectiveSubcat : ReflectiveSubPrecat FrameCat FrameUPresCat FrameUnitalSubcat.F {\\n  | Func => FrameUnitalSubcat.Func\\n  | reflector => reflector\\n  | reflectorMap => \\\\lam (X : Ob {D {\\\\this}}) => \\\\new FrameUPresHom X (Functor.F {\\\\this} (reflector {\\\\this} X)) {\\n    | func => embed {X}\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | isReflective => \\\\lam {X : Ob {D {\\\\this}}} {Y : Ob {C {\\\\this}}} =>\\n  \\\\new QEquiv {Hom {C {\\\\this}} (reflector {\\\\this} X) Y} {Hom {D {\\\\this}} X (Functor.F {\\\\this} Y)}\\n    (\\\\lam (p0 : A {\\\\this}) => Functor.Func {\\\\this} {reflector {\\\\this} X} {Y} p0 \u2218 ReflectiveSubPrecat.reflectorMap {\\\\this} X) {\\n    | ret => ret {isReflective {X} {Y}}\\n    | ret_f => ret_f {isReflective {X} {Y}}\\n    | f_sec => \\\\lam (h : B {\\\\this}) => path (\\\\lam (i : I) => (\\n      \\\\have arg => path (\\\\lam (i : I) => func {f_ret {isReflective {X} {Y}} h @ i})\\n      \\\\in \\\\new FrameUPresHom X (Functor.F {\\\\this} Y) {\\n            | func => arg @ i\\n            | func-conj => {?hidden}\\n            | func-basicCover => {?hidden}\\n            | func-unit => {?hidden}\\n          }))\\n  }\\n} => \\\\new ReflectiveSubPrecat {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n}', '\\\\class Locale \\\\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\\\hlevels  {\\n  | Join-ldistr>= {J : \\\\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\\\lam (j : J) => e \u2227 f j)\\n  | basicCover-stable => \\\\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\\\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\\n    meet-univ {x} {Join {J} (\\\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\\\lam (j : J) => (g j).1} {x}\\n  | ldistr>= => \\\\lam {x : E} {y : E} {z : E} => (\\n    \\\\have t => path (\\\\lam (i : I) (b : Bool) => (\\\\case b \\\\with {\\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\\n          }) @ i)\\n    \\\\in transportInv\\n        {Bool -> E} (\\\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\\n          {\\\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\\\lam (b : Bool) => x \u2227 if {E} b y z} t\\n          (Join-ldistr>= {Bool} {\\\\lam (p0 : Bool) => if {E} p0 y z} {x}))\\n  | Meet-cond => \\\\lam {J : \\\\Set} (j : J) {f : J -> E} =>\\n  Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n    {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)\\n  | join-left => \\\\lam {x : E} {y : E} => Join-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | join-right => \\\\lam {x : E} {y : E} => Join-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | Meet-univ => \\\\lam {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) =>\\n  Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n    {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  | join-univ => \\\\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\\n  Join-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n    | true => x<=z\\n    | false => y<=z\\n  }))\\n  | join => \\\\lam (x : E) (y : E) => Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)\\n  | Meet => \\\\lam {J : \\\\Set} (g : J -> E) =>\\n    Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)\\n  | isBasicCover => \\\\lam (x : Ob) {J : \\\\Set} (g : J -> Ob) => x <= Join {J} (\\\\lam (j : J) => (g j).1)\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\instance colimit-obj {J : Precat} (G : Functor J FrameUPresCat) : FrameUPres (FTerm {J} G) {\\n  | conj => fconj {J} {G}\\n  | BasicCover => \\\\lam {K : \\\\Set} (x : E {\\\\this}) (f : K -> E {\\\\this}) =>\\n  (\\\\Sigma (j : J.Ob) (y : E {G.F j}) (g : K -> E {G.F j}) (BasicCover {G.F j} {K} y g) (x = finj {J} {G} {j} y)\\n    (\\\\Pi (k : K) -> f k = finj {J} {G} {j} (g k))) || ((K, f) = (\\\\Sigma, \\\\lam (_ : \\\\Sigma) => funit {J} {G}))\\n  | unit => funit {J} {G}\\n} => \\\\new FrameUPres {\\n  | isUnit => {?hidden}\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', 'fconj-eq {j : J.Ob} (_ _ : E {G.F j}) I', '\\\\func DiscretePrecat (X : \\\\Type) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Trunc0 (x = y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => in0 {x = x} (idp {X} {x})\\n  | o => o {X}\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func functor \\\\plevels obj >= hom {J : \\\\Type} {D : Precat} (G : J -> D.Ob) : Functor (DiscretePrecat J) D G {\\n  | Func => map {J} {D} G\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', 'right', '\\\\instance FrameUPresCat : Cat FrameUPres {\\n  | Hom => FrameUPresHom\\n  | id => \\\\lam (X : Ob {\\\\this}) => \\\\new FrameUPresHom X X {\\n    | func => \\\\lam (x : X.E) => x\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new FrameUPresHom X Z {\\n    | func => \\\\lam (x : X.E) => g.func (f.func x)\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', 'finj {j : J.Ob} (E {G.F j})', 'cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)', \"\\\\data FTerm {J : Precat} (Functor J FrameUPresCat) : \\\\Set \\n  | finj {j : J.Ob} (E {G.F j})\\n  | fconj (FTerm {J} G) (FTerm {J} G)\\n  | funit\\n  | finj-eq {j j' : J.Ob} (J.Hom j j') (E {G.F j}) I\\n  | fconj-eq {j : J.Ob} (_ _ : E {G.F j}) I\\n  | funit-eq {j : J.Ob} I\", '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>Cover {colimit-obj {Precat.op {DiscretePrecat (Fin 2)}}\n  (Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\n    (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))}))}\n  (fconj-eq {Precat.op {DiscretePrecat (Fin 2)}}\n    {Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\n      (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})} {0} a1 a2 right) {\\Sigma}\n  (\\lam (_ : \\Sigma) => finj {Precat.op {DiscretePrecat (Fin 2)}}\n    {Comp {Precat.op {DiscretePrecat (Fin 2)}} {Precat.op {LocaleCat}} {FrameUPresCat} FrameUnitalReflectiveSubcat\n      (Functor.op {functor {Fin 2} {LocaleCat} ((!!) (L :: M :: nil))})} {0} a1)", "completion": "cover-proj1 idp () idp"}
{"prompt": "['x : E', 'r_s_x1<r__s<x2 : (\\\\case (false, x) \\\\with {\\n  | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n    | zero => (p, q)\\n    | suc zero => (r, s)\\n  }))\\n  | (false, (p, q)) =>\\n    (\\\\Sigma (r s : Rat) (p < r) (r < s) (s < q), (p, q), \\\\lam (t : \\\\Sigma (r s : Rat) (p < r) (r < s) (s < q)) => (t.1, t.2))\\n}).1']<<<break>>>['\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '\\\\type \\\\infix 4 <=< \\\\hlevels  {this : Locale} (x y : E) : \\\\Prop => top <= neg x \u2228 y', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\instance RealPres \\\\hlevels  (Q : Dec) : FramePres (Interval Q) {\\n  | conj => (\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))} {Interval Q}\\n    (\\\\lam (p0 : \\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))) =>\\n    (\\\\case p0 \\\\with {\\n      | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n        | zero => (p, q)\\n        | suc zero => (r, s)\\n      }))\\n      | (false, (p, q)) => (\\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\\n        \\\\lam (t : \\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\\n    }))\\n} => \\\\new FramePres', '\\\\lemma wellInside \\\\hlevels  {x y : Interval RatField} (_ : x < y) : embed {RealPres RatField} x <=< embed {RealPres RatField} y ', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>embed {RealPres RatField} (r, s) <=< embed {RealPres RatField} x", "completion": "wellInside (later (x1<r, s<x2))"}
{"prompt": "['x : E', 'M : CancelGCDMonoid', \"this : UnitlessGCDMonoid (Quotient {E} (~)) {\\n  | ide => in~ {E} {(~)} M.ide\\n  | * => (*')\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | cancel_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | uniqueUnit => {?hidden}\\n  | isGCD => {?hidden}\\n}\", 'y : E']<<<break>>>['\\\\func DivPreoder \\\\hlevels  (M : CMonoid) : Preorder M.E {\\n  | <= => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => TruncP (LDiv {M} y x)\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', '| res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res', \"\\\\instance DivQuotientCancelMonoid \\\\hlevels  (M1 : CancelCMonoid) : UnitlessMonoid (Quotient {E} (Transitive.~)) {\\n  | ide => in~ {E} {(Transitive.~)} M.ide\\n  | * => (*')\\n} => \\\\new UnitlessMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | cancel_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | uniqueUnit => {?hidden}\\n}\", '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\func div-to~ \\\\hlevels  {M : CMonoid} {x y : M.E} (x|y : LDiv {M} x y) : LDiv {DivQuotientMonoid M} (inD {M} x) (inD {M} y) (inD {M} x|y.inv) \\n=> \\\\new LDiv {\\n  | inv-right => {?hidden}\\n}', '| val1 : E {M}', '| \\\\infixl 7 * E E : E', '\\\\class GCD \\\\hlevels  {\\n  | M : CMonoid\\n  | val1 : E {M}\\n  | val2 : E {M}\\n  | res : E {M}\\n  | res|val1 : LDiv {M} res val1\\n  | res|val2 : LDiv {M} res val2\\n  | res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res\\n}', '| val2 : E {M}', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '\\\\func EquivRel \\\\hlevels  {this2 : Preorder} : Equivalence E {\\n  | ~ => \\\\lam (x : A {\\\\this}) (y : A {\\\\this}) => \\\\Sigma (x <= y) (y <= x)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', '| res|val2 : LDiv {M} res val2', '| M : CMonoid', 'in~ A', '| res : E {M}', \"\\\\instance DivQuotientMonoid \\\\hlevels  (M : CMonoid) : OrderedCMonoid (DivQuotient M) {\\n  | <= => (<=C)\\n  | ide => inD {M} M.ide\\n  | * => (*')\\n} => \\\\new OrderedCMonoid {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | <=_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n}\", 'levelProp \\\\hlevels  {M : CancelMonoid} (x y : M.E) : isProp (LDiv {M} x y) => cancelProp {M} x (M.cancel_*-left x) y', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func inD \\\\hlevels  {M : CMonoid} (x : M.E) : DivQuotient M => in~ {E} {(~)} x', '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', '| res|val1 : LDiv {M} res val1', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma div-from~ \\\\hlevels  {M : CancelCMonoid} {x y : M.E} (_ : LDiv {DivQuotientMonoid M} (inD {M} x) (inD {M} y)) : LDiv {M} x y ', '| isGCD (x y : E) : TruncP (GCD x y)']<<<break>>>TruncP (GCD (in~ {M.E} {(~)} x) (in~ {M.E} {(~)} y))", "completion": "map (isGCD x y) (\\lam (g : GCD x y) => \\new GCD (inD x) (inD y) (inD g) {\n  | res|val1 => div-to~ (res|val1 {g})\n  | res|val2 => div-to~ (res|val2 {g})\n  | res-univ => \\lam [g'] [g']|x [g']|y =>\n  (\\case \\elim [g'], [g']|x, [g']|y \\return \\level (LDiv [g'] (inD g)) (levelProp [g'] (inD g)) \\with {\n    | in~ g', (in~ x', ~x'*g'=x), (in~ y', ~y'*g'=y) => div-to~ (res-univ {g} g' (div-from~ (\\new LDiv {\n      | inv => inD x'\n      | inv-right => ~x'*g'=x\n    }))\n      (div-from~ (\\new LDiv {\n        | inv => inD y'\n        | inv-right => ~y'*g'=y\n      })))\n  })\n})"}
{"prompt": "[]<<<break>>>['| zro : E', '| U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| U Rat : \\\\Prop', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>\\Pi {q : Rat} -> U {zro} q -> TruncP (\\Sigma (r : Rat) (U {zro} r) (r < q))", "completion": "U-rounded {zro}"}
{"prompt": "[\"a' : A.E\", \"a<a' : a A.< a'\", 'a : A.E', 'A : Dec']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', 'nil', '| <-irreflexive {x : E} : Not (x < x)', '| <-transitive \\\\alias \\\\infixr 9 <\u2218 {x y z : E} (x < y) (y < z) : x < z', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data Empty \\\\plevels  \\\\hlevels  ', 'inl A', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func dec<_<= \\\\hlevels  {A : Dec} (a a' : A.E) : Or (a A.< a') (a' <= a) => \\\\case A.trichotomy a a' \\\\with {\\n  | less a<a' => inl {a A.< a'} {a' <= a} a<a'\\n  | equals a=a' => inr {a A.< a'} {a' <= a} (transportInv {A.E} ((<=) a') {a} {a'} a=a' (A.<-irreflexive {a'}))\\n  | greater a'<a => inr {a A.< a'} {a' <= a} (A.<=-less {a'} {a} a'<a)\\n}\", 'inr B', '| E : \\\\Set', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>(\\case dec<_<= {A} a' a \\with {\n  | inl x<a => a' :: a :: nil {A.E}\n  | inr a<=x => a :: a' :: nil {A.E}\n}) = (\\case dec<_<= {A} a a' \\with {\n| inl x<a => a :: a' :: nil {A.E}\n| inr a<=x => a' :: a :: nil {A.E}\n})", "completion": "\\case dec<_<= {A} a' a \\as o : case_return_arg_1_1, dec<_<= {A} a a' \\as o : case_return_arg_2_1 \\return (=) case_return_arg_1 case_return_arg_2 \\with {\n  | inl x<a, inl x<a => idp <|> contradiction\n  | inl x<a, inr a<=x => idp <|> contradiction\n  | inr a<=x, inl x<a => idp <|> contradiction\n  | inr a<=x, inr a<=x => idp <|> contradiction\n}"}
{"prompt": "['F : StronglyRegularCauchyFilter RatNormed', 'this : Real (\\\\lam (a : Rat) => TruncP (\\\\Sigma (x eps : Rat) (zro < eps) (F.F (OBall {RatNormed} eps x)) (a < x - eps)))\\n  (\\\\lam (b : Rat) => TruncP (\\\\Sigma (x eps : Rat) (zro < eps) (F.F (OBall {RatNormed} eps x)) (x AddMonoid.+ eps < b))) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}']<<<break>>>['| F (E {A}) : \\\\Prop', '\\\\lemma mid>left \\\\plevels  \\\\hlevels  {a b : Rat} (_ : a < b) : a < mid a b ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'inP A', '\\\\func mid \\\\plevels  \\\\hlevels  (a b : Rat) : Rat => (a + b) * ratio (pos 1) 2', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '| L Rat : \\\\Prop', '| zro : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma mid<right \\\\plevels  \\\\hlevels  {a b : Rat} (_ : a < b) : mid a b < b ', '\\\\func OBall \\\\hlevels  {X : ExPseudoMetricSpace} (eps : Rat) (x : X.E) : Set X.E => \\\\lam (y : X.E) => U {X.dist x y} eps', '\\\\instance RatNormed \\\\hlevels  : NormedAbGroup Rat {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | negative => RatField.negative\\n  | norm => \\\\lam (a : E {\\\\this}) => Real.fromRat (abs {RatField} a)\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}']<<<break>>>\\Pi {a : Rat} -> L {\\this} a -> TruncP (\\Sigma (r : Rat) (L {\\this} r) (a < r))", "completion": "\\lam {a} p0 => (\\scase \\elim p0 \\with {\n  | inP (x, eps, eps>0, FB, a<x-eps) => inP (mid a (x - eps), inP (x, eps, eps>0, FB, mid<right a<x-eps), mid>left a<x-eps)\n})"}
{"prompt": "['y : \\\\Sigma Real A.E', 'A : StoneC*PseudoAlgebra']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '| ide : E', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\infixl 7 *r \\\\hlevels  {this : RealBanachSpace} (r : Real) (a : E) : E => func {lift} (r, a)', '| norm E : ExUpperReal', '| \\\\infixl 7 * E E : E', '\\\\instance ExUpperRealLattice \\\\hlevels  : CompleteLattice ExUpperReal {\\n  | <= => (ExUpperReal.<=)\\n  | meet => meet\\n  | join => join\\n  | top => top-impl\\n  | Join => ExUpperRealLattice.Join\\n  | Meet => ExUpperRealLattice.Meet\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| join-right {x y : E} : y <= x \u2228 y', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>A.norm (y.1 *r s'.1 A.+ y.2 A.* s'.1) ExUpperReal.<= abs {RealAbGroup} y.1 \u2228 Join {\\Sigma (y : A.E) (A.norm y Preorder.<= ide)}\n  (\\lam (s'1 : \\Sigma (y : A.E) (A.norm y Preorder.<= ide)) => A.norm (y.1 *r s'1.1 A.+ y.2 A.* s'1.1))", "completion": "Join-cond s' <=\u2218 join-right"}
{"prompt": "['k : Fin (len {map {B.E} {B.E} ((B.\u2227) b) l})', 'B : BooleanRing', 'l : Array B.E', 'b : B.E']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', ':zro', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func interpretNF \\\\hlevels  {B : BooleanRing} {n : Nat} (env : Fin n -> B.E) (l : NF n) : B.E \\n  => interpretNF' {B} {n} (\\\\new Array B.E n env) (collapse {n} (sort {LexicographicalArray {n} BoolOpPoset} l))\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma terms-equality \\\\hlevels  {B : BooleanRing} (env : Array B.E) (t s : Term env.len)\\n  (_ : interpretNF {B} {env.len} env.at (normalize {env.len} (t :+ s)) = B.zro) : interpret {B} env t = interpret {B} env s ', '\\\\infixl 7 :* (_ _ : Term n)', '| zro : E', '\\\\func diff \\\\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '\\\\infixl 6 :+ (_ _ : Term n)', '\\\\func normalize {n5 : Nat} (_ : Term n5) : NF n5 \\n  | {n}, var j => singleAt {Bool} {n} j true false :: nil {Array Bool n}\\n  | {n}, :zro => nil {Array Bool n}\\n  | {n}, :negative t => normalize {n} t\\n  | {n}, t :+ s => normalize {n} t ++ normalize {n} s\\n  | {n}, t :* s => multiply {n} (normalize {n} t) (normalize {n} s)', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', 'var (Fin n)']<<<break>>>diff {B} b (l.at k) B.\u2227 (b B.\u2227 l.at k) <= B.zro", "completion": "=_<= bRing"}
{"prompt": "['this : UnboundedDenseLinearOrder Real {\\n  | < => (OrderedAddGroup.<)\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <-comparison => {?hidden}\\n  | <-connectedness => {?hidden}\\n  | isDense => {?hidden}\\n  | withoutUpperBound => {?hidden}\\n  | withoutLowerBound => {?hidden}\\n}']<<<break>>>['| L Rat : \\\\Prop', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma real_<_U \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : x < fromRat a <-> x.U a ', '| U Rat : \\\\Prop', 'inP A', '| E : \\\\Set', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\lemma real_<-rat-char \\\\plevels  \\\\hlevels  {x y : Real} : x < y <-> TruncP (\\\\Sigma (a : Rat) (x.U a) (y.L a)) ', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma real_<_L \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : fromRat a < x <-> x.L a ']<<<break>>>\\Pi {x z : E {\\this}} -> x < z -> TruncP (\\Sigma (y : E {\\this}) (x < y) (y < z))", "completion": "\\lam x<z => (\\scase real_<-rat-char.1 x<z \\with {\n  | inP (a, x<a, a<z) => inP (a, real_<_U.2 x<a, real_<_L.2 a<z)\n})"}
{"prompt": "['a : Rat', 'a>=0 : zro <= a', 'b : E', 'a<b : a < b', 'a<c : U {fromRat a} c', 'c : Rat']<<<break>>>['| zro : E', '\\\\lemma finv>0 {this : DiscreteOrderedField} {x : E} (_ : zro < x) : zro < finv x ', '| \\\\infixl 7 * E E : E', '| finv E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)', '\\\\lemma <_*_positive_positive \\\\hlevels  {this : OrderedSemiring} {x y : E} (_ : zro < x) (_ : zro < y) : zro < x * y ']<<<break>>>zro < b * finv c", "completion": "<_*_positive_positive {RatField} (a>=0 <\u2218r a<b) (finv>0 {RatField} (a>=0 <\u2218r a<c))"}
{"prompt": "['f : FrameHom (PresentedFrame P) L', 'g : FrameHom (PresentedFrame P) L', 'e : Opens P', 'arg : \\\\Pi (U : E) -> f.func U = g.func U', 'L : Locale']<<<break>>>['| E : \\\\Set', '| func (E {Dom}) : E {Cod}']<<<break>>>f.func e = g.func e", "completion": "arg e"}
{"prompt": "['R : Ring', 'x : E']<<<break>>>['| \\\\infixl 7 * E E : E', '| ide : E', '| E : \\\\Set', '| ide-right {x : E} : x * ide = x']<<<break>>>x R.* R.ide = x", "completion": "ide-right {_} {x}"}
{"prompt": "['X : ExPseudoNormedAbGroup']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func mkSet \\\\hlevels  {X : CoverSpace} (U : Set X.E) : Set (RegularCauchyFilter X) => \\\\lam (F1 : RegularCauchyFilter X) => F.F U', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| dist E E : ExUpperReal', '| norm-dist {x y : E} : dist x y = norm (x - y)', '| \\\\infix 4 <= E E : \\\\Prop', '| isSeparatedCoverSpace {x y : E} (\\\\Pi {C : Set (Set E)} -> isCauchy C -> TruncP (\\\\Sigma (U : Set E) (C U) (\\\\Sigma (U x) (U y)))) : x = y', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\instance ExMetricCompletion (X1 : ExPseudoMetricSpace) : CompleteExMetricSpace (RegularCauchyFilter X1) {\\n  | isOpen => isOpen {coverSpace {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set E)) =>\\n    TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set E) (D V) (mkSet {X1} U \u2286 V))))\\n  | dist => ExMetricCompletion.dist {X1}\\n} => \\\\new CompleteExMetricSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | isComplete => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n}', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '| negative E : E', '\\\\lemma isDenseEmbedding \\\\hlevels  {S : CoverSpace} : IsDenseEmbedding {completion {S}} ', '\\\\func completion-ex-isometry {X1 : ExPseudoMetricSpace} : IsometricMap X1 (ExMetricCompletion X1) {\\n  | func => pointCF {X1}\\n} => \\\\new IsometricMap {\\n  | func-isometry => {?hidden}\\n}', '| dist-uniform {C : Set (Set E)} : isUniform C <-> TruncP (\\\\Sigma (eps : Rat) (zro < eps) (\\\\Pi (x : E) -> TruncP (\\\\Sigma (U1 : Set E) (C U1) (\\\\Pi {y : E} -> U {dist x y} eps -> U1 y))))', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma filter-norm_dist {X : ExPseudoNormedAbGroup} {F : RegularCauchyFilter X} : norm {X} F = dist F (pointCF {X} X.zro) ', '\\\\func abGroup \\\\hlevels  {X : TopAbGroup} : AbGroup (RegularCauchyFilter X) {\\n  | zro => pointCF {X} X.zro\\n  | + => +-func {X}\\n  | negative => func {negative-cover {X}}\\n} => \\\\new AbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n}', '\\\\lemma subtract-cont \\\\hlevels  {this1 : TopAbGroup} : ContMap (ProductTopSpace this1 this1) this1 {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 - s.2\\n} ', '| cauchy-open {S : Set E} : isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))', '\\\\lemma dist-uniform-map \\\\hlevels  {X : ExPseudoMetricSpace} : UniformMap (X \u2a2f X) ExUpperRealMetric {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => X.dist s.1 s.2\\n} ', '\\\\func proj1 \\\\hlevels  {X Y : TopSpace} : ContMap (X \u2a2f Y) X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\lemma negative_zro \\\\hlevels  {this : AddGroup} : negative zro = zro ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '| zro-right {x : E} : x + zro = x', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| dist-symm {x y : E} : dist x y = dist y x', '\\\\instance TopAbGroupCompletion \\\\hlevels  (X1 : TopAbGroup) : CompleteTopAbGroup (RegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X1}}\\n  | zro => pointCF {X1} X.zro\\n  | + => +-func {X1}\\n  | negative => func {negative-cover {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set E)) =>\\n    TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set E) (D V) (mkSet {X1} U \u2286 V))))\\n} => \\\\new CompleteTopAbGroup {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | +-cont => {?hidden}\\n  | negative-cont => {?hidden}\\n  | neighborhood-uniform => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\lemma lift2-char \\\\hlevels  {X : CoverSpace} {f : CoverMap (X \u2a2f X) X} {x y : X.E} :\\n  func {lift2 {X} f} (pointCF {X} x, pointCF {X} y) = pointCF {X} (f.func (x, y)) ', '| isComplete : IsCompleteCoverSpace \\\\this', '\\\\func dist {X1 : ExPseudoMetricSpace} (F1 G : RegularCauchyFilter X1) :\\nExUpperReal (\\\\lam (q : Rat) => TruncP (\\\\Sigma (r : Rat) (r < q) (U1 : E {F.A}) (F.F U1) (V : E {G.A}) (G.F V)\\n  (\\\\Pi {x : F.X} -> U1 x -> \\\\Pi {y : G.X} -> V y -> U {X.dist x y} r))) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func prod \\\\hlevels  {X Y X' Y' : CoverSpace} (f : CoverMap X Y) (g : CoverMap X' Y') : CoverMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} z, func {g \u2218 proj2 {X} {X'}} z)\\n} => tuple {Y} {Y'} {X \u2a2f X'} (f \u2218 proj1 {X} {X'}) (g \u2218 proj2 {X} {X'})\", '| zro-left {x : E} : zro + x = x', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| negative-left {x : E} : negative x + x = zro', '| func (E {Dom}) : E {Cod}', '\\\\instance ProductTopSpace \\\\hlevels  (X Y : TopSpace) : TopSpace (\\\\Sigma X.E Y.E) {\\n  | isOpen => \\\\lam (W : Set (E {\\\\this})) =>\\n  \\\\Pi {s : E {\\\\this}} -> W s -> TruncP (\\\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\\n    (\\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}', '\\\\lemma norm-cont {X : ExPseudoNormedAbGroup} : ContMap (ExMetricCompletion X) ExUpperRealMetric {\\n  | func => norm {X}\\n} ', '| Dom : BaseSet', '| dist-triang {x y z : E} : dist x z <= dist x y + dist y z', '\\\\class CompleteExNormedAbGroup \\\\extends ExNormedAbGroup, CompleteExMetricSpace, CompleteTopAbGroup \\\\hlevels ', '| func-isometry {x y : E {Dom}} : dist {Cod} (func x) (func y) = dist {Dom} x y', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '\\\\func +-func \\\\hlevels  {X : TopAbGroup} (x y : RegularCauchyFilter X) : E {Cod {+-cover {X}}} => func {+-cover {X}} (x, y)', '| Cod : BaseSet', '\\\\func isOpen \\\\hlevels  {this : PrecoverSpace} (S : Set E) : \\\\Prop => \\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S)', '\\\\lemma +-uniform \\\\hlevels  {X : TopAbGroup} : TopAbGroupMap (X \u2a2f X) X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 X.+ s.2\\n} ', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : TopSpace} (g : ContMap Y Z) (f : ContMap X Y) : ContMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\lemma dense-lift-unique \\\\hlevels  {X Y : TopSpace} {Z : HausdorffTopSpace} (f : ContMap X Y) (_ : IsDense {f}) (g h : ContMap Y Z)\\n  (_ : \\\\Pi (x : X.E) -> g.func (f.func x) = h.func (f.func x)) (y : Y.E) : g.func y = h.func y ', '\\\\lemma norm_dist \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : X.norm x = X.dist X.zro x ', '| dist-refl {x : E} : dist x x = zro', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\instance ExUpperRealMetric \\\\hlevels  : CompleteExMetricSpace ExUpperReal {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => ExUpperRealMetric.dist\\n} => \\\\new CompleteExMetricSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | isComplete => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n}', '| isCompleteMetric (F1 : ProperFilter E) (\\\\Pi {eps : Rat} -> zro < eps -> TruncP (\\\\Sigma (x : E) (F.F (OBall eps x)))) : TruncP (\\\\Sigma (x : E) (\\\\Pi {eps : Rat} -> zro < eps -> F.F (OBall eps x)))', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| uniform-cauchy {C : Set (Set E)} : isCauchy C <-> Closure {E} isUniform C', '\\\\func completion \\\\hlevels  {S : CoverSpace} : CoverMap S (coverSpace {S}) {\\n  | func => pointCF {S}\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', 'negative-cover \\\\hlevels  {X : TopAbGroup} : CoverMap (UniformCompletion X) (Completion X) \\n=> subtract-cover {X} \u2218 tuple {UniformCompletion X} {UniformCompletion X} {UniformCompletion X}\\n  (const {UniformCompletion X} {UniformCompletion X} (pointCF {X} X.zro)) (id {UniformCompletion X})', '\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', '\\\\lemma negative-uniform \\\\hlevels  {X : TopAbGroup} : TopAbGroupMap X X {\\n  | func => X.negative\\n} ', '| dist-ext {x y : E} (dist x y = zro) : x = y', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func coverSpace \\\\hlevels  {X1 : CoverSpace} : CoverSpace (RegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => isCCauchy {X1}\\n} => \\\\new CoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n}', '\\\\instance TopSpaceHasProduct \\\\hlevels  : HasProduct TopSpace {\\n  | Product => ProductTopSpace\\n} => \\\\new HasProduct', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| norm E : ExUpperReal', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : CoverSpace} (g : CoverMap Y Z) (f : CoverMap X Y) : CoverMap X Z {\\n  | func => \\\\lam (x : E {Dom {g \u2218 f}}) => g.func (f.func x)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\func id \\\\hlevels  {X : CoverSpace} : CoverMap X X {\\n  | func => \\\\lam (x : E {Dom {id {X}}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\lemma subtract_- \\\\hlevels  {X : TopAbGroup} {F G : RegularCauchyFilter X} : func {subtract-cover {X}} (F, G) = F - G ', '| isHausdorff {x y : E} (\\\\Pi {U V : Set E} -> isOpen U -> isOpen V -> U x -> V y -> TruncP (\\\\Sigma (e : E) ((\u2227) U V e))) : x = y', '\\\\instance UniformCompletion \\\\hlevels  (X1 : UniformSpace) : CompleteUniformSpace (RegularCauchyFilter X1) {\\n  | isOpen => isOpen {coverSpace {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set (E {\\\\this}))) => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C)\\n    (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (D V) (mkSet {X1} U \u2286 V))))\\n} => \\\\new CompleteUniformSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cover => {?hidden}\\n  | uniform-top => {?hidden}\\n  | uniform-refine => {?hidden}\\n  | uniform-inter => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | uniform-star => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\func isCCauchy \\\\hlevels  {X : CoverSpace} (D : Set (Set (RegularCauchyFilter X))) : \\\\Prop => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isCauchy C)\\n  (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (RegularCauchyFilter X)) (D V) (mkSet {X} U \u2286 V))))', \"\\\\lemma isDense \\\\hlevels  {X X' Y Y' : TopSpace} {f : ContMap X Y} {g : ContMap X' Y'} (_ : IsDense {f}) (_ : IsDense {g}) :\\n  IsDense {prod {X} {X'} {Y} {Y'} f g} \", '| +-comm {x y : E} : x + y = y + x', '\\\\func norm {X1 : ExPseudoNormedAbGroup} (F1 : RegularCauchyFilter X1) :\\n  ExUpperReal (\\\\lam (q : Rat) => TruncP (\\\\Sigma (r : Rat) (r < q) (U1 : E {F.A}) (F.F U1) (\\\\Pi {x : F.X} -> U1 x -> U {X.norm x} r))) \\n=> \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\func proj2 \\\\hlevels  {X Y : TopSpace} : ContMap (X \u2a2f Y) Y {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.2\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', \"\\\\func prod \\\\hlevels  {X X' Y Y' : TopSpace} (f : ContMap X Y) (f' : ContMap X' Y') : ContMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} x, func {f' \u2218 proj2 {X} {X'}} x)\\n} => tuple {X \u2a2f X'} {Y} {Y'} (f \u2218 proj1 {X} {X'}) (f' \u2218 proj2 {X} {X'})\", 'lift2 \\\\hlevels  {X : CoverSpace} (f : CoverMap (X \u2a2f X) X) : CoverMap (coverSpace {X} \u2a2f coverSpace {X}) (Completion X) \\n=> dense-lift {X \u2a2f X} {coverSpace {X} \u2a2f coverSpace {X}} {Completion X}\\n  (prod {X} {coverSpace {X}} {X} {coverSpace {X}} (completion {X}) (completion {X}))\\n  (ProductCoverSpace.prod.isDenseEmbedding\\n  {Dom {completion {X}}} {Dom {completion {X}}} {Cod {completion {X}}} {Cod {completion {X}}} {completion {X}}\\n    {completion {X}} (completion.isDenseEmbedding {X}) (completion.isDenseEmbedding {X})) (completion {X} \u2218 f)']<<<break>>>CompleteExNormedAbGroup (RegularCauchyFilter X) {\n  | isOpen => isOpen {coverSpace {X}}\n  | isCauchy => isCCauchy {X}\n  | cauchy-open => {?hidden}\n  | isUniform => \\lam (D : Set (Set E)) =>\n    TruncP (\\Sigma (C : Set (Set X.E)) (X.isUniform C) (\\Pi {U : Set X.E} -> C U -> TruncP (\\Sigma (V : Set E) (D V) (mkSet {X} U \u2286 V))))\n  | uniform-cauchy => {?hidden}\n  | dist => ExMetricCompletion.dist {X}\n  | dist-refl => {?hidden}\n  | dist-symm => {?hidden}\n  | dist-triang => {?hidden}\n  | dist-uniform => {?hidden}\n  | zro => pointCF {X} X.zro\n  | + => +-func {X}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative => func {negative-cover {X}}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | norm => ExNormedAbGroupCompletion.norm {X}\n  | norm_zro => {?hidden}\n  | norm_negative => {?hidden}\n  | norm_+ => {?hidden}\n  | norm-dist => {?hidden}\n  | isHausdorff => {?hidden}\n  | isSeparatedCoverSpace => {?hidden}\n  | dist-ext => {?hidden}\n  | norm-ext => {?hidden}\n  | isComplete => {?hidden}\n  | isCompleteMetric => {?hidden}\n}", "completion": "\\new CompleteExNormedAbGroup {\n  | CompleteExMetricSpace => ExMetricCompletion X\n  | CompleteTopAbGroup => TopAbGroupCompletion X\n  | norm => norm {X}\n  | norm-dist => \\lam {F} {G} => dense-lift-unique\n    (prod completion completion) (isDense isDenseEmbedding.1 isDenseEmbedding.1) (dist-uniform-map {ExMetricCompletion X})\n      (norm-cont \u2218 subtract-cont {TopAbGroupCompletion X})\n      (\\lam s => func-isometry {completion-ex-isometry} *> norm-dist *> norm_dist *> dist-symm *> inv (func-isometry {completion-ex-isometry}) *> inv filter-norm_dist *> pmap norm (inv lift2-char *> subtract_- {X}))\n      (F, G)\n}"}
{"prompt": "['this : Nucleus']<<<break>>>['| meet-left {x y : E} : x \u2227 y <= x', '| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', '| nucleus-meet>= {x y : E {L}} : nucleus x \u2227 nucleus y <= nucleus (x \u2227 y)', '| E : \\\\Set', '| L : Locale', '| nucleus (E {L}) : E {L}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>\\Pi {x : E {L}} -> \\Pi {y : E {L}} -> nucleus (x \u2227 y) = nucleus x \u2227 nucleus y", "completion": "\\lam {x} {y} => <=-antisymmetric (meet-univ (nucleus-<= {this} meet-left) (nucleus-<= {this} meet-right)) (nucleus-meet>= {this})"}
{"prompt": "['E : CRing', 'l : Array E.E']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func evalMS \\\\hlevels  {M2 : \\\\Set} {R2 : Semiring} (_ : MonoidSet M2 R2) (_ : M2 -> R.E) : R.E \\n  | {M}, {R}, in~ l, f => BigSum {R} (map {\\\\Sigma R.E M} {R.E} (\\\\lam (s : \\\\Sigma R.E M) => s.1 R.* f s.2) l)\\n  | {M}, {R}, ~-equiv l l' r i, f => evalMS-coh {M} {R} f {l} {l'} r @ i\", '\\\\instance MonoidRing \\\\hlevels  (M : Monoid) (R : Ring) : Ring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | negative => negative {M.E} {R}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ', '\\\\func evalMSMonoidHom \\\\hlevels  {M : \\\\Set} {R : Semiring} (f : M -> R.E) : AddMonoidHom (MonoidAbMonoid M R) R {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => evalMS {M} {R} p0 f\\n} => \\\\new AddMonoidHom {\\n  | func-zro => {?hidden}\\n  | func-+ => {?hidden}\\n}', '| at (j : Fin len) : A j', '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func mPolyEval \\\\hlevels  {J : \\\\Set} {R : CRing} (f : J -> R.E) : RingHom (MonoidRing (PermSetMonoid J) R) R {\\n  | func => \\\\lam (p0 : E {Dom {evalMSMonoidHom {E} {R} (func {permSet-univ {J} {R} f})}}) =>\\n    evalMS {E} {R} p0 (func {permSet-univ {J} {R} f})\\n} => evalMSRingHom {PermSetMonoid J} {R} (permSet-univ {J} {R} f)', '| Dom : BaseSet', '\\\\func permSet-univ \\\\hlevels  {A : \\\\Set} {B : CMonoid} (f : A -> B.E) : MonoidHom (PermSetMonoid A) B {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => permSet-sum {B} (permSet-map {A} {B.E} f x)\\n} => \\\\new MonoidHom {\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}']<<<break>>>RingHom (MonoidRing (PermSetMonoid (Fin l.len)) E1) E1 {\n  | func => \\lam (p0 : E {Dom {evalMSMonoidHom {E} {E1} (func {permSet-univ {Fin l.len} {E1} l.at})}}) =>\n    evalMS {E} {E1} p0 (func {permSet-univ {Fin l.len} {E1} l.at})\n}", "completion": "mPolyEval l"}
{"prompt": "['A : StoneC*Algebra', 'y : A.E', 'x<=y : x A.<= y', 'y<=1 : y A.<= A.ide', 'n : Nat', 'x : A.E']<<<break>>>['| \\\\infixl 7 * E E : E', 'yfunc \\\\hlevels  {this2 : RealBanachAlgebra} (_ : Nat) (_ : E) : E \\n  | {this}, 0, x => zro\\n  | {this}, suc n, x => ratio (pos 1) 2 *q (ide - x + yfunc n x * yfunc n x)', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma yfunc-mono \\\\hlevels  {A : StoneC*Algebra} {x y : A.E} (_ : x A.<= y) (_ : y A.<= A.ide) {n : Nat} : yfunc {A} n y A.<= yfunc {A} n x ', '| <=_*_positive-left {x y z : E} (x <= y) (zro <= z) : x * z <= y * z', '\\\\lemma yfunc>=0 \\\\hlevels  {A : StoneC*Algebra} {x : A.E} (_ : x A.<= A.ide) {n : Nat} : A.zro A.<= yfunc {A} n x ']<<<break>>>yfunc {A} n y A.* yfunc {A} n y A.<= yfunc {A} n x A.* yfunc {A} n y", "completion": "<=_*_positive-left (yfunc-mono {A} x<=y y<=1) (yfunc>=0 {A} y<=1)"}
{"prompt": "['d : HasDensePoints', 'Cc : isCauchy (\\\\lam (U : Set E) => (U = bottom) || C U)', 'C : Set (Set E)', 'this : PrecoverSpace']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| bottom : E', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>isCauchy (\\lam (U : Set E) => \\Sigma ((U = bottom) || C U) (TruncP (\\Sigma (e : E) (U e))))", "completion": "d Cc"}
{"prompt": "['Z : CoverSpace', 'p : CauchyMap Y Z', 'z : Z.E', 'z<=F : F {pointCF {Z} z} \u2286 F {SetFilter-map {Y.E} {Z.E} p.func F1}', 'Y : CoverSpace', 'q : \\\\Pi (F1 : RegularCauchyFilter X) -> \\\\Pi {z : Z.E} -> F {pointCF {Z} z} \u2286 F {p.func-cauchy (f.func-cauchy F1)} ->\\n  TruncP (\\\\Sigma (y : Y.E) (p.func y = z) (F {pointCF {Y} y} \u2286 F {f.func-cauchy F1}))', 'f : CoverMap X Y', 'fd : IsDenseEmbedding {f}', 'F : CauchyFilter Y', 'X : CoverSpace']<<<break>>>['| F (E {A}) : \\\\Prop', '\\\\lemma Reg_CF~_<= \\\\hlevels  {X : CoverSpace} {F1 : RegularCauchyFilter X} {G : CauchyFilter X} (_ : F1 CF~ G) : F.F \u2286 G.F ', '| func-cauchy (F1 : CauchyFilter Dom) : CauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isProper => {?hidden}\\n}', '| S : CoverSpace', '\\\\lemma func-CF~ \\\\hlevels  {this : CauchyMap} {F G : CauchyFilter Dom} (_ : F CF~ G) : func-cauchy F CF~ func-cauchy G ', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '| Cod : BaseSet', '\\\\func regCF \\\\hlevels  {X1 : CoverSpace} (F1 : CauchyFilter X1) :\\n  RegularCauchyFilter X1 (\\\\lam (U : E {A {\\\\this}}) => \\\\Pi {G : CauchyFilter X1} -> G.F \u2286 F.F -> G.F U) \\n=> \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '\\\\instance CauchyFilterEquivalence \\\\hlevels  (S1 : CoverSpace) : Equivalence (CauchyFilter S1) {\\n  | ~ => (CF~)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma map-equiv \\\\hlevels  {X Y : CoverSpace} {f : CoverMap X Y} {F : CauchyFilter Y} (fd : IsDenseEmbedding {f}) :\\n  f.func-cauchy (dense-filter-lift {X} {Y} f fd F) CF~ F ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma regCF_<= \\\\hlevels  {S : CoverSpace} {F1 : CauchyFilter S} : F {regCF {S} F1} \u2286 F.F ', '\\\\lemma CF~-sym \\\\hlevels  {S : CoverSpace} {F G : WeaklyCauchyFilter S} (_ : F CF~ G) : G CF~ F ', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', \"\\\\func dense-filter-lift \\\\hlevels  {X1 Y : CoverSpace} (f : CoverMap X1 Y) (fd : IsDenseEmbedding {f}) (F1 : CauchyFilter Y) :\\n  CauchyFilter X1 (\\\\lam (U : E {A {\\\\this}}) => TruncP (\\\\Sigma (V' V : Set Y.E) (f.func ^-1 V \u2286 U) (V' <=< V) (F.F V'))) \\n=> \\\\new CauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n}\", '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '| ~-transitive {x y z : A} (x ~ y) (y ~ z) : x ~ z', '\\\\lemma CF~_<= \\\\hlevels  {S : CoverSpace} {F1 G : WeaklyCauchyFilter S} (_ : F.F \u2286 G.F) : F1 CF~ G ']<<<break>>>TruncP (\\Sigma (y : Y.E) (p.func y = z) (F {pointCF {Y} y} \u2286 F {f.func-cauchy (regCF {X} (dense-filter-lift {X} {Y} f fd F1))}))", "completion": "q (regCF $ dense-filter-lift f fd F) {z}\n  (Reg_CF~_<= {_} {pointCF z} {func-cauchy {p} $ func-cauchy {f} $ regCF _} $ ~-transitive {_} {pointCF z} (CF~_<= {_} {_} {func-cauchy {p} F} z<=F) $ func-CF~ {p} $ CF~-sym $ ~-transitive (func-CF~ {f} $ CF~_<= {_} {_} {dense-filter-lift f fd F} regCF_<=) (map-equiv fd))"}
{"prompt": "['C : Precat', 'G : Functor J (VPresheafCat D C)', 'D : CompleteCat', 'J : Precat', 'j : J.Ob', \"this : NatTrans {op {C1}} {D1} (VPresheaf.F {VPresheafComplete.limit'.apex {C1} {D1} {J} {G1}}) (VPresheaf.F {G.F j}) {\\n  | trans => \\\\lam (c : Ob {C {\\\\this}}) => coneMap j\\n  | natural => {?hidden}\\n}\"]<<<break>>>['| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '\\\\func apex \\\\hlevels  {C : Precat} {D : CompleteCat} {J1 : Precat} {G1 : Functor J1 (VPresheafCat D C)} :\\nVPresheaf D C (\\\\new Functor (op {VPresheaf.C {\\\\this}}) (VPresheaf.D {\\\\this}) (\\\\lam (c : Ob {Functor.C {\\\\this}}) => apex) {\\n  | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) =>\\n    limMap {D.limit {J1} (functor-at-point {C} {D} {J1} {G1} Y)} {apex} (cone {C} {D} {J1} {G1} {X} {Y} f)\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}) => \\\\new VPresheaf', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j', '| D : Precat', '\\\\func cone \\\\hlevels  {C : Precat} {D : CompleteCat} {J1 : Precat} {G : Functor J1 (VPresheafCat D C)} {X Y : C.Ob} (f : C.Hom Y X) :\\nCone {J1} {D} (functor-at-point {C} {D} {J1} {G} Y) apex {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => Func {VPresheaf.F {G.F j}} {X} {Y} f D.\u2218 coneMap j\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex', '\\\\func L \\\\hlevels  {C : Precat} {D : CompleteCat} {J : Precat} {G : Functor J (VPresheafCat D C)} (c : C.Ob) :\\n  Limit {J} {D} (functor-at-point {C} {D} {J} {G} c) => D.limit {J} (functor-at-point {C} {D} {J} {G} c)', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| G : Functor J D', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| C : Precat', '| Ob : \\\\hType']<<<break>>>\\Pi {o : Ob {C {\\this}}} -> \\Pi {Y : Ob {C {\\this}}} -> \\Pi (f : Hom {C {\\this}} o Y) ->\n  coneMap j D.\u2218 limMap {Cone.apex} (cone {C1} {D} {J} {G} {o} {Y} f) = Func {VPresheaf.F {G.F j}} {o} {Y} f D.\u2218 coneMap j", "completion": "\\lam {_} {Y} f => rewrite (limBeta {L {C} {D} {J} {G} Y} (cone {C} {D} {J} {G} f) j) idp"}
{"prompt": "['q : hasNegative (\\\\new p {}) (\\\\new Array Nat p.len (\\\\lam (j : Fin p.len) => c.1 !! suc j)) = true', 'h : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))', 'this : LinearData', 'p : Problem', 'c : CorrectCert (toContr p t1 t2)']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', 'suc Nat', '| R : Semiring', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| vars : Array (E {M})', '| \\\\infix 4 < E E : \\\\Prop', \"\\\\func hasNegative-correct \\\\hlevels  {this2 : LinearData} (p1 : Problem) (c1 : Cert p.len) (_ : hasNegative p1 c1 = true) :\\n  TruncP (\\\\Sigma (j : Fin p.len) (0 < c.at j) ((p.at j).2 = Less)) \\n  | {this}, nil, nil, q => \\\\case q \\\\with {}\\n  | {this}, :: {n} e p, k :: c, q => \\\\case toOr {isLess e.2 and isSuc k} {hasNegative p c} q \\\\with {\\n    | byLeft s => inP {\\\\Sigma (j : Fin (suc p.len)) (0 < at {k :: c} j) ((at {e :: p} j).2 = Less)}\\n      (0, LinearData.isSuc.correct {k} (toSigma {isLess e.2} {isSuc k} s).2,\\n        LinearData.isLess.correct {(at {e :: p} 0).2} (toSigma {isLess e.2} {isSuc k} s).1)\\n    | byRight q' => \\\\case hasNegative-correct p c q' \\\\with {\\n      | inP t => inP {\\\\Sigma (j : Fin (suc p.len)) (0 < at {k :: c} j) ((at {e :: p} j).2 = Less)} (suc t.1, t.2, t.3)\\n    }\\n  }\", '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\field mData : MonoidData {R} vars', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\lemma aux \\\\hlevels  {this : LinearData} (p : Problem) (c : Cert p.len) (_ : TruncP (\\\\Sigma (j : Fin p.len) (0 < c.at j) ((p.at j).2 = Less)))\\n  (_ : \\\\Pi (j : Fin p.len) -> interpretEq (p !! j)) :\\ncertSum (map {\\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))}\\n  {RingTerm (E {C}) (Fin (len {vars}))}\\n  (\\\\lam (p0 : \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))) => p0.1)\\n  p) c < certSum (map {\\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))}\\n  {RingTerm (E {C}) (Fin (len {vars}))}\\n  (\\\\lam (p0 : \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))) => p0.3)\\n  p) c ', '| at (j : Fin len) : A j', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '| E : \\\\Set', '\\\\func certSum \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => BigSum {R} (\\\\new Array (E {R}) l.len (\\\\lam (j : Fin l.len) => natCoef {R} (c.at j) * interpret (l.at j)))']<<<break>>>certSum (map {\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))}\n  {RingTerm (E {C}) (Fin (len {vars}))}\n  (\\lam (p0 : \\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))) => p0.1)\n  p) (\\new Array Nat p.len (\\lam (j : Fin p.len) => at {c.1} (suc j))) < certSum (map {\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))}\n  {RingTerm (E {C}) (Fin (len {vars}))}\n  (\\lam (p0 : \\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))) => p0.3)\n  p) (\\new Array Nat p.len (\\lam (j : Fin p.len) => at {c.1} (suc j)))", "completion": "aux {this} p (\\lam j => c.1 (suc j)) (hasNegative-correct {this} p _ q) h"}
{"prompt": "['S : DecSet', 'a2 : \\\\Sigma S.E Bool', 'e : a.1 = a1.1', 'a1 : \\\\Sigma S.E Bool', 'x1 : List (\\\\Sigma S.E Bool)', 'a : \\\\Sigma S.E Bool', 'x : List (\\\\Sigma S.E Bool)', 'p : reduce {S} x = a2 :: x1']<<<break>>>['true', '\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func AreAdjacent \\\\hlevels  {S : \\\\Set} (w_1 w_2 : E) : \\\\Prop => TruncP (\\\\Sigma (u_1 u_2 : E) (x : S) (p : Bool)\\n  (\\\\Sigma (w_1 = u_1 * u_2) (w_2 = u_1 * ((x, p) :: nil {\\\\Sigma S Bool}) * ((x, not p) :: nil {\\\\Sigma S Bool}) * u_2)))', 'csym (Closure {A} R y x)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func reduce_equiv \\\\hlevels  {S3 : DecSet} (x1 : List (\\\\Sigma S.E Bool)) : x1 ~ reduce {S3} x1 \\n  | {S}, nil => crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool}} {reduce {S} (nil {\\\\Sigma S.E Bool})}\\n    (idp {List (\\\\Sigma S.E Bool)} {nil {\\\\Sigma S.E Bool}})\\n  | {S}, a :: nil =>\\n  crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: nil {\\\\Sigma S.E Bool}} {reduce {S} (a :: nil {\\\\Sigma S.E Bool})}\\n    (idp {List (\\\\Sigma S.E Bool)} {a :: nil {\\\\Sigma S.E Bool}})\\n  | {S}, a :: a1 :: x => \\\\case reduce {S} x, idp {List (\\\\Sigma S.E Bool)} {reduce {S} x} \\\\with {\\n    | nil, p => \\\\case S.decideEq a.1 a1.1, idp {Dec (a.1 = a1.1)} {S.decideEq a.1 a1.1} \\\\with {\\n      | yes e, p1 => \\\\case a.2 xor a1.2, idp {Bool} {a.2 xor a1.2} \\\\with {\\n        | false, p2 => transport {List (\\\\Sigma S.E Bool)} (\\\\lam (x1 : List (\\\\Sigma S.E Bool)) => a :: a1 :: x ~ a :: a1 :: x1) {reduce {S} x}\\n          {nil {\\\\Sigma S.E Bool}} p\\n          (adjacent_cons {S.E} {a1 :: x} {a1 :: reduce {S} x} a (adjacent_cons {S.E} {x} {reduce {S} x} a1 (reduce_equiv {S} x)))\\n        | true, p2 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n          | yes e, true => nil {\\\\Sigma S.E Bool}\\n          | d, b => (a.1, a.2) :: (a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}\\n        }} (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n          | yes e, true => nil {\\\\Sigma S.E Bool}\\n          | d, b => (a.1, a.2) :: (a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}\\n        }} {a :: a1 :: x} {x} (csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n          | yes e, true => nil {\\\\Sigma S.E Bool}\\n          | d, b => (a.1, a.2) :: (a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}\\n        }} {x} (transport {List (\\\\Sigma S.E Bool)} ((~) x) {reduce {S} x} {nil {\\\\Sigma S.E Bool}} p (reduce_equiv {S} x)))\\n          (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {x} {a :: a1 :: x} (inP {\\\\Sigma (u_1 u_2 : E) (x1 : S.E) (p : Bool)\\n            (\\\\Sigma (x = u_1 * u_2) (a :: a1 :: x = u_1 * ((x1, p) :: nil {\\\\Sigma S.E Bool}) * ((x1, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n            (nil {\\\\Sigma S.E Bool}, x, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {x}, transportInv {S.E} (\\\\lam (x1 : S.E) =>\\n              a :: a1 :: x = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x1, not a.2) :: nil {\\\\Sigma S.E Bool}) * x)\\n              {a.1} {a1.1} e (transportInv {Bool} (\\\\lam (x1 : Bool) =>\\n                a :: a1 :: x = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a1.1, x1) :: nil {\\\\Sigma S.E Bool}) * x)\\n                {not a.2} {a1.2} (helper1 {a.2} {a1.2} p2) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: x})))))))\\n      }\\n      | no n, p1 => transport {List (\\\\Sigma S.E Bool)} (\\\\lam (x1 : List (\\\\Sigma S.E Bool)) => a :: a1 :: x ~ a :: a1 :: x1) {reduce {S} x}\\n        {nil {\\\\Sigma S.E Bool}} p\\n        (adjacent_cons {S.E} {a1 :: x} {a1 :: reduce {S} x} a (adjacent_cons {S.E} {x} {reduce {S} x} a1 (reduce_equiv {S} x)))\\n    }\\n    | a2 :: x1, p => \\n      \\\\have A0 => transport {List (\\\\Sigma S.E Bool)} (\\\\lam (x1 : List (\\\\Sigma S.E Bool)) => a :: a1 :: x ~ a :: a1 :: x1) {reduce {S} x} {a2 :: x1} p\\n              (adjacent_cons {S.E} {a1 :: x} {a1 :: reduce {S} x} a (adjacent_cons {S.E} {x} {reduce {S} x} a1 (reduce_equiv {S} x)))\\n      \\\\in \\\\case S.decideEq a.1 a1.1, idp {Dec (a.1 = a1.1)} {S.decideEq a.1 a1.1} \\\\with {\\n            | yes e, p1 => \\\\case S.decideEq a1.1 a2.1, idp {Dec (a1.1 = a2.1)} {S.decideEq a1.1 a2.1} \\\\with {\\n              | yes e1, p2 => \\\\case a1.2 xor a2.2, idp {Bool} {a1.2 xor a2.2} \\\\with {\\n                | false, p3 => transportInv {Dec (a.1 = a1.1)} (\\\\lam (x2 : Dec (a.1 = a1.1)) => a :: a1 :: x ~ (\\\\case x2, a.2 xor a1.2 \\\\with {\\n                  | yes e, true => (a2.1, a2.2) :: x1\\n                  | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                })) {S.decideEq a.1 a1.1} {yes {a.1 = a1.1} e} p1 (\\\\case a.2 xor a1.2, idp {Bool} {a.2 xor a1.2} \\\\with {\\n                  | false, p4 => A0\\n                  | true, p4 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} {a :: a1 :: x} {x} (csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} {x} (transport {List (\\\\Sigma S.E Bool)} ((~) x) {reduce {S} x} {a2 :: x1} p (reduce_equiv {S} x)))\\n                    (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {x} {a :: a1 :: x} (inP {\\\\Sigma (u_1 u_2 : E) (x1 : S.E) (p : Bool)\\n                      (\\\\Sigma (x = u_1 * u_2) (a :: a1 :: x = u_1 * ((x1, p) :: nil {\\\\Sigma S.E Bool}) * ((x1, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                      (nil {\\\\Sigma S.E Bool}, x, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {x}, transportInv {S.E} (\\\\lam (x1 : S.E) =>\\n                        a :: a1 :: x = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x1, not a.2) :: nil {\\\\Sigma S.E Bool}) * x)\\n                        {a.1} {a1.1} e (transportInv {Bool} (\\\\lam (x1 : Bool) =>\\n                          a :: a1 :: x = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a1.1, x1) :: nil {\\\\Sigma S.E Bool}) * x)\\n                          {not a.2} {a1.2} (helper1 {a.2} {a1.2} p4) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: x})))))))\\n                })\\n                | true, p3 => ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case \\\\case yes {a1.1 = a2.1} e1, true \\\\with {\\n                  | yes e, true => x1\\n                  | d, b => (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                } \\\\with {\\n                  | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                  | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                    | yes e, true => ys\\n                    | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                  }\\n                }} {a :: a1 :: a2 :: x1} A0 (\\\\case x1, idp {List (\\\\Sigma S.E Bool)} {x1} \\\\with {\\n                  | nil, p4 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                    | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                    | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                      | yes e, true => ys\\n                      | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                    }\\n                  }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                    | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                    | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                      | yes e, true => ys\\n                      | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                    }\\n                  }} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}}\\n                    (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                      | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                      | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                        | yes e, true => ys\\n                        | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                      }\\n                    }) = u_1 * u_2)\\n                      (a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                      (a :: nil {\\\\Sigma S.E Bool}, nil {\\\\Sigma S.E Bool}, a1.1, a1.2,\\n                        (idp {List (\\\\Sigma S.E Bool)} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                          | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                          | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                            | yes e, true => ys\\n                            | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                          }\\n                        }},\\n                          transportInv {S.E}\\n                            (\\\\lam (x : S.E) => a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * nil {\\\\Sigma S.E Bool})\\n                            {a1.1} {a2.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                              a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * nil {\\\\Sigma S.E Bool})\\n                              {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}}))))))\\n                  | a3 :: x2, p4 => \\\\case S.decideEq a.1 a3.1, idp {Dec (a.1 = a3.1)} {S.decideEq a.1 a3.1} \\\\with {\\n                    | yes e2, p5 => \\\\case a.2 xor a3.2, idp {Bool} {a.2 xor a3.2} \\\\with {\\n                      | false, p6 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case yes {a.1 = a3.1} e2, false \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a3.1} e2, false \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} {a :: a1 :: a2 :: a3 :: x2}\\n                        (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case yes {a.1 = a3.1} e2, false \\\\with {\\n                          | yes e, true => x2\\n                          | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                        }) = u_1 * u_2)\\n                          (a :: a1 :: a2 :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                          (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2, (idp {List (\\\\Sigma S.E Bool)} {\\\\case yes {a.1 = a3.1} e2, false \\\\with {\\n                            | yes e, true => x2\\n                            | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                          }},\\n                            transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: a3 :: x2}))))))\\n                      | true, p6 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case yes {a.1 = a3.1} e2, true \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool} * x2}\\n                        {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)}\\n                        {a :: a3 :: x2} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool} * x2} {a :: a3 :: x2}\\n                          (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma (nil {\\\\Sigma S.E Bool} * x2 = u_1 * u_2)\\n                            (a :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                            (nil {\\\\Sigma S.E Bool}, x2, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {nil {\\\\Sigma S.E Bool} * x2}, transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a3 :: x2 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a.2) :: nil {\\\\Sigma S.E Bool}) * x2)\\n                              {a.1} {a3.1} e2 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a3 :: x2 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a3.1, x) :: nil {\\\\Sigma S.E Bool}) * x2)\\n                                {not a.2} {a3.2} (helper1 {a.2} {a3.2} p6) (idp {List (\\\\Sigma S.E Bool)} {a :: a3 :: x2}))))))\\n                        (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a3 :: x2}\\n                          {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)}\\n                          (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma (a :: a3 :: x2 = u_1 * u_2)\\n                            ((a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                            (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2, (idp {List (\\\\Sigma S.E Bool)} {a :: a3 :: x2}, transportInv {S.E}\\n                              (\\\\lam (x : S.E) => (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)}\\n                                  {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)})))))))\\n                    }\\n                    | no n, p5 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case no {a.1 = a3.1} n, a.2 xor a3.2 \\\\with {\\n                      | yes e, true => x2\\n                      | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                    }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case no {a.1 = a3.1} n, a.2 xor a3.2 \\\\with {\\n                      | yes e, true => x2\\n                      | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                    }} {a :: a1 :: a2 :: a3 :: x2}\\n                      (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case no {a.1 = a3.1} n, a.2 xor a3.2 \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }) = u_1 * u_2)\\n                        (a :: a1 :: a2 :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                        (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2,\\n                          (idp {List (\\\\Sigma S.E Bool)} {\\\\case no {a.1 = a3.1} n, a.2 xor a3.2 \\\\with {\\n                            | yes e, true => x2\\n                            | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                          }},\\n                            transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: a3 :: x2}))))))\\n                  }\\n                })\\n              }\\n              | no n, p2 => transportInv {Dec (a.1 = a1.1)} (\\\\lam (x2 : Dec (a.1 = a1.1)) => a :: a1 :: x ~ (\\\\case x2, a.2 xor a1.2 \\\\with {\\n                | yes e, true => (a2.1, a2.2) :: x1\\n                | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n              })) {S.decideEq a.1 a1.1} {yes {a.1 = a1.1} e} p1\\n                (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case yes {a.1 = a1.1} e, a.2 xor a1.2 \\\\with {\\n                  | yes e, true => (a2.1, a2.2) :: x1\\n                  | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                }} {a :: a1 :: a2 :: x1} A0 (\\\\case a.2 xor a1.2, idp {Bool} {a.2 xor a1.2} \\\\with {\\n                  | false, p3 => crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: x1} {\\\\case yes {a.1 = a1.1} e, false \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: x1})\\n                  | true, p3 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: x1} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} {a :: a1 :: a2 :: x1}\\n                    (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                      | yes e, true => (a2.1, a2.2) :: x1\\n                      | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                    }) = u_1 * u_2)\\n                      (a :: a1 :: a2 :: x1 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                      (nil {\\\\Sigma S.E Bool}, a2 :: x1, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {\\\\case yes {a.1 = a1.1} e, true \\\\with {\\n                        | yes e, true => (a2.1, a2.2) :: x1\\n                        | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                      }},\\n                        transportInv {S.E}\\n                          (\\\\lam (x : S.E) => a :: a1 :: a2 :: x1 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a.2) :: nil {\\\\Sigma S.E Bool}) * (a2 :: x1))\\n                          {a.1} {a1.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                            a :: a1 :: a2 :: x1 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a1.1, x) :: nil {\\\\Sigma S.E Bool}) * (a2 :: x1))\\n                            {not a.2} {a1.2} (helper1 {a.2} {a1.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: x1}))))))\\n                }))\\n            }\\n            | no n, p1 => ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: x} {\\\\case \\\\case S.decideEq a1.1 a2.1, a1.2 xor a2.2 \\\\with {\\n              | yes e, true => x1\\n              | d, b => (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n            } \\\\with {\\n              | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n              | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                | yes e, true => ys\\n                | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n              }\\n            }} {a :: a1 :: a2 :: x1} A0 (\\\\case S.decideEq a1.1 a2.1, idp {Dec (a1.1 = a2.1)} {S.decideEq a1.1 a2.1} \\\\with {\\n              | yes e, p2 => \\\\case a1.2 xor a2.2, idp {Bool} {a1.2 xor a2.2} \\\\with {\\n                | false, p3 => transportInv {Dec (a.1 = a1.1)} (\\\\lam (x : Dec (a.1 = a1.1)) =>\\n                  Closure {List (\\\\Sigma S.E Bool)} (AreAdjacent {S.E}) (a :: a1 :: a2 :: x1) (\\\\case x, a.2 xor a1.2 \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  })) {S.decideEq a.1 a1.1} {no {a.1 = a1.1} n} p1\\n                    (crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: x1} {\\\\case no {a.1 = a1.1} n, a.2 xor a1.2 \\\\with {\\n                      | yes e, true => (a2.1, a2.2) :: x1\\n                      | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                    }} (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: x1}))\\n                | true, p3 => \\\\case x1, idp {List (\\\\Sigma S.E Bool)} {x1} \\\\with {\\n                  | nil, p4 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                    | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                    | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                      | yes e, true => ys\\n                      | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                    }\\n                  }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                    | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                    | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                      | yes e, true => ys\\n                      | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                    }\\n                  }} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}}\\n                    (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                      | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                      | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                        | yes e, true => ys\\n                        | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                      }\\n                    }) = u_1 * u_2)\\n                      (a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                      (a :: nil {\\\\Sigma S.E Bool}, nil {\\\\Sigma S.E Bool}, a1.1, a1.2,\\n                        (idp {List (\\\\Sigma S.E Bool)} {\\\\case nil {\\\\Sigma S.E Bool} \\\\with {\\n                          | nil => (a.1, a.2) :: nil {\\\\Sigma S.E Bool}\\n                          | (ya, yb) :: ys => \\\\case S.decideEq a.1 ya, a.2 xor yb \\\\with {\\n                            | yes e, true => ys\\n                            | d, b => (a.1, a.2) :: (ya, yb) :: ys\\n                          }\\n                        }},\\n                          transportInv {S.E}\\n                            (\\\\lam (x : S.E) => a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * nil {\\\\Sigma S.E Bool})\\n                            {a1.1} {a2.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                              a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool} = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * nil {\\\\Sigma S.E Bool})\\n                              {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: nil {\\\\Sigma S.E Bool}}))))))\\n                  | a3 :: x2, p4 => \\\\case S.decideEq a.1 a3.1, idp {Dec (a.1 = a3.1)} {S.decideEq a.1 a3.1} \\\\with {\\n                    | yes e1, p5 => \\\\case a.2 xor a3.2, idp {Bool} {a.2 xor a3.2} \\\\with {\\n                      | false, p6 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case yes {a.1 = a3.1} e1, false \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case yes {a.1 = a3.1} e1, false \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} {a :: a1 :: a2 :: a3 :: x2}\\n                        (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case yes {a.1 = a3.1} e1, false \\\\with {\\n                          | yes e, true => x2\\n                          | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                        }) = u_1 * u_2)\\n                          (a :: a1 :: a2 :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                          (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2, (idp {List (\\\\Sigma S.E Bool)} {\\\\case yes {a.1 = a3.1} e1, false \\\\with {\\n                            | yes e, true => x2\\n                            | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                          }},\\n                            transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: a3 :: x2}))))))\\n                      | true, p6 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case yes {a.1 = a3.1} e1, true \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }} (ctrans {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool} * x2}\\n                        {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)}\\n                        {a :: a3 :: x2} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {nil {\\\\Sigma S.E Bool} * x2} {a :: a3 :: x2}\\n                          (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma (nil {\\\\Sigma S.E Bool} * x2 = u_1 * u_2)\\n                            (a :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                            (nil {\\\\Sigma S.E Bool}, x2, a.1, a.2, (idp {List (\\\\Sigma S.E Bool)} {nil {\\\\Sigma S.E Bool} * x2}, transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a3 :: x2 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a.2) :: nil {\\\\Sigma S.E Bool}) * x2)\\n                              {a.1} {a3.1} e1 (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a3 :: x2 = nil {\\\\Sigma S.E Bool} * ((a.1, a.2) :: nil {\\\\Sigma S.E Bool}) * ((a3.1, x) :: nil {\\\\Sigma S.E Bool}) * x2)\\n                                {not a.2} {a3.2} (helper1 {a.2} {a3.2} p6) (idp {List (\\\\Sigma S.E Bool)} {a :: a3 :: x2}))))))\\n                        (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a3 :: x2}\\n                          {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)}\\n                          (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma (a :: a3 :: x2 = u_1 * u_2)\\n                            ((a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                            (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2, (idp {List (\\\\Sigma S.E Bool)} {a :: a3 :: x2}, transportInv {S.E}\\n                              (\\\\lam (x : S.E) => (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2) = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)}\\n                                  {(a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, a2.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2)})))))))\\n                    }\\n                    | no n1, p5 => csym {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: a3 :: x2} {\\\\case no {a.1 = a3.1} n1, a.2 xor a3.2 \\\\with {\\n                      | yes e, true => x2\\n                      | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                    }} (cin {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {\\\\case no {a.1 = a3.1} n1, a.2 xor a3.2 \\\\with {\\n                      | yes e, true => x2\\n                      | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                    }} {a :: a1 :: a2 :: a3 :: x2}\\n                      (inP {\\\\Sigma (u_1 u_2 : E) (x : S.E) (p : Bool) (\\\\Sigma ((\\\\case no {a.1 = a3.1} n1, a.2 xor a3.2 \\\\with {\\n                        | yes e, true => x2\\n                        | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                      }) = u_1 * u_2)\\n                        (a :: a1 :: a2 :: a3 :: x2 = u_1 * ((x, p) :: nil {\\\\Sigma S.E Bool}) * ((x, not p) :: nil {\\\\Sigma S.E Bool}) * u_2))}\\n                        (a :: nil {\\\\Sigma S.E Bool}, a3 :: x2, a1.1, a1.2,\\n                          (idp {List (\\\\Sigma S.E Bool)} {\\\\case no {a.1 = a3.1} n1, a.2 xor a3.2 \\\\with {\\n                            | yes e, true => x2\\n                            | d, b => (a.1, a.2) :: (a3.1, a3.2) :: x2\\n                          }},\\n                            transportInv {S.E}\\n                              (\\\\lam (x : S.E) => a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((x, not a1.2) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                              {a1.1} {a2.1} e (transportInv {Bool} (\\\\lam (x : Bool) =>\\n                                a :: a1 :: a2 :: a3 :: x2 = (a :: nil {\\\\Sigma S.E Bool}) * ((a1.1, a1.2) :: nil {\\\\Sigma S.E Bool}) * ((a2.1, x) :: nil {\\\\Sigma S.E Bool}) * (a3 :: x2))\\n                                {not a1.2} {a2.2} (helper1 {a1.2} {a2.2} p3) (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: a3 :: x2}))))))\\n                  }\\n                }\\n              }\\n              | no n1, p2 => transportInv {Dec (a.1 = a1.1)} (\\\\lam (x : Dec (a.1 = a1.1)) =>\\n                Closure {List (\\\\Sigma S.E Bool)} (AreAdjacent {S.E}) (a :: a1 :: a2 :: x1) (\\\\case x, a.2 xor a1.2 \\\\with {\\n                  | yes e, true => (a2.1, a2.2) :: x1\\n                  | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                })) {S.decideEq a.1 a1.1} {no {a.1 = a1.1} n} p1\\n                  (crefl {List (\\\\Sigma S.E Bool)} {AreAdjacent {S.E}} {a :: a1 :: a2 :: x1} {\\\\case no {a.1 = a1.1} n, a.2 xor a1.2 \\\\with {\\n                    | yes e, true => (a2.1, a2.2) :: x1\\n                    | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\\n                  }} (idp {List (\\\\Sigma S.E Bool)} {a :: a1 :: a2 :: x1}))\\n            })\\n          }\\n  }', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\func W \\\\hlevels  {S : \\\\Set} : Monoid (List (\\\\Sigma S Bool)) {\\n  | ide => nil {\\\\Sigma S Bool}\\n  | * => (++)\\n} => ListMonoid {\\\\Sigma S Bool}', '\\\\instance equivWords \\\\hlevels  {S : \\\\Set} : Equivalence (List (\\\\Sigma S Bool)) {\\n  | ~ => Closure {List (\\\\Sigma S Bool)} (AreAdjacent {S})\\n} => isEquivalence {List (\\\\Sigma S Bool)} (AreAdjacent {S})', 'yes E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func reduce \\\\hlevels  {S2 : DecSet} (_ : List (\\\\Sigma S.E Bool)) : List (\\\\Sigma S.E Bool) \\n  | {S}, nil => nil {\\\\Sigma S.E Bool}\\n  | {S}, (xa, xb) :: xs => \\\\case reduce {S} xs \\\\with {\\n    | nil => (xa, xb) :: nil {\\\\Sigma S.E Bool}\\n    | (ya, yb) :: ys => \\\\case S.decideEq xa ya, xb xor yb \\\\with {\\n      | yes e, true => ys\\n      | d, b => (xa, xb) :: (ya, yb) :: ys\\n    }\\n  }', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '\\\\data Closure {A : \\\\Type} (A -> A -> \\\\Type) (_ _ : A) : \\\\Prop \\n  | cin (R x y)\\n  | crefl (x = y)\\n  | csym (Closure {A} R y x)\\n  | ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)']<<<break>>>Closure {List (\\Sigma S.E Bool)} (AreAdjacent {S.E}) (\\case yes {a.1 = a1.1} e, true \\with {\n  | yes e, true => (a2.1, a2.2) :: x1\n  | d, b => (a.1, a.2) :: (a1.1, a1.2) :: (a2.1, a2.2) :: x1\n}) x", "completion": "csym (rewrite p in reduce_equiv x)"}
{"prompt": "['this : ToposPrecat', 'C : Ob', 'B : Ob', 'g : Hom A (apex B C)', 'A : Ob']<<<break>>>['| Hom Ob Ob : \\\\Set', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\func apex \\\\plevels obj >= hom \\\\hlevels  {this : ToposPrecat} (B C : Ob) : Ob => apex', '| Bprod (x y : Ob) : Product {Fin 2} (at {x :: y :: nil})', '\\\\func belongs \\\\plevels obj >= hom \\\\hlevels  {this : ToposPrecat} {B : Ob} : Hom (apex {Bprod (Power B) B}) omega => corefl-map {p-exponential B}', \"\\\\func prodMap \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y x' y' : Ob} (f : Hom x y) (f' : Hom x' y') : Hom (apex {Bprod x x'}) (apex {Bprod y y'}) \\n  => pair {y} {y'} {apex {Bprod x x'}} (f \u2218 proj1 {x} {x'}) (f' \u2218 proj2 {x} {x'})\", '| apex : Ob {D}', '\\\\func associator \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} : Hom (apex {Bprod (apex {Bprod x y}) z}) (apex {Bprod x (apex {Bprod y z})}) \\n=> pair {x} {apex {Bprod y z}} {apex {Bprod (apex {Bprod x y}) z}} (proj1 {x} {y} \u2218 proj1 {apex {Bprod x y}} {z})\\n  (pair {y} {z} {apex {Bprod (apex {Bprod x y}) z}} (proj2 {x} {y} \u2218 proj1 {apex {Bprod x y}} {z}) (proj2 {apex {Bprod x y}} {z}))', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '| id (X : Ob) : Hom X X', '\\\\func map \\\\plevels obj >= hom \\\\hlevels  {this : ToposPrecat} {B C : Ob} : Hom (ToposPrecat.graphs.apex B C) (Power (Product.apex {Bprod B C})) => pbProj2', '\\\\func Power \\\\plevels obj >= hom \\\\hlevels  {this : ToposPrecat} (B : Ob) : Ob => Coreflected {p-exponential B}', '| subobj-classifier \\\\alias omega : Ob']<<<break>>>belongs {Product.apex {Bprod B C}} \u2218 prodMap {A} {Power (Product.apex {Bprod B C})} {Product.apex {Bprod B C}} {Product.apex {Bprod B C}} (map {B} {C} \u2218 g)\n  (id (Product.apex {Bprod B C})) \u2218 associator {A} {B} {C} = belongs {Product.apex {Bprod B C}} \u2218 (prodMap {A} {Power (Product.apex {Bprod B C})} {Product.apex {Bprod B C}} {Product.apex {Bprod B C}} (map {B} {C} \u2218 g)\n  (id (Product.apex {Bprod B C})) \u2218 associator {A} {B} {C})", "completion": "o-assoc {this}"}
{"prompt": "['p : \\\\Sigma (IsInj {M.E} {N.E} f.func) (IsSurj {M.E} {N.E} f.func)', 'f : LinearMap {R} M N']<<<break>>>['| zro : E', '\\\\instance KerLModule \\\\hlevels  {R1 : Ring} {A B : LModule R1} (f : LinearMap {R1} A B) : LModule R1 (Kernel f) {\\n  | zro => (zro {f.Dom}, f.func-zro)\\n  | + => \\\\lam (a : E) (b : E) => (a.1 + b.1,\\n    f.func-+ {a.1} {b.1} *> pmap2 {E {f.Cod}} {E {f.Cod}} {E {f.Cod}} ((+) {f.Cod}) {f.func a.1} {zro {f.Cod}} a.2 {f.func b.1} {zro {f.Cod}} b.2 *> zro-left {f.Cod} {zro {f.Cod}})\\n  | negative => \\\\lam (a : E) => (negative {f.Dom} a.1,\\n    func-negative {f} {a.1} *> pmap {E {f.Cod}} {E {f.Cod}} (negative {f.Cod}) {f.func a.1} {zro {f.Cod}} a.2 *> negative_zro {f.Cod})\\n  | *c => \\\\lam (r : E {R {\\\\this}}) (a : E {\\\\this}) =>\\n    (r A.*c a.1, f.func-*c {r} {a.1} *> pmap {B.E} {B.E} ((B.*c) r) {f.func a.1} {B.zro} a.2 *> *c_zro-right {B} {r})\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| Cod : BaseSet', '| E : \\\\Set', '\\\\lemma inj->zeroKer \\\\hlevels  {R : Ring} {M N : LModule R} {f : LinearMap {R} M N} (_ : IsInj {M.E} {N.E} f.func) :\\n  IsZeroMod {R} (KerLModule {R} {M} {N} f) ', '| Dom : BaseSet', '| R : Ring']<<<break>>>\\Pi (m : E) -> m = zro", "completion": "inj->zeroKer p.1"}
{"prompt": "['bb=y : b * b = y - zro', 'aa=x : a * a = x - zro', 'x : E', 'this : StoneC*Algebra', 'a : E', 'b : E', 'y : E']<<<break>>>['| interpretNF {n : Nat} (Fin n -> M) (NF n) : M', '\\\\func iterr {A1 : \\\\Type} (_ : A1 -> A1) (_ : Nat) (_ : A1) : A1 \\n  | {A}, f, 0, a => a\\n  | {A}, f, suc n, a => f (iterr {A} f n a)', 'nil', 'inP A', '\\\\infixl 7 :* (_ _ : Term n)', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\type \\\\infix 4 <= \\\\hlevels  {R : Ring} (x y : R.E) : \\\\Prop => IsSquare {R} (y - x)', '| at (j : Fin len) : A j', '\\\\lemma terms-equality \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s)) :\\n  interpret {env.len} env.at t = interpret {env.len} env.at s ', '| normalize {n : Nat} (Term n) : NF n', '| E : \\\\Set', '\\\\lemma apply-axiom \\\\hlevels  {M : CMonoid} (env : Array M.E) (t s : Term env.len)\\n  (_ : interpret {M} {env.len} env.at t = interpret {M} {env.len} env.at s) (n : Nat) (add : List (Fin env.len)) :\\n  interpretNF {M} {Fin env.len} env.at (sort {FinOrder env.len} (iterr {List (Fin env.len)} ((++) (normalize {env.len} t)) n add)) = interpretNF {M} {Fin env.len} env.at (sort {FinOrder env.len} (iterr {List (Fin env.len)} ((++) (normalize {env.len} s)) n add)) ', 'var (Fin n)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func MonoidSolverModel \\\\hlevels  (M1 : Monoid) : SubstSolverModel M.E {\\n  | Term => MonoidSolverModel.Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => \\\\lam {n : Nat} (t : SolverModel.Term {\\\\this} n) => normalize-aux {n} t (nil {Fin n})\\n  | interpret => MonoidSolverModel.interpret {M1}\\n  | interpretNF => \\\\lam {n : Nat} => MonoidSolverModel.interpretNF {M1} {Fin n}\\n  | nfVar => \\\\lam {n : Nat} (v : Fin n) => v :: nil {Fin n}\\n  | >>= => \\\\lam {m : Nat} {n : Nat} => (>>=)\\n} => \\\\new SubstSolverModel {\\n  | interpretNF-consistent => {?hidden}\\n  | >>=-consistent => {?hidden}\\n}', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func sort \\\\hlevels  {A : Dec} (l : List A.E) : List A.E => rbTreeToList {A.E} (aux {A} l (rbLeaf {A.E})) (nil {A.E})', '\\\\lemma minus_zro \\\\hlevels  {this : AddGroup} {x : E} : x - zro = x ', '| zro : E', '\\\\func CMonoidSolverModel \\\\hlevels  (M1 : CMonoid) : SolverModel M.E {\\n  | Term => MonoidSolverModel.Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => normalize\\n  | interpret => MonoidSolverModel.interpret {M1}\\n  | interpretNF => \\\\lam {n : Nat} (env : Fin n -> M {\\\\this}) (nf : NF {\\\\this} n) =>\\n    MonoidSolverModel.interpretNF {M1} {Fin n} env (sort {FinOrder n} nf)\\n} => \\\\new SolverModel {\\n  | interpretNF-consistent => {?hidden}\\n}', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func interpretNF \\\\hlevels  {M2 : Monoid} {V1 : \\\\Set} (_ : V1 -> M.E) (_ : List V1) : M.E \\n  | {M}, {V}, env, nil => M.ide\\n  | {M}, {V}, env, x :: nil => env x\\n  | {M}, {V}, env, x :: l => env x M.* interpretNF {M} {V} env l', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)']<<<break>>>zro <= x * y", "completion": "inP (a * {this} b, cMonoid {(aa=x *> minus_zro {this}, bb=y *> minus_zro {this})} *> inv (minus_zro {this}))"}
{"prompt": "['cr : IsReduced {V} {B} c', 'i : Fin (len {map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) (\\\\new Array (\\\\Sigma V.E B.E) P.finCard\\n  (\\\\lam (j : Fin P.finCard) => ((b.at (Pe.f j).1.1).1, (b.at (Pe.f j).1.1).2 B.* (c.at (Pe.f j).1.2).2)))})', 'Pe : Equiv {Fin P.finCard} {P.E}', 'env : Array B.E 4', 'j : Fin (len {map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) (\\\\new Array (\\\\Sigma V.E B.E) P.finCard\\n  (\\\\lam (j : Fin P.finCard) => ((b.at (Pe.f j).1.1).1, (b.at (Pe.f j).1.1).2 B.* (c.at (Pe.f j).1.2).2)))})', 'B : BooleanRing', 'q : Not ((Pe.f i).1.2 = (Pe.f j).1.2)']<<<break>>>['true', \"\\\\func multiply \\\\plevels  \\\\hlevels  {n2 : Nat} (_ _ : NF n2) : NF n2 \\n  | {n}, l1, nil => nil {Array Bool n}\\n  | {n}, l1, l2 => multiply' {n} l1 l2 (nil {Array Bool n})\", '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'nil', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', \"\\\\func interpretNF \\\\hlevels  {B : BooleanRing} {n : Nat} (env : Fin n -> B.E) (l : NF n) : B.E \\n  => interpretNF' {B} {n} (\\\\new Array B.E n env) (collapse {n} (sort {LexicographicalArray {n} BoolOpPoset} l))\", '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\infixl 7 :* (_ _ : Term n)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'false', '| at (j : Fin len) : A j', \"\\\\func interpretNF' \\\\hlevels  {B3 : BooleanRing} {n2 : Nat} (_ : Array B.E n2) (_ : NF n2) : B.E \\n  | {B}, {n}, env, nil => B.zro\\n  | {B}, {n}, env, x :: nil => interpretMonomial {B} {n} env x\\n  | {B}, {n}, env, x :: l => interpretMonomial {B} {n} env x B.+ interpretNF' {B} {n} env l\", '| E : \\\\Set', 'var (Fin n)', '\\\\data Term \\\\plevels  \\\\hlevels  Nat \\n  | var (Fin n)\\n  | :zro\\n  | :negative (Term n)\\n  | \\\\infixl 6 :+ (_ _ : Term n)\\n  | \\\\infixl 7 :* (_ _ : Term n)', '\\\\func interpret \\\\hlevels  {B4 : BooleanRing} (env4 : Array B.E) (_ : Term env.len) : B.E \\n  | {B}, env, var j => env.at j\\n  | {B}, env, :zro => B.zro\\n  | {B}, env, :negative t => B.negative (interpret {B} env t)\\n  | {B}, env, t :+ s => interpret {B} env t B.+ interpret {B} env s\\n  | {B}, env, t :* s => interpret {B} env t B.* interpret {B} env s', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', ':zro', \"\\\\lemma apply-axioms \\\\hlevels  {B : BooleanRing} {n : Nat} (env : Array B.E n)\\n  (l : Array (\\\\Sigma (NF n) (t s : Term n) (interpret {B} env t = interpret {B} env s))) (add : NF n) :\\ninterpretNF {B} {n} env.at (Big {List (Array Bool n)} {List (Array Bool n)} (++) add\\n  (map {\\\\Sigma (NF n) (t s : Term n) (interpret {B} env t = interpret {B} env s)} {List (Array Bool n)}\\n    (\\\\lam (s : \\\\Sigma (NF n) (t s : Term n) (interpret {B} env t = interpret {B} env s)) =>\\n      multiply {n} s.1 (normalize {n} (s.2 :+ s.3))) l)) = interpretNF' {B} {n} env add \", '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func normalize {n5 : Nat} (_ : Term n5) : NF n5 \\n  | {n}, var j => singleAt {Bool} {n} j true false :: nil {Array Bool n}\\n  | {n}, :zro => nil {Array Bool n}\\n  | {n}, :negative t => normalize {n} t\\n  | {n}, t :+ s => normalize {n} t ++ normalize {n} s\\n  | {n}, t :* s => multiply {n} (normalize {n} t) (normalize {n} s)', '\\\\infixl 6 :+ (_ _ : Term n)', '\\\\func NF \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => List (Array Bool n)', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpretNF {B} {4} env.at (Big {List (Array Bool 4)} {List (Array Bool 4)} (++) (nil {Array Bool 4})\n  (map {\\Sigma (NF 4) (t s : Term 4) (interpret {B} env t = interpret {B} env s)} {List (Array Bool 4)}\n    (\\lam (s : \\Sigma (NF 4) (t s : Term 4) (interpret {B} env t = interpret {B} env s)) =>\n      multiply {4} s.1 (normalize {4} (s.2 :+ s.3)))\n    (((true :: false :: true :: false :: nil) :: nil {Array Bool 4}, var {4} 1 :* var {4} 3, :zro {4},\n      cr {(Pe.f i).1.2} {(Pe.f j).1.2} q) :: nil))) = interpretNF' {B} {4} env (nil {Array Bool 4})", "completion": "apply-axioms\nenv (((true :: false :: true :: false :: nil) :: nil, var 1 :* var 3, :zro, cr {(Pe.f i).1.2} {(Pe.f j).1.2} q) :: nil)\n  nil"}
{"prompt": "['i : Fin n', 'd : IsUpperTriangular {R} {suc n} {suc n} A', 'j : Fin n', 'R : CRing', 'i<j : j < i', 'A : Matrix R.E (suc n) (suc n)']<<<break>>>['| zro : E', 'suc Nat', 'suc<suc (n < m)', '| at (j : Fin len) : A j', '| E : \\\\Set']<<<break>>>at {at {A} (suc i)} (suc j) = R.zro", "completion": "d (suc i) (suc j) (suc<suc i<j)"}
{"prompt": "['n/=0 : n /= 0', 'a : Rat', 'b : Rat', 'a<b : a < b', 'a>=0 : zro <= a', 'n : Nat']<<<break>>>['\\\\lemma rat_real_<= \\\\plevels  \\\\hlevels  {a b : Rat} : a <= b <-> fromRat a <= fromRat b ', '| zro : E', '\\\\lemma root-monotone {n : Nat} (_ : n /= 0) {x y : Real} (_ : zro <= x) (_ : x < y) : root n x < root n y ', '\\\\lemma rat_real_< \\\\plevels  \\\\hlevels  {a b : Rat} : a < b <-> fromRat a < fromRat b ', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\instance RatNormed \\\\hlevels  : NormedAbGroup Rat {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | negative => RatField.negative\\n  | norm => \\\\lam (a : E {\\\\this}) => Real.fromRat (abs {RatField} a)\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', 'root (_ : Nat) (_ : Real) : Real \\n  | 0, x => zro\\n  | suc n, x => (ret {rootEquiv {suc n} (suc/=0 {n})} (x \u2228 zro, join-right {x} {zro})).1', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)']<<<break>>>root n (fromRat a) < root n (fromRat b)", "completion": "root-monotone n/=0 (rat_real_<=.1 a>=0) (rat_real_<.1 a<b)"}
{"prompt": "['this : Precat (ObOver {C} x) {\\n  | Hom => \\\\lam (p0 : Ob {\\\\this}) (p1 : Ob {\\\\this}) => \\\\Sigma (h : C.Hom p0.1 p1.1) (p1.2 C.\u2218 h = p0.2)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (C.id p0.1, C.id-right {p0.1} {x} {p0.2})\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) => (p0.1 C.\u2218 p1.1,\\n    inv {C.Hom X.1 x} {Z.2 C.\u2218 p0.1 C.\u2218 p1.1} {Z.2 C.\u2218 (p0.1 C.\u2218 p1.1)} (C.o-assoc {X.1} {Y.1} {Z.1} {x} {Z.2} {p0.1} {p1.1}) *> pmap {C.Hom Y.1 x} {C.Hom X.1 x} (\\\\lam (_x : C.Hom Y.1 x) => _x C.\u2218 p1.1) {Z.2 C.\u2218 p0.1} {Y.2} p0.2 *> p1.2)\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', 'x : C.Ob', 'C : Precat']<<<break>>>['| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| Hom Ob Ob : \\\\Set', '| id (X : Ob) : Hom X X', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| Ob : \\\\hType', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z']<<<break>>>\\Pi {X : Ob {\\this}} -> \\Pi {Y : Ob {\\this}} -> \\Pi {f : Hom {\\this} X Y} -> id {\\this} Y \u2218 f = f", "completion": "\\lam {X} {Y} {f} => ext id-left"}
{"prompt": "['d : E', 'this : GCDMonoid', 'a : E', 'r : LDiv d e|a.inv', 'e : E', 'e|a : LDiv e a']<<<break>>>['| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func make \\\\hlevels  {M : Monoid} {a b : M.E} (c : M.E) (p : a M.* c = b) : LDiv {M} a b c => \\\\new LDiv {\\n  | inv-right => {?hidden}\\n}', '| E : \\\\Set', '| inv : E {M}', '| inv-right : val * inv = elem', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>LDiv (d * e) a r.inv", "completion": "make (inv {r})\n  (pmap (\\lam _x => _x * {this} _) (*-comm {this}) *> *-assoc {this} *> pmap ((*) {this} e) (inv-right {r}) *> inv-right {e|a})"}
{"prompt": "['A : PseudoNormedAbGroup', 'S : Series A.E']<<<break>>>['\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\lemma real_<_U \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : x < fromRat a <-> x.U a ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| norm E : ExUpperReal', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '| zro : E', '\\\\instance RealValuedRing : CompleteValuedCRing Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (+)\\n  | negative => negative\\n  | norm => abs {RealAbGroup}\\n  | * => (RealField.*)\\n  | ide => fromRat ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n} => \\\\new CompleteValuedCRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func midSum \\\\hlevels  {A3 : AddMonoid} (_ : Series A.E) (_ _ : Nat) : A.E \\n  | {A}, S, 0, m => partialSum {A} S m\\n  | {A}, S, suc n, 0 => A.zro\\n  | {A}, S, suc n, suc m => midSum {A} (\\\\lam (j : Nat) => S (suc j)) n m', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| U Rat : \\\\Prop', '\\\\lemma rat_real_< \\\\plevels  \\\\hlevels  {a b : Rat} : a < b <-> fromRat a < fromRat b ', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}']<<<break>>>(\\Pi {eps : Real} -> zro < eps -> TruncP (\\Sigma (N : Nat) (\\Pi {n : Nat} -> N <= n -> A.norm (midSum {A} S N n) < eps))) ->\n  \\Pi {eps : Rat} -> zro < eps -> TruncP (\\Sigma (N : Nat) (\\Pi {n : Nat} -> N <= n -> U {A.norm (midSum {A} S N n)} eps))", "completion": "\\lam sc eps>0 => (\\case sc (rat_real_<.1 eps>0) \\with {\n  | inP (N, h) => inP (N, \\lam p => real_<_U.1 $ h p)\n})"}
{"prompt": "['null : Ob {C}', 'this : RightAdjointCoreflection']<<<break>>>['| Coreflected : Ob {D}', '| corefl-map : Hom {C} (F {L} Coreflected) B', '| Hom Ob Ob : \\\\Set', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| L : Functor D C', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| coreflection (Z : Ob {C}) : Coreflection {C} {D} L Z', '| B : Ob {C}', '\\\\func adjoint {this : Equiv} {a : A} {b : B} (p : f a = b) : a = ret b \\n  => inv {A} {ret (f a)} {a} (ret_f a) *> pmap {B} {A} ret {f a} {b} p', '| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| ret B : A', '| id (X : Ob) : Hom X X', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| D : Precat', '| isCoreflection {Z : Ob {D}} : Equiv {Hom {D} Z Coreflected} {Hom {C} (F {L} Z) B} (\\\\lam (x : A {\\\\this}) => corefl-map \u2218 Func {L} {Z} {Coreflected} x)', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| C : Precat', '| L : Functor D C', '| C : Precat', '| Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)']<<<break>>>Func {o} {o} (id {C} o) = id {D} (F o)", "completion": "unfold (rewrite id-left $ inv $ adjoint $ unfold $ rewrite (Func-id {L {this}}, id-right) idp)"}
{"prompt": "['N : \\\\hType', 'Y-conn : isConnectedType {nullTypeUniverse N} Y', 'X-local : isLocal X', 'Y : \\\\hType', 'M : \\\\hType', 'X : \\\\hType']<<<break>>>['| A : \\\\Type', '\\\\data PushoutData {A B C : \\\\Type} (A -> B) (A -> C) \\n  | pinl B\\n  | pinr C\\n  | pglue A I', '\\\\func nullTypeUniverse (M : \\\\Type) : Modality {\\n  | isLocal => \\\\lam (Z : \\\\hType) => \\\\Sigma -> Equiv {\\\\Sigma -> Z} {M -> Z} (\\\\lam (_x : A {\\\\this}) => _x o (\\\\lam (_ : M) => ()))\\n  | localization => \\\\lam (A1 : \\\\hType) => \\\\new Localization {famUniverse {\\\\new Family {\\n    | J => \\\\Sigma\\n    | X => \\\\lam (_ : \\\\Sigma) => M\\n    | Y => \\\\lam (_ : J {\\\\this}) => \\\\Sigma\\n    | F => \\\\lam (j : J {\\\\this}) (_ : X {\\\\this} j) => ()\\n  }}} A1 (\\\\new Local {U {\\\\this}} (LData {famHat {\\\\new Family {\\n    | J => \\\\Sigma\\n    | X => \\\\lam (_ : \\\\Sigma) => M\\n    | Y => \\\\lam (_ : J {\\\\this}) => \\\\Sigma\\n    | F => \\\\lam (j : J {\\\\this}) (_ : X {\\\\this} j) => ()\\n  }}} A1) {\\n    | local => {?hidden}\\n  }) {\\n    | inL => alpha {famHat {\\\\new Family {\\n      | J => \\\\Sigma\\n      | X => \\\\lam (_ : \\\\Sigma) => M\\n      | Y => \\\\lam (_ : J {\\\\this}) => \\\\Sigma\\n      | F => \\\\lam (j : J {\\\\this}) (_ : X {\\\\this} j) => ()\\n    }}} {A1}\\n    | local-univ => {?hidden}\\n  }\\n} => nullFamUniverse {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => M)', '\\\\func Join (A B : \\\\Type) : \\\\hType \\n  => PushoutData {\\\\Sigma A B} {A} {B} (\\\\lam (p0 : \\\\Sigma A B) => p0.1) (\\\\lam (p0 : \\\\Sigma A B) => p0.2)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma connected_local_join-left \\\\hlevels  (X Y M N : \\\\hType) (_ : isConnectedType {nullTypeUniverse M} X) (_ : isLocal Y) : isLocal Y ', '\\\\func Equiv-to-= {A B : \\\\Type} (e : Equiv {A} {B}) : A = B => QEquiv-to-= {A} {B} (fromEquiv e)', '| isLocal \\\\hType : \\\\Prop', '\\\\func Join-sym (A B : \\\\Type) : QEquiv {Join A B} {Join B A} (flip {A} {B}) {\\n  | ret => flip {B} {A}\\n  | ret_f => flip-flip {A} {B}\\n  | f_sec => flip-flip {B} {A}\\n} => \\\\new QEquiv', '\\\\class Equiv \\\\extends Section, Retraction', '\\\\func \\\\infixr 8 o {A B C : \\\\Type} (g : B -> C) (f : A -> B) : \\\\Pi (x : A) -> C => \\\\lam (x : A) => g (f x)']<<<break>>>\\Sigma -> Equiv {\\Sigma -> X} {Join Y M -> X} (\\lam (_x : A {\\this}) => _x o (\\lam (_ : Join Y M) => ()))", "completion": "connected_local_join-left Y X N M Y-conn (rewriteI (Equiv-to-= (Join-sym M N)) X-local)"}
{"prompt": "['N : Nat', 'S : Series A.E', 'A : ExPseudoNormedAbGroup']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func IsConvUpperSeries \\\\hlevels  (S : Series ExUpperReal) : \\\\Prop => \\\\Pi {eps : Rat} ->\\n  zro < eps -> TruncP (\\\\Sigma (N : Nat) (\\\\Pi {n : Nat} -> N <= n -> U {midSum {ExUpperRealAbMonoid} S N n} eps))', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma norm>=0 \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : zro <= X.norm x ', '\\\\lemma upperSeries-shifts-conv \\\\plevels  \\\\hlevels  {S : Series ExUpperReal} (_ : \\\\Pi (j : Nat) -> zro <= S j) (N : Nat) :\\n  IsConvUpperSeries S <-> IsConvUpperSeries (\\\\lam (n : Nat) => S (n + N)) ', '| norm E : ExUpperReal']<<<break>>>\\Sigma (IsConvUpperSeries (\\lam (j : Nat) => A.norm (S j)) ->\n  IsConvUpperSeries (\\lam (n : Nat) => (\\lam (j : Nat) => A.norm (S j)) (n + N)))\n  (IsConvUpperSeries (\\lam (n : Nat) => (\\lam (j : Nat) => A.norm (S j)) (n + N)) ->\n    IsConvUpperSeries (\\lam (j : Nat) => A.norm (S j)))", "completion": "upperSeries-shifts-conv (\\lam j => norm>=0) N"}
{"prompt": "['V : LModule R', 'lv : Array V.E l.len', 'U : LModule R', 'R : Ring', 'lb : IsBasis {U} l', 'j : Fin l.len', 'l : Array U.E']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma BigSum-unique \\\\hlevels  {this : AddMonoid} {l : Array E} (i : Fin l.len) (_ : \\\\Pi (j : Fin l.len) -> i /= j -> l.at j = zro) : BigSum l = l.at i ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', 'basis-split \\\\hlevels  {this : LModule} {l : Array E} (lb : IsBasis l) (x : E) : Array (E {R}) l.len => (basis-split-pair {l} lb x).1', '| zro : E', '\\\\lemma *c_zro-left \\\\hlevels  {this : LModule} {a : E} : zro {R} *c a = zro ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\lemma basis_split_/= \\\\hlevels  {this : LModule} {l : Array E} {lb : IsBasis l} {j k : Fin l.len} (_ : j /= k) :\\n  at {basis-split {l} lb (l.at j)} k = zro {R} ', '| at (j : Fin len) : A j', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>BigSum {V} (\\new Array V.E l.len (\\lam (k : Fin l.len) => at {basis-split {U} {l} lb (l.at j)} k V.*c lv.at k)) = at {basis-split {U} {l} lb (l.at j)} j V.*c lv.at j", "completion": "BigSum-unique {V} {\\lam k => basis-split {U} lb (l j) k *c lv k} j\n  (\\lam k j/=k => pmap (\\lam _x => _x *c _) (basis_split_/= {U} j/=k) *> *c_zro-left {V})"}
{"prompt": "['r : Retraction {s.A} {s.B} s.f', 's : Section']<<<break>>>['| A : \\\\Type', '\\\\class Retraction \\\\extends Map {\\n  | sec B : A\\n  | f_sec (y : B) : f (sec y) = y\\n}', '\\\\func =Fiber {A B1 : \\\\Type} (f : A -> B1) : Retraction {A} {B1} f = Fib {B1 -> A} {B1 -> B1} (o- {B1} {A} {B1} f) (id {B1}) \\n=> path (iso {Retraction {A} {B1} f} {\\\\Sigma (a : B1 -> A) ((\\\\lam (x : B1) => f (a x)) = (\\\\lam (x : B1) => x))}\\n  (\\\\lam (s : Retraction {A} {B1} f) =>\\n  make {B1 -> A} {B1 -> B1} {\\\\lam (a : B1 -> A) (x : B1) => f (a x)} {\\\\lam (x : B1) => x} s.sec\\n    (path (\\\\lam (i : I) (x : B1) => s.f_sec x @ i)))\\n  (\\\\lam (z : \\\\Sigma (a : B1 -> A) ((\\\\lam (x : B1) => f (a x)) = (\\\\lam (x : B1) => x))) => \\\\new Retraction {A} {B1} f {\\n    | sec => z.1\\n    | f_sec => \\\\lam (x : B {\\\\this}) => path (\\\\lam (p0 : I) => (@) z.2 p0 x)\\n  }) (idpe {Retraction {A} {B1} f}) (idpe {\\\\Sigma (a : B1 -> A) ((\\\\lam (x : B1) => f (a x)) = (\\\\lam (x : B1) => x))}))', '\\\\func id {A : \\\\Type} : \\\\Pi (x : A) -> A => \\\\lam (x : A) => x', '| f_sec (y : B) : f (sec y) = y', \"\\\\class Contr {\\n  | A : \\\\Type\\n  | center : A\\n  | contraction (a' : A) : center = a'\\n}\", '\\\\lemma fromSection (s : Section) (_ : Retraction {s.A} {s.B} s.f) : hasContrFibers {s.A} {s.B} s.f ', '| ret_f (x : A) : ret (f x) = x', '| ret B : A', '| f A : B', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func o- {A B C : \\\\Type} (g : B -> C) : \\\\Pi (f : A -> B) -> \\\\Pi (x : A) -> C => \\\\lam (f : A -> B) (x : A) => g (f x)', '\\\\class Section \\\\extends Map {\\n  | ret B : A\\n  | ret_f (x : A) : ret (f x) = x\\n}', '| sec B : A', '| B : \\\\Type']<<<break>>>Contr (Retraction {s.A} {s.B} s.f)", "completion": "transportInv Contr (=Fiber s) (fromSection (\\new Section (o- s) {\n  | ret => o- (ret {s})\n  | ret_f => \\lam g => path (\\lam i x => ret_f {s} (g x) i)\n})\n  (\\new Retraction {\n    | sec => o- (sec {r})\n    | f_sec => \\lam g => path (\\lam i x => f_sec {r} (g x) i)\n  }) id)"}
{"prompt": "['X : TopLModule R', 'x : Total {X.E} S', 'Y : TopLModule R', 'g : Total {X.E} S -> X2.E', 'a : X.E', 'So : X.isOpen S', 'R : NearSkewField', 'X1 : TopLModule R', 'S : Set X.E', 'f : Total {X.E} S -> X1.E', 'X2 : TopLModule R', 'b : BilinearMap {R} X1 X2 Y']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func DirSet \\\\hlevels  {R : NearSkewField} {X : TopLModule R} {S : Set X.E} {x : Total {X.E} S} {a : X.E} (So : X.isOpen S) :\\nDirectedSet (\\\\Sigma (V : Set R.E) (R.isOpen V) (V R.zro) (x1 : R.E) (V x1) ((\u2227) (\\\\lam (h : R.E) => Inv {R} h) (\\\\lam (x1 : R.E) =>\\n  S (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1))\\n  x1)) {\\n  | <= => \\\\lam (S : E {\\\\this}) (T : E {\\\\this}) => T.1 \u2286 S.1\\n} => InvDirectedSet {R} {\\\\lam (x1 : R.E) =>\\n  S (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1)}\\n  (aux1 {R} {X} {S} {x} {a} So) (aux2 {R} {X} {S} {x} {a})', '\\\\func tuple \\\\hlevels  {X Y Z : TopSpace} (f : ContMap X Y) (g : ContMap X Z) : ContMap X (Y \u2a2f Z) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, g.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| func (E {A}) (E {B}) : E {C}', '| val : E {M}', '\\\\func dquot \\\\hlevels  {R : NearSkewField} {X Y : TopLModule R} {S : Set X.E} (f : Total {X.E} S -> Y.E) {x : Total {X.E} S} (h : Inv {R})\\n  (a : X.E) (\\\\property s : S (x.1 X.+ h.val X.*c a)) : Y.E => h.inv Y.*c (f (x.1 X.+ h.val X.*c a, s) - f x)', '\\\\func id \\\\hlevels  {X : TopSpace} : ContMap X X {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func const \\\\hlevels  {Y X : TopSpace} (x : X.E) : ContMap Y X {\\n  | func => \\\\lam (_ : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\lemma dquot_bilinear \\\\hlevels  {R : NearSkewField} {X X1 X2 Y : TopLModule R} (S : Set X.E) {f : Total {X.E} S -> X1.E} {g : Total {X.E} S -> X2.E}\\n  {x : Total {X.E} S} {a : X.E} (b : BilinearMap {R} X1 X2 Y) (h : Inv {R}) (Sh : S (x.1 X.+ h.val X.*c a)) :\\n  dquot {R} {X} {Y} {S} (\\\\lam (x : Total {X.E} S) => b.func (f x) (g x)) {x} h a {?hidden} = b.func (dquot {R} {X} {X1} {S} f {x} h a {?hidden}) (g (x.1 X.+ h.val X.*c a, Sh)) Y.+ b.func (f x) (dquot {R} {X} {X2} {S} g {x} h a {?hidden}) ', '\\\\func Total {X : \\\\Type} (U : Set X) : \\\\Type => \\\\Sigma (x : X) (\\\\property (U x))']<<<break>>>\\Pi (h : E) -> dquot {R} {X} {Y} {S} (\\lam (x : Total {X.E} S) => b.func (f x) (g x)) {x} h.6.1\n  (SetHom.func {tuple {R} {R} {X} (id {R}) (const {R} {X} a)} h.4).2 {?hidden} = b.func (dquot {R} {X} {X1} {S} f {x} h.6.1 (SetHom.func {tuple {R} {R} {X} (id {R}) (const {R} {X} a)} h.4).2 {?hidden})\n  (g (x.1 X.+ val {h.6.1} X.*c (SetHom.func {tuple {R} {R} {X} (id {R}) (const {R} {X} a)} h.4).2, h.6.2)) Y.+ b.func (f x) (dquot {R} {X} {X2} {S} g {x} h.6.1 (SetHom.func {tuple {R} {R} {X} (id {R}) (const {R} {X} a)} h.4).2 {?hidden})", "completion": "\\lam h => dquot_bilinear S b h.6.1 h.6.2"}
{"prompt": "['n : E {G {\\\\this}}', 'f : InterwiningMap {G} {R} A B', 'm : E {G {\\\\this}}', 'e : E {\\\\this}', 'this : LinRepres R1 G1 (Image {E {f.Dom}} {E {f.Cod}} f.func) {\\n  | zro => (zro {f.Cod}, inP {\\\\Sigma (a : E {f.Dom}) (f.func a = zro {f.Cod})} (zro {f.Dom}, f.func-zro))\\n  | + => \\\\lam (a : E) (b : E) => (a.1 + b.1, \\\\case a.2, b.2 \\\\with {\\n    | inP t, inP s => inP {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1 + b.1)} (t.1 + s.1,\\n      f.func-+ {t.1} {s.1} *> pmap2 {E {f.Cod}} {E {f.Cod}} {E {f.Cod}} ((+) {f.Cod}) {f.func t.1} {a.1} t.2 {f.func s.1} {b.1} s.2)\\n  })\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => \\\\lam (a : E) => (negative {f.Cod} a.1,\\n    map {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)} {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = negative {f.Cod} a.1)} a.2\\n      (\\\\lam (s : \\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)) =>\\n        (negative {f.Dom} s.1, func-negative {f} {s.1} *> pmap {E {f.Cod}} {E {f.Cod}} (negative {f.Cod}) {f.func s.1} {a.1} s.2)))\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c => \\\\lam (r : E {R}) (a : E) =>\\n  (r B.*c a.1, map {\\\\Sigma (a1 : A.E) (f.func a1 = a.1)} {\\\\Sigma (a1 : A.E) (f.func a1 = r B.*c a.1)} a.2\\n    (\\\\lam (s : \\\\Sigma (a1 : A.E) (f.func a1 = a.1)) =>\\n      (r A.*c s.1, f.func-*c {r} {s.1} *> pmap {B.E} {B.E} ((B.*c) r) {f.func s.1} {a.1} s.2)))\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | ** => \\\\lam (g : G.E) (e : E) => (g B.** e.1, map {\\\\Sigma (a : A.E) (f.func a = e.1)} {\\\\Sigma (a : A.E) (f.func a = g B.** e.1)} e.2\\n    (\\\\lam (s : \\\\Sigma (a : A.E) (f.func a = e.1)) =>\\n      (g A.** s.1, f.func-** {s.1} {g} *> pmap {B.E} {B.E} ((B.**) g) {f.func s.1} {e.1} s.2)))\\n  | **-assoc => {?hidden}\\n  | id-action => {?hidden}\\n  | **-ldistr => {?hidden}\\n  | **-*c => {?hidden}\\n}']<<<break>>>['| \\\\infixl 7 * E E : E', '| G : Group', '| \\\\infixl 8 ** (E {G}) E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (a : E {f.Dom}) (f.func a = ((m * n) ** e).1))", "completion": "((m G.* n) B.** e.1, map {\\Sigma (a : A.E) (f.func a = e.1)} {\\Sigma (a : A.E) (f.func a = (m G.* n) B.** e.1)} e.2\n  (\\lam (s : \\Sigma (a : A.E) (f.func a = e.1)) =>\n    ((m G.* n) A.** s.1, f.func-** {s.1} {m G.* n} *> pmap {B.E} {B.E} ((B.**) (m G.* n)) {f.func s.1} {e.1} s.2))).2"}
{"prompt": "['this : HeytingAlebra']<<<break>>>['\\\\func neg \\\\hlevels  {this : HeytingAlebra} (x : E) : E => x --> bottom', '| bottom : E', '| top : E', '| \\\\infix 4 <= E E : \\\\Prop', '| bottom-univ {x : E} : bottom <= x']<<<break>>>bottom <= neg top", "completion": "bottom-univ {this}"}
{"prompt": "['t : \\\\Sigma (p : E {e.dom} = E {e.cod}) (Path (\\\\lam (i : I) => Dec (p @ i)) (\\\\new e.dom {}) (\\\\new e.cod {}))\\n  (\\\\Pi (x : E {e.dom}) -> transport {\\\\Type} (\\\\lam (Z : \\\\Type) => Z) {E {e.dom}} {E {e.cod}} p x = func {e.f} x)', 'i : I']<<<break>>>['\\\\field trichotomy (x y : E) : Tri x y', \"\\\\data Tri \\\\hlevels  {A : StrictPoset} (_ _ : A.E) \\n  | less (a A.< a')\\n  | equals (a = a')\\n  | greater (a A.> a')\", '| E : \\\\Set']<<<break>>>\\Pi (x y : E {t.2 @ i}) -> Tri {t.2 @ i} x y", "completion": "trichotomy {t.2 @ i}"}
{"prompt": "['f : UniformMap X Y', \"V' : Set Y.E\", \"V'y : V' y\", 'Z : CompleteUniformSpace', \"W' : Set Z.E\", 'U : Set X.E', 'X : UniformSpace', \"V'<=<V : V' <=< V\", 'q : f.func ^-1 V \u2286 U', 'y : Y.E', 'g : UniformMap X Z', 'V : Set Y.E', 'fd : IsDenseUniformEmbedding {f}', 'Y : UniformSpace', \"p : U = g.func ^-1 W'\"]<<<break>>>['| <=<-right {U V W : E {A}} (U <= V) (R V W) : R U W', '| F (E {A}) : \\\\Prop', '| func-cauchy (F1 : CauchyFilter Dom) : CauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isProper => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func IsEmbedding \\\\hlevels  {this : PrecoverMap} : \\\\Prop => \\\\Pi {C : Set (Set (E {Dom}))} -> isCauchy {Dom} C ->\\n  isCauchy {Cod} (\\\\lam (V : Set (E {Cod})) => TruncP (\\\\Sigma (U : Set (E {Dom})) (C U) (func ^-1 V \u2286 U)))', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\lemma embedding->coverEmbedding \\\\hlevels  {this : UniformMap} (_ : IsUniformEmbedding) : IsEmbedding ', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\lemma <=<-inter \\\\hlevels  {X : CoverSpace} {x : X.E} {U : Set X.E} (_ : single {X.E} x <=< U) :\\n  TruncP (\\\\Sigma (V : Set X.E) (single {X.E} x <=< V) (V <=< U)) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func IsDenseEmbedding \\\\hlevels  {this : PrecoverMap} : \\\\Prop => \\\\Sigma IsDense IsEmbedding', '\\\\func IsDense \\\\hlevels  {this : ContMap} : \\\\Prop => IsDenseSet {Cod} (\\\\lam (y : E {Cod}) => TruncP (\\\\Sigma (x : E {Dom}) (func x = y)))', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', \"\\\\func dense-filter-lift \\\\hlevels  {X1 Y : CoverSpace} (f : CoverMap X1 Y) (fd : IsDenseEmbedding {f}) (F1 : CauchyFilter Y) :\\n  CauchyFilter X1 (\\\\lam (U : E {A {\\\\this}}) => TruncP (\\\\Sigma (V' V : Set Y.E) (f.func ^-1 V \u2286 U) (V' <=< V) (F.F V'))) \\n=> \\\\new CauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n}\", '| func (E {Dom}) : E {Cod}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '\\\\lemma single_<= \\\\hlevels  {X : \\\\Set} {a : X} {U : Set X} (_ : U a) : single {X} a \u2286 U ']<<<break>>>F {g.func-cauchy (dense-filter-lift {X} {Y} f {?hidden} (pointCF {Y} y))} W'", "completion": "\\case <=<-inter (<=<-right (single_<= V'y) V'<=<V) \\with {\n  | inP (V'', y<=<V'', V''<=<V) => inP $ later (V'', V, rewrite p in q, V''<=<V, y<=<V'')\n}"}
{"prompt": "['this : ColimitData', 'f : ModelHom {T} Colimit M', 's : Sort', 'M : Model T', 'h : Symb {T} s', 'j : Fin (len {domain {T} {s} h})', 'd : DArray {len {domain {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} h)}}\\n  (\\\\lam (j : Fin (len {domain {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} h)})) =>\\n  Term {thExt} (\\\\lam (_ : Sort) => Empty)\\n    (at {domain {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} h)} j))']<<<break>>>['| E (Sort {T}) : \\\\Set', '| Sort : \\\\Set', '\\\\instance ModelPrecat (T : Theory) : Precat (Model T) {\\n  | Hom => ModelHom {T}\\n  | id => \\\\lam (M : Ob {\\\\this}) => \\\\new ModelHom {T} M M {\\n    | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => x\\n    | func-op => {?hidden}\\n    | func-rel => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new ModelHom {T} X Z {\\n    | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => g.funcs {s} (f.funcs {s} x)\\n    | func-op => {?hidden}\\n    | func-rel => {?hidden}\\n  }\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', 'qinj (Term (\\\\lam (_ : Sort) => Empty) s)', '\\\\func interpret \\\\hlevels  {this1 : Structure} {V1 : Sort {T} -> \\\\Set} (_ : Env V1) {s2 : Sort {T}} (_ : Term {T} V1 s2) : E s2 \\n  | {this}, {V}, rho, {s}, var v => rho {s} v\\n  | {this}, {V}, rho, {s}, apply f d =>\\n  operation {s} f (\\\\new DArray {len {domain {T} {s} f}} (\\\\lam (j : Fin (len {domain {T} {s} f})) => E (at {domain {T} {s} f} j))\\n    (\\\\lam (j : Fin (len {domain {T} {s} f})) => interpret {V} rho {at {domain {T} {s} f} j} (d.at j)))', '| J : Precat', '\\\\func colimitCone {this2 : ColimitData} : Cone {Precat.op {ModelCat.ColimitData.J}} {Precat.op {ModelPrecat ModelCat.ColimitData.T}}\\n  (Functor.op {ModelCat.ColimitData.G}) Colimit {\\n  | coneMap => colimitMap\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '\\\\data Trunc0 \\\\Type : \\\\Set \\n  | in0 A', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\lemma interpret=map {this : ColimitData} {M : Model ModelCat.ColimitData.T} (f : ModelHom {ModelCat.ColimitData.T} Colimit M) {s : Sort}\\n  (t : Term {thExt} (\\\\lam (_ : Sort) => Empty) s) :\\ninterpret {modelExt {M} (conePullback {Precat.op {J}} {Precat.op {ModelPrecat ModelCat.ColimitData.T}} {Functor.op {G}} colimitCone M f)}\\n  {\\\\lam (_ : Sort) => Empty} (\\\\lam {s : Sort {Structure.T}} => absurd {M.E s}) {s} t = f.funcs {s} (qinj {thExt} {s} t) ', '| domain {s : Sort} (Symb s) : Array Sort', '| at (j : Fin len) : A j', \"\\\\instance thExt {this1 : ColimitData} : Theory {\\n  | Sort => Sort {T}\\n  | Symb => \\\\lam (s : Sort) => Or (Symb {T} s) (Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s)))\\n  | domain => \\\\lam {s : Sort} (p0 : Symb s) => (\\\\case p0 \\\\with {\\n    | inl f => domain {T} {s} f\\n    | inr t => nil\\n  })\\n  | PredSymb => PredSymb {T}\\n  | predDomain => predDomain {T}\\n  | axioms => \\\\lam (S : Sequent) =>\\n  OneOf ((\\\\Sigma (S' : Sequent {T}) (axioms {T} S') (S = liftSequent S')) :: (\\\\Sigma (j : Ob {J}) (s : Sort {T}) (f : Symb {T} s)\\n    (vars : DArray {len {domain {T} {s} f}} (\\\\lam (i : Fin (len {domain {T} {s} f})) => E {F {G} j} (at {domain {T} {s} f} i)))\\n    (S = (\\\\lam (_ : Sort {\\\\this}) => Empty, emptyFin {Sort {T}}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Empty} {s}\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)\\n        (\\\\new DArray {len {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)}}\\n          (\\\\lam (j : Fin (len {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)})) =>\\n          Term (\\\\lam (_ : Sort {\\\\this}) => Empty)\\n            (at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} j))\\n          (\\\\lam (i : Fin (len {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)})) =>\\n          apply {\\\\lam (_ : Sort {\\\\this}) => Empty}\\n            {at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} i}\\n            (inr {Symb {T} (at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} i)}\\n              {Trunc0 (\\\\Sigma (j : Ob {J})\\n                (E {F {G} j} (at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} i)))}\\n              (in0 {\\\\Sigma (j : Ob {J})\\n                (E {F {G} j} (at {domain {\\\\this} {s} (inl {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} f)} i))}\\n                (j, vars.at i))) nil)))\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {s} (inr {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))}\\n        (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} s)} (j, operation {F {G} j} {s} f vars))) nil)))) :: (\\\\Sigma (j : Ob {J}) (P : PredSymb {T})\\n      (vars : DArray {len {predDomain {T} P}} (\\\\lam (i : Fin (len {predDomain {T} P})) => E {F {G} j} (at {predDomain {T} P} i)))\\n      (relation {F {G} j} P vars) (S = (\\\\lam (_ : Sort {\\\\this}) => Empty, emptyFin {Sort {T}}, nil,\\n        predicate {\\\\lam (_ : Sort {\\\\this}) => Empty} P (\\\\new DArray {len {predDomain {\\\\this} P}}\\n          (\\\\lam (j : Fin (len {predDomain {\\\\this} P})) => Term (\\\\lam (_ : Sort {\\\\this}) => Empty) (at {predDomain {\\\\this} P} j))\\n          (\\\\lam (i : Fin (len {predDomain {\\\\this} P})) => apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {at {predDomain {\\\\this} P} i}\\n            (inr {Symb {T} (at {predDomain {\\\\this} P} i)} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} (at {predDomain {\\\\this} P} i)))}\\n              (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} (at {predDomain {\\\\this} P} i))} (j, vars.at i))) nil))))) :: (\\\\Sigma (j j' : Ob {J}) (h : Hom {J} j j') (s : Sort {T}) (x : E {F {G} j} s)\\n        (S = (\\\\lam (_ : Sort {\\\\this}) => Empty, emptyFin {Sort {T}}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Empty} {s}\\n          (apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {s} (inr {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))}\\n            (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} s)} (j', funcs {Func {G} {j} {j'} h} {s} x))) nil)\\n          (apply {\\\\lam (_ : Sort {\\\\this}) => Empty} {s}\\n            (inr {Symb {T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))} (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} s)} (j, x))) nil)))) :: nil)\\n} => \\\\new Theory\", '| Symb Sort : \\\\Set', '| T : Signature', '| F (Ob {C}) : Ob {D}', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', 'inl A', '| T : Theory', '\\\\func conePullback \\\\plevels obj >= hom \\\\hlevels  {J1 : Precat} {D1 : Precat} {F1 : Functor J1 D1} (C : Cone {J1} {D1} F1) (z : D.Ob) (f : D.Hom z C.apex) :\\nCone {J1} {D1} F1 z {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => C.coneMap j D.\u2218 f\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| Ob : \\\\hType', '\\\\func modelExt {this1 : ColimitData} {M : Model ModelCat.ColimitData.T}\\n  (C : Cone {Precat.op {J}} {Precat.op {ModelPrecat ModelCat.ColimitData.T}} (Functor.op {G}) M) : Model thExt M.E {\\n  | operation => \\\\lam {r : Sort {Structure.T}} (p0 : Symb {Structure.T} r) => (\\\\case p0 \\\\with {\\n    | inl h => M.operation {r} h\\n    | inr (in0 (j, x)) =>\\n    \\\\lam (_ : DArray {len {domain {r} (inr {Symb {ModelCat.ColimitData.T} r} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} r))}\\n      (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} r)} (j, x)))}}\\n      (\\\\lam (j1 : Fin (len {domain {r} (inr {Symb {ModelCat.ColimitData.T} r} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} r))}\\n        (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} r)} (j, x)))})) =>\\n      M.E (at {domain {r} (inr {Symb {ModelCat.ColimitData.T} r} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} r))}\\n        (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} r)} (j, x)))} j1))) => funcs {C.coneMap j} {r} x\\n  })\\n  | relation => M.relation\\n} => \\\\new Model {\\n  | isModel => {?hidden}\\n}', '| funcs {s : Sort {T}} (E {Dom} s) : E {Cod} s', '| G : Functor J (ModelPrecat T)', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}']<<<break>>>interpret {modelExt {M} (conePullback {Precat.op {J}} {Precat.op {ModelPrecat ModelCat.ColimitData.T}} {Functor.op {G}} colimitCone M f)}\n  {\\lam (_ : Sort) => Empty} (\\lam {s : Sort {Structure.T}} => absurd {M.E s})\n  {at {domain {s} (inl {Symb {ModelCat.ColimitData.T} s} {Trunc0 (\\Sigma (j : Ob {J}) (E {F {G} j} s))} h)} j} (d.at j) = f.funcs {at {domain {s} (inl {Symb {ModelCat.ColimitData.T} s} {Trunc0 (\\Sigma (j : Ob {J}) (E {F {G} j} s))} h)} j}\n  (qinj {thExt} {at {domain {s} (inl {Symb {ModelCat.ColimitData.T} s} {Trunc0 (\\Sigma (j : Ob {J}) (E {F {G} j} s))} h)} j}\n    (d.at j))", "completion": "interpret=map f (d j)"}
{"prompt": "['m : MatchingFamily {C} {D} {F} x {J} g z', 'j : J']<<<break>>>[\"| isMatching (j j' : J) : Func {vsheafOnSiteWithBasis.MatchingFamily.F} {(g j).1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n  (pbProj1 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) \u2218 family j = Func {vsheafOnSiteWithBasis.MatchingFamily.F} {(g j').1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n  (pbProj2 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) \u2218 family j'\", '| Hom Ob Ob : \\\\Set', '| pullback {x y z : Ob} (f : Hom x z) (g : Hom y z) : Pullback {x} {y} {z} f g', '| pbProj2 : Hom {D} apex y', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| pbProj1 : Hom {D} apex x', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| family (j : J) : Hom {D} z (Functor.F {vsheafOnSiteWithBasis.MatchingFamily.F} (g j).1)', '| F : Functor (op {C}) D', '| z : Ob {D}', '| C : SiteWithBasis', '| g J : Ob', '| x : Ob {C}', '| D : Cat']<<<break>>>Func {m.F} {(m.g j.1).1} {apex {pullback {m.C} {(m.g j.1).1} {(m.g j.2).1} {m.x} (m.g j.1).2 (m.g j.2).2}}\n  (pbProj1 {pullback {m.C} {(m.g j.1).1} {(m.g j.2).1} {m.x} (m.g j.1).2 (m.g j.2).2}) \u2218 m.family j.1 = Func {m.F} {(m.g j.2).1} {apex {pullback {m.C} {(m.g j.1).1} {(m.g j.2).1} {m.x} (m.g j.1).2 (m.g j.2).2}}\n  (pbProj2 {pullback {m.C} {(m.g j.1).1} {(m.g j.2).1} {m.x} (m.g j.1).2 (m.g j.2).2}) \u2218 m.family j.2", "completion": "isMatching {m} j.1 j.2"}
{"prompt": "['bd : Nat', 'bh : R.isHomogen b bd', 'b : R.E', 'ah : R.isHomogen a ad', 's : \\\\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b n = a R.* c) (bd * n = ad + cd)', 'R : GradedCRing', 'ad : Nat', 'a : R.E']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func shom \\\\hlevels  {R : GradedCRing} {a b : R.E} {ad bd : Nat} {ah : R.isHomogen a ad} {bh : R.isHomogen b bd} (n : Nat) (c : R.E)\\n  (cd : Nat) (ch : R.isHomogen c cd) (p : pow {R} b n = a R.* c) (bd*n=ad+cd : bd Semigroup.* n = ad + cd) :\\nRingHom (HomogenLocRing {R} (powers {R} a)) (HomogenLocRing {R} (powers {R} b)) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (smap {R} {a} {b} {ad} {bd} ah bh n c cd ch p bd*n=ad+cd x).1\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}']<<<break>>>\\Pi {x y : E {Dom {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6}}} ->\n  func {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6} (x + y) = func {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6} x + func {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6} y", "completion": "func-+ {shom {R} {a} {b} {ad} {bd} {ah} {bh} s.1 s.2 s.3 s.4 s.5 s.6}"}
{"prompt": "['h1 : Hom {D {\\\\this}} w (apex {\\\\this})']<<<break>>>['| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| Dom : BaseSet']<<<break>>>\\Pi {x y : E {h1.Dom}} -> h1.func x \u2227 h1.func y <= h1.func (x \u2227 y)", "completion": "func-meet>= {h1}"}
{"prompt": "['R : Ring X']<<<break>>>['| \\\\infixl 6 + E E : E', '| natCoefSuc (n : Nat) : natCoef (suc n) = natCoef n + ide', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| natCoef Nat : E', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| E : \\\\Set']<<<break>>>\\Pi (n : Nat) -> R.natCoef (suc n) = R.natCoef n R.+ R.ide", "completion": "natCoefSuc {R}"}
{"prompt": "['this : SubLModule']<<<break>>>['| zro : E', '\\\\func IAddGroup \\\\hlevels  {this2 : SubAddGroup} : AddGroup (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro)\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E {\\\\this}) => (negative {S} x.1, contains_negative {x.1} x.2)\\n} => \\\\new AddGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | negative-right => {?hidden}\\n}', '| \\\\infixl 6 + E E : E', '\\\\func IAddMonoid \\\\hlevels  {this2 : SubAddMonoid} : AddMonoid (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro)\\n  | + => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\\n} => \\\\new AddMonoid {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n}', '| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)', '| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)', '\\\\class AddGroup \\\\extends AddMonoid \\\\hlevels  {\\n  | negative E : E\\n  | negative-left {x : E} : negative x + x = zro\\n  | negative-right {x : E} : x + negative x = zro\\n}', '| E : \\\\Set', '| negative E : E', '| S : BaseSet', '| contains_zro : contains (zro {S})', '| contains (E {S}) : \\\\Prop']<<<break>>>AddGroup (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro)\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E {\\this}) => (negative {S} x.1, contains_negative {x.1} x.2)\n}", "completion": "IAddGroup {this}"}
{"prompt": "[\"l' : Array (\\\\Sigma (Array R.E) J.E)\", \"e : EPerm {\\\\Sigma R.E J.E} l\\n  (Big {Array (\\\\Sigma R.E J.E)} {Array (\\\\Sigma R.E J.E)} (++) nil (map {\\\\Sigma (Array R.E) J.E} {Array (\\\\Sigma R.E J.E)}\\n    (\\\\lam (s : \\\\Sigma (Array R.E) J.E) => map {R.E} {\\\\Sigma R.E J.E} (\\\\lam (p0 : R.E) => (p0, s.2)) s.1) l'))\", 'J : DecSet', 'R : Semiring', 'l : Array (\\\\Sigma R.E J.E)', 'j : J.E']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\func count \\\\hlevels  {R : Semiring} {J : DecSet} (l : Array (\\\\Sigma R.E J.E)) (j : J.E) : R.E \\n=> BigSum {R} (map {\\\\Sigma R.E J.E} {R.E} (\\\\lam (p0 : \\\\Sigma R.E J.E) => p0.1)\\n  (keep {\\\\Sigma R.E J.E} {\\\\lam (s : \\\\Sigma R.E J.E) => j = s.2} (\\\\lam (s : \\\\Sigma R.E J.E) => J.decideEq j s.2) l))', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', \"\\\\lemma count_EPerm \\\\hlevels  {R : Semiring} {J : DecSet} {l l' : Array (\\\\Sigma R.E J.E)} (_ : EPerm {\\\\Sigma R.E J.E} l l') {j : J.E} :\\n  count {R} {J} l j = count {R} {J} l' j \", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>count {R} {J} l j = count {R} {J}\n  (Big {Array (\\Sigma R.E J.E)} {Array (\\Sigma R.E J.E)} (++) nil (map {\\Sigma (Array R.E) J.E} {Array (\\Sigma R.E J.E)}\n    (\\lam (s : \\Sigma (Array R.E) J.E) => map {R.E} {\\Sigma R.E J.E} (\\lam (p0 : R.E) => (p0, s.2)) s.1) l')) j", "completion": "count_EPerm e"}
{"prompt": "['d : E', 'this : GCDMonoid', 'p : \\\\Pi (i j : Fin (suc l.len)) -> i /= j -> IsCoprime (at {d :: l} i) (at {d :: l} j)', 'l : Array E n', 'n : Nat']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'suc Nat', '\\\\lemma fsuc/= \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : x /= y) : fsuc {n} x /= fsuc {n} y ', '| at (j : Fin len) : A j', '\\\\type IsCoprime \\\\hlevels  {M : CMonoid} (x y : M.E) : \\\\Prop => \\\\Pi (z : M.E) -> LDiv {M} z x -> LDiv {M} z y -> Inv {M} z', '| E : \\\\Set']<<<break>>>\\Pi (i : Fin l.len) -> \\Pi (j : Fin l.len) -> i /= j -> IsCoprime (at {d :: l} (suc i)) (at {d :: l} (suc j))", "completion": "\\lam i j i/=j => p (suc i) (suc j) (fsuc/= i/=j)"}
{"prompt": "[\"s : tc.Sort'\", \"context : List tc.Sort'\", 'f : symbol {tc.envs color} s', 'color : E {tc.Color}', \"middle-subst_substitution-equality_l-eq : \\\\Sigma (inner-substitution : MetaSubstitution (tc.envs color) context\\n  (LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)) inner-mc)\\n  (\\\\Pi {s1 : tc.Sort'} ->\\n    \\\\Pi (m : metaname {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} s1) ->\\n    big-subst {s1} m = apply {env {tc}}\\n      {context ++ m-domain {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {s1} m}\\n      {nil {tc.Sort'}} {s1} {inner-mc} {mc} (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s1}\\n        {context ++ m-domain {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {s1} m}\\n        {inner-mc} {color} (inner-substitution {s1} m))\\n      (sublist-nil-free {tc.Sort'}\\n        {context ++ m-domain {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {s1} m})\\n      subst)\\n  (apply {tc.envs color} {context ++ nil {tc.Sort'}} {context} {s}\\n    {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {inner-mc}\\n    (weakening {tc.envs color} {s} {nil {tc.Sort'}} {context ++ nil {tc.Sort'}}\\n      {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)}\\n      (convert-to-term {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx))\\n      (extend-left-single {tc.Sort'} {nil {tc.Sort'}} {nil {tc.Sort'}} (identity {tc.Sort'} {nil {tc.Sort'}}) {context}))\\n    (extend-right-single {tc.Sort'} {context} {context} (identity {tc.Sort'} {context}) {nil {tc.Sort'}}) inner-substitution = transport {List tc.Sort'} (\\\\lam (p0 : List tc.Sort') => Term (tc.envs color) p0 s inner-mc) {context} {context ++ nil {tc.Sort'}}\\n    (inv {List tc.Sort'} {context ++ nil {tc.Sort'}} {context} (++_nil {tc.Sort'} {context}))\\n    (func {tc.envs color} {context} {s} {inner-mc} f arguments))\", 'tc : TheoremContext', \"inner-mc : MetaContext tc.Sort'\", 'arguments : DArray {arity {tc.envs color} {s} f} (\\\\lam (index : Fin (arity {tc.envs color} {s} f)) =>\\n  Term (tc.envs color) (context ++ f !!domain index) (f !!sort index) inner-mc)', 'idx : rule-J {tc.rules color} s']<<<break>>>['| rules (c : E {Color}) : LinearRegistry (envs c)', \"| Sort' : \\\\Set\", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", 'nil', '\\\\func identity {A2 : \\\\Type} {list1 : List A2} : SubList {A2} list1 list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})', '\\\\func sublist-nil-free {A2 : \\\\Type} {list1 : List A2} : SubList {A2} (nil {A2}) list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-skip {A} {nil {A}} {a} {list} (sublist-nil-free {A} {list})', 'sublist-nil', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| rule-container {s : Sort {env}} (rule-J s) : RewriteRule {env} s', '\\\\func extension-to-nil-left {A2 : \\\\Type} {a2 : List A2} :\\n  sublist-nil-free {A2} {a2 ++ nil {A2}} = extend-left-single {A2} {nil {A2}} {nil {A2}} (sublist-nil {A2}) {a2} \\n  | {A}, {nil} => idp {SubList {A} (nil {A}) (nil {A} ++ nil {A})} {sublist-nil-free {A} {nil {A} ++ nil {A}}}\\n  | {A}, {a :: a1} => pmap {SubList {A} (nil {A}) (a1 ++ nil {A})} {SubList {A} (nil {A}) (a :: a1 ++ nil {A})}\\n    (sublist-skip {A} {nil {A}} {a} {a1 ++ nil {A}}) {sublist-nil-free {A} {a1 ++ nil {A}}}\\n    {extend-left-single {A} {nil {A}} {nil {A}} (sublist-nil {A}) {a1}} (extension-to-nil-left {A} {a1})', 'func (f : env.symbol termSort) (DArray {arity {env} {termSort} f}\\n  (\\\\lam (index : Fin (arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func ++_nil {A2 : \\\\Type} {l1 : List A2} : l1 ++ nil {A2} = l1 \\n  | {A}, {nil} => idp {List A} {nil {A} ++ nil {A}}\\n  | {A}, {a :: l} => pmap {List A} {List A} ((::) a) {l ++ nil {A}} {l} (++_nil {A} {l})', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func extend-left-single {A1 : \\\\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \\n  | {A}, {l}, {r}, sublist, {nil} => sublist\\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})', '\\\\func apply \\\\hlevels  {env3 : FSignature} {context3 core-context2 : List env.Sort} {s3 : env.Sort}\\n  {old-metacontext2 new-metacontext3 : MetaContext env.Sort} (_ : Term env3 context3 s3 old-metacontext2)\\n  (_ : SubList {env.Sort} core-context2 context3)\\n  (_ : MetaSubstitution env3 core-context2 old-metacontext2 new-metacontext3) : Term env3 context3 s3 new-metacontext3 \\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, var index p, sublist, subst =>\\n    var {env} {context} {s} {new-metacontext} index p\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, metavar m arguments, sublist, subst =>\\n  Substitution.apply {env} {s} {core-context ++ old-metacontext.m-domain {s} m} {new-metacontext} (subst {s} m) {context}\\n    (extend-substitution-left {env} {core-context} {old-metacontext.m-domain {s} m} {context} {new-metacontext} sublist\\n      (\\\\lam (i : Index {env.Sort} (old-metacontext.m-domain {s} m)) => MetaSubstitution.apply\\n        {env} {context} {core-context} {old-metacontext.m-domain {s} m !! i} {old-metacontext} {new-metacontext} (arguments.at i)\\n          sublist subst))\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, func f arguments, sublist, subst =>\\n  func {env} {context} {s} {new-metacontext} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) new-metacontext)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => MetaSubstitution.apply\\n      {env} {context ++ f !!domain i} {core-context} {f !!sort i} {old-metacontext} {new-metacontext} (arguments.at i)\\n        (extend-right-single {env.Sort} {core-context} {context} sublist {f !!domain i}) subst))', \"\\\\func get-rule-pattern \\\\hlevels  {this : TheoremContext} {s : Sort'} {c : E {Color}} (idx : rule-J {rules c} s) : LinearPattern (envs c) (nil {Sort'}) s \\n  => rule-pattern {rules c} {s} idx\", '| Sort : \\\\Set', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func extend-right-single {A3 : \\\\Type} {l1 r : List A3} (_ : SubList {A3} l1 r) {add3 : List A3} : SubList {A3} l1 (r ++ add3) \\n  | {A}, {nil}, {nil}, sublist-nil, {add} => sublist-nil-free {A} {nil {A} ++ add}\\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, {add} =>\\n    sublist-match {A} {x} {xs} {y} {ys ++ add} p (extend-right-single {A} {xs} {ys} sublist {add})\\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, {add} =>\\n    sublist-skip {A} {l} {y} {ys ++ add} (extend-right-single {A} {l} {ys} sublist {add})', \"\\\\func weakening \\\\hlevels  {env3 : FSignature} {s'3 : env.Sort} {narrow-context3 wide-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Term env3 narrow-context3 s'3 mc3) (_ : SubList {env.Sort} narrow-context3 wide-context3) :\\n  Term env3 wide-context3 s'3 mc3 \\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, var index p, sublist =>\\n  var {env} {wide-context} {s'} {mc} (shift-index {env.Sort} {narrow-context} {wide-context} sublist index)\\n    (proof {env.Sort} {narrow-context} {wide-context} {s'} sublist index p)\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, metavar m arguments, sublist =>\\n  metavar {env} {wide-context} {s'} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s'} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s'} m)) => Term env wide-context (mc.m-domain {s'} m !! index) mc)\\n    (\\\\lam (i1 : Fin (MetaContext.arity {mc} {s'} m)) =>\\n      weakening {env} {mc.m-domain {s'} m !! i1} {narrow-context} {wide-context} {mc} (arguments.at i1) sublist))\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, func f arguments, sublist =>\\n  func {env} {wide-context} {s'} {mc} f (\\\\new DArray {FSignature.arity {env} {s'} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s'} f)) => Term env (wide-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i1 : Fin (FSignature.arity {env} {s'} f)) =>\\n    weakening {env} {f !!sort i1} {narrow-context ++ f !!domain i1} {wide-context ++ f !!domain i1} {mc} (arguments.at i1)\\n      (extend-right-both {env.Sort} {narrow-context} {wide-context} sublist {f !!domain i1})))\", '| rr-pattern : LinearPattern env (nil {Sort {env}}) s', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\func extension-to-nil-right {A2 : \\\\Type} {a2 : List A2} :\\nextend-right-single {A2} {a2} {a2} (identity {A2} {a2}) {nil {A2}} = transport {List A2} (SubList {A2} a2) {a2} {a2 ++ nil {A2}} (inv {List A2} {a2 ++ nil {A2}} {a2} (++_nil {A2} {a2}))\\n  (identity {A2} {a2}) \\n  | {A}, {nil} => idp {SubList {A} (nil {A}) (nil {A} ++ nil {A})}\\n    {extend-right-single {A} {nil {A}} {nil {A}} (identity {A} {nil {A}}) {nil {A}}}\\n  | {A}, {a :: a1} => transportInv {SubList {A} a1 (a1 ++ nil {A})} (\\\\lam (x : SubList {A} a1 (a1 ++ nil {A})) =>\\n    sublist-match {A} {a} {a1} {a} {a1 ++ nil {A}} (idp {A} {a}) x = transport {List A} (SubList {A} (a :: a1)) {a :: a1} {a :: a1 ++ nil {A}}\\n      (inv {List A} {a :: a1 ++ nil {A}} {a :: a1} (path (\\\\lam (i : I) => a :: ++_nil {A} {a1} @ i)))\\n      (sublist-match {A} {a} {a1} {a} {a1} (idp {A} {a}) (identity {A} {a1})))\\n      {extend-right-single {A} {a1} {a1} (identity {A} {a1}) {nil {A}}}\\n      {transport {List A} (SubList {A} a1) {a1} {a1 ++ nil {A}} (inv {List A} {a1 ++ nil {A}} {a1} (++_nil {A} {a1})) (identity {A} {a1})}\\n      (extension-to-nil-right {A} {a1})\\n      (sublist-match-over-transport-right-inv {A} {a} {a1} {a1} {a1 ++ nil {A}} (++_nil {A} {a1}) (identity {A} {a1}))', '\\\\func convert-to-term \\\\hlevels  {env3 : FSignature} {context3 : List env.Sort} {s3 : env.Sort} {allowVariables3 : \\\\Prop}\\n  (term : GenericLinearTerm env3 context3 s3 allowVariables3) :\\n  Term env3 context3 s3 (LinearMetaContext {env3} {context3} {s3} {allowVariables3} term) \\n  | {env}, {context}, {s}, {allowVariables}, l-func f arguments => func {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-func {env} {context} {s} {allowVariables} f arguments)} f\\n    (\\\\new DArray {FSignature.arity {env} {s} f}\\n      (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index)\\n        (LinearMetaContext {env} {context} {s} {allowVariables} (l-func {env} {context} {s} {allowVariables} f arguments)))\\n      (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => upgrade-metavariables\\n        {env} {context ++ f !!domain i} {f !!sort i} {length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f)} {i}\\n          (\\\\lam (i : Fin (length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f))) =>\\n            LinearMetaContext {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))\\n          (convert-to-term {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))))\\n  | {env}, {context}, {s}, {allowVariables}, l-var index p a => var {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-var {env} {context} {s} {allowVariables} index p a)} index p\\n  | {env}, {context}, {s}, {allowVariables}, l-full-metavar => metavar {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})}\\n    (idp {env.Sort} {s}) (\\\\new DArray {MetaContext.arity\\n      {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n        (idp {env.Sort} {s})}\\n        (\\\\lam (index : Fin (MetaContext.arity\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}))) => Term env context\\n          (m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}) !! index)\\n          (LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})))\\n        (\\\\lam (i : Fin (MetaContext.arity\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}))) => var {env} {context}\\n          {m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}) !! i}\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} i\\n          (idp {env.Sort}\\n            {m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n              (idp {env.Sort} {s}) !! i})))', '\\\\lemma different-weakening \\\\hlevels  {env : FSignature} {context : List env.Sort} {s : env.Sort} {ms : MetaContext env.Sort}\\n  (T : Term env (nil {env.Sort}) s ms) :\\nweakening {env} {s} {nil {env.Sort}} {context} {ms} T (sublist-nil-free {env.Sort} {context}) = transport {List env.Sort} (\\\\lam (p0 : List env.Sort) => Term env p0 s ms) {context ++ nil {env.Sort}} {context}\\n  (++_nil {env.Sort} {context})\\n  (weakening {env} {s} {nil {env.Sort}} {context ++ nil {env.Sort}} {ms} T (extend-right-single\\n    {env.Sort} {nil {env.Sort}} {nil {env.Sort}} (identity {env.Sort} {nil {env.Sort}}) {context ++ nil {env.Sort}})) ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", '\\\\func LinearMetaContext \\\\hlevels  {env3 : FSignature} {context2 : List env.Sort} {s2 : env.Sort} {allowVariables1 : \\\\Prop}\\n  (_ : GenericLinearTerm env3 context2 s2 allowVariables1) : MetaContext env.Sort \\n  | {env}, {context}, {s}, {allowVariables}, l-func f arguments =>\\n  ModularMetaContext {env} {length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f)}\\n    (\\\\lam (i : Fin (length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f))) =>\\n      LinearMetaContext {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))\\n  | {env}, {context}, {s}, {allowVariables}, l-var index p a => EmptyMetaContext {env}\\n  | {env}, {context}, {s}, {allowVariables}, l-full-metavar => SingularMetaContext {env} s context', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", \"\\\\lemma metasubst-over-transport \\\\hlevels  {env : FSignature} {context context' : List env.Sort} {s : env.Sort} {ms ms' : MetaContext env.Sort}\\n  (eq : context = context') (T : Term env context s ms) (S : Term env context' s ms')\\n  (msubst : MetaSubstitution env context' ms ms') (_ : apply {env} {context} {context'} {s} {ms} {ms'} T\\n    (transport {List env.Sort} (SubList {env.Sort} context') {context'} {context} (inv {List env.Sort} {context} {context'} eq)\\n      (identity {env.Sort} {context'})) msubst = transport {List env.Sort} (\\\\lam (p0 : List env.Sort) => Term env p0 s ms') {context'} {context}\\n    (inv {List env.Sort} {context} {context'} eq) S) : apply {env} {context'} {context'} {s} {ms} {ms'}\\n  (transport {List env.Sort} (\\\\lam (p0 : List env.Sort) => Term env p0 s ms) {context} {context'} eq T)\\n  (identity {env.Sort} {context'}) msubst = S \", '\\\\data SubList {A : \\\\Type} (_ _ : List A) \\\\with\\n  | {A}, nil, nil => sublist-nil\\n  | {A}, x :: xs, y :: ys => sublist-match (x = y) (SubList {A} xs ys)\\n  | {A}, l, y :: ys => sublist-skip (SubList {A} l ys)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>apply {tc.envs color} {context} {context} {s}\n  {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)} {inner-mc}\n  (weakening {tc.envs color} {s} {nil {Sort {tc.envs color}}} {context}\n    {LinearMetaContext {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx)}\n    (convert-to-term {tc.envs color} {nil {tc.Sort'}} {s} {Empty} (get-rule-pattern {tc} {s} {color} idx))\n    (sublist-nil-free {Sort {tc.envs color}} {context})) (identity {tc.Sort'} {context}) middle-subst = func {tc.envs color} {context} {s} {inner-mc} f arguments", "completion": "rewrite (different-weakening {envs color})\n  (metasubst-over-transport {envs color} ++_nil _ (func f arguments) middle-subst (rewrite (inv extension-to-nil-right)\n    (pmap (\\lam sl => apply {envs color} (weakening {envs color} (convert-to-term {envs color} (get-rule-pattern {_} {_} {color} idx)) sl)\n      (extend-right-single identity) middle-subst) extension-to-nil-left) *> l-eq))"}
{"prompt": "['p3 : Hom {C {\\\\this}} p1 p2', 'p2 : Ob {C {\\\\this}}', 'p1 : Ob {C {\\\\this}}', 'this : CartesianClosedPrecat']<<<break>>>[\"\\\\func prodMap \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y x' y' : Ob} (f : Hom x y) (f' : Hom x' y') : Hom (apex {Bprod x x'}) (apex {Bprod y y'}) \\n  => pair {y} {y'} {apex {Bprod x x'}} (f \u2218 proj1 {x} {x'}) (f' \u2218 proj2 {x} {x'})\", '| apex : Ob {D}', '\\\\func eval-map \\\\plevels obj >= hom \\\\hlevels  {this : CartesianClosedPrecat} {Y Z : Ob} : Hom (apex {Bprod (F {exp Y} Z) Y}) Z => trans {epsilon {exp Y}} Z', '| id (X : Ob) : Hom X X', '| Hom Ob Ob : \\\\Set', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func eval-transpose \\\\plevels obj >= hom \\\\hlevels  {this : CartesianClosedPrecat} {X Y Z : Ob} (g : Hom (apex {Bprod X Y}) Z) :\\n  eval-map {Y} {Z} \u2218 prodMap {X} {F {exp Y} Z} {Y} {Y} (transpose {X} {Y} {Z} g) (id Y) = g \\n  => ret_f {eta_epsilon-equiv {exp Y} {X} {Z}} g', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| Bprod (x y : Ob) : Product {Fin 2} (at {x :: y :: nil})', '| exp (X : Ob) : isExponential X', '\\\\func transpose \\\\plevels obj >= hom \\\\hlevels  {this : CartesianClosedPrecat} {X Y Z : Ob} (f : Hom (apex {Bprod X Y}) Z) : Hom X (F {exp Y} Z) \\n  => Func {exp Y} {apex {Bprod X Y}} {Z} f \u2218 trans {eta {exp Y}} X']<<<break>>>eval-map {p2.1} {p2.2} \u2218 prodMap {F {exp p1.1} p1.2} {F {exp p2.1} p2.2} {p2.1} {p2.1} (transpose {F {exp p1.1} p1.2} {p2.1} {p2.2}\n  (p3.2 \u2218 eval-map {p1.1} {p1.2} \u2218 prodMap {F {exp p1.1} p1.2} {F {exp p1.1} p1.2} {p2.1} {p1.1} (id (F {exp p1.1} p1.2)) p3.1))\n  (id p2.1) = p3.2 \u2218 eval-map {p1.1} {p1.2} \u2218 prodMap {F {exp p1.1} p1.2} {F {exp p1.1} p1.2} {p2.1} {p1.1} (id (F {exp p1.1} p1.2)) p3.1", "completion": "eval-transpose {this} _"}
{"prompt": "['I : DirectedSet']<<<break>>>['\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\class PrecoverSpace \\\\extends TopSpace \\\\hlevels  {\\n  | isCauchy (Set (Set E)) : \\\\Prop\\n  | cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))\\n  | cauchy-top : isCauchy (single {E -> \\\\Prop} top)\\n  | cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D\\n  | cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))\\n  | cauchy-open {S : Set E} : TopSpace.isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))\\n}', '| E : \\\\Set', '\\\\func precover \\\\hlevels  {I : DirectedSet} : PrecoverSpace I.E {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n  \\\\Sigma (TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (N : I.E) (\\\\Pi {n : I.E} -> N I.<= n -> U n)))\\n    (\\\\Pi (n : I.E) -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (C V) (V n)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '\\\\func isOpen \\\\hlevels  {this : PrecoverSpace} (S : Set E) : \\\\Prop => \\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>PrecoverSpace I.E {\n  | isOpen => isOpen\n  | isCauchy => \\lam (C : Set (Set (E {\\this}))) =>\n  \\Sigma (TruncP (\\Sigma (U : Set (E {\\this})) (C U) (N : I.E) (\\Pi {n : I.E} -> N I.<= n -> U n)))\n    (\\Pi (n : I.E) -> TruncP (\\Sigma (V : Set (E {\\this})) (C V) (V n)))\n}", "completion": "precover {I}"}
{"prompt": "['nPj : \\\\Pi (i : Fin (suc l.len)) -> P (at {a :: l} i) -> i = 0', 'l : Array A n', 'P : A -> \\\\Prop']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\data Empty \\\\plevels  \\\\hlevels  ', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j']<<<break>>>\\Pi (i : Fin l.len) -> P (l.at i) -> Empty", "completion": "\\lam i Pi => (\\case nPj (suc i) Pi \\with {})"}
{"prompt": "['x : E', 'a : E', 'this : RealBanachPseudoAlgebra', 'b : E']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\lemma *r_*q \\\\hlevels  {this : RealBanachSpace} {q : Rat} {a : E} : fromRat q *r a = q *q a ', '| E : \\\\Set', '\\\\infixl 7 *r \\\\hlevels  {this : RealBanachSpace} (r : Real) (a : E) : E => func {lift} (r, a)', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}']<<<break>>>fromRat x *r (a * b) = x *q (a * b)", "completion": "*r_*q {this}"}
{"prompt": "['e<b : e.U b', 'f : J -> E {\\\\this}', 'this : CompleteLattice ExUpperReal {\\n  | <= => (ExUpperReal.<=)\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet => meet\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join => join\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top => top-impl\\n  | top-univ => {?hidden}\\n  | Join => ExUpperRealLattice.Join\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet => ExUpperRealLattice.Meet\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', 'b : Rat', 'e : E {\\\\this}', 'J : \\\\Set', 'c : \\\\Pi (j : J) -> f j <= e']<<<break>>>['| U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| Join {J : \\\\Set} (J -> E) : E', '| U Rat : \\\\Prop', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'inP A', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>U {Join {\\this} {J} f} b", "completion": "\\scase U-rounded e<b \\with {\n  | inP (a, e<a, a<b) => inP (a, a<b, \\lam j => c j e<a)\n}"}
{"prompt": "['g : GCD {M} x y z', 'z : M.E', 'x : M.E', 'y : M.E', 'M : CancelCMonoid']<<<break>>>['\\\\func DivPreoder \\\\hlevels  (M : CMonoid) : Preorder M.E {\\n  | <= => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => TruncP (LDiv {M} y x)\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', '| res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res', \"\\\\instance DivQuotientMonoid \\\\hlevels  (M : CMonoid) : OrderedCMonoid (DivQuotient M) {\\n  | <= => (<=C)\\n  | ide => inD {M} M.ide\\n  | * => (*')\\n} => \\\\new OrderedCMonoid {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | <=_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n}\", 'levelProp \\\\hlevels  {M : CancelMonoid} (x y : M.E) : isProp (LDiv {M} x y) => cancelProp {M} x (M.cancel_*-left x) y', \"\\\\instance DivQuotientCancelMonoid \\\\hlevels  (M1 : CancelCMonoid) : UnitlessMonoid (Quotient {E} (Transitive.~)) {\\n  | ide => in~ {E} {(Transitive.~)} M.ide\\n  | * => (*')\\n} => \\\\new UnitlessMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | cancel_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | uniqueUnit => {?hidden}\\n}\", '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\func div-to~ \\\\hlevels  {M : CMonoid} {x y : M.E} (x|y : LDiv {M} x y) : LDiv {DivQuotientMonoid M} (inD {M} x) (inD {M} y) (inD {M} x|y.inv) \\n=> \\\\new LDiv {\\n  | inv-right => {?hidden}\\n}', '| val1 : E {M}', '\\\\func inD \\\\hlevels  {M : CMonoid} (x : M.E) : DivQuotient M => in~ {E} {(~)} x', '| res|val1 : LDiv {M} res val1', '\\\\class GCD \\\\hlevels  {\\n  | M : CMonoid\\n  | val1 : E {M}\\n  | val2 : E {M}\\n  | res : E {M}\\n  | res|val1 : LDiv {M} res val1\\n  | res|val2 : LDiv {M} res val2\\n  | res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res\\n}', '| val2 : E {M}', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '\\\\func EquivRel \\\\hlevels  {this2 : Preorder} : Equivalence E {\\n  | ~ => \\\\lam (x : A {\\\\this}) (y : A {\\\\this}) => \\\\Sigma (x <= y) (y <= x)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', '\\\\lemma div-from~ \\\\hlevels  {M : CancelCMonoid} {x y : M.E} (_ : LDiv {DivQuotientMonoid M} (inD {M} x) (inD {M} y)) : LDiv {M} x y ', '| res|val2 : LDiv {M} res val2', '| M : CMonoid', 'in~ A']<<<break>>>GCD {DivQuotientMonoid M1} (inD {M1} x) (inD {M1} y) (inD {M1} z) (div-to~ {M1} {z} {x} g.res|val1)\n  (div-to~ {M1} {z} {y} g.res|val2)\n  (\\lam ([g] : E {M {\\this}}) ([g]|[x] : LDiv {M {\\this}} [g] (val1 {\\this})) ([g]|[y] : LDiv {M {\\this}} [g] (val2 {\\this})) =>\n  (\\case [g], [g]|[x], [g]|[y] \\with {\n    | in~ g', ~g'|x, ~g'|y =>\n      div-to~ {M1} {g'} {z} (g.res-univ g' (div-from~ {M1} {g'} {x} ~g'|x) (div-from~ {M1} {g'} {y} ~g'|y))\n  }))", "completion": "\\new GCD {\n  | M => _\n  | val1 => inD x\n  | val2 => inD y\n  | res => inD z\n  | res|val1 => div-to~ (res|val1 {g})\n  | res|val2 => div-to~ (res|val2 {g})\n  | res-univ => \\lam [g] [g]|[x] [g]|[y] =>\n  (\\case \\elim [g], [g]|[x], [g]|[y] \\return \\level (LDiv [g] (inD z)) (levelProp [g] (inD z)) \\with {\n    | in~ g', ~g'|x, ~g'|y => div-to~ (res-univ {g} g' (div-from~ ~g'|x) (div-from~ ~g'|y))\n  })\n}"}
{"prompt": "['I : Ideal R', 'f : \\\\Pi (i : Fin l.len) -> \\\\Sigma (l1 : Array (\\\\Sigma (x : R.E) (I.contains x) M.E))\\n  (l.at i = BigSum {M} (map {\\\\Sigma (x : R.E) (I.contains x) M.E} {M.E} (\\\\lam (s : \\\\Sigma (x : R.E) (I.contains x) M.E) => s.1 M.*c s.3) l1))', 'R : CRing', 'j : Fin l.len', 'i : Fin l.len', 'g : \\\\Pi (i : Fin l.len) -> \\\\Pi (i1 : Fin (len {(f i).1})) -> \\\\Sigma (c : Array R.E l.len)\\n  ((at {(f i).1} i1).3 = BigSum {M} (\\\\new Array M.E l.len (\\\\lam (i : Fin l.len) => c.at i M.*c l.at i)))']<<<break>>>['| len : Nat', '| \\\\infixl 6 + E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma negative_zro \\\\hlevels  {this : AddGroup} : negative zro = zro ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)', '| zro-right {x : E} : x + zro = x', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\lemma bigSum \\\\hlevels  {this : Ideal} (l : Array (E {S})) (_ : \\\\Pi (i : Fin l.len) -> contains (l.at i)) : contains (BigSum {S} l) ', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro-left {x : E} : zro + x = x', '| E : \\\\Set', '| negative E : E', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray', '| contains (E {S}) : \\\\Prop', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| ideal-right {r a : E {S}} (contains a) : contains (a * r)']<<<break>>>I.contains (R.zro R.+ R.negative (Big {R.E} {R.E} (R.+) R.zro\n  (mkArray {R.E} {len {(f i).1}} (\\lam (j1 : Fin (len {(f i).1})) => ((f i).1 !! j1).1 R.* (g i j1).1 !! j))) R.+ R.negative R.zro)", "completion": "transport (\\lam x0 => substitution_meta) (inv ((path (\\lam (i1 : I) => R.zro-left {R.negative (Big {R.E} {R.E} (R.+) R.zro\n  (mkArray {R.E} {len {(f i).1}} (\\lam (j1 : Fin (len {(f i).1})) => ((f i).1 !! j1).1 R.* (g i j1).1 !! j)))} @ i1 R.+ R.negative R.zro) *> path (\\lam (i1 : I) => R.negative (Big {R.E} {R.E} (R.+) R.zro\n  (mkArray {R.E} {len {(f i).1}} (\\lam (j1 : Fin (len {(f i).1})) => ((f i).1 !! j1).1 R.* (g i j1).1 !! j))) R.+ negative_zro {R} @ i1)) *> path ((@) (R.zro-right {R.negative (Big {R.E} {R.E} (R.+) R.zro\n  (mkArray {R.E} {len {(f i).1}} (\\lam (j1 : Fin (len {(f i).1})) => ((f i).1 !! j1).1 R.* (g i j1).1 !! j)))}))))\n  (contains_negative $ bigSum {I} _ (\\lam k => later $ ideal-right ((f i).1 k).2))"}
{"prompt": "['g : \\\\Pi {y : InfReal} -> B < y -> a y', 'B : Real', 'b : E {A {\\\\this}}', 'p : a <= b']<<<break>>>['\\\\type \\\\infix 4 < \\\\plevels  \\\\hlevels  (x y : InfReal) : \\\\Prop => TruncP (\\\\Sigma (a : Rat) (x.U a) (y.L a))', '\\\\class InfReal \\\\extends LowerReal, ExUpperReal \\\\hlevels  {\\n  | LU-disjoint {q : Rat} (L q) (U q) : Empty\\n  | LU-located {q r : Rat} (q < r) : L q || U r\\n  | LU-focus-bound (B : Rat) {eps : Rat} (eps > zro) : L B || (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}']<<<break>>>\\Pi {y : InfReal} -> B < y -> b y", "completion": "\\lam d => p (g d)"}
{"prompt": "['B : Fin 0 -> Decide']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| E : \\\\Prop']<<<break>>>\\Pi (p0 : Fin 0) -> E {B p0}", "completion": "\\lam p0 => (\\case p0 \\with {})"}
{"prompt": "[\"p1 : TruncP (\\\\Sigma (U : Set X.E) (D U) (V : Set Y.E) (D' V) (p0 = Prod {X.E} {Y.E} U V))\", 'Y : UniformSpace', \"U' : Set Y.E\", \"p2 : \\\\Sigma (e : \\\\Sigma X.E Y.E) ((\u2227) (Prod {X.E} {Y.E} V V') p0 e)\", \"D' : Set (Set Y.E)\", \"g' : \\\\Pi {W : Set Y.E} -> D' W -> \\\\Sigma (e : Y.E) ((\u2227) V' W e) -> W \u2286 U'\", 'V : Set X.E', \"V' : Set Y.E\", 'W : Set (\\\\Sigma X.E Y.E)', 'U : Set X.E', 'X : UniformSpace', 'p0 : Set (\\\\Sigma X.E Y.E)', 'D : Set (Set X.E)', 'g : \\\\Pi {W : Set X.E} -> D W -> \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U', \"UU'<=W : Prod {X.E} {Y.E} U U' \u2286 W\"]<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func Prod \\\\hlevels  {X Y : \\\\hType} (U : Set X) (V : Set Y) : Set (\\\\Sigma X Y) => \\\\lam (s : \\\\Sigma X Y) => \\\\Sigma (U s.1) (V s.2)']<<<break>>>p0 \u2286 W", "completion": "\\case \\elim p0, \\elim p1, \\elim p2 \\with {\n  | _, inP (V2, DV2, V'2, D'V'2, idp), (t, ((Vt, V't), (V2t, V'2t))) => (\\lam {s} p0 => (\n    \\let (V2s, V'2s) => p0\n    \\in (g DV2 (t.1, (Vt, V2t)) V2s, g' D'V'2 (t.2, (V't, V'2t)) V'2s))) <=\u2218 UU'<=W\n}"}
{"prompt": "['a : E {Dom {\\\\this}}', 'X : TopLModule R', 'R : NearSkewField', 'b : E {Dom {\\\\this}}']<<<break>>>['\\\\class ContMap \\\\extends SetHom \\\\hlevels  {\\n  | func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))\\n}', '| \\\\infixl 6 + E E : E', '| E : \\\\Set', '\\\\func const \\\\hlevels  {Y X : TopSpace} (x : X.E) : ContMap Y X {\\n  | func => \\\\lam (_ : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| Dom : BaseSet']<<<break>>>ContMap R X {\n  | func => \\lam (_ : E {Dom {\\this}}) => a + b\n}", "completion": "const (a + b)"}
{"prompt": "['this : NatTrans', 'e : \\\\Pi {X : Ob {C}} -> Iso {D} {Functor.F {NatTrans.F} X} {Functor.F {G} X} (trans X)', 'f : Hom {C {\\\\this}} X Y', 'X : Ob {C {\\\\this}}', 'Y : Ob {C {\\\\this}}']<<<break>>>['| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X', '| C : Precat', '| Hom Ob Ob : \\\\Set', '| f_hinv : f \u2218 hinv = id {C} cod', '| hinv : Hom {C} cod dom', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| f : Hom {C} dom cod', '| dom : Ob {C}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| cod : Ob {C}', '| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| D : Precat', '| id (X : Ob) : Hom X X', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| F : Functor C D', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| G : Functor C D', '| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)']<<<break>>>id {D} (Functor.F {G} Y) \u2218 Func {G} {X} {Y} f1 = f {e {Y}} \u2218 (Func {NatTrans.F} {X} {Y} f1 \u2218 hinv {e {X}})", "completion": "rewrite id-left\n  (rewrite (inv o-assoc) (rewrite (natural {this} f) (rewrite o-assoc (rewrite (f_hinv {e}) (rewrite id-right idp)))))"}
{"prompt": "[\"context' : List env.Sort\", 'f : env.symbol s', 'mc : MetaContext env.Sort', 'context : List env.Sort', 's : env.Sort', 'env : FSignature', \"mc' : MetaContext env.Sort\", \"msubst : MetaSubstitution env (nil {env.Sort}) mc mc'\", 'index : Fin (arity {env} {s} f)', 'arguments : DArray {arity {env} {s} f}\\n  (\\\\lam (index : Fin (arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc)', \"sublist : SubList {env.Sort} context context'\"]<<<break>>>[\"\\\\lemma over-metasubstitution \\\\hlevels  {env : FSignature} {s : env.Sort} {mc mc' : MetaContext env.Sort} {context context' : List env.Sort}\\n  (t : Term env context s mc) (msubst : MetaSubstitution env (nil {env.Sort}) mc mc')\\n  (sublist : SubList {env.Sort} context context') : weakening {env} {s} {context} {context'} {mc'}\\n  (apply {env} {context} {nil {env.Sort}} {s} {mc} {mc'} t (sublist-nil-free {env.Sort} {context}) msubst) sublist = apply {env} {context'} {nil {env.Sort}} {s} {mc} {mc'} (weakening {env} {s} {context} {context'} {mc} t sublist)\\n  (sublist-nil-free {env.Sort} {context'}) msubst \", '\\\\func apply \\\\hlevels  {env3 : FSignature} {context3 core-context2 : List env.Sort} {s3 : env.Sort}\\n  {old-metacontext2 new-metacontext3 : MetaContext env.Sort} (_ : Term env3 context3 s3 old-metacontext2)\\n  (_ : SubList {env.Sort} core-context2 context3)\\n  (_ : MetaSubstitution env3 core-context2 old-metacontext2 new-metacontext3) : Term env3 context3 s3 new-metacontext3 \\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, var index p, sublist, subst =>\\n    var {env} {context} {s} {new-metacontext} index p\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, metavar m arguments, sublist, subst =>\\n  Substitution.apply {env} {s} {core-context ++ old-metacontext.m-domain {s} m} {new-metacontext} (subst {s} m) {context}\\n    (extend-substitution-left {env} {core-context} {old-metacontext.m-domain {s} m} {context} {new-metacontext} sublist\\n      (\\\\lam (i : Index {env.Sort} (old-metacontext.m-domain {s} m)) => MetaSubstitution.apply\\n        {env} {context} {core-context} {old-metacontext.m-domain {s} m !! i} {old-metacontext} {new-metacontext} (arguments.at i)\\n          sublist subst))\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, func f arguments, sublist, subst =>\\n  func {env} {context} {s} {new-metacontext} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) new-metacontext)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => MetaSubstitution.apply\\n      {env} {context ++ f !!domain i} {core-context} {f !!sort i} {old-metacontext} {new-metacontext} (arguments.at i)\\n        (extend-right-single {env.Sort} {core-context} {context} sublist {f !!domain i}) subst))', '\\\\func \\\\infix 7 !!sort \\\\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\\\Sigma (List Sort) Sort} (domain {s} m)) : Sort \\n  => (domain {s} m !! index).2', '| Sort : \\\\Set', '\\\\func \\\\infix 7 !!domain \\\\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\\\Sigma (List Sort) Sort} (domain {s} m)) : List Sort \\n  => (domain {s} m !! index).1', '\\\\func extend-right-both {A3 : \\\\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \\n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})', '| at (j : Fin len) : A j', 'nil', '\\\\func sublist-nil-free {A2 : \\\\Type} {list1 : List A2} : SubList {A2} (nil {A2}) list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-skip {A} {nil {A}} {a} {list} (sublist-nil-free {A} {list})', \"\\\\func weakening \\\\hlevels  {env3 : FSignature} {s'3 : env.Sort} {narrow-context3 wide-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Term env3 narrow-context3 s'3 mc3) (_ : SubList {env.Sort} narrow-context3 wide-context3) :\\n  Term env3 wide-context3 s'3 mc3 \\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, var index p, sublist =>\\n  var {env} {wide-context} {s'} {mc} (shift-index {env.Sort} {narrow-context} {wide-context} sublist index)\\n    (proof {env.Sort} {narrow-context} {wide-context} {s'} sublist index p)\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, metavar m arguments, sublist =>\\n  metavar {env} {wide-context} {s'} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s'} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s'} m)) => Term env wide-context (mc.m-domain {s'} m !! index) mc)\\n    (\\\\lam (i1 : Fin (MetaContext.arity {mc} {s'} m)) =>\\n      weakening {env} {mc.m-domain {s'} m !! i1} {narrow-context} {wide-context} {mc} (arguments.at i1) sublist))\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, func f arguments, sublist =>\\n  func {env} {wide-context} {s'} {mc} f (\\\\new DArray {FSignature.arity {env} {s'} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s'} f)) => Term env (wide-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i1 : Fin (FSignature.arity {env} {s'} f)) =>\\n    weakening {env} {f !!sort i1} {narrow-context ++ f !!domain i1} {wide-context ++ f !!domain i1} {mc} (arguments.at i1)\\n      (extend-right-both {env.Sort} {narrow-context} {wide-context} sublist {f !!domain i1})))\", '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))']<<<break>>>weakening {env} {f !!sort index} {context ++ f !!domain index} {context' ++ f !!domain index} {mc'}\n  (apply {env} {context ++ f !!domain index} {nil {env.Sort}} {f !!sort index} {mc} {mc'} (arguments.at index)\n    (sublist-nil-free {env.Sort} {context ++ f !!domain index}) msubst)\n  (extend-right-both {env.Sort} {context} {context'} sublist {f !!domain index}) = apply {env} {context' ++ f !!domain index} {nil {env.Sort}} {f !!sort index} {mc} {mc'}\n  (weakening {env} {f !!sort index} {context ++ f !!domain index} {context' ++ f !!domain index} {mc} (arguments.at index)\n    (extend-right-both {env.Sort} {context} {context'} sublist {f !!domain index}))\n  (sublist-nil-free {env.Sort} {context' ++ f !!domain index}) msubst", "completion": "over-metasubstitution (arguments index) msubst (extend-right-both sublist)"}
{"prompt": "['c*-sum : \\\\Pi {a b : X.E} -> X.norm (a X.* a) <= X.norm (a X.* a X.+ b X.* b)', 'X : RealBanachAlgebra', 'b : X.E', 'a : X.E']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '| norm E : ExUpperReal']<<<break>>>X.norm (b X.* b) <= X.norm (b X.* b X.+ a X.* a)", "completion": "c*-sum {_} {a}"}
{"prompt": "['n : Nat', 'this : CGroupData', 'x : E {G}']<<<break>>>['true', '\\\\lemma inverse_pow \\\\hlevels  {this : Group} {x : E} {n : Nat} : inverse (pow x n) = pow (inverse x) n ', '\\\\func not \\\\plevels  \\\\hlevels  (_ : Bool) : Bool \\n  | true => false\\n  | false => true', '| G : Group', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '| E : \\\\Set', '| inverse E : E', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>inverse {G} (pow {G} (if {E {G}} (not true) (inverse {G} x) x) n) = pow {G} (inverse {G} (if {E {G}} (not true) (inverse {G} x) x)) n", "completion": "inverse_pow {G {this}}"}
{"prompt": "['l : PFunc {V} {B}', 'B : BooleanRing', 'g : B.E -> B.E', 'V : PosetQModule']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>Array (\\Sigma V.E B.E) l.len (\\lam (i : Fin l.len) => (\\lam (s : \\Sigma V.E B.E) => (s.1, g s.2)) (l.at i))", "completion": "map (\\lam s => (s.1, g s.2)) l"}
{"prompt": "['U1 : E {A}', 'U2 : E {A}', \"R'V2U2 : R' V2 U2\", 'RV1U1 : R V1 U1', 'V1 : E {A}', \"p' : \\\\Pi {V U : E {A}} -> R' V U -> R V U\", 'p : \\\\Pi {V U : E {A}} -> R1 V U -> R V U', 'this : RatherBelow', 'V2 : E {A}']<<<break>>>[\"| <=<_meet {U V U' V' : E {A}} (R U V) (R U' V') : R (U \u2227 U') (V \u2227 V')\", '| R (E {A}) (E {A}) : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| A : TopMeetSemilattice']<<<break>>>R (V1 \u2227 V2) (U1 \u2227 U2)", "completion": "<=<_meet {this} (p RV1U1) (p' R'V2U2)"}
{"prompt": "['e3 : QEquiv {A} {C} (g o e1.f)', 'e1 : Retraction {A} {B}', 'A : \\\\Type', 'g : B -> C', 'C : \\\\Type', 'B : \\\\Type']<<<break>>>['| A : \\\\Type', '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| f_sec (y : B) : f (sec y) = y', '\\\\func \\\\infixr 8 o {A B C : \\\\Type} (g : B -> C) (f : A -> B) : \\\\Pi (x : A) -> C => \\\\lam (x : A) => g (f x)', '\\\\func \\\\infix 2 qed {A : \\\\Type} (a : A) : a = a => idp {A} {a}', \"\\\\func \\\\infix 2 ==< {A : \\\\Type} (a : A) {a' : A} (p : a = a') : a = a' => p\", '| ret_f (x : A) : ret (f x) = x', '| ret B : A', '| f A : B', '| sec B : A', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| B : \\\\Type', \"\\\\func \\\\infixr 1 >== {A : \\\\Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a'' => p *> q\"]<<<break>>>QEquiv {B1} {C} g {\n  | ret => \\lam (c : B {\\this}) => e1.f (e3.ret c)\n  | ret_f => \\lam (b : A {\\this}) => (==<) {B1} (e1.f (e3.ret (g b))) {(o) e1.f (e3.ret o g) (e1.f (e1.sec b))}\n    (pmap {B1} {B1} (e1.f o e3.ret o g) {b} {e1.f (e1.sec b)} (inv {B1} {e1.f (e1.sec b)} {b} (e1.f_sec b))) >== (==<) {B1} (e1.f (e3.ret (g (e1.f (e1.sec b))))) {e1.f (e1.sec b)}\n    (pmap {A1} {B1} e1.f {e3.ret ((o) g e1.f (e1.sec b))} {e1.sec b} (e3.ret_f (e1.sec b))) >== (==<) {B1} (e1.f (e1.sec b)) {b} (e1.f_sec b) >== qed {B1} b\n  | f_sec => e3.f_sec\n}", "completion": "\\new QEquiv {\n  | A => _\n  | B => _\n  | f => g\n  | ret => \\lam c => e1 (ret {e3} c)\n  | ret_f => \\lam b => e1 (ret {e3} (g b)) ==< pmap (e1 o ret {e3} o g) (inv (f_sec {e1} b)) >== e1 (ret {e3} (g (e1 (sec {e1} b)))) ==< pmap e1 (ret_f {e3} (sec {e1} b)) >== e1 (sec {e1} b) ==< f_sec {e1} b >== qed b\n  | f_sec => f_sec {e3}\n}"}
{"prompt": "['x : P.E', 'Ux : U.1 x', 'U : E', 'P : FramePres']<<<break>>>['\\\\func pHat \\\\hlevels  {this : Locale} (P : \\\\Prop) : E => Join {P} (\\\\lam (_ : P) => top)', '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', 'cover-inj (j : J) (g j = x)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| top : E', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', \"\\\\lemma remove' \\\\plevels  \\\\hlevels  {A : \\\\Prop} (_ : TruncP A) : A \", '\\\\func IsPositive \\\\hlevels  {this : Locale} (a : E) : \\\\Prop => \\\\Pi (P : \\\\Prop) -> a <= pHat P -> P', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>(\\Pi {J : \\Set} -> \\Pi (g : J -> P.E) -> Cover {P} x {J} g -> TruncP J) ->\nCover {P} x {\\Sigma (IsPositive {PresentedFrame P} U) (x : P.E) (top.1 x)}\n  (\\lam (p0 : \\Sigma (IsPositive {PresentedFrame P} U) (x : P.E) (top.1 x)) => p0.2)", "completion": "\\lam i => cover-inj (\\lam Q p => remove' $ map (i _ (p Ux)) (\\lam p0 => p0.1), x, ()) idp"}
{"prompt": "['B : Real', 'eps : Real']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| M : Monoid', '| R : Semiring', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| vars : Array (E {M})', '\\\\field mData : MonoidData {R} vars', '| E : \\\\Set', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>LinearRatAlgebraData {RealField} (eps :: B :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => eps :: B :: nil\n}"}
{"prompt": "['S : Set (Set (E {\\\\this}))', 'L : Locale', 'g : \\\\Pi {x : CompleteFilter L} -> U x <-> x.F a', 'a : L.E', 'U : Set (E {\\\\this})', 'SU : S U']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '| F (E {A}) : \\\\Prop', '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U : Set (CompleteFilter L)) (S U) (\\Pi {x : CompleteFilter L} -> U x <-> x.F a))", "completion": "inP (U, SU, g)"}
{"prompt": "['R : GradedCRing', 'n : Nat', 'b : R.E', 'k : Nat', 'c : R.E']<<<break>>>['true', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '| ide-left {x : E} : ide * x = x', '\\\\func closure \\\\hlevels  {R : CRing} {J : \\\\Set} (g : J -> R.E) : Ideal R (\\\\lam (e : E {S {\\\\this}}) =>\\n  TruncP (\\\\Sigma (l : Array (\\\\Sigma R.E J)) (e = BigSum {R} (map {\\\\Sigma R.E J} {R.E} (\\\\lam (p : \\\\Sigma R.E J) => p.1 R.* g p.2) l)))) \\n=> \\\\new Ideal {\\n  | contains_zro => {?hidden}\\n  | contains_+ => {?hidden}\\n  | ideal-left => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| ide : E', 'inP A', '| zro-right {x : E} : x + zro = x', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| zro : E', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '| S : BaseSet', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>TruncP (\\Sigma (l : Array (\\Sigma R.E Bool))\n  (pow {S} (if {R.E} true b c) n = BigSum {R} (map {\\Sigma R.E Bool} {R.E} (\\lam (p : \\Sigma R.E Bool) => p.1 R.* if {R.E} p.2 (pow {R} b n) (pow {R} c k)) l)))", "completion": "inP ((1, true) :: nil, simplify)"}
{"prompt": "['n : Nat', 'v : Fin n']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func singleAt {A : \\\\Type} {n : Nat} (j : Fin n) (value def : A) : Array A n (\\\\lam (i : Fin n) => (\\\\case decideEq j i \\\\with {\\n  | yes p => value\\n  | no n => def\\n})) => \\\\new DArray', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)', 'pos Nat']<<<break>>>Array Int n (\\lam (i : Fin n) => (\\case decideEq v i \\with {\n  | yes p => pos 1\n  | no n => pos 0\n}))", "completion": "singleAt v (pos 1) 0"}
{"prompt": "[]<<<break>>>['\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '\\\\lemma *-cover \\\\hlevels  : CoverMap (ProductCoverSpace RealNormed RealNormed) RealNormed {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 * s.2\\n} ', '\\\\lemma proj2 \\\\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) Y {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.2\\n} ', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : CoverSpace} (g : CoverMap Y Z) (f : CoverMap X Y) : CoverMap X Z {\\n  | func => \\\\lam (x : E {Dom {g \u2218 f}}) => g.func (f.func x)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\func id \\\\hlevels  {X : CoverSpace} : CoverMap X X {\\n  | func => \\\\lam (x : E {Dom {id {X}}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', \"\\\\func prod \\\\hlevels  {X Y X' Y' : CoverSpace} (f : CoverMap X Y) (g : CoverMap X' Y') : CoverMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} z, func {g \u2218 proj2 {X} {X'}} z)\\n} => tuple {Y} {Y'} {X \u2a2f X'} (f \u2218 proj1 {X} {X'}) (g \u2218 proj2 {X} {X'})\", '\\\\func tuple \\\\hlevels  {X Y Z : CoverSpace} (f : CoverMap Z X) (g : CoverMap Z Y) : CoverMap Z (X \u2a2f Y) {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (f.func z, g.func z)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\class CoverMap \\\\extends PrecoverMap, StronglyCauchyMap \\\\hlevels  {\\n  | func-weak-cauchy => \\\\lam (F1 : WeaklyCauchyFilter Dom) =>\\n  \\\\new WeaklyCauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n    | filter-mono => {?hidden}\\n    | filter-top => {?hidden}\\n    | filter-meet => {?hidden}\\n    | isWeaklyProper => {?hidden}\\n    | isCauchyFilter => {?hidden}\\n  }\\n}', '\\\\lemma proj1 \\\\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) X {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} ', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>CoverMap (RealNormed \u2a2f RealNormed \u2a2f RealNormed) (RealNormed \u2a2f RealNormed) {\n  | func => \\lam (z : E {Dom {\\this}}) => (func {proj1 {RealNormed} {RealNormed} \u2218 proj1 {RealNormed \u2a2f RealNormed} {RealNormed}} z,\n    func {*-cover \u2218 prod {RealNormed \u2a2f RealNormed} {RealNormed} {RealNormed} {RealNormed} (proj2 {RealNormed} {RealNormed}) (id {RealNormed})}\n      z)\n}", "completion": "tuple (proj1 \u2218 proj1) (*-cover \u2218 prod proj2 id)"}
{"prompt": "['R : CRing', 'u : R.E', 'B : Matrix R.E 2 2', 's : R.E', 'q : s R.* u R.+ t R.* v = R.ide', 'd : CRingData {R} (u :: B !! 0 !! 0 :: v :: B !! 1 !! 1 :: s :: t :: nil) {\\n  | interpretNF_negate => {?hidden}\\n}', 'p : at {at {B} 0} 0 R.* u = at {at {B} 1} 1 R.* v', 't : R.E', 'v : R.E']<<<break>>>['| \\\\infixl 6 + E E : E', '| C : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', 'coef C', 'nil', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', ':ide', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', ':zro', '| negative E : E', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\infixl 7 :* (_ _ : RingTerm C V)', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', 'pos Nat', '| zro : E', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\field mData : MonoidData {R} vars', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ', '\\\\infixr 5 :: A (List A)']<<<break>>>(R.negative u R.* B !! 0 !! 0 R.+ (v R.* R.zro R.+ R.zro)) R.* R.ide R.+ ((R.negative u R.* R.zro R.+ (v R.* B !! 1 !! 1 R.+ R.zro)) R.* R.ide R.+ R.zro) = R.zro", "completion": "fromZero {R}\n  {(R.negative u R.* B !! 0 !! 0 R.+ (v R.* R.zro R.+ R.zro)) R.* R.ide R.+ ((R.negative u R.* R.zro R.+ (v R.* B !! 1 !! 1 R.+ R.zro)) R.* R.ide R.+ R.zro)}\n  {R.zro} (terms-equality {d}\n    ((:negative (var 0) :* var 1 :+ (var 2 :* :zro :+ :zro)) :* :ide :+ ((:negative (var 0) :* :zro :+ (var 2 :* var 3 :+ :zro)) :* :ide :+ :zro) :+ :negative :zro)\n    (:negative (coef 1) :* (var 1 :* var 0 :+ :negative (var 3 :* var 2)) :+ (coef 0 :* (var 4 :* var 0 :+ var 5 :* var 2 :+ :negative :ide) :+ :zro))\n    idp *> gensZeroToIdealZero ((interpret {d} (:negative (coef 1)), B !! 0 !! 0 R.* u + negative (B !! 1 !! 1 R.* v),\n    toZero {R} {B !! 0 !! 0 R.* u} {B !! 1 !! 1 R.* v} p) :: (interpret {d} (coef 0), s R.* u R.+ t R.* v + negative R.ide, toZero {R} {s R.* u R.+ t R.* v} {R.ide} q) :: nil))"}
{"prompt": "['M : CMonoid']<<<break>>>[\"\\\\func \\\\infixl 7 *' \\\\hlevels  {M3 : CMonoid} (_ _ : DivQuotient M3) : DivQuotient M3 \\n  | {M}, in~ x, in~ y => inD {M} (x M.* y)\\n  | {M}, in~ x, ~-equiv y y' y~y' i => ~-equiv {E} {(~)} (x M.* y) (x M.* y') (\\\\case y~y' \\\\with {\\n    | (inP y'|y, inP y|y') => (inP {LDiv {M} (x M.* y') (x M.* y)} (product-left {M} x {y'} {y} y'|y),\\n      inP {LDiv {M} (x M.* y) (x M.* y')} (product-left {M} x {y} {y'} y|y'))\\n  }) i\\n  | {M}, ~-equiv x x' x~x' i, in~ y => ~-equiv {E} {(~)} (x M.* y) (x' M.* y) (\\\\case x~x' \\\\with {\\n    | (inP x'|x, inP x|x') => (inP {LDiv {M} (x' M.* y) (x M.* y)} (product-right {M} y {x'} {x} x'|x),\\n      inP {LDiv {M} (x M.* y) (x' M.* y)} (product-right {M} y {x} {x'} x|x'))\\n  }) i\", '\\\\class OrderedCMonoid \\\\extends OrderedMonoid, CMonoid \\\\hlevels  {\\n  | <=_*-right => \\\\lam (z : E) {x y : E} (x<y : x <= y) =>\\n    transport2 {E} {E} (<=) {x * z} {z * x} {y * z} {z * y} (*-comm {x} {z}) (*-comm {y} {z}) (<=_*-left z {x} {y} x<y)\\n}', '\\\\func DivPreoder \\\\hlevels  (M : CMonoid) : Preorder M.E {\\n  | <= => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => TruncP (LDiv {M} y x)\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', '\\\\func inD \\\\hlevels  {M : CMonoid} (x : M.E) : DivQuotient M => in~ {E} {(~)} x', \"\\\\instance DivQuotientMonoid \\\\hlevels  (M : CMonoid) : OrderedCMonoid (DivQuotient M) {\\n  | <= => (<=C)\\n  | ide => inD {M} M.ide\\n  | * => (*')\\n} => \\\\new OrderedCMonoid {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | <=_*-left => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func PreorderC \\\\hlevels  {this : Preorder} : \\\\Set => Quotient {E} (~)', '| ide : E', \"\\\\func \\\\infix 4 <=C \\\\hlevels  {this3 : Preorder} (_ _ : PreorderC) : \\\\Prop \\n  | {this}, in~ x, in~ y => x <= y\\n  | {this}, ~-equiv x x' x~x' i, in~ y =>\\n    propExt {x <= y} {x' <= y} ((<=\u2218) {x'} {x} {y} x~x'.2) ((<=\u2218) {x} {x'} {y} x~x'.1) @ i\\n  | {this}, in~ x, ~-equiv y y' y~y' i =>\\n    propExt {x <= y} {x <= y'} (\\\\lam (p0 : x <= y) => p0 <=\u2218 y~y'.1) (\\\\lam (p0 : x <= y') => p0 <=\u2218 y~y'.2) @ i\", '\\\\func DivQuotient \\\\hlevels  (M : CMonoid) : \\\\Set => PreorderC {DivPreoder M}']<<<break>>>OrderedCMonoid (DivQuotient M) {\n  | <= => (<=C)\n  | ide => inD {M} M.ide\n  | * => (*')\n}", "completion": "DivQuotientMonoid M"}
{"prompt": "['M : \\\\hType', 'X : \\\\hType', 'Y-local : isLocal Y', 'X-conn : isConnectedType {nullTypeUniverse M} X', 'Y : \\\\hType', 'N : \\\\hType']<<<break>>>['| A : \\\\Type', '\\\\func nullTypeUniverse (M : \\\\Type) : Modality {\\n  | isLocal => \\\\lam (Z : \\\\hType) => \\\\Sigma -> Equiv {\\\\Sigma -> Z} {M -> Z} (\\\\lam (_x : A {\\\\this}) => _x o (\\\\lam (_ : M) => ()))\\n  | localization => \\\\lam (A1 : \\\\hType) => \\\\new Localization {famUniverse {\\\\new Family {\\n    | J => \\\\Sigma\\n    | X => \\\\lam (_ : \\\\Sigma) => M\\n    | Y => \\\\lam (_ : J {\\\\this}) => \\\\Sigma\\n    | F => \\\\lam (j : J {\\\\this}) (_ : X {\\\\this} j) => ()\\n  }}} A1 (\\\\new Local {U {\\\\this}} (LData {famHat {\\\\new Family {\\n    | J => \\\\Sigma\\n    | X => \\\\lam (_ : \\\\Sigma) => M\\n    | Y => \\\\lam (_ : J {\\\\this}) => \\\\Sigma\\n    | F => \\\\lam (j : J {\\\\this}) (_ : X {\\\\this} j) => ()\\n  }}} A1) {\\n    | local => {?hidden}\\n  }) {\\n    | inL => alpha {famHat {\\\\new Family {\\n      | J => \\\\Sigma\\n      | X => \\\\lam (_ : \\\\Sigma) => M\\n      | Y => \\\\lam (_ : J {\\\\this}) => \\\\Sigma\\n      | F => \\\\lam (j : J {\\\\this}) (_ : X {\\\\this} j) => ()\\n    }}} {A1}\\n    | local-univ => {?hidden}\\n  }\\n} => nullFamUniverse {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => M)', '\\\\lemma conv \\\\plevels  \\\\hlevels  {A B : \\\\Prop} (_ : A = B) (_ : B) : A ', '\\\\func Join (A B : \\\\Type) : \\\\hType \\n  => PushoutData {\\\\Sigma A B} {A} {B} (\\\\lam (p0 : \\\\Sigma A B) => p0.1) (\\\\lam (p0 : \\\\Sigma A B) => p0.2)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\lemma local_join \\\\hlevels  (A A' B : \\\\hType) : (\\\\Pi (f : A' -> B) -> isLocal (\\\\Sigma (b : B) (\\\\Pi (a : A') -> f a = b))) = isLocal B \", '| isLocal \\\\hType : \\\\Prop', '\\\\class Local \\\\hlevels  {\\n  | U : Universe\\n  | S : \\\\hType\\n  | local : isLocal {U} S\\n}', '\\\\class Equiv \\\\extends Section, Retraction', '\\\\func \\\\infixr 8 o {A B C : \\\\Type} (g : B -> C) (f : A -> B) : \\\\Pi (x : A) -> C => \\\\lam (x : A) => g (f x)']<<<break>>>\\Pi (f : N -> Y) ->\n\\Sigma -> Equiv {\\Sigma -> \\Sigma (b : Y) (\\Pi (a : N) -> f a = b)} {X -> \\Sigma (b : Y) (\\Pi (a : N) -> f a = b)}\n  (\\lam (_x : A {\\this}) => _x o (\\lam (_ : X) => ()))", "completion": "\\lam f => X-conn (\\new Local {\n  | S => _\n  | local => conv (local_join M N Y) Y-local f\n})"}
{"prompt": "['J : \\\\Set', 'l : Array (\\\\Sigma (Array R.E) J)', 'R : Semiring']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\func remove {A2 : \\\\Type} {P1 : A2 -> \\\\Prop} (_ : \\\\Pi (a : A2) -> Dec (P1 a)) (_ : Array A2) : Array A2 \\n  | {A}, {P}, D, nil => nil\\n  | {A}, {P}, D, :: {n} a l => \\\\case D a \\\\with {\\n    | yes p => remove {A} {P} D l\\n    | no n => a :: remove {A} {P} D l\\n  }', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| at (j : Fin len) : A j', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>\\Pi (i : Fin (len {remove {\\Sigma (Array R.E) J} {\\lam (s : \\Sigma (Array R.E) J) => len {s.1} = 0}\n  (\\lam (s : \\Sigma (Array R.E) J) => decideEq (len {s.1}) 0) l})) ->\nArray (\\Sigma R.E J) (len {(at {remove {\\Sigma (Array R.E) J} {\\lam (s : \\Sigma (Array R.E) J) => len {s.1} = 0}\n  (\\lam (s : \\Sigma (Array R.E) J) => decideEq {NatSemiring} (len {s.1}) 0) l} i).1})\n  (\\lam (i1 : Fin (len {(at {remove {\\Sigma (Array R.E) J} {\\lam (s : \\Sigma (Array R.E) J) => len {s.1} = 0}\n    (\\lam (s : \\Sigma (Array R.E) J) => decideEq {NatSemiring} (len {s.1}) 0) l} i).1})) =>\n  (\\lam (p0 : R.E) => (p0, (at {remove {\\Sigma (Array R.E) J} {\\lam (s : \\Sigma (Array R.E) J) => len {s.1} = 0}\n    (\\lam (s : \\Sigma (Array R.E) J) => decideEq {NatSemiring} (len {s.1}) 0) l} i).2))\n  (at {(at {remove {\\Sigma (Array R.E) J} {\\lam (s : \\Sigma (Array R.E) J) => len {s.1} = 0}\n    (\\lam (s : \\Sigma (Array R.E) J) => decideEq {NatSemiring} (len {s.1}) 0) l} i).1} i1))", "completion": "\\lam i => map (\\lam p0 => (p0, (remove (\\lam s => decideEq (len {s.1}) 0) l i).2)) (remove (\\lam s => decideEq (len {s.1}) 0) l i).1"}
{"prompt": "['y : E', 'x : E', 'this : HeytingAlebra', 'z : E']<<<break>>>['| meet-left {x y : E} : x \u2227 y <= x', '| <=-refl {x : E} : x <= x', '\\\\lemma eval \\\\hlevels  {this : HeytingAlebra} {x y : E} : (x --> y) \u2227 x <= y ', '\\\\lemma ldistr>= \\\\hlevels  {this : HeytingAlebra} {x y z : E} : x \u2227 (y \u2228 z) <= x \u2227 y \u2228 x \u2227 z ', '| join-univ {x y z : E} (x <= z) (y <= z) : x \u2228 y <= z', '| \\\\infix 4 <= E E : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '| implies \\\\alias \\\\infixr 5 --> E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>(x --> z) \u2227 (y --> z) \u2227 (x \u2228 y) <= z", "completion": "ldistr>= {this} <=\u2218 {this} join-univ {this} (meet-monotone {this} (meet-left {this}) (<=-refl {this}) <=\u2218 {this} eval {this})\n  (meet-monotone {this} (meet-right {this}) (<=-refl {this}) <=\u2218 {this} eval {this})"}
{"prompt": "['p0 : \\\\Sigma E E', 'x : Real']<<<break>>>['\\\\lemma abs>=_- \\\\hlevels  {this : LatticeAbGroup} {x y : E} : y - x <= abs (x - y) ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>p0.1 - x <= abs {RealAbGroup} (x - p0.1)", "completion": "abs>=_- {RealAbGroup}"}
{"prompt": "['q : Rat', 'r : Rat', 'q<r : fromRat q < fromRat r']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma natUnit \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n * m = 1) : m = 1 ', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatAlgebraData {RealField} (zro :: zro :: fromRat q :: fromRat r :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}}\n  (var {E} {Fin 4} 2 :+ (var {E} {Fin 4} 3 :+ :negative {E} {Fin 4} (var {E} {Fin 4} 2)) :* coef {E} {Fin 4} (rat (pos 1) 8 {?hidden} {?hidden}) :* coef {E} {Fin 4} (rat (pos 2) 1 {?hidden} {?hidden})) < interpret {\\new LinearRatAlgebraData {RealField} (zro :: zro :: fromRat q :: fromRat r :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}}\n  (var {E} {Fin 4} 3 :+ :negative {E} {Fin 4} ((var {E} {Fin 4} 3 :+ :negative {E} {Fin 4} (var {E} {Fin 4} 2)) :* coef {E} {Fin 4} (rat (pos 1) 8 {?hidden} {?hidden}) :* coef {E} {Fin 4} (rat (pos 2) 1 {?hidden} {?hidden})))", "completion": "solve<Problem {\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => zro :: zro :: fromRat q :: fromRat r :: nil\n}} ((var 2, Less, var 3) :: nil)\n  (var 2 :+ (var 3 :+ :negative (var 2)) :* coef (rat (pos 1) 8 {?hidden} {?hidden}) :* coef (rat (pos 2) 1 {?hidden} {?hidden}))\n  (var 3 :+ :negative ((var 3 :+ :negative (var 2)) :* coef (rat (pos 1) 8 {?hidden} {?hidden}) :* coef (rat (pos 2) 1 {?hidden} {?hidden})))\n  (4 :: 2 :: nil, 0, idp, idp {Bool} {true}) (q<r :: nil)"}
{"prompt": "['R : GradedCRing', 'l0 : Nat', 'dy0p : d R.* pow {R} b0 n R.* pow {R} g0.1 l0 R.* pow {R} g0.1 m0 = y0 R.* pow {R} g0.1 (k0 * n) R.* pow {R} g0.1 m0', 'y0 : R.E', 'b0 : R.E', 'm0 : Nat', 'n : Nat', 'k0 : Nat', 'd : R.E', 'g0 : Carrier R']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| E : \\\\Set', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>d R.* pow {R} b0 n R.* pow {R} g0.1 l0 R.* pow {R} g0.1 m0 - y0 R.* pow {R} g0.1 (k0 * n) R.* pow {R} g0.1 m0 = R.zro", "completion": "toZero {R} {d R.* pow {R} b0 n R.* pow {R} g0.1 l0 R.* pow {R} g0.1 m0} {y0 R.* pow {R} g0.1 (k0 * n) R.* pow {R} g0.1 m0} dy0p"}
{"prompt": "['R : AddMonoid', 'l : Array (\\\\Sigma R.E M)', 'z : Array (\\\\Sigma R.E M)', 'M : \\\\Set', 'e2 : Closure {Array (\\\\Sigma R.E M)} (~) z l2', 'l2 : Array (\\\\Sigma R.E M)']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\data Closure {A : \\\\Type} (A -> A -> \\\\Type) (_ _ : A) : \\\\Prop \\n  | cin (R x y)\\n  | ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', '\\\\lemma ~_++-right \\\\hlevels  {M : \\\\Set} {R : AddMonoid} {l l1 l2 : Array (\\\\Sigma R.E M)} (_ : Closure {Array (\\\\Sigma R.E M)} (~) l1 l2) :\\n  Closure {Array (\\\\Sigma R.E M)} (~) (l ++ l1) (l ++ l2) ']<<<break>>>Closure {Array (\\Sigma R.E M)} (~) (l ++ z) (l ++ l2)", "completion": "~_++-right e2"}
{"prompt": "['q : Poly R', 'p : \\\\Pi (x : R.E) -> x = R.zro', 'R : AddPointed']<<<break>>>['pzero', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '\\\\lemma poly-trivial \\\\hlevels  {R : AddPointed} (_ : \\\\Pi (x : R.E) -> x = R.zro) (p : Poly R) : p = pzero {R} ']<<<break>>>q = pzero {R}", "completion": "poly-trivial p q"}
{"prompt": "['l : Array E', 'k : Int', 'this : CGroup']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func ipow \\\\hlevels  {this2 : Group} (_ : E) (_ : Int) : E \\n  | {this}, a, pos n => pow a n\\n  | {this}, a, neg n => pow (inverse a) n', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set']<<<break>>>Array E l.len (\\lam (i : Fin l.len) => ipow (l.at i) k)", "completion": "\\lam i => ipow {this} (l i) k"}
{"prompt": "['y : E', 'x : E', 'this : LatticeAbGroup']<<<break>>>['\\\\lemma negative_<= \\\\hlevels  {this : PosetAddGroup} {x y : E} (_ : x <= y) : negative y <= negative x ', '| \\\\infix 4 <= E E : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| negative E : E', '| join-right {x y : E} : y <= x \u2228 y']<<<break>>>negative (x \u2228 y) <= negative y", "completion": "negative_<= {this} (join-right {this})"}
{"prompt": "['h1 : func {div-map {R} {a} {b} a|b \u2218 locMap {R} {powers {R} a}} = func {locMap {R} {powers {R} b}}', 'R : CRing', 'a : R.E', 'b : R.E', 'a|b : LDiv {R} a b']<<<break>>>['| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| \\\\infixl 7 * E E : E', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func locMap \\\\hlevels  {R : CRing} {S : SubMonoid R} : RingHom R (LocRing {R} S) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) =>\\n    in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (x, R.ide, S.contains_ide)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\func powers \\\\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (pow {M} a n = x))) \\n=> \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', '| E : \\\\Set', '\\\\instance LocRing \\\\hlevels  {R : CRing} (S : SubMonoid R) : CRing (Type {R} {S}) {\\n  | zro => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.zro, R.ide, S.contains_ide)\\n  | + => ++ {R} {S}\\n  | * => ** {R} {S}\\n  | negative => neg {R} {S}\\n  | ide => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.ide, R.ide, S.contains_ide)\\n  | natCoef => \\\\lam (n : Nat) => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2}\\n    (R.natCoef n, R.ide, S.contains_ide)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func \\\\infixl 8 compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {R S T : Ring} (g : RingHom S T) (f : RingHom R S) : RingHom R T {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\func div-map \\\\hlevels  {R : CRing} {a b : R.E} (a|b : LDiv {R} a b) : RingHom (LocRing {R} (powers {R} a)) (LocRing {R} (powers {R} b)) {\\n  | func => aux-func {R} {a} {b} a|b\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}']<<<break>>>Path (\\lam (i : I) => \\Pi {x y : R.E} -> (@) h1 i (x R.* y) = (@) h1 i x * (@) h1 i y)\n  (func-* {div-map {R} {a} {b} a|b \u2218 locMap {R} {powers {R} a}}) (func-* {locMap {R} {powers {R} b}})", "completion": "prop-dpi (\\lam i => ext_coe) (func-* {div-map {R} {a} {b} a|b \u2218 locMap {R} {powers {R} a}}) (func-* {locMap {R} {powers {R} b}})"}
{"prompt": "['g : J -> Set X.E', 'j : J', 'U : Set X.E', 'gj=W : g j = W', 'X : StronglyRegularCoverSpace', 'V : Set X.E', 'Z=VW : U = V \u2227 W', 'W : Set X.E']<<<break>>>[\"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>U \u2286 g j", "completion": "rewrite Z=VW (rewrite gj=W meet-right)"}
{"prompt": "['f : AddMonoidHom', 'y : E {Dom {\\\\this}}', 'x : E {Dom {\\\\this}}']<<<break>>>['| \\\\infixl 6 + E E : E', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>func {f} (x + y) = func {f} x + func {f} y", "completion": "f.func-+ {x} {y}"}
{"prompt": "['L : Locale', 'S : VSheaf {\\n  | C => L\\n}']<<<break>>>['| D : Cat', '| id (X : Ob) : Hom X X', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| F : Functor (op {C}) D', \"\\\\lemma direct_image_locale \\\\hlevels  {L L' : Locale} (f : FrameHom L' L) (S : VSheaf {\\n  | C => L\\n}) : VSheaf S.D L' (Comp {Precat.op {L'}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {f}})) \", '\\\\class VSheaf \\\\extends VPresheaf \\\\hlevels  {\\n  | isSheaf {x : Ob {C}} {s : Sieve {C} x} (isCover {C} x s) : Limit {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {D}\\n    (Comp {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n      (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C}} {D} VPresheaf.F\\n      (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F} apex) {\\n    | coneMap => \\\\lam (j : Ob {J}) => Func {VPresheaf.F} {apex} {Functor.F j} (coneMap j)\\n    | coneCoh => {?hidden}\\n  }\\n}', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func functor \\\\hlevels  {this2 : FrameHom} : Functor Dom Cod func {\\n  | Func => func-<=\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>VSheaf S.D L (Comp {Precat.op {L}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {id {LocaleCat} L}}))", "completion": "direct_image_locale {L} {L} (id L) S"}
{"prompt": "['I : Ideal R', 'f : \\\\Pi (i : Fin l.len) -> \\\\Sigma (l1 : Array (\\\\Sigma (x : R.E) (I.contains x) M.E))\\n  (l.at i = BigSum {M} (map {\\\\Sigma (x : R.E) (I.contains x) M.E} {M.E} (\\\\lam (s : \\\\Sigma (x : R.E) (I.contains x) M.E) => s.1 M.*c s.3) l1))', 'R : CRing', 'p : i = j', 'j : Fin l.len', 'i : Fin l.len', 'l : Array M.E', 'g : \\\\Pi (i : Fin l.len) -> \\\\Pi (i1 : Fin (len {(f i).1})) -> \\\\Sigma (c : Array R.E l.len)\\n  ((at {(f i).1} i1).3 = BigSum {M} (\\\\new Array M.E l.len (\\\\lam (i : Fin l.len) => c.at i M.*c l.at i)))']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 6 + E E : E', '\\\\lemma simplify-correct \\\\hlevels  {this : CGroupData} (t : GroupTerm V) : interpret t = interpret (simplify t) ', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '| V : \\\\Set', 'yes E', '\\\\lemma bigSum \\\\hlevels  {this : Ideal} (l : Array (E {S})) (_ : \\\\Pi (i : Fin l.len) -> contains (l.at i)) : contains (BigSum {S} l) ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', ':inv (GroupTerm V)', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set', '| negative E : E', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray', '| contains (E {S}) : \\\\Prop', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| ideal-right {r a : E {S}} (contains a) : contains (a * r)', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class CGroupData \\\\extends NatData \\\\hlevels ', '\\\\lemma negative_zro \\\\hlevels  {this : AddGroup} : negative zro = zro ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| zro-right {x : E} : x + zro = x', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '| zro : E', 'var V', '\\\\infixl 6 :* (_ _ : GroupTerm V)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro-left {x : E} : zro + x = x', '| S : BaseSet']<<<break>>>contains {I} ((\\case yes {i = j} p \\with {\n  | yes p => R.ide\n  | no n => R.zro\n}) R.+ R.negative (BigSum {R} (mkArray {R.E} {len {(f i).1}} (\\lam (j1 : Fin (len {(f i).1})) => ((f i).1 !! j1).1 R.* (g i j1).1 !! j))) - R.ide)", "completion": "simplify (contains_negative $ bigSum {I} _ (\\lam k => later $ ideal-right ((f i).1 k).2))"}
{"prompt": "['this : LatticeData']<<<break>>>['\\\\func toSemiring \\\\hlevels  (L : BoundedDistributiveLattice) : CSemiring L.E {\\n  | zro => L.bottom\\n  | + => (L.\u2228)\\n  | * => (L.\u2227)\\n  | ide => L.top\\n  | natCoef => natCoefImpl\\n} => \\\\new CSemiring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func natCoefImpl \\\\hlevels  {this2 : Semiring} (_ : Nat) : E \\n  | {this}, 0 => zro\\n  | {this}, suc n => natCoefImpl n + ide', '| bottom : E', '| top : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| L : BoundedDistributiveLattice', '\\\\class CSemiring \\\\extends Semiring, PseudoCSemiring, CMonoid \\\\hlevels ']<<<break>>>CSemiring (E {L}) {\n  | zro => bottom {L}\n  | + => (\u2228) {L}\n  | * => (\u2227) {L}\n  | ide => top {L}\n  | natCoef => natCoefImpl\n}", "completion": "L {this}"}
{"prompt": "['this : GradedCRing', 'm : Nat']<<<break>>>['| zro : E', '\\\\lemma BigSum_replicate \\\\hlevels  {this : Semiring} {x : E} {n : Nat} : BigSum (replicate {E} n x) = natCoef n * x ', '\\\\func replicate {A : \\\\Type} (n : Nat) (a : A) : Array A n (\\\\lam (_ : Fin n) => a) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '| natCoef Nat : E', '| E : \\\\Set', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l']<<<break>>>BigSum (replicate {E} m zro) = natCoef m * zro", "completion": "BigSum_replicate {this}"}
{"prompt": "['n : Nat']<<<break>>>['\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', 'suc Nat', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| <=_*-positive {x y : E} (zro <= x) (zro <= y) : zro <= x * y', '| \\\\infixl 7 * E E : E', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', 'rfunc \\\\hlevels  (_ : Nat) : Rat \\n  | 0 => zro\\n  | suc n => ratio (pos 1) 2 * (ide + rfunc n * rfunc n)', '\\\\lemma square_>=0 \\\\hlevels  {this : LinearlyOrderedSemiring} {x : E} : zro <= x * x ', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\func negative (_ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 xReduced => rat (negative xNom) xDenom {?hidden} {?hidden}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', 'pos Nat', '| zro : E', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\lemma rat_<=-dec \\\\plevels  \\\\hlevels  {r q : Rat} {so : So (rat_<=_Bool r q)} : r <= q ', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>zro <= rat (pos 1) 2 {?hidden} {?hidden} Semigroup.* ((rat (pos 1) 1 {?hidden} {?hidden} + negative (rfunc (suc n))) RatField.* (ide - rfunc (suc n)))", "completion": "<=_*-positive {RatField} rat_<=-dec (square_>=0 {RatField})"}
{"prompt": "['x : Real', 'n : Int', 'd : dist (fromRat (fromInt n)) x < ide']<<<break>>>['\\\\lemma abs>=neg \\\\hlevels  {this : LatticeAbGroup} {x : E} : negative x <= abs x ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func RealNormedAbGroup \\\\hlevels  : NormedAbGroup Real {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', '| ide : E', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| negative E : E', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>negative (fromRat (fromInt n) - x) < ide", "completion": "abs>=neg {RealAbGroup} <\u2218r d"}
{"prompt": "['x>0 : zro < x', 'x : E', 'this : OrderedField']<<<break>>>['| zro : E', '\\\\lemma pinv>0 \\\\hlevels  {this : OrderedField} {x : E} (x>0 : zro < x) : zro < pinv x {?hidden} ', '\\\\func pinv \\\\hlevels  {this : OrderedField} (x : E) (\\\\property x>0 : zro < x) : E => inv {pos#0 {x} x>0}', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>zro OrderedAddGroup.< pinv x {?hidden}", "completion": "pinv>0 {this} x>0"}
{"prompt": "['x : E', 'x*z<y*z : x * z < y * z', 'y : E', 'this : LinearlyOrderedCSemiring', 'z : E']<<<break>>>['| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', '| E : \\\\Set', \"\\\\func transport2 {A B : \\\\Type} (C : A -> B -> \\\\Type) {a a' : A} {b b' : B} (_ : a = a') (_ : b = b') (_ : C a b) : C a' b' \\n  | {A}, {B}, C, {a}, {a'}, {b}, {b'}, idp, idp, c => c\", '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>z * x < z * y", "completion": "transport2 ((<) {this}) (*-comm {this}) (*-comm {this}) x*z<y*z"}
{"prompt": "['gs : IsSurj {U.E} {V.E} g.func', 'g : LinearMap {R} U V', 'V : FinModule R', 'R : Ring', 'U : LModule R']<<<break>>>['\\\\func id \\\\hlevels  {R1 : Ring} {M : LModule R1} : LinearMap {R1} M M {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => a\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\class LinearMap \\\\extends AddGroupHom \\\\hlevels  {\\n  | R : Ring\\n  | func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\lemma surj-lift \\\\hlevels  {R : Ring} {F : FinModule R} {U V : LModule R} (f : LinearMap {R} F V) (g : LinearMap {R} U V)\\n  (_ : IsSurj {U.E} {V.E} g.func) : TruncP (\\\\Sigma (h : LinearMap {R} F U) (\\\\Pi (x : F.E) -> g.func (h.func x) = f.func x)) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (h : LinearMap {R} V U) (\\Pi (x : V.E) -> g.func (h.func x) = func {id {R} {V}} x))", "completion": "surj-lift id g gs"}
{"prompt": "['y : E {R {\\\\this}}', 'p : x < y', 'x : E {R {\\\\this}}']<<<break>>>['| isDense {x z : E} (x < z) : TruncP (\\\\Sigma (y : E) (x < y) (y < z))', '\\\\instance RatDenseOrder \\\\hlevels  : UnboundedDenseLinearOrder.Dec Rat {\\n  | < => (OrderedAddGroup.<)\\n  | meet => meet\\n  | join => join\\n  | # => \\\\lam (x : E) (y : E) => #0 (x - y)\\n  | decideEq => \\\\lam (x : E) (y : E) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | trichotomy => \\\\lam (x : E) (y : E) => (\\\\case +_trichotomy (x - y) \\\\with {\\n    | less x-y<0 => less {RatField} {x} {y} (fromNeg {RatField} {x} {y} (<0_neg {RatField} {x - y} x-y<0))\\n    | equals x-y=0 => equals {RatField} {x} {y} (fromZero {RatField} {x} {y} x-y=0)\\n    | greater x-y>0 => greater {RatField} {x} {y} (>0_pos {RatField} {x - y} x-y>0)\\n  })\\n} => \\\\new UnboundedDenseLinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | isDense => {?hidden}\\n  | withoutUpperBound => {?hidden}\\n  | withoutLowerBound => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>TruncP (\\Sigma (y1 : E) (x < y1) (y1 < y))", "completion": "isDense p"}
{"prompt": "['C : Set (Set X.E)', 'Cc : X.isCauchy C', 'X : RegularPreuniformSpace']<<<break>>>['\\\\lemma <=*-cauchy-regular \\\\hlevels  {this : RegularPreuniformSpace} {C : Set (Set E)} (_ : isCauchy C) :\\n  isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=* U))) ', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\func \\\\infix 4 <=* \\\\hlevels  {X : PreuniformSpace} (V U : Set X.E) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (star {X.E} V C \u2286 U))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>X.isCauchy (\\lam (V : Set X.E) => TruncP (\\Sigma (U : Set X.E) (C U) (V <=* U)))", "completion": "<=*-cauchy-regular {X} Cc"}
{"prompt": "['t : \\\\Sigma (p : E {e.dom} = E {e.cod}) (Path (\\\\lam (i : I) => AddPointed (p @ i)) (\\\\new e.dom {}) (\\\\new e.cod {}))\\n  (\\\\Pi (x : E {e.dom}) -> transport {\\\\Type} (\\\\lam (Z : \\\\Type) => Z) {E {e.dom}} {E {e.cod}} p x = func {e.f} x)']<<<break>>>['| zro : E', '\\\\class AddPointed \\\\extends BaseSet \\\\hlevels  {\\n  | zro : E\\n}', '| E : \\\\Set']<<<break>>>\\Pi (i : I) -> AddPointed (E {t.2 @ i}) {\n  | zro => zro {t.2 @ i}\n}", "completion": "\\lam i => \\new AddPointed {\n  | E => E {t.2 @ i}\n  | zro => zro {t.2 @ i}\n}"}
{"prompt": "['m : I.E', 'n : I.E', 'x : X.E', 'X : TopAbGroup', 'f : I.E -> X.E']<<<break>>>['| V : \\\\Set', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class CGroupData \\\\extends NatData \\\\hlevels ', '| at (j : Fin len) : A j', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '| E : \\\\Set', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}']<<<break>>>CGroupData {toCGroup X} (\\lam (a : V {\\this}) => at {f m :: x :: f n :: nil} (fromNat {2} a))", "completion": "\\new CGroupData {toCGroup X} ((::) (f m) (x :: f n :: nil) a)"}
{"prompt": "['g : Mono {C} {y} {z}', 'C : PrecatWithPullbacks', 'z : C.Ob', 'y : C.Ob', 'x : C.Ob', 'f : Mono {C} {x} {z}']<<<break>>>['| Hom Ob Ob : \\\\Set', '| pullback {x y z : Ob} (f : Hom x z) (g : Hom y z) : Pullback {x} {y} {z} f g', '| f : Hom {C} dom cod', '| y : Ob {D}', '| pbBeta2 {w : Ob {D}} {p1 : Hom {D} w x} {p2 : Hom {D} w y} {c : f \u2218 p1 = g \u2218 p2} : pbProj2 \u2218 pbMap {w} p1 p2 c = p2', '| pbProj2 : Hom {D} apex y', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| apex : Ob {D}', '| g : Hom {D} y z', '| f : Hom {D} x z', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| pbMap {w : Ob {D}} (p1 : Hom {D} w x) (p2 : Hom {D} w y) (f \u2218 p1 = g \u2218 p2) : Hom {D} w apex', '| x : Ob {D}', '| Ob : \\\\hType', '| z : Ob {D}', '| D : Precat']<<<break>>>\\Pi {w : Ob {D {pullback {C} {y1} {x1} {z1} g.f f.f}}} ->\n\\Pi {p1 : Hom {D {pullback {C} {y1} {x1} {z1} g.f f.f}} w (x {pullback {C} {y1} {x1} {z1} g.f f.f})} ->\n  \\Pi {p2 : Hom {D {pullback {C} {y1} {x1} {z1} g.f f.f}} w (y {pullback {C} {y1} {x1} {z1} g.f f.f})} ->\n  \\Pi {c : Pullback.f {pullback {C} {y1} {x1} {z1} g.f f.f} \u2218 p1 = g {pullback {C} {y1} {x1} {z1} g.f f.f} \u2218 p2} ->\n    pbProj2 {pullback {C} {y1} {x1} {z1} g.f f.f} \u2218 pbMap {pullback {C} {y1} {x1} {z1} g.f f.f} {w} p1 p2 c = p2", "completion": "pbBeta2 {pullback (f {g}) (f {f})}"}
{"prompt": "['reduced : gcd {NatEuclidean} (iabs n2) d2 = 1', \"this : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (RatField.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => RatField.negative\\n  | negative-left => {?hidden}\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | zeroProduct => {?hidden}\\n  | meet => meet\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join => join\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | *-comm => {?hidden}\\n  | finv => RatField.finv\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n}\", 'n2 : Int', 'd2 : Nat', 'd1 : Nat', 'denom/=0 : d1 /= 0', 'p : rat n2 d2 {?hidden} {?hidden} < (\\\\case inr {n2 * pos d1 < n1 * pos d2} {n1 * pos d2 <= n2 * pos d1} x<=y \\\\with {\\n  | inl y<x => rat n2 d2 {?hidden} {?hidden}\\n  | inr x<=y => rat n1 d1 {?hidden} {?hidden}\\n})', 'n1 : Int', 'reduced : gcd {NatEuclidean} (iabs n1) d1 = 1', 'denom/=0 : d2 /= 0']<<<break>>>[\"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\func signum \\\\plevels  \\\\hlevels  (_ : Int) : Int \\n  | pos 0 => pos 0\\n  | pos (suc n) => pos 1\\n  | neg (suc n) => neg 1', 'pos Nat', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', \"\\\\func \\\\infixl 6 +' \\\\plevels  \\\\hlevels  (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)\", \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', \"\\\\lemma +=+' \\\\plevels  \\\\hlevels  {x y : Rat} : x + y = x +' y \", '| negative E : E', '\\\\func ratNom \\\\plevels  \\\\hlevels  (_ : Rat) : Int \\n  | rat n denom denom/=0 reduced => n', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}']<<<break>>>signum (ratNom (rat n1 d1 {?hidden} {?hidden} +' negative {\\this} (rat n2 d2 {?hidden} {?hidden}))) = pos 1", "completion": "rewrite +=+' (unfolds p)"}
{"prompt": "['k_k2 : B {\\\\this}', 'p0 : B {\\\\this}', 'n : Nat']<<<break>>>['suc Nat', '\\\\lemma id<suc \\\\plevels  \\\\hlevels  {n : Nat} : n < suc n ', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', \"\\\\func gcd-isGCD \\\\hlevels  {this1 : EuclideanSemiringData} (a b : E) :\\nGCD a b (gcd a b) (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val1 {\\\\this}) (reduce a b).1 {\\n  | inv-right => {?hidden}\\n})\\n  (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val2 {\\\\this}) (reduce a b).2 {\\n    | inv-right => {?hidden}\\n  }) (gcd-isGCD-fueled (suc' (euclideanMap b)) {a} {b}) => \\\\new GCD\", \"\\\\func reduce \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : \\\\Sigma E E => reduce-fueled (suc' (euclideanMap b)) a b\", '| euclideanMap E : Nat', '| val1 : E {M}', '| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', '\\\\class GCD \\\\hlevels  {\\n  | M : CMonoid\\n  | val1 : E {M}\\n  | val2 : E {M}\\n  | res : E {M}\\n  | res|val1 : LDiv {M} res val1\\n  | res|val2 : LDiv {M} res val2\\n  | res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res\\n}', '| val2 : E {M}', '| E : \\\\Set', \"\\\\lemma suc'=suc \\\\plevels  \\\\hlevels  (n : Nat) : suc' n = suc n \", '| M : CMonoid', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| res : E {M}', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\lemma reduce*fueled-left \\\\hlevels  {this : EuclideanSemiringData} (s : Nat) (a b : E) (_ : euclideanMap b < s) :\\n  (reduce-fueled s a b).1 * gcd-fueled s a b = a ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func gcd-isGCD-fueled \\\\hlevels  {this1 : EuclideanSemiringData} (s1 : Nat) {a1 b1 g1 : E} (_ : LDiv g1 a1) (_ : LDiv g1 b1) :\\n  LDiv g1 (gcd-fueled s1 a1 b1) \\n  | {this}, 0, {a}, {b}, {g}, g|a, g|b => g|a\\n  | {this}, suc s, {a}, {b}, {g}, g|a, g|b => \\\\case decideEq b zro \\\\with {\\n    | yes p => g|a\\n    | no b/=0 => gcd-isGCD-fueled s {b} {(divMod a b).2} {g} g|b\\n      (summandDiv {g|b.inv * (divMod a b).1} {(divMod a b).2} {g|a.inv} {g} (ldiv/=0 {g} {b} b/=0 g|b)\\n        (pmap {E} {E} (\\\\lam (_x : E) => _x + (divMod a b).2) {g * (g|b.inv * (divMod a b).1)} {g * g|b.inv * (divMod a b).1}\\n          (Paths.inv {E} {g * g|b.inv * (divMod a b).1} {g * (g|b.inv * (divMod a b).1)} (*-assoc {g} {g|b.inv} {(divMod a b).1})) *> pmap {E} {E} (\\\\lam (p0 : E) => p0 * (divMod a b).1 + (divMod a b).2) {g * g|b.inv} {b} g|b.inv-right *> isDivMod a b *> Paths.inv {E} {g * g|a.inv} {a} g|a.inv-right))\\n  }', '\\\\instance IntEuclidean \\\\hlevels  : EuclideanRingData Int {\\n  | zro => pos 0\\n  | + => (+)\\n  | * => (IntRing.*)\\n  | ide => pos 1\\n  | natCoef => pos\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => iabs\\n  | divMod => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\n    \\\\let! (d, m) => Nat.divMod (iabs x) (iabs y)\\n    \\\\in (pos d Semigroup.* signum y Semigroup.* signum x, pos m Semigroup.* signum x))\\n  | negative => negative\\n} => \\\\new EuclideanRingData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n  | negative-left => {?hidden}\\n}', \"\\\\func suc' \\\\plevels  \\\\hlevels  (_ : Nat) : Nat \\n  | 0 => 1\\n  | suc n => suc (suc n)\"]<<<break>>>GCD {IntEuclidean} (pos k) (pos (suc n)) (gcd {IntEuclidean} (pos k) (pos (suc n)))\n  (\\new LDiv {M {\\this}} (res {\\this}) (val1 {\\this}) (reduce {IntEuclidean} (pos k) (pos (suc n))).1 {\n    | inv-right => {?hidden}\n  })\n  (\\new LDiv {M {\\this}} (res {\\this}) (val2 {\\this}) (reduce {IntEuclidean} (pos k) (pos (suc n))).2 {\n    | inv-right => {?hidden}\n  }) (gcd-isGCD-fueled {IntEuclidean} (suc' (euclideanMap (pos (suc n)))) {pos k} {pos (suc n)})", "completion": "gcd-isGCD {IntEuclidean} (pos k) (pos (suc n))"}
{"prompt": "['n : Nat', 's : j = a', 'i<j : i < j', 'a : Fin n', 'j : Fin (suc n)', 'i : Fin (suc n)']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '\\\\lemma id<suc \\\\plevels  \\\\hlevels  {n : Nat} : n < suc n ', '\\\\lemma id/=suc \\\\plevels  \\\\hlevels  {n : Nat} : n /= suc n ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\lemma transposition1-left \\\\plevels  \\\\hlevels  {n : Nat} {a : Fin n} : f {transposition1 {n} a} a = suc a ', '| <-transitive \\\\alias \\\\infixr 9 <\u2218 {x y z : E} (x < y) (y < z) : x < z', '| \\\\infix 4 < E E : \\\\Prop', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| f A : B', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', 'transposition \\\\plevels  \\\\hlevels  {n : Nat} {a b : Fin n} (a/=b : a /= b) : Sym n => cycle {n} {2} (a :: b :: nil) (inj {n} {a} {b} {a/=b})']<<<break>>>i < f {transposition {suc n} {a} {suc a} (id/=suc {a})} a", "completion": "rewrite transposition1-left ((rewrite s in i<j) <\u2218 id<suc)"}
{"prompt": "['M : AbMonoid']<<<break>>>['| M : \\\\Set', '\\\\class SolverModel \\\\hlevels  {\\n  | M : \\\\Set\\n  | Term Nat : \\\\Set\\n  | NF Nat : \\\\Set\\n  | normalize {n : Nat} (Term n) : NF n\\n  | interpret {n : Nat} (Fin n -> M) (Term n) : M\\n  | interpretNF {n : Nat} (Fin n -> M) (NF n) : M\\n  | interpretNF-consistent {n : Nat} {env : Fin n -> M} {t : Term n} : interpretNF {n} env (normalize {n} t) = interpret {n} env t\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func AbMonoidSolverModel \\\\hlevels  (A : AbMonoid) : SolverModel E {\\n  | Term => Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => normalize\\n  | interpret => interpret {toCMonoid A}\\n  | interpretNF => \\\\lam {n : Nat} (env : Fin n -> M {\\\\this}) (nf : NF {\\\\this} n) => interpretNF {toCMonoid A} {Fin n} env (sort {FinOrder n} nf)\\n} => CMonoidSolverModel (toCMonoid A)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func interpret {M2 : Monoid} {n1 : Nat} (_ : Fin n1 -> M.E) (_ : Term n1) : M.E \\n  | {M}, {n}, env, var x => env x\\n  | {M}, {n}, env, :ide => M.ide\\n  | {M}, {n}, env, t :* s => interpret {M} {n} env t M.* interpret {M} {n} env s', '| NF Nat : \\\\Set', '\\\\func sort \\\\hlevels  {A : Dec} (l : List A.E) : List A.E => rbTreeToList {A.E} (aux {A} l (rbLeaf {A.E})) (nil {A.E})', '\\\\data Term \\\\plevels  \\\\hlevels  Nat \\n  | var (Fin n)\\n  | :ide\\n  | \\\\infixl 7 :* (_ _ : Term n)', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func interpretNF \\\\hlevels  {M2 : Monoid} {V1 : \\\\Set} (_ : V1 -> M.E) (_ : List V1) : M.E \\n  | {M}, {V}, env, nil => M.ide\\n  | {M}, {V}, env, x :: nil => env x\\n  | {M}, {V}, env, x :: l => env x M.* interpretNF {M} {V} env l', '\\\\func toCMonoid \\\\hlevels  (M : AbMonoid) : CMonoid M.E {\\n  | ide => M.zro\\n  | * => (M.+)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| normalize {n : Nat} (Term n) : NF n', '| E : \\\\Set', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func MonoidSolverModel \\\\hlevels  (M1 : Monoid) : SubstSolverModel M.E {\\n  | Term => MonoidSolverModel.Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => \\\\lam {n : Nat} (t : SolverModel.Term {\\\\this} n) => normalize-aux {n} t (nil {Fin n})\\n  | interpret => MonoidSolverModel.interpret {M1}\\n  | interpretNF => \\\\lam {n : Nat} => MonoidSolverModel.interpretNF {M1} {Fin n}\\n  | nfVar => \\\\lam {n : Nat} (v : Fin n) => v :: nil {Fin n}\\n  | >>= => \\\\lam {m : Nat} {n : Nat} => (>>=)\\n} => \\\\new SubstSolverModel {\\n  | interpretNF-consistent => {?hidden}\\n  | >>=-consistent => {?hidden}\\n}']<<<break>>>SolverModel E {\n  | Term => Term\n  | NF => \\lam (n : Nat) => List (Fin n)\n  | normalize => normalize\n  | interpret => interpret {toCMonoid M1}\n  | interpretNF => \\lam {n : Nat} (env : Fin n -> M {\\this}) (nf : NF {\\this} n) => interpretNF {toCMonoid M1} {Fin n} env (sort {FinOrder n} nf)\n}", "completion": "AbMonoidSolverModel M"}
{"prompt": "['X : Ob {C {\\\\this}}', 'this : PrecoverMap (F {\\\\this} X) (F {\\\\this} Y) {\\n  | func => filter-map {X} {Y} f\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', 'V_DV : \\\\Sigma (s : Set (CompleteFilter Y)) (D s)', 'D : Set (Set (E {Cod {\\\\this}}))', 'f : Hom {C {\\\\this}} X Y', 'Y : Ob {C {\\\\this}}']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', 'inP A', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func points^* \\\\hlevels  {L : Locale} (a : L.E) : Set (CompleteFilter L) => \\\\lam (x : CompleteFilter L) => x.F a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma points^*-points_* \\\\hlevels  {L : Locale} {a : L.E} {U : Set (CompleteFilter L)} (_ : points^* {L} a \u2286 U) : a L.<= points_* {L} U ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func Total {B : \\\\Type} (F : B -> \\\\Type) : \\\\Type => \\\\Sigma (b : B) (F b)', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '| func-Join>= {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\\\lam (j : J) => func (f j))', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)']<<<break>>>f.func (Y.Join {\\Sigma (s : Set (CompleteFilter Y)) (D s)} (\\lam (s : \\Sigma (s : Set (CompleteFilter Y)) (D s)) => points_* {Y} s.1)) X.<= X.Join {\\Sigma (s : Set (CompleteFilter X)) (TruncP (\\Sigma (V : Set (CompleteFilter Y)) (D V) (s = func {\\this} ^-1 V)))}\n  (\\lam (s : \\Sigma (s : Set (CompleteFilter X)) (TruncP (\\Sigma (V : Set (CompleteFilter Y)) (D V) (s = func {\\this} ^-1 V)))) =>\n    points_* {X} s.1)", "completion": "func-Join>= <=\u2218 Join-univ (\\lam p0 => (\n  \\let (V, DV) => p0\n  \\in func-Join>= <=\u2218 Join-univ (\\lam p0 => (\n        \\let (b, p) => p0\n        \\in points^*-points_* (\\lam c => later $ p $ later c) <=\u2218 Join-cond (later (_, inP (V, DV, idp)))))))"}
{"prompt": "['this : StronglyRegularPreuniformSpace']<<<break>>>['\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', '| uniform-cauchy {C : Set (Set E)} : isCauchy C <-> Closure {E} isUniform C', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| uniform-strongly-regular {C : Set (Set E)} (isUniform C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V s<=* U)))', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '\\\\type \\\\infix 4 s<=* \\\\hlevels  {X : PreuniformSpace} (V U : Set X.E) : \\\\Prop => X.isUniform (\\\\lam (W : Set X.E) => (W = Compl {X.E} V) || (W = U))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {C : Set (Set E)} ->\n  isUniform C -> Closure {E} isUniform (\\lam (V : Set E) => TruncP (\\Sigma (U : Set E) (C U) (V s<=* U)))", "completion": "\\lam Cu => (uniform-cauchy {this}).1 $ uniform-strongly-regular {this} Cu"}
{"prompt": "['x : X.E', 'X : RealBanachAlgebra', 'y : X.E']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', '| ide : E', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '\\\\lemma *c-ldistr_- \\\\hlevels  {this : LModule} {r : E {R}} {a b : E} : r *c (a - b) = r *c a - r *c b ', '\\\\func toRatModule \\\\hlevels  {this1 : QModule} : LModule RatField E {\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | negative => negative\\n  | *c => (*q)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', 'pos Nat']<<<break>>>ratio (pos 1) 2 *c (X.ide X.+ X.ide - (x X.+ y)) = ratio (pos 1) 2 *c (X.ide X.+ X.ide) - ratio (pos 1) 2 *c (x X.+ y)", "completion": "*c-ldistr_- {toRatModule {X}}"}
{"prompt": "['b : E', 'a : E', 's : Nat', 'this : EuclideanSemiringData', 'b<=s : euclideanMap b < suc s']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 6 + E E : E', '\\\\func gcd-fueled \\\\hlevels  {this1 : EuclideanSemiringData} (_ : Nat) (_ _ : E) : E \\n  | {this}, 0, a, b => a\\n  | {this}, suc s, a, b => \\\\case decideEq b zro \\\\with {\\n    | yes p => a\\n    | no n => gcd-fueled s b (divMod a b).2\\n  }', '\\\\lemma reduce_zro \\\\hlevels  {this : EuclideanSemiringData} (s : Nat) (a : E) : reduce-fueled s a zro = (ide, zro) ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| euclideanMap E : Nat', '| \\\\infixl 7 * E E : E', 'yes E', 'no (Not E)', '| *-comm {x y : E} : x * y = y * x', '| isEuclideanMap (x y : E) (y /= zro) ((divMod x y).2 /= zro) : euclideanMap (divMod x y).2 < euclideanMap y', '| E : \\\\Set', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| isDivMod (x y : E) : y * (divMod x y).1 + (divMod x y).2 = x', \"\\\\func reduce-fueled \\\\hlevels  {this2 : EuclideanSemiringData} (_ : Nat) (_ _ : E) : \\\\Sigma E E \\n  | {this}, 0, a, b => (ide, zro)\\n  | {this}, suc s, a, b => \\\\case decideEq b zro \\\\with {\\n    | yes p => (ide, zro)\\n    | no n => \\n      \\\\let! | (d, m) => divMod a b\\n            | (a', b') => reduce-fueled s b m\\n      \\\\in (a' * d + b', a')\\n  }\", '| ide-left {x : E} : ide * x = x', '\\\\lemma <_suc_<= \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < suc m) : n <= m ', '| divMod E E : \\\\Sigma E E', '\\\\lemma reduce*fueled-left \\\\hlevels  {this : EuclideanSemiringData} (s : Nat) (a b : E) (_ : euclideanMap b < s) :\\n  (reduce-fueled s a b).1 * gcd-fueled s a b = a ', '\\\\lemma reduce*fueled-right \\\\hlevels  {this : EuclideanSemiringData} (s : Nat) (a b : E) (_ : euclideanMap b < s) :\\n  (reduce-fueled s a b).2 * gcd-fueled s a b = b ', '| ide : E', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| zro-right {x : E} : x + zro = x', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| zro : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma fueled_zro \\\\hlevels  {this : EuclideanSemiringData} (s : Nat) (a : E) : gcd-fueled s a zro = a ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| rdistr {x y z : E} : (x + y) * z = x * z + y * z', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>(\\case decideEq b zro \\with {\n  | yes p => (ide, zro)\n  | no n => ((reduce-fueled s b (divMod a b).2).1 * (divMod a b).1 + (reduce-fueled s b (divMod a b).2).2,\n    (reduce-fueled s b (divMod a b).2).1)\n}).1 * (\\case decideEq b zro \\with {\n| yes p => a\n| no n => gcd-fueled s b (divMod a b).2\n}) = a", "completion": "\\case decideEq b zro \\as d : case_return_arg_1_1 \\return (\\lam (_x : \\Sigma E E) (e : E) => _x.1 * e = a) case_return_arg_1 case_return_arg_2 \\with {\n  | yes _ => ide-left {this}\n  | no b/=0 => \\case decideEq {this} (divMod {this} a b).2 0 \\with {\n    | yes mod=0 => unfold_let (rewrite (mod=0, reduce_zro {this}, fueled_zro {this}, zro-right {this}, ide-left {this})\n      (*-comm {this} *> inv (pmap ((+) {this} _) mod=0 *> zro-right {this}) *> isDivMod {this} a b))\n    | no mod/=0 => rdistr {this} *> pmap2 ((+) {this})\n      (pmap (\\lam _x => _x * {this} _) (*-comm {this}) *> *-assoc {this} *> *-comm {this} *> pmap (\\lam _x => _x * {this} _)\n        (reduce*fueled-left s b (divMod {this} a b).2 (isEuclideanMap {this} a b b/=0 mod/=0 <\u2218l <_suc_<= b<=s)))\n      (reduce*fueled-right {this} s b (divMod {this} a b).2 (isEuclideanMap {this} a b b/=0 mod/=0 <\u2218l <_suc_<= b<=s)) *> isDivMod {this} a b\n  }\n}"}
{"prompt": "['i : Fin (f {e} 0)', 'e : Sym (suc n)']<<<break>>>['| f A : B', 'suc Nat', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma suc_<_<= \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < m) : suc n <= m ', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>suc i <= f {e} 0", "completion": "suc_<_<= (fin_< i)"}
{"prompt": "['V : PosetQModule', \"a=0 : ((a :: l') !! 0).1 = V.zro\", 'a : \\\\Sigma V.E B.E', 'B : BooleanRing', 'n : Nat', \"l' : Array (\\\\Sigma V.E B.E) n\"]<<<break>>>['| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', \"~-zro-left {b : B.E} (l = (V.zro, b) :: l')\", '| E : \\\\Set']<<<break>>>(((a :: l') !! 0).1, a.2) :: nil ~ nil", "completion": "~-zro-left (pmap (\\lam x => (x, a.2) :: nil) a=0)"}
{"prompt": "['i : Fin l.len', 'a : \\\\Sigma V.E B.E', 'l : Array (\\\\Sigma V.E B.E) n', 'B : BooleanRing', 'V : PosetQModule', 'n : Nat', 'lr : IsReduced {V} {B} (a :: l)']<<<break>>>['| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', '\\\\lemma fsuc/=0 \\\\plevels  \\\\hlevels  {n : Nat} {x : Fin n} : fsuc {n} x /= 0 ', 'suc Nat', '| at (j : Fin len) : A j', \"\\\\lemma /=-sym {A : \\\\Type} {a a' : A} (_ : a /= a') : a' /= a \", '| E : \\\\Set', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>at {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (a :: l)} 0 B.* at {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) (a :: l)} (suc i) = B.zro", "completion": "lr (/=-sym fsuc/=0)"}
{"prompt": "['j : Iso']<<<break>>>['| C : Precat', '| hinv_f : hinv \u2218 f = id {C} dom', '| Hom Ob Ob : \\\\Set', '| id (X : Ob) : Hom X X', '| hinv : Hom {C} cod dom', '| f : Hom {C} dom cod', '| dom : Ob {C}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| cod : Ob {C}']<<<break>>>j.hinv \u2218 j.f = id {j.C} j.dom", "completion": "hinv_f {j}"}
{"prompt": "['a : Rat', 'a>0 : fromInt (pos 0) < a']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatData (a :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (:zro {Rat} {Fin 1}) < interpret {\\new LinearRatData (a :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 1} 0 :* coef {E} {Fin 1} (rat (pos 1) 2 {?hidden} {?hidden}))", "completion": "solve<Problem {\\new LinearRatData {\n  | R => RatField\n  | vars => a :: nil\n}} ((:zro, Less, var 0) :: nil) :zro (var 0 :* coef (rat (pos 1) 2 {?hidden} {?hidden}))\n  (2 :: 1 :: nil, 0, idp, idp {Bool} {true}) (a>0 :: nil)"}
{"prompt": "[\"E' : Set (Set Y.E)\", 'X : CoverSpace', \"E'<E : \\\\Pi {V : Set Y.E} ->\\n  E' V -> TruncP (\\\\Sigma (U : Set Y.E) (E1 U) (\\\\Pi {W : Set Y.E} -> E' W -> \\\\Sigma (e : Y.E) ((\u2227) V W e) -> W \u2286 U))\", 'E : Set (Set Y.E)', 'Y : UniformSpace', 'U : Set X.E', 'f : I.E -> CoverMap X Y', 'I : DirectedSet', 'N : I.E', \"h : \\\\Pi {x : X.E} -> U x -> TruncP (\\\\Sigma (W : Set Y.E) (E' W) (\\\\Pi {n : I.E} -> N I.<= n -> W (func {f n} x)))\"]<<<break>>>['| <=-refl {x : E} : x <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {p0 : Set X.E} -> TruncP (\\Sigma (V : Set Y.E) (E' V) (p0 = func {f N} ^-1 V)) ->\n  TruncP (\\Sigma (W : Set Y.E) (E1 W) (\\Pi {n : I.E} -> N I.<= n -> \\Pi {x : X.E} -> U x -> p0 x -> W (func {f n} x)))", "completion": "\\lam {p0} p1 => (\\case \\elim p0, \\elim p1 \\with {\n  | _, inP (W', E'W', idp) => \\case E'<E E'W' \\with {\n    | inP (W, EW, g) => inP (W, EW, \\lam N<=n {x} Ux W'fNx => (\n      \\let W'fNx => W'fNx\n      \\in \\case h Ux \\with {\n            | inP (W'', E'W'', c) => g E'W'' (f N x, (W'fNx, c <=-refl)) (c N<=n)\n          }))\n  }\n})"}
{"prompt": "[\"a>a' : a A.> a'\", 'a : A.E', \"a' : A.E\", 'l : List A.E', 'A : Dec']<<<break>>>['\\\\func insert \\\\hlevels  {A2 : Dec} (_ : A.E) (_ : List A.E) : List A.E \\n  | {A}, a, nil => a :: nil {A.E}\\n  | {A}, a, x :: xs => \\\\case dec<_<= {A} x a \\\\with {\\n    | inl x<a => x :: insert {A} a xs\\n    | inr a<=x => a :: x :: xs\\n  }', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\lemma aux \\\\hlevels  {A : Dec} {a a' : A.E} (_ : a A.< a') (l : List A.E) : insert {A} a (insert {A} a' l) = insert {A} a' (insert {A} a l) \", '| E : \\\\Set', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>insert {A} a' (insert {A} a l) = insert {A} a (insert {A} a' l)", "completion": "aux a>a' l"}
{"prompt": "['h1 : x.contains = y.contains', 'M : LModule R', 'y : E {\\\\this}', 'this : SubLModule R1 M (\\\\lam (e : E {S {\\\\this}}) => arg e @ i) {\\n  | contains_zro => {?hidden}\\n  | contains_+ => {?hidden}\\n  | contains_negative => {?hidden}\\n  | contains_*c => {?hidden}\\n}', 'i : I', 'x : E {\\\\this}']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)', '| E : \\\\Set', '| S : BaseSet']<<<break>>>\\Pi {x : E {S {\\this}}} -> \\Pi {y : M.E} -> (@) h1 i x -> (@) h1 i y -> (@) h1 i (x M.+ y)", "completion": "\\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (contains_+ {x}) (contains_+ {y})) i {x}"}
{"prompt": "['M : Matrix R.E n n', 'e : Sym n', 'n : Nat', 'R : CRing']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 6 + E E : E', \"\\\\func + {R5 : Ring} (_ _ : Poly R5) : Poly R5 \\n  | {R}, pzero, q => q\\n  | {R}, padd p e, pzero => padd {R} p e\\n  | {R}, padd p e, padd q e' => padd {R} (p PolyRing.+ q) (e R.+ e')\\n  | {R}, padd p e, peq i =>\\n  pmap2 {Poly R} {R.E} {Poly R} (padd {R}) {p PolyRing.+ pzero {R}} {p} (PolyRing.zro-right {R} {p}) {e R.+ R.zro} {e}\\n    (R.zro-right {e}) @ i\\n  | {R}, peq i, pzero => peq {R} i\\n  | {R}, peq i, padd q e => pmap {R.E} {Poly R} (padd {R} q) {R.zro R.+ e} {e} (R.zro-left {e}) @ i\", '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\func degree<= \\\\hlevels  {R3 : AddPointed} (_ : Poly R3) (_ : Nat) : \\\\Prop \\n  | {R}, pzero, n => \\\\Sigma\\n  | {R}, padd p a, 0 => p = pzero {R}\\n  | {R}, padd p a, suc n => degree<= {R} p n\\n  | {R}, peq i, 0 =>\\n    propExt {pzero {R} = pzero {R}} {\\\\Sigma} (\\\\lam (_ : pzero {R} = pzero {R}) => ()) (\\\\lam (_ : \\\\Sigma) => idp {Poly R} {pzero {R}}) @ i\\n  | {R}, peq i, suc n => idp {\\\\Prop} {\\\\Sigma} @ i', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', 'padd (Poly R) R.E', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\func \\\\infixl 7 *c \\\\hlevels  {R3 : Ring} (_ : R.E) (_ : Poly R3) : Poly R3 \\n  | {R}, r, pzero => pzero {R}\\n  | {R}, r, padd p e => padd {R} (r *c p) (r R.* e)\\n  | {R}, r, peq i =>\\n    (pmap {R.E} {Poly R} (padd {R} (pzero {R})) {r R.* R.zro} {R.zro} (R.zro_*-right {r}) *> path (peq {R})) @ i', 'pzero', '| \\\\infixl 7 * E E : E', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func * {R3 : Ring} (_ _ : Poly R3) : Poly R3 \\n  | {R}, pzero, q => pzero {R}\\n  | {R}, padd p e, q => padd {R} (p * q) R.zro + e *c q\\n  | {R}, peq i, q =>\\n    (pmap {Poly R} {Poly R} ((+) (padd {R} (pzero {R}) R.zro)) {R.zro *c q} {pzero {R}} (zro_*c {R} {q}) *> path (peq {R})) @ i', '| at (j : Fin len) : A j', '| E : \\\\Set', '| negative E : E', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\lemma degree<=_BigProd1 \\\\hlevels  {R : Ring} {l : Array (Poly R)} (_ : \\\\Pi (j : Fin l.len) -> degree<= {R} (l.at j) 1) :\\n  degree<= {R} (BigProd {PolyRing R} l) l.len ', '| zro : E', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>degree<= {R} (Big {E} {E} (*) ide\n  (\\new Array (Poly R) n (\\lam (j : Fin n) => padd {R} ide R.zro * padd {R} zro (\\case decideEq (f {e} j) j \\with {\n    | yes p => R.ide\n    | no n => R.zro\n  }) + negative (padd {R} zro (at {at {M} (f {e} j)} j)))))\n  (len {\\new Array (Poly R) n (\\lam (j : Fin n) => padd {R} ide R.zro * padd {R} zro (\\case decideEq (f {e} j) j \\with {\n    | yes p => R.ide\n    | no n => R.zro\n  }) + negative (padd {R} zro (at {at {M} (f {e} j)} j)))})", "completion": "degree<=_BigProd1 (\\lam _ => idp)"}
{"prompt": "['U : E {A {\\\\this}}', 'q : V <= W', 'V : E {A {\\\\this}}', 'X : PrecoverSpace', 'W : E {A {\\\\this}}']<<<break>>>['byLeft A', '| <=-refl {x : E} : x <= x', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'byRight B', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func Compl \\\\hlevels  {X : \\\\hType} (U : Set X) : Set X => \\\\lam (x : X) => Not (U x)']<<<break>>>\\Pi {U' : Set X.E} -> (U' = Compl {X.E} U) || (U' = V) ->\n  TruncP (\\Sigma (V : Set X.E) ((\\lam (W1 : Set X.E) => (W1 = Compl {X.E} U) || (W1 = W)) V) (U' \u2286 V))", "completion": "\\lam {U'} => later (\\lam p0 => (\\case p0 \\with {\n  | byLeft r => rewrite r $ inP (_, byLeft idp, <=-refl)\n  | byRight r => rewrite r $ inP (_, byRight idp, q)\n}))"}
{"prompt": "['x : E {\\\\this}']<<<break>>>['| A : TopMeetSemilattice', '| F (E {A}) : \\\\Prop', '| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>\\Pi {a b : E {x.A}} -> x.F a -> x.F b -> x.F (a \u2227 b)", "completion": "filter-meet {x}"}
{"prompt": "['x : E {\\\\this}', 'y : E {\\\\this}', 'R : HeytingAlebra', 'this : BooleanAlgebra (NegatedElem R) {\\n  | <= => \\\\lam (a : E {\\\\this}) (b : E {\\\\this}) => a.1 R.<= b.1\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet => \\\\lam (a : E {\\\\this}) (b : E {\\\\this}) => (a.1 R.\u2227 b.1, meet-negated {R} {a.1} {b.1} a.2 b.2)\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join => \\\\lam (a : E {\\\\this}) (b : E {\\\\this}) => (neg {R} (neg {R} (a.1 R.\u2228 b.1)), neg-negated {R} {neg {R} (a.1 R.\u2228 b.1)})\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | ldistr>= => {?hidden}\\n  | bottom => (R.bottom, bottom-negated {R})\\n  | bottom-univ => {?hidden}\\n  | top => (R.top, R.top-univ {neg {R} (neg {R} R.top)})\\n  | top-univ => {?hidden}\\n  | exp => exp\\n  | compl => \\\\lam (a : E {\\\\this}) => (neg {R} a.1, neg-negated {R} {a.1})\\n  | compl-meet => {?hidden}\\n  | compl-join => {?hidden}\\n}']<<<break>>>['\\\\lemma id<=neg_neg \\\\hlevels  {this : HeytingAlebra} {x : E} : x <= neg (neg x) ', '| \\\\infix 4 <= E E : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| join-right {x y : E} : y <= x \u2228 y', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>y.1 R.<= (x \u2228 y).1", "completion": "join-right <=\u2218 id<=neg_neg"}
{"prompt": "['p/=0 : p /= zro', 'R : Dec', 'd : degree< {R} p 0', 'p : Poly R']<<<break>>>['\\\\func degree \\\\hlevels  {R1 : Ring.Dec} (_ : Poly R1) : Nat \\n  | {R}, pzero => 0\\n  | {R}, padd p e => \\\\case decideEq p zro \\\\with {\\n    | yes p => 0\\n    | no n => suc (degree {R} p)\\n  }\\n  | {R}, peq i => idp {Nat} {0} @ i', '\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', '\\\\lemma trivialPoly \\\\hlevels  {R : AddPointed} {p : Poly R} (_ : \\\\Pi (k : Nat) -> degree<= {R} p k -> polyCoef {R} p k = R.zro) : p = pzero {R} ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func degree<= \\\\hlevels  {R3 : AddPointed} (_ : Poly R3) (_ : Nat) : \\\\Prop \\n  | {R}, pzero, n => \\\\Sigma\\n  | {R}, padd p a, 0 => p = pzero {R}\\n  | {R}, padd p a, suc n => degree<= {R} p n\\n  | {R}, peq i, 0 =>\\n    propExt {pzero {R} = pzero {R}} {\\\\Sigma} (\\\\lam (_ : pzero {R} = pzero {R}) => ()) (\\\\lam (_ : \\\\Sigma) => idp {Poly R} {pzero {R}}) @ i\\n  | {R}, peq i, suc n => idp {\\\\Prop} {\\\\Sigma} @ i', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ']<<<break>>>degree {R} p < 0", "completion": "absurd (p/=0 $ trivialPoly (\\lam k _ => d zero<=_))"}
{"prompt": "['k : Nat', 'q : k <= m', 'j : Fin k', 'R : CRing', 'p : k <= n', 'm : Nat', 'A : Matrix R.E n m', 'n : Nat']<<<break>>>['| zro : E', '\\\\lemma zero-div \\\\hlevels  {this : Semiring} {x : E} : LDiv x zro zro ', '| at (j : Fin len) : A j', '\\\\func index \\\\plevels  \\\\hlevels  {n k : Nat} (p : k <= n) (i : Fin k) : Fin n => toFin i {n} {?hidden}', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}']<<<break>>>LDiv {R} (at {at {A} (index {n} {k} p j)} (index {m} {k} q j)) R.zro R.zro", "completion": "zero-div {R}"}
{"prompt": "['this : LinearlyOrderedSemiring', 'a : E', 'p : a * b \u2228 a * c < a * (b \u2228 c)', 'c : E', 'b : E', 'a>=0 : zro <= a']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\lemma <_*_positive-cancel-left \\\\hlevels  {this : LinearlyOrderedSemiring} {x y z : E} (_ : zro <= x) (_ : x * y < x * z) : y < z ', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| join-right {x y : E} : y <= x \u2228 y', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>c < b \u2228 c", "completion": "<_*_positive-cancel-left {this} a>=0 (join-right {this} <\u2218r {this} p)"}
{"prompt": "['x : X.E', 'n : I.E', \"c : \\\\Pi {n : I.E} -> N I.<= n -> W'' (func {f n} x)\", \"W'' : Set Y.E\", 'f : I.E -> CoverMap X Y', 'N<=n : N I.<= n']<<<break>>>['| func (E {Dom}) : E {Cod}']<<<break>>>W'' (func {f n} x)", "completion": "c N<=n"}
{"prompt": "['a : E {P.P}', 'U : E', 'b : E {P.P}', 'Ua : U.1 a', 'P : RingedFramePres', 'p : Cover1 {P.P} b a']<<<break>>>['\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '| P : FramePres', 'cover-inj (j : J) (g j = x)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| E : \\\\Set', '\\\\lemma cover-trans1 \\\\hlevels  {P : FramePres} {x : P.E} {J : \\\\Set} {g : J -> P.E} {y : P.E} (_ : Cover1 {P} x y) (_ : Cover {P} y {J} g) :\\n  Cover {P} x {J} g ', '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x']<<<break>>>embed {P.P} b <= U", "completion": "\\lam {z} c => U.2 z $ cover-trans1 c $ cover-trans1 p $ cover-inj (a, Ua) idp"}
{"prompt": "['S : DecSet', 'a1 : \\\\Sigma S.E Bool', 'e : a.1 = a1.1', 'a : \\\\Sigma S.E Bool', 'x : List (\\\\Sigma S.E Bool)', 'p2 : a.2 xor a1.2 = true']<<<break>>>['\\\\func AreAdjacent \\\\hlevels  {S : \\\\Set} (w_1 w_2 : E) : \\\\Prop => TruncP (\\\\Sigma (u_1 u_2 : E) (x : S) (p : Bool)\\n  (\\\\Sigma (w_1 = u_1 * u_2) (w_2 = u_1 * ((x, p) :: nil {\\\\Sigma S Bool}) * ((x, not p) :: nil {\\\\Sigma S Bool}) * u_2)))', '\\\\func not \\\\plevels  \\\\hlevels  (_ : Bool) : Bool \\n  | true => false\\n  | false => true', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'cin (R x y)', 'nil', 'inP A', '\\\\func W \\\\hlevels  {S : \\\\Set} : Monoid (List (\\\\Sigma S Bool)) {\\n  | ide => nil {\\\\Sigma S Bool}\\n  | * => (++)\\n} => ListMonoid {\\\\Sigma S Bool}', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| E : \\\\Set', '\\\\instance ListMonoid \\\\hlevels  {A : \\\\Set} : Monoid (List A) {\\n  | ide => nil {A}\\n  | * => (++)\\n} => \\\\new Monoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n}', '\\\\func helper1 \\\\plevels  \\\\hlevels  {a2 b2 : Bool} (_ : a2 xor b2 = true) : not a2 = b2 \\n  | {false}, {true}, p => idp {Bool} {not false}\\n  | {true}, {false}, p => idp {Bool} {not true}', '\\\\data Closure {A : \\\\Type} (A -> A -> \\\\Type) (_ _ : A) : \\\\Prop \\n  | cin (R x y)\\n  | crefl (x = y)\\n  | csym (Closure {A} R y x)\\n  | ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)']<<<break>>>Closure {List (\\Sigma S.E Bool)} (AreAdjacent {S.E}) x (a :: a1 :: x)", "completion": "cin (inP (nil, x, a.1, a.2, (idp, rewrite {2} e (rewrite (helper1 p2) idp))))"}
{"prompt": "['q : Rat', 'this : StoneC*Algebra', 'eps : E']<<<break>>>[\"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '| ide : E', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', '| dist E E : ExUpperReal', '| \\\\infixl 7 *c (E {R}) E : E', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| dist-symm {x y : E} : dist x y = dist y x', '\\\\func toRatModule \\\\hlevels  {this1 : QModule} : LModule RatField E {\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | negative => negative\\n  | *c => (*q)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', 'pos Nat']<<<break>>>dist (q *c ide) ((q + eps * ratio (pos 1) 4) *c ide) = dist ((q + eps * ratio (pos 1) 4) *c ide) (q *c ide)", "completion": "dist-symm {this}"}
{"prompt": "['k : Fin (BigSum {NatSemiring} (\\\\new Array Nat V.len (\\\\lam (i : Fin V.len) => len {(W i).1})))', 'E : Set X.E -> Set (Set X.E)', 'V : Array (Set X.E)', 'W : \\\\Pi (i : Fin V.len) ->\\n\\\\Sigma (D : Array (Set X.E)) (IsCover {X.E} (\\\\lam (V : Set X.E) => TruncP (\\\\Sigma (j : Fin D.len) (D !! j = V))))\\n  (\\\\Pi (j : Fin D.len) -> E1 (V !! i) (D !! j))']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func f {n1 : Nat} {Q1 : Fin n1 -> Nat} (_ : Fin (BigSum {NatSemiring} (\\\\new Array Nat n1 Q1))) :\\n  \\\\Sigma (i : Fin n1) (Fin (Q1 i)) \\n  | {suc n}, {Q}, k =>\\n  \\\\case OrFin.aux.f {Q 0} {Big {Nat} {Nat} (+) zro (\\\\new Array Nat n (\\\\lam (j : Fin n) => Q (suc j)))} k \\\\with {\\n    | inl s => (0, s)\\n    | inr t => \\n      \\\\have (i, r) => SigmaFin.aux.f {n} {\\\\lam (j : Fin n) => Q (suc j)} t\\n      \\\\in (suc i, r)\\n  }', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ']<<<break>>>\\Pi (j : Fin (len {(W (f {V.len} {\\lam (i : Fin V.len) => len {(W i).1}} k).1).1})) ->\nE (V !! (f {V.len} {\\lam (i : Fin V.len) => len {(W i).1}} k).1)\n  ((W (f {V.len} {\\lam (i : Fin V.len) => len {(W i).1}} k).1).1 !! j)", "completion": "(W _).3"}
{"prompt": "['f : MonoidHom']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Cod : BaseSet', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\instance ImageMonoid \\\\hlevels  (f : MonoidHom) : Monoid (Image {E {f.Dom}} {E {f.Cod}} f.func) {\\n  | ide => (ide {f.Cod}, inP {\\\\Sigma (a : E {f.Dom}) (f.func a = ide {f.Cod})} (ide {f.Dom}, f.func-ide))\\n  | * => \\\\lam (a : E {\\\\this}) (b : E {\\\\this}) => (a.1 * b.1, \\\\case a.2, b.2 \\\\with {\\n    | inP t, inP s => inP {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1 * b.1)} (t.1 * s.1,\\n      f.func-* {t.1} {s.1} *> pmap2 {E {f.Cod}} {E {f.Cod}} {E {f.Cod}} ((*) {f.Cod}) {f.func t.1} {a.1} t.2 {f.func s.1} {b.1} s.2)\\n  })\\n} => \\\\new Monoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n}', '| func-ide : func (ide {Dom}) = ide {Cod}', '| Dom : BaseSet', '\\\\class MonoidHom \\\\extends PointedHom \\\\hlevels  {\\n  | func-* {x y : E {Dom}} : func (x * y) = func x * func y\\n}', '\\\\func ImagePointedRightHom \\\\hlevels  (f : PointedHom) : PointedHom (ImagePointed f) f.Cod {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} => \\\\new PointedHom {\\n  | func-ide => {?hidden}\\n}']<<<break>>>MonoidHom (ImageMonoid f) f.Cod {\n  | func => \\lam (p0 : E {Dom {ImagePointedRightHom f}}) => p0.1\n  | func-ide => {?hidden}\n  | func-* => {?hidden}\n}", "completion": "\\new MonoidHom {\n  | Dom => ImageMonoid f\n  | Cod => Cod {f}\n  | PointedHom => ImagePointedRightHom f\n  | func-* => idp\n}"}
{"prompt": "[\"i : Iso {LocaleCat} {E.apex} {E'.apex} (eqMap {E'} {E.apex} E.eql (equal {\\\\new E {}})) {\\n  | hinv => eqMap {\\\\new E {}} {E'.apex} E'.eql E'.equal\\n}\", 'M : Locale', 'y : L.E', 'E : Equalizer {LocaleCat} {M} {\\n  | apex => L\\n  | eql => f\\n}', \"E' : Equalizer {LocaleCat} {M} {E.Y} E.f E.g (apex {limit {Shape} (functor {LocaleCat} {M} {E.Y} E.f E.g)})\\n  (coneMap {limit {Shape} (functor {LocaleCat} {M} {E.Y} E.f E.g)} false)\", \"s : \\\\Pi (U : E) -> \\\\Sigma (x : M.E) (func {E'.eql} x = U)\"]<<<break>>>['\\\\func FrameUnitalReflectiveSubcat : ReflectiveSubPrecat FrameCat FrameUPresCat FrameUnitalSubcat.F {\\n  | Func => FrameUnitalSubcat.Func\\n  | reflector => reflector\\n  | reflectorMap => \\\\lam (X : Ob {D {\\\\this}}) => \\\\new FrameUPresHom X (Functor.F {\\\\this} (reflector {\\\\this} X)) {\\n    | func => embed {X}\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | isReflective => \\\\lam {X : Ob {D {\\\\this}}} {Y : Ob {C {\\\\this}}} =>\\n  \\\\new QEquiv {Hom {C {\\\\this}} (reflector {\\\\this} X) Y} {Hom {D {\\\\this}} X (Functor.F {\\\\this} Y)}\\n    (\\\\lam (p0 : A {\\\\this}) => Functor.Func {\\\\this} {reflector {\\\\this} X} {Y} p0 \u2218 ReflectiveSubPrecat.reflectorMap {\\\\this} X) {\\n    | ret => ret {isReflective {X} {Y}}\\n    | ret_f => ret_f {isReflective {X} {Y}}\\n    | f_sec => \\\\lam (h : B {\\\\this}) => path (\\\\lam (i : I) => (\\n      \\\\have arg => path (\\\\lam (i : I) => func {f_ret {isReflective {X} {Y}} h @ i})\\n      \\\\in \\\\new FrameUPresHom X (Functor.F {\\\\this} Y) {\\n            | func => arg @ i\\n            | func-conj => {?hidden}\\n            | func-basicCover => {?hidden}\\n            | func-unit => {?hidden}\\n          }))\\n  }\\n} => \\\\new ReflectiveSubPrecat {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n}', '| hinv : Hom {C} cod dom', '\\\\instance colimit-obj {J : Precat} (G : Functor J FrameUPresCat) : FrameUPres (FTerm {J} G) {\\n  | conj => fconj {J} {G}\\n  | BasicCover => \\\\lam {K : \\\\Set} (x : E {\\\\this}) (f : K -> E {\\\\this}) =>\\n  (\\\\Sigma (j : J.Ob) (y : E {G.F j}) (g : K -> E {G.F j}) (BasicCover {G.F j} {K} y g) (x = finj {J} {G} {j} y)\\n    (\\\\Pi (k : K) -> f k = finj {J} {G} {j} (g k))) || ((K, f) = (\\\\Sigma, \\\\lam (_ : \\\\Sigma) => funit {J} {G}))\\n  | unit => funit {J} {G}\\n} => \\\\new FrameUPres {\\n  | isUnit => {?hidden}\\n}', '| g : Hom {D} X Y', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', '| eql : Hom {D} apex X', '\\\\func FrameBicat : BicompleteCat Locale {\\n  | Hom => FrameHom\\n  | id => \\\\lam (L : Ob) => \\\\new FrameHom L L {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n  }\\n  | o => FrameCat.o\\n  | pullback => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} (f : Hom {\\\\this} X Z) (g1 : Hom {\\\\this} Y Z) =>\\n  \\\\new Pullback {X} {Y} {Z} f g1 (pullback-obj {X} {Y} {Z} f g1) {\\n    | pbProj1 => proj1 {f.Dom} {g.Dom} {f.Cod} {f} {g1}\\n    | pbProj2 => proj2 {f.Dom} {g.Dom} {f.Cod} {f} {g1}\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {Pullback.D {\\\\this}}} (p1 : Hom {Pullback.D {\\\\this}} w (x {\\\\this})) (p2 : Hom {Pullback.D {\\\\this}} w (y {\\\\this}))\\n      (c : Pullback.f {\\\\this} Precat.\u2218 p1 = g {\\\\this} Precat.\u2218 p2) => \\\\new FrameHom w (Pullback.apex {\\\\this}) {\\n      | func => \\\\lam (x : E {Dom {\\\\this}}) => (p1.func x, p2.func x, path (\\\\lam (i : I) => func {c @ i} x))\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | terminal => fromLimit {Empty} (limit {\\\\this} {DiscretePrecat Empty} (functor {Empty} (absurd {Ob {\\\\this}})))\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J1 : Precat} (G1 : Functor J1 this4) => \\\\new Limit {J1} G1 (limit-obj {J1} G1) {\\n    | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => \\\\new FrameHom (Cone.apex {\\\\this}) (F {G {\\\\this}} j) {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => P.1 j\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | coneCoh => {?hidden}\\n    | isLimit => {?hidden}\\n    | limMap => limMap-impl\\n    | limBeta => {?hidden}\\n    | limUnique => {?hidden}\\n  }\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this4) => reflectiveSubPrecatColimit\\n    {J} FrameUnitalReflectiveSubcat G (colimit {J} (Comp {J} {FrameUPresCat} FrameUnitalReflectiveSubcat G))\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\instance FrameUPresCat : Cat FrameUPres {\\n  | Hom => FrameUPresHom\\n  | id => \\\\lam (X : Ob {\\\\this}) => \\\\new FrameUPresHom X X {\\n    | func => \\\\lam (x : X.E) => x\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new FrameUPresHom X Z {\\n    | func => \\\\lam (x : X.E) => g.func (f.func x)\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func functor \\\\plevels obj >= hom \\\\hlevels  {D : Precat} {x y : D.Ob} (f g : D.Hom x y) : Functor Shape D (\\\\lam (p0 : Ob {C {\\\\this}}) => if {D.Ob} p0 y x) {\\n  | Func => map {D} {x} {y} f g\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func Shape \\\\hlevels  : Precat Bool {\\n  | Hom => Arrows\\n  | id => id\\n  | o => o\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| Y : Ob {D}', '| func (E {Dom}) : E {Cod}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| f : Hom {D} X Y', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>func {E'.eql} (s (func {i.hinv} y)).1 = func {i.hinv} y", "completion": "(s (hinv {i} y)).2"}
{"prompt": "['CU : C s.1', 'L : Locale', 's : \\\\Sigma (s : Set (CompleteFilter L)) ((s = bottom) || C s)', 'C : Set (Set E)']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)']<<<break>>>(\\lam (s : \\Sigma (s : Set (CompleteFilter L)) (C s)) => points_* {L} s.1) (s.1, CU) L.<= Join {L} {\\Sigma (s : Set (CompleteFilter L)) (C s)}\n  (\\lam (s : \\Sigma (s : Set (CompleteFilter L)) (C s)) => points_* {L} s.1)", "completion": "Join-cond $ later (s.1, CU)"}
{"prompt": "['x : E {\\\\this}', 'y : E {\\\\this}', 'G : CGroup']<<<break>>>['| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', '| E : \\\\Set']<<<break>>>x G.* y = y G.* x", "completion": "*-comm {G}"}
{"prompt": "['l : GroupTerm V', 'q : 0 = count-leaves l', 'this : NatData']<<<break>>>[\"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func count-leaves \\\\hlevels  {this1 : NatData} (_ : GroupTerm V) : Nat \\n  | {this}, l :* r => count-leaves l + count-leaves r\\n  | {this}, :inv (var x) => 1\\n  | {this}, :inv g => 0\\n  | {this}, var x => 1\\n  | {this}, t => 0', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func rp-count-leaves-lemma \\\\hlevels  {this2 : NatData} (t1 : GroupTerm V) (fstLeafToRemoveInd2 : Nat) :\\n  count-leaves (remove-pair t1 fstLeafToRemoveInd2).1 <= count-leaves t1 \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | greater q => \\\\case (remove-pair r (fstLeafToRemoveInd -' count-leaves l)).2 \\\\with {\\n      | true => <=_+ {count-leaves l} {count-leaves l} {0} {count-leaves r} (<=-refl {count-leaves l}) (zero<=_ {count-leaves r})\\n      | false => <=_+ {count-leaves l} {count-leaves l} {count-leaves (remove-pair r (fstLeafToRemoveInd -' count-leaves l)).1}\\n        {count-leaves r} (<=-refl {count-leaves l}) (rp-count-leaves-lemma r (fstLeafToRemoveInd -' count-leaves l))\\n    }\\n    | less q => \\\\case (remove-pair l fstLeafToRemoveInd).2 \\\\with {\\n      | true => <=_+ {0} {count-leaves l} {count-leaves r} {count-leaves r} (zero<=_ {count-leaves l}) (<=-refl {count-leaves r})\\n      | false => <=_+ {count-leaves (remove-pair l fstLeafToRemoveInd).1} {count-leaves l} {count-leaves r} {count-leaves r}\\n        (rp-count-leaves-lemma l fstLeafToRemoveInd) (<=-refl {count-leaves r})\\n    }\\n    | equals q => \\\\case (remove-pair l fstLeafToRemoveInd).2, (remove-pair r 0).2 \\\\with {\\n      | true, true => zero<=_ {count-leaves l + count-leaves r}\\n      | true, false => <=_+ {0} {count-leaves l} {count-leaves (remove-pair r 0).1} {count-leaves r} (zero<=_ {count-leaves l})\\n        (rp-count-leaves-lemma r 0)\\n      | false, true => <=_+ {count-leaves (remove-pair l fstLeafToRemoveInd).1} {count-leaves l} {0} {count-leaves r}\\n        (rp-count-leaves-lemma l fstLeafToRemoveInd) (zero<=_ {count-leaves r})\\n      | false, false =>\\n      <=_+ {count-leaves (remove-pair l fstLeafToRemoveInd).1} {count-leaves l} {count-leaves (remove-pair r 0).1} {count-leaves r}\\n        (rp-count-leaves-lemma l fstLeafToRemoveInd) (rp-count-leaves-lemma r 0)\\n    }\\n  }\\n  | {this}, var v, fstLeafToRemoveInd => zero<=_ {1}\\n  | {this}, :ide, fstLeafToRemoveInd => zero<=_ {0}\\n  | {this}, :inv t, fstLeafToRemoveInd => \\\\case t \\\\with {\\n    | var v => zero<=_ {1}\\n    | :ide => zero<=_ {0}\\n    | :inv g => zero<=_ {0}\\n    | t :* s => zero<=_ {0}\\n  }\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infix 4 <= E E : \\\\Prop', \"\\\\func remove-pair \\\\hlevels  {this5 : NatData} (_ : GroupTerm V) (_ : Nat) : \\\\Sigma (GroupTerm V) Bool \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | less _x => \\n      \\\\let res-l => remove-pair l fstLeafToRemoveInd\\n      \\\\in \\\\case res-l.2 \\\\with {\\n            | true => (r, false)\\n            | false => (res-l.1 :* r, false)\\n          }\\n    | equals p => \\n      \\\\let | res-l => remove-pair l fstLeafToRemoveInd\\n           | res-r => remove-pair r 0\\n      \\\\in \\\\case res-l.2, res-r.2 \\\\with {\\n            | true, true => (:ide {Nat}, true)\\n            | true, false => res-r\\n            | false, true => res-l\\n            | false, false => (res-l.1 :* res-r.1, false)\\n          }\\n    | greater _x => \\n      \\\\let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l)\\n      \\\\in \\\\case res-r.2 \\\\with {\\n            | true => (l, false)\\n            | false => (l :* res-r.1, false)\\n          }\\n  }\\n  | {this}, :inv (var x), fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :inv g, fstLeafToRemoveInd => (:inv {V} g, false)\\n  | {this}, var x, fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :ide, fstLeafToRemoveInd => (:ide {Nat}, false)\"]<<<break>>>count-leaves (remove-pair l 0).1 <= 0", "completion": "rewrite (inv q) (rp-count-leaves-lemma {this} l 0)"}
{"prompt": "['fun : Q.E -> Bool', 'a : Interval Q', 'x<a1b : point {Q} x < (a.1, Big {Q.E} {Q.E} (Q.\u2227) a.2 (filter {Q.E} fun (map {Interval Q} {Q.E} (\\\\lam (p0 : Interval Q) => p0.2) l)))', 'l : Array (Interval Q)', 'Q : Dec', 'x : Q.E']<<<break>>>['\\\\func filter {A2 : \\\\Type} (_ : A2 -> Bool) (_ : Array A2) : Array A2 \\n  | {A}, p, nil => nil\\n  | {A}, p, :: {n} a l => if {Array A} (p a) (a :: filter {A} p l) (filter {A} p l)', '\\\\lemma Big_<=_meet0 \\\\hlevels  {this : MeetSemilattice} {l : Array E} {x : E} : Big {E} {E} (\u2227) x l <= x ', '\\\\type \\\\infix 4 < \\\\hlevels  {Q : BiorderedSet} (x y : Interval Q) : \\\\Prop => \\\\Sigma (y.1 Q.< x.1) (x.2 Q.< y.2)', '\\\\type Interval \\\\hlevels  (Q : Poset) : \\\\Set => \\\\Sigma Q.E Q.E', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '| E : \\\\Set', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\func point \\\\hlevels  {Q : Poset} (x : Q.E) : Interval Q => (x, x)', '| \\\\infix 4 < E E : \\\\Prop', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>point {Q} x < a", "completion": "(x<a1b.1, x<a1b.2 <\u2218l Big_<=_meet0)"}
{"prompt": "['b : Rat', 'x : ExUpperReal', 'x<=b : x <= fromRat b']<<<break>>>['true', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| U Rat : \\\\Prop', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>x.U (b + ide)", "completion": "x<=b linarith"}
{"prompt": "['s : \\\\Sigma (i j : Nat) (i < j) (pow a i = pow a j)']<<<break>>>['suc Nat', \"\\\\lemma <=_exists \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n <= m) : n + (m -' n) = m \", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '\\\\lemma suc_<_<= \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < m) : suc n <= m ']<<<break>>>suc s.1 + (s.2 -' suc s.1) = s.2", "completion": "<=_exists (suc_<_<= s.3)"}
{"prompt": "['a : E {A {\\\\this}}', 'U : Set X', 'X : \\\\Set', 'F : SetFilter (Total {X} U)', 'p : a <= b', 'b : E {A {\\\\this}}']<<<break>>>['| X : \\\\Set', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Total {X : \\\\Type} (U : Set X) : \\\\Type => \\\\Sigma (x : X) (\\\\property (U x))']<<<break>>>(\\lam (s : Total {X1} U) => a s.1) \u2286 (\\lam (s : Total {X1} U) => b s.1)", "completion": "\\lam c => p c"}
{"prompt": "['A : LModule R', 'R : Ring', 'r : E {R {\\\\this}}', 'B : LModule R', '_ : E {Dom {\\\\this}}']<<<break>>>['| zro : E', '\\\\lemma *c_zro-right \\\\hlevels  {this : LModule} {r : E {R}} : r *c zro = zro ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\instance ProductLModule \\\\hlevels  (R1 : Ring) (A B : LModule R1) : LModule R1 (\\\\Sigma A.E B.E) {\\n  | zro => (A.zro, B.zro)\\n  | + => \\\\lam (p : E) (q : E) => (p.1 A.+ q.1, p.2 B.+ q.2)\\n  | negative => \\\\lam (p : E) => (A.negative p.1, B.negative p.2)\\n  | *c => \\\\lam (r : E {R {\\\\this}}) (p : E {\\\\this}) => (r A.*c p.1, r B.*c p.2)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '\\\\lemma aux \\\\hlevels  {R : Ring} {A B : LModule R} {r : R.E} {a : A.E} {b : B.E} : r *c (a, b) = (r A.*c a, r B.*c b) ']<<<break>>>(r A.*c e, r B.*c B.zro) = r *c (e, r B.*c B.zro)", "completion": "rewrite (inv aux) (rewrite (*c_zro-right {B}) idp)"}
{"prompt": "['this : Iso {GroupCat} {toGroup G} {toGroup H} (toGroupHom {G} {H} f1) {\\n  | hinv => toGroupHom {H} {G} p.hinv\\n  | hinv_f => {?hidden}\\n  | f_hinv => {?hidden}\\n}', 'H : Ring', 'x : E {Dom {\\\\this}}', 'i : I', 'h1 : func {p.f \u2218 p.hinv} = func {id {p.C} p.cod}']<<<break>>>['| C : Precat', '| hinv : Hom {C} cod dom', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| f : Hom {C} dom cod', '| dom : Ob {C}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| cod : Ob {C}', '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| \\\\infixl 7 * E E : E', '| id (X : Ob) : Hom X X', '\\\\func toGroup \\\\hlevels  (G : AddGroup) : Group G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new Group {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | inverse-right => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set']<<<break>>>\\Pi {y : H.E} -> (@) h1 i (x * y) = (@) h1 i x * (@) h1 i y", "completion": "(@) (prop-dpi (\\lam i => ext_coe) (func-* {toGroupHom {G} {H} f \u2218 toGroupHom {H} {G} p.hinv}) (func-* {id (toGroup H)})) i\n  {x}"}
{"prompt": "['l : GroupTerm V', \"abs' : 0 = 1\", 'r : GroupTerm V', 'this : NatData']<<<break>>>['| zro : E', \"\\\\func get-leaf \\\\hlevels  {this3 : NatData} (_ : GroupTerm V) (_ : Nat) : GroupTerm V \\n  | {this}, l :* r, ind => \\\\case dec<_<= {NatSemiring} ind (suc (count-leaves l)) \\\\with {\\n    | inl _x => get-leaf l ind\\n    | o => get-leaf r (ind -' count-leaves l)\\n  }\\n  | {this}, :inv (var x), ind => \\\\case ind \\\\with {\\n    | suc 0 => :inv {V} (var {V} x)\\n    | n => :ide {Nat}\\n  }\\n  | {this}, :inv g, ind => :ide {Nat}\\n  | {this}, var x, ind => \\\\case ind \\\\with {\\n    | suc 0 => var {V} x\\n    | n => :ide {Nat}\\n  }\\n  | {this}, :ide, ind => :ide {Nat}\", '| V : \\\\Set', '| G : Group', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\infixl 6 :* (_ _ : GroupTerm V)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| E : \\\\Set', \"\\\\func remove-pair \\\\hlevels  {this5 : NatData} (_ : GroupTerm V) (_ : Nat) : \\\\Sigma (GroupTerm V) Bool \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | less _x => \\n      \\\\let res-l => remove-pair l fstLeafToRemoveInd\\n      \\\\in \\\\case res-l.2 \\\\with {\\n            | true => (r, false)\\n            | false => (res-l.1 :* r, false)\\n          }\\n    | equals p => \\n      \\\\let | res-l => remove-pair l fstLeafToRemoveInd\\n           | res-r => remove-pair r 0\\n      \\\\in \\\\case res-l.2, res-r.2 \\\\with {\\n            | true, true => (:ide {Nat}, true)\\n            | true, false => res-r\\n            | false, true => res-l\\n            | false, false => (res-l.1 :* res-r.1, false)\\n          }\\n    | greater _x => \\n      \\\\let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l)\\n      \\\\in \\\\case res-r.2 \\\\with {\\n            | true => (l, false)\\n            | false => (l :* res-r.1, false)\\n          }\\n  }\\n  | {this}, :inv (var x), fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :inv g, fstLeafToRemoveInd => (:inv {V} g, false)\\n  | {this}, var x, fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :ide, fstLeafToRemoveInd => (:ide {Nat}, false)\", '\\\\func interpret \\\\hlevels  {this4 : GroupData} (_ : GroupTerm V) : E {G} \\n  | {this}, var x => f x\\n  | {this}, :ide => ide {G}\\n  | {this}, :inv t => inverse {G} (interpret t)\\n  | {this}, t :* s => interpret t * interpret s']<<<break>>>\\Sigma (interpret (l :* r) = interpret (get-leaf (l :* r) 1)) (interpret (remove-pair (l :* r) 0).1 = ide {G})", "completion": "\\case abs' \\with {}"}
{"prompt": "['null : SType {R} {?error}', 'R : CRing']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class CGroupData \\\\extends NatData \\\\hlevels ', '\\\\lemma negative_zro \\\\hlevels  {this : AddGroup} : negative zro = zro ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '\\\\lemma simplify-correct \\\\hlevels  {this : CGroupData} (t : GroupTerm V) : interpret t = interpret (simplify t) ', '| zro-right {x : E} : x + zro = x', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| zro : E', '| \\\\infixl 7 * E E : E', '| V : \\\\Set', 'var V', '\\\\infixl 6 :* (_ _ : GroupTerm V)', ':inv (GroupTerm V)', '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma negative_*-left \\\\hlevels  {this : PseudoRing} {x y : E} : negative x * y = negative (x * y) ', '| E : \\\\Set', '| negative E : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| ide-right {x : E} : x * ide = x']<<<break>>>(R.negative s.1 R.* s.2 R.+ s.1 R.* s.2) R.* R.ide = R.zro", "completion": "transport (\\lam x0 => substitution_meta)\n  (inv ((((path ((@) (R.ide-right {R.negative s.1 R.* s.2 R.+ s.1 R.* s.2})) *> path (\\lam (i : I) => negative_*-left {R} {s.1} {s.2} @ i R.+ s.1 R.* s.2)) *> (\n    \\let d => \\new CGroupData {toCGroup R} ((::) (R.negative s.1 R.* s.2) (s.1 R.* s.2 :: nil) a)\n    \\in simplify-correct {d} (:inv (var 1) :* var 1))) *> path ((@) (R.zro-right {R.negative R.zro}))) *> path ((@) (negative_zro {R}))))\n  idp"}
{"prompt": "[]<<<break>>>['\\\\class Locale \\\\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\\\hlevels  {\\n  | Join-ldistr>= {J : \\\\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\\\lam (j : J) => e \u2227 f j)\\n  | basicCover-stable => \\\\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\\\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\\n    meet-univ {x} {Join {J} (\\\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\\\lam (j : J) => (g j).1} {x}\\n  | ldistr>= => \\\\lam {x : E} {y : E} {z : E} => (\\n    \\\\have t => path (\\\\lam (i : I) (b : Bool) => (\\\\case b \\\\with {\\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\\n          }) @ i)\\n    \\\\in transportInv\\n        {Bool -> E} (\\\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\\n          {\\\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\\\lam (b : Bool) => x \u2227 if {E} b y z} t\\n          (Join-ldistr>= {Bool} {\\\\lam (p0 : Bool) => if {E} p0 y z} {x}))\\n  | Meet-cond => \\\\lam {J : \\\\Set} (j : J) {f : J -> E} =>\\n  Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n    {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)\\n  | join-left => \\\\lam {x : E} {y : E} => Join-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | join-right => \\\\lam {x : E} {y : E} => Join-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | Meet-univ => \\\\lam {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) =>\\n  Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n    {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  | join-univ => \\\\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\\n  Join-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n    | true => x<=z\\n    | false => y<=z\\n  }))\\n  | join => \\\\lam (x : E) (y : E) => Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)\\n  | Meet => \\\\lam {J : \\\\Set} (g : J -> E) =>\\n    Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)\\n  | isBasicCover => \\\\lam (x : Ob) {J : \\\\Set} (g : J -> Ob) => x <= Join {J} (\\\\lam (j : J) => (g j).1)\\n}', '\\\\class ContMap \\\\extends SetHom \\\\hlevels  {\\n  | func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))\\n}', '| Hom Ob Ob : \\\\Set', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\class FrameHom \\\\extends SetHom \\\\hlevels  {\\n  | func-<= {x y : E {Dom}} (x <= y) : func x <= func y\\n  | func-top : func (top {Dom}) = top {Cod}\\n  | func-top>= : top {Cod} <= func (top {Dom})\\n  | func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y\\n  | func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)\\n  | func-Join {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\\\lam (j : J) => func (f j))\\n  | func-Join>= {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\\\lam (j : J) => func (f j))\\n}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func Func {L M : Locale} (f : FrameHom M L) : ContMap (PointsSpace L) (PointsSpace M) {\\n  | func => filter-map {L} {M} f\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id (X : Ob) : Hom X X', '\\\\class Functor \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F (Ob {C}) : Ob {D}\\n  | Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)\\n  | Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)\\n  | Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f\\n}', '\\\\instance PointsSpace \\\\hlevels  (L : Locale) : TopSpace (CompleteFilter L) {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) => TruncP (\\\\Sigma (a : L.E) (\\\\Pi {x : CompleteFilter L} -> U x <-> x.F a))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}', '| Ob : \\\\hType', '| C : Precat', '\\\\instance TopCat : Cat TopSpace {\\n  | Hom => ContMap\\n  | id => ContMap.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}']<<<break>>>Functor LocaleCat TopCat PointsSpace {\n  | Func => PointsSpaceFunctor.Func\n  | Func-id => {?hidden}\n  | Func-o => {?hidden}\n}", "completion": "\\new Functor {\n  | C => LocaleCat\n  | D => TopCat\n  | F => PointsSpace\n  | Func => Func\n  | Func-id => idp\n  | Func-o => idp\n}"}
{"prompt": "['a : Rat', 'j : Nat']<<<break>>>['\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 < E E : \\\\Prop', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>ExUpperReal ((<) (pow {RatValuedRing} a j))", "completion": "pow a j"}
{"prompt": "['Y : E', 'X : Ob {C {\\\\this}}', 'this : HeytingAlebra']<<<break>>>['| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma exponent-adj-unit \\\\hlevels  {this : HeytingAlebra} {x y : E} : x <= y --> x \u2227 y ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| implies \\\\alias \\\\infixr 5 --> E E : E']<<<break>>>X <= Y --> X \u2227 Y", "completion": "exponent-adj-unit {this}"}
{"prompt": "['n : Nat', 'this : AbMonoid', 'x : Fin n -> E']<<<break>>>['\\\\lemma FinSum_char2 {this : AbMonoid} {A : FinSet} {x : A.E -> E} (e : Equiv {Fin A.finCard} {A.E}) :\\n  FinSum {A} x = BigSum (\\\\new Array E A.finCard (\\\\lam (j : Fin A.finCard) => x (e.f j))) ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '| f A : B', '\\\\func idEquiv {A1 : \\\\Type} : QEquiv {A1} {A1} (\\\\lam (x : A {\\\\this}) => x) {\\n  | ret => \\\\lam (x : B {\\\\this}) => x\\n  | ret_f => \\\\lam (a : A {\\\\this}) => idp {A1} {ret {\\\\this} a}\\n  | f_sec => \\\\lam (b : B {\\\\this}) => idp {A1} {sec {\\\\this} b}\\n} => \\\\new QEquiv', 'FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| finCard : Nat', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l']<<<break>>>FinSum {FinFin n} x = BigSum (\\new Array E finCard (\\lam (j : Fin finCard) => x (f {idEquiv {Fin finCard}} j)))", "completion": "FinSum_char2 {this} idEquiv"}
{"prompt": "['X : Ob {C {\\\\this}}', 'this : PrecoverMap (F {\\\\this} X) (F {\\\\this} Y) {\\n  | func => filter-map {X} {Y} f\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', 'V_DV : \\\\Sigma (s : Set (CompleteFilter Y)) (D s)', 'D : Set (Set (E {Cod {\\\\this}}))', 'f : Hom {C {\\\\this}} X Y', 'p0 : \\\\Sigma (s : Set (CompleteFilter Y)) (D s)', 'Y : Ob {C {\\\\this}}']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func points^* \\\\hlevels  {L : Locale} (a : L.E) : Set (CompleteFilter L) => \\\\lam (x : CompleteFilter L) => x.F a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma points^*-points_* \\\\hlevels  {L : Locale} {a : L.E} {U : Set (CompleteFilter L)} (_ : points^* {L} a \u2286 U) : a L.<= points_* {L} U ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>X.Join {\\Sigma (b : Y.E) (points^* {Y} b \u2286 p0.1)} (\\lam (j : \\Sigma (b : Y.E) (points^* {Y} b \u2286 p0.1)) => f.func j.1) X.<= X.Join {\\Sigma (s : Set (CompleteFilter X)) (TruncP (\\Sigma (V : Set (CompleteFilter Y)) (D V) (s = func {\\this} ^-1 V)))}\n  (\\lam (s : \\Sigma (s : Set (CompleteFilter X)) (TruncP (\\Sigma (V : Set (CompleteFilter Y)) (D V) (s = func {\\this} ^-1 V)))) =>\n    points_* {X} s.1)", "completion": "Join-univ (\\lam p0 => (\n  \\let (b, p) => p0\n  \\in points^*-points_* (\\lam c => later $ p $ later c) <=\u2218 Join-cond (later (_, inP (V, DV, idp)))))"}
{"prompt": "['B : A.S -> Local', 'A : Local', 'j : J', 'X : J -> \\\\Type']<<<break>>>['\\\\func fromEquiv (e : Equiv) : QEquiv {e.A} {e.B} e.f {\\n  | ret => e.ret\\n  | ret_f => e.ret_f\\n  | f_sec => f_ret {e}\\n} => \\\\new QEquiv', '| A : \\\\Type', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', \"\\\\func sigma-left {A1 A' : \\\\Type} {B' : A' -> \\\\Type} (e : HAEquiv {A1} {A'}) :\\nQEquiv {\\\\Sigma (a : A1) (B' (e.f a))} {\\\\Sigma (a' : A') (B' a')} (\\\\lam (p : A {\\\\this}) => (e.f p.1, p.2)) {\\n  | ret => \\\\lam (p : B {\\\\this}) =>\\n    (e.ret p.1, transport {A'} B' {p.1} {e.f (e.sec p.1)} (inv {A'} {e.f (e.sec p.1)} {p.1} (e.f_sec p.1)) p.2)\\n  | ret_f => \\\\lam (p : A {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => (e.ret_f p.1,\\n            path (\\\\lam (i : I) => coe (\\\\lam (j : I) => B' (e.f_ret_f=f_sec_f p.1 @ i @ j)) (ret {\\\\this} (e.f p.1, p.2)).2 right) *> transport_id_inv {A'} B' {e.f (e.sec (e.f p.1))} {e.f p.1} (e.f_sec (e.f p.1)) p.2)\\n      \\\\in \\n            \\\\let h1 => arg.1\\n            \\\\in (h1 @ i, pathOver {\\\\lam (i : I) => B' (e.f (h1 @ i))} {(ret {\\\\this} (e.f p.1, p.2)).2} {p.2} arg.2 @ i)))\\n  | f_sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => (e.f_sec p.1, transport_id_inv {A'} B' {e.f (e.sec p.1)} {p.1} (e.f_sec p.1) p.2)\\n    \\\\in \\n          \\\\let h1 => arg.1\\n          \\\\in (h1 @ i, pathOver {\\\\lam (i : I) => B' (h1 @ i)} {(sec {\\\\this} p).2} {p.2} arg.2 @ i)))\\n} => \\\\new QEquiv\", \"\\\\func pathOver {A : I -> \\\\Type} {a : A left} {a' : A right} (p : coe A a right = a') : Path A a a' \\n  => concat {A} {a} {coe A a right} {a'} (idpOver A a) p\", '| local : isLocal {U} S', '| f_sec (y : B) : f (sec y) = y', '| S : \\\\hType', '\\\\func coe (A : I -> \\\\Type) (a : A left) (i : I) : A i ', 'right', '| f_ret_f=f_sec_f (x : A) : pmap {A} {B} f {ret (f x)} {x} (ret_f x) = f_sec (f x)', '\\\\func transport_id_inv {A1 : \\\\Type} (B1 : A1 -> \\\\Type) {a1 b : A1} (p : a1 = b) (x1 : B1 b) :\\n  transport {A1} B1 {a1} {b} p (transport {A1} B1 {b} {a1} (inv {A1} {a1} {b} p) x1) = x1 \\n  | {A}, B, {a}, {b}, idp, x =>\\n    idp {B a} {transport {A} B {a} {a} (idp {A} {a}) (transport {A} B {a} {a} (inv {A} {a} {a} (idp {A} {a})) x)}', '| ret_f (x : A) : ret (f x) = x', '| ret B : A', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func fromQEquiv (e : QEquiv) : HAEquiv {e.A} {e.B} e.f {\\n  | ret => e.ret\\n  | ret_f => e.ret_f\\n  | f_sec => coh_f_sec e e.f_sec\\n  | f_ret_f=f_sec_f => coh_f_ret_f=f_sec_f e e.f_sec\\n} => \\\\new HAEquiv', '| sec B : A', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| B : \\\\Type', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>QEquiv {\\Sigma (a : \\Sigma -> A.S)\n  ((\\lam (a' : X j -> A.S) => \\Pi (x : X j) -> S {B1 (a' x)}) (f {fromQEquiv (fromEquiv (A.local j))} a))}\n  {\\Sigma (a' : X j -> A.S) ((\\lam (a' : X j -> A.S) => \\Pi (x : X j) -> S {B1 (a' x)}) a')}\n  (\\lam (p : A {\\this}) => (f {fromQEquiv (fromEquiv (A.local j))} p.1, p.2)) {\n  | ret => \\lam (p : B {\\this}) => (ret {fromQEquiv (fromEquiv (A.local j))} p.1,\n    transport {X j -> A.S} (\\lam (a' : X j -> A.S) => \\Pi (x : X j) -> S {B1 (a' x)}) {p.1}\n      {f {fromQEquiv (fromEquiv (A.local j))} (sec {fromQEquiv (fromEquiv (A.local j))} p.1)}\n      (inv {X j -> A.S} {f {fromQEquiv (fromEquiv (A.local j))} (sec {fromQEquiv (fromEquiv (A.local j))} p.1)} {p.1}\n        (f_sec {fromQEquiv (fromEquiv (A.local j))} p.1)) p.2)\n  | ret_f => \\lam (p : A {\\this}) => path (\\lam (i : I) => (\n    \\have arg => (ret_f {fromQEquiv (fromEquiv (A.local j))} p.1,\n            path (\\lam (i : I) => coe (\\lam (j1 : I) => (\\lam (a' : X j -> A.S) => \\Pi (x : X j) -> S {B1 (a' x)})\n              (f_ret_f=f_sec_f {fromQEquiv (fromEquiv (A.local j))} p.1 @ i @ j1))\n              (ret {\\this} (f {fromQEquiv (fromEquiv (A.local j))} p.1, p.2)).2 right) *> transport_id_inv\n            {X j -> A.S} (\\lam (a' : X j -> A.S) => \\Pi (x : X j) -> S {B1 (a' x)}) {f {fromQEquiv (fromEquiv (A.local j))}\n              (sec {fromQEquiv (fromEquiv (A.local j))} (f {fromQEquiv (fromEquiv (A.local j))} p.1))}\n              {f {fromQEquiv (fromEquiv (A.local j))} p.1}\n              (f_sec {fromQEquiv (fromEquiv (A.local j))} (f {fromQEquiv (fromEquiv (A.local j))} p.1)) p.2)\n      \\in \n            \\let h1 => arg.1\n            \\in (h1 @ i,\n                  pathOver {\\lam (i : I) => (\\lam (a' : X j -> A.S) => \\Pi (x : X j) -> S {B1 (a' x)}) (f {fromQEquiv (fromEquiv (A.local j))} (h1 @ i))}\n                    {(ret {\\this} (f {fromQEquiv (fromEquiv (A.local j))} p.1, p.2)).2} {p.2} arg.2 @ i)))\n  | f_sec => \\lam (p : B {\\this}) => path (\\lam (i : I) => (\n    \\have arg => (f_sec {fromQEquiv (fromEquiv (A.local j))} p.1,\n            transport_id_inv {X j -> A.S} (\\lam (a' : X j -> A.S) => \\Pi (x : X j) -> S {B1 (a' x)})\n              {f {fromQEquiv (fromEquiv (A.local j))} (sec {fromQEquiv (fromEquiv (A.local j))} p.1)} {p.1}\n              (f_sec {fromQEquiv (fromEquiv (A.local j))} p.1) p.2)\n      \\in \n            \\let h1 => arg.1\n            \\in (h1 @ i,\n                  pathOver {\\lam (i : I) => (\\lam (a' : X j -> A.S) => \\Pi (x : X j) -> S {B1 (a' x)}) (h1 @ i)} {(sec {\\this} p).2} {p.2} arg.2 @ i)))\n}", "completion": "sigma-left (local {A} j)"}
{"prompt": "['e : Sym (suc n)', 'n : Nat', 'lem : \\\\Pi (a : Fin (f {e} 0)) -> f {e} (ret {e} (a mod suc n)) = a', 'a : Fin (f {e} 0)']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| <-irreflexive {x : E} : Not (x < x)', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| ret B : A', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 8 mod \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n mod m', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma nat_fin_= \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : x = y) : x = y ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>ret {e} (a mod suc n) = 0 -> Empty", "completion": "\\lam p => <-irreflexive $ rewrite (inv (lem a) *> pmap e (nat_fin_= p)) in fin_< a"}
{"prompt": "['this : FromJoin', 'x : E', 'y : E']<<<break>>>['| \\\\infix 4 <= E E : \\\\Prop', '| negative E : E', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| join-left {x y : E} : x <= x \u2228 y']<<<break>>>negative x <= negative x \u2228 negative y", "completion": "join-left {this}"}
{"prompt": "['h1 : x.nucleus = y.nucleus', 'L : Locale', 'x : E {\\\\this}', 'y : E {\\\\this}']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set']<<<break>>>Path (\\lam (i : I) => \\Pi {x y : L.E} -> x L.<= y -> (@) h1 i x L.<= (@) h1 i y) x.nucleus-<= y.nucleus-<=", "completion": "prop-dpi (\\lam i => ext_coe) (nucleus-<= {x}) (nucleus-<= {y})"}
{"prompt": "['bB : \\\\Pi (n : Nat) -> U {b n} B', 'j : Nat', 'b : Series ExUpperReal', 'B : Rat']<<<break>>>['\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '| join-left {x y : E} : x <= x \u2228 y', 'pos Nat', '\\\\lemma U_<= \\\\plevels  \\\\hlevels  {this : ExUpperReal} {q r : Rat} (_ : U q) (_ : q <= r) : U r ', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| U Rat : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}']<<<break>>>U {b j} (B \u2228 rat (pos 1) 1 {?hidden} {?hidden})", "completion": "U_<= (bB j) join-left"}
{"prompt": "['h1 : (\\\\lam (e : A.E) => B.zro B.+ x.func e) = x.func', 'A : LinRepres R G', 'B : LinRepres R G', 'this : LModule R (InterwiningMap {G} {R} A B) {\\n  | zro => zeroInterwining {R} {G} {A} {B}\\n  | + => addInterwining {R} {G} {A} {B}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => negativeInterwining {R} {G} {A} {B}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c => mulconstInterwining {R} {G} {A} {B}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', 'i : I', 'this : InterwiningMap {G} {R1} A B {\\n  | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n  | func-** => {?hidden}\\n}', 'x : E {\\\\this}']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| Dom : BaseSet']<<<break>>>\\Pi {x : E {Dom {\\this}}} -> \\Pi {y : A.E} -> (@) h1 i (x A.+ y) = (@) h1 i x B.+ (@) h1 i y", "completion": "\\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (func-+ {addInterwining {R} {G} {A} {B} (zeroInterwining {R} {G} {A} {B}) x}) (func-+ {x}))\n  i {x}"}
{"prompt": "['x : X.E', 'X : PseudoMetricSpace', 'delta : Real', \"delta' : Rat\", 'Y : PseudoMetricSpace', \"h : \\\\Pi {x' : X.E} -> X.dist x x' < delta -> Y.dist (f x) (f x') < fromRat eps\", 'f : X.E -> Y.E', \"delta'<delta : delta.L delta'\", 'eps : Rat']<<<break>>>['\\\\lemma real_<_U \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : x < fromRat a <-> x.U a ', '| U Rat : \\\\Prop', '| dist E E : ExUpperReal', '| E : \\\\Set', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| <-transitive \\\\alias \\\\infixr 9 <\u2218 {x y z : E} (x < y) (y < z) : x < z', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\lemma real_<_L \\\\plevels  \\\\hlevels  {a : Rat} {x : Real} : fromRat a < x <-> x.L a ']<<<break>>>\\Pi {x' : X.E} -> U {X.dist x x'} delta' -> U {Y.dist (f x) (f x')} eps", "completion": "\\lam xx'<delta => real_<_U.1 $ h $ real_<_U.2 xx'<delta <\u2218 real_<_L.2 delta'<delta"}
{"prompt": "['X : Ob {\\\\this}', 'g : Hom {\\\\this} Y Z', 'Y : Ob {\\\\this}', 'f : Hom {\\\\this} X Y', 'Z : Ob {\\\\this}', 'T : Theory']<<<break>>>['\\\\class ModelHom {\\n  | T : Theory\\n  | Dom : Model ModelHom.T\\n  | Cod : Model ModelHom.T\\n  | funcs {s : Sort {ModelHom.T}} (E {Dom} s) : E {Cod} s\\n  | func-op {r : Sort {ModelHom.T}} (h : Symb {ModelHom.T} r) (d : DArray {len {domain {ModelHom.T} {r} h}}\\n    (\\\\lam (j : Fin (len {domain {ModelHom.T} {r} h})) => E {Dom} (at {domain {ModelHom.T} {r} h} j))) : funcs {r} (operation {Dom} {r} h d) = operation {Cod} {r} h (\\\\new DArray {len {domain {Structure.T {Cod}} {r} h}}\\n    (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => E {Cod} (at {domain {Structure.T {Cod}} {r} h} j))\\n    (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => funcs {at {domain {ModelHom.T} {r} h} j} (d.at j)))\\n  | func-rel (P : PredSymb {ModelHom.T}) (d : DArray {len {predDomain {ModelHom.T} P}}\\n    (\\\\lam (j : Fin (len {predDomain {ModelHom.T} P})) => E {Dom} (at {predDomain {ModelHom.T} P} j))) (relation {Dom} P d) : relation {Cod} P (\\\\new DArray {len {predDomain {Structure.T {Cod}} P}}\\n    (\\\\lam (j : Fin (len {predDomain {Structure.T {Cod}} P})) => E {Cod} (at {predDomain {Structure.T {Cod}} P} j))\\n    (\\\\lam (j : Fin (len {predDomain {Structure.T {Cod}} P})) => funcs {at {predDomain {ModelHom.T} P} j} (d.at j)))\\n}', '| E (Sort {T}) : \\\\Set', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| func-rel (P : PredSymb {ModelHom.T}) (d : DArray {len {predDomain {ModelHom.T} P}}\\n  (\\\\lam (j : Fin (len {predDomain {ModelHom.T} P})) => E {Dom} (at {predDomain {ModelHom.T} P} j))) (relation {Dom} P d) : relation {Cod} P (\\\\new DArray {len {predDomain {Structure.T {Cod}} P}}\\n  (\\\\lam (j : Fin (len {predDomain {Structure.T {Cod}} P})) => E {Cod} (at {predDomain {Structure.T {Cod}} P} j))\\n  (\\\\lam (j : Fin (len {predDomain {Structure.T {Cod}} P})) => funcs {at {predDomain {ModelHom.T} P} j} (d.at j)))', '| predDomain PredSymb : Array Sort', '| Sort : \\\\Set', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| Dom : Model T', '| T : Theory', '| operation {r : Sort {T}} (h : Symb {T} r)\\n  (DArray {len {domain {T} {r} h}} (\\\\lam (j : Fin (len {domain {T} {r} h})) => E (at {domain {T} {r} h} j))) : E r', '| func-op {r : Sort {ModelHom.T}} (h : Symb {ModelHom.T} r) (d : DArray {len {domain {ModelHom.T} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {ModelHom.T} {r} h})) => E {Dom} (at {domain {ModelHom.T} {r} h} j))) : funcs {r} (operation {Dom} {r} h d) = operation {Cod} {r} h (\\\\new DArray {len {domain {Structure.T {Cod}} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => E {Cod} (at {domain {Structure.T {Cod}} {r} h} j))\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => funcs {at {domain {ModelHom.T} {r} h} j} (d.at j)))', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| domain {s : Sort} (Symb s) : Array Sort', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| Cod : Model T', '| funcs {s : Sort {T}} (E {Dom} s) : E {Cod} s', '| Symb Sort : \\\\Set', '| PredSymb : \\\\Set', '| T : Signature', '| relation (P : PredSymb {T})\\n  (DArray {len {predDomain {T} P}} (\\\\lam (j : Fin (len {predDomain {T} P})) => E (at {predDomain {T} P} j))) : \\\\Prop']<<<break>>>ModelHom {T} X Z {\n  | funcs => \\lam {s : Sort {ModelHom.T {\\this}}} (x : E {Dom {\\this}} s) => g.funcs {s} (f.funcs {s} x)\n  | func-op => {?hidden}\n  | func-rel => {?hidden}\n}", "completion": "\\new ModelHom {\n  | funcs => \\lam x => g (f x)\n  | func-op => \\lam h d => rewrite (func-op {f} h d) (func-op {g} h _)\n  | func-rel => \\lam P d x => func-rel P (\\lam j => f (d j)) (func-rel P d x)\n}"}
{"prompt": "['this : Cat FrameUPres {\\n  | Hom => FrameUPresHom\\n  | id => \\\\lam (X : Ob {\\\\this}) => \\\\new FrameUPresHom X X {\\n    | func => \\\\lam (x : X.E) => x\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new FrameUPresHom X Z {\\n    | func => \\\\lam (x : X.E) => g.func (f.func x)\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-unit => {?hidden}\\n  }\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}']<<<break>>>['| Hom Ob Ob : \\\\Set', '| func-basicCover {J : \\\\Set} {x : E {Dom}} {f : J -> E {Dom}} (BasicCover {Dom} {J} x f) : BasicCover {Cod} {J} (func x) (\\\\lam (j : J) => func (f j))', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| Cod : BaseSet', '| func-unit : func (unit {Dom}) = unit {Cod}', '| unit : E', '\\\\class FrameUPresHom \\\\extends FramePresHom \\\\hlevels  {\\n  | func-unit : func (unit {Dom}) = unit {Cod}\\n  | func-image => \\\\lam {y : E {Cod}} =>\\n    cover-trans {Cod} {y} {E {Dom}} {func} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => unit {Cod}} (cover-basic {Cod} {y} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => unit {Cod}} (isUnit {Cod} {y})) (\\\\lam (_ : \\\\Sigma) => cover-inj {Cod} {unit {Cod}} {E {Dom}} {func} (unit {Dom}) func-unit)\\n}', '| Ob : \\\\hType', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| func-conj {x y : E {Dom}} : func (conj {Dom} x y) = conj {Cod} (func x) (func y)', '\\\\instance FramePresCat : Cat FramePres {\\n  | Hom => FramePresHom\\n  | id => \\\\lam (X : Ob {\\\\this}) => \\\\new FramePresHom X X {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-image => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new FramePresHom X Z {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n    | func-conj => {?hidden}\\n    | func-basicCover => {?hidden}\\n    | func-image => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| Dom : BaseSet', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>\\Pi {X Y Z : Ob {\\this}} -> \\Pi (g : Hom {\\this} Y Z) -> \\Pi (f : Hom {\\this} X Y) -> FrameUPresHom X Z {\n  | func => \\lam (x : X.E) => g.func (f.func x)\n  | func-conj => {?hidden}\n  | func-basicCover => {?hidden}\n  | func-unit => {?hidden}\n}", "completion": "\\lam g f => \\new FrameUPresHom {\n  | FramePresHom => g \u2218 {FramePresCat} f\n  | func-unit => pmap g func-unit *> func-unit\n}"}
{"prompt": "[\"j' : Ob {J {\\\\this}}\", 'this : Limit {J1} G1 (limit-obj {J1} G1) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => \\\\new FrameHom (apex {\\\\this}) (F {G {\\\\this}} j) {\\n    | func => \\\\lam (P : E {Dom {\\\\this}}) => P.1 j\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n  }\\n  | coneCoh => {?hidden}\\n  | isLimit => {?hidden}\\n  | limMap => limMap-impl\\n  | limBeta => {?hidden}\\n  | limUnique => {?hidden}\\n}', \"h1 : (\\\\lam (e : \\\\Sigma (P : \\\\Pi (j : J.Ob) -> E {G.F j}) (\\\\Pi {j j' : J.Ob} -> \\\\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) =>\\n  func {G.Func {j} {j'} h} (e.1 j)) = (\\\\lam (e : \\\\Sigma (P : \\\\Pi (j : J.Ob) -> E {G.F j}) (\\\\Pi {j j' : J.Ob} -> \\\\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) => e.1 j')\", 'j : Ob {J {\\\\this}}', \"h : Hom {J {\\\\this}} j j'\"]<<<break>>>['| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| G : Functor J D', '| E : \\\\Set', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| D : Precat']<<<break>>>Path (\\lam (i : I) => \\Pi {x y : E {apex {\\this}}} -> (@) h1 i (x \u2227 y) = (@) h1 i x \u2227 (@) h1 i y)\n  (func-meet {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-meet {coneMap {\\this} j'})", "completion": "prop-dpi (\\lam i => ext_coe)\n  (func-meet {o {limit-obj {J} G} {G.F j} {G.F j'} (G.Func {j} {j'} h) (\\new FrameHom (limit-obj {J} G) (G.F j) {\n    | func => \\lam (P : E) => P.1 j\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  })})\n  (func-meet {\\new FrameHom (limit-obj {J} G) (G.F j') {\n    | func => \\lam (P : E) => P.1 j'\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }})"}
{"prompt": "[\"l' : PFunc {V} {B}\", 'v : V.E', 'V : PosetQModule', 'B : BooleanRing']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', \"\\\\type SFRefines \\\\hlevels  {V : PosetQModule} {B : BooleanRing} (l l' : PFunc {V} {B}) : \\\\Prop => \\\\Sigma (\\\\Pi (j : Fin l'.len) ->\\n  ((l' !! j).1 = V.zro) || (l' !! j).2 B.<= BigJoin {B} (map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) l))\\n  (\\\\Pi (j : Fin l.len) -> TruncP (\\\\Sigma (j1 : Fin l'.len) ((l !! j).1 = (l' !! j1).1) ((l !! j).2 B.<= (l' !! j1).2)))\", 'inP A', '\\\\func PFunc \\\\hlevels  {V : PosetQModule} {B : BooleanRing} : \\\\Set => Array (\\\\Sigma V.E B.E)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma SFRefines-refl \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l : PFunc {V} {B}} : SFRefines {V} {B} l l ', '| bottom : E', '\\\\func IsReduced \\\\hlevels  {V : PosetQModule} {B : BooleanRing} (l : PFunc {V} {B}) : \\\\Prop \\n  => IsReducedB {B} (map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) l)', '\\\\lemma SFRefines_add_0 \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l : PFunc {V} {B}} {v : V.E} : SFRefines {V} {B} l (add {V} {B} v B.zro l) ', '| E : \\\\Set', '\\\\func reduce \\\\hlevels  {V2 : PosetQModule} {B2 : BooleanRing} (_ : PFunc {V2} {B2}) : PFunc {V2} {B2} \\n  | {V}, {B}, nil => nil\\n  | {V}, {B}, :: {n} x l => add {V} {B} x.1 x.2 (reduce {V} {B} l)', '\\\\lemma reduce_IsReduced \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l : PFunc {V} {B}} : IsReduced {V} {B} (reduce {V} {B} l) ']<<<break>>>TruncP (\\Sigma (m : PFunc {V} {B}) (IsReduced {V} {B} m) (SFRefines {V} {B} m (reduce {V} {B} ((v, B.bottom) :: l')))\n  (SFRefines {V} {B} m (reduce {V} {B} l')))", "completion": "inP (reduce {V} {B} l', reduce_IsReduced {V} {B}, SFRefines_add_0 {V} {B}, SFRefines-refl {V} {B})"}
{"prompt": "['a : E', 'l : Array E', 'p : \\\\Pi (j : Fin l.len) -> IsCoprime (l.at j) a', 'this : GCDMonoid', 'j : Fin l.len']<<<break>>>['| at (j : Fin len) : A j', '\\\\type IsCoprime \\\\hlevels  {M : CMonoid} (x y : M.E) : \\\\Prop => \\\\Pi (z : M.E) -> LDiv {M} z x -> LDiv {M} z y -> Inv {M} z']<<<break>>>IsCoprime (l.at j) a", "completion": "p j"}
{"prompt": "['A : DecSet', 'x : A.E', \"l' : Array A.E n\", \"e : EPerm {A.E} l l'\", 'a : A.E', 'l : Array A.E n']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func count \\\\hlevels  {A1 : DecSet} (_ : Array A.E) (_ : A.E) : Nat \\n  | {A}, nil, a => 0\\n  | {A}, :: {n} x l, a => \\\\case A.decideEq a x \\\\with {\\n    | yes p => suc (count {A} l a)\\n    | no n => count {A} l a\\n  }', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)', \"\\\\lemma EPerm_count \\\\hlevels  {A : DecSet} {l l' : Array A.E} (_ : EPerm {A.E} l l') (a : A.E) : count {A} l a = count {A} l' a \"]<<<break>>>(\\case A.decideEq a x \\with {\n  | yes p => suc (count {A} l a)\n  | no n => count {A} l a\n}) = (\\case A.decideEq a x \\with {\n| yes p => suc (count {A} l' a)\n| no n => count {A} l' a\n})", "completion": "\\case A.decideEq a x \\as d : case_return_arg_1_1 \\return (=) case_return_arg_1 case_return_arg_2 \\with {\n  | yes p => pmap suc (EPerm_count e a)\n  | no n => EPerm_count e a\n}"}
{"prompt": "['x : X.E', 'X : RealBanachAlgebra', 'y : X.E']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma norm_*q-ofPos \\\\hlevels  {this : RealBanachSpace} {q : Rat} (_ : zro <= q) {x : E} : norm (q *q x) = fromRat q * norm x ', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| norm E : ExUpperReal', 'pos Nat', '| zro : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\lemma rat_<=-dec \\\\plevels  \\\\hlevels  {r q : Rat} {so : So (rat_<=_Bool r q)} : r <= q ']<<<break>>>X.norm (ratio (pos 1) 2 *q (X.ide - x X.+ (X.ide - y))) = fromRat (ratio (pos 1) 2) * X.norm (X.ide - x X.+ (X.ide - y))", "completion": "norm_*q-ofPos {X} rat_<=-dec"}
{"prompt": "[]<<<break>>>['| zro : E', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', 'rfunc \\\\hlevels  (_ : Nat) : Rat \\n  | 0 => zro\\n  | suc n => ratio (pos 1) 2 * (ide + rfunc n * rfunc n)']<<<break>>>rfunc 0 = zro", "completion": "\\peval rfunc 0"}
{"prompt": "['this : PrecatWithBprod', \"x' : Ob\", 'x : Ob', 'y : Ob', \"y' : Ob\", \"f : Hom x x'\", \"g : Hom y y'\"]<<<break>>>[\"\\\\func prodMap \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y x' y' : Ob} (f : Hom x y) (f' : Hom x' y') : Hom (apex {Bprod x x'}) (apex {Bprod y y'}) \\n  => pair {y} {y'} {apex {Bprod x x'}} (f \u2218 proj1 {x} {x'}) (f' \u2218 proj2 {x} {x'})\", '| apex : Ob {D}', '\\\\func change \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom (apex {Bprod x y}) (apex {Bprod y x}) \\n  => pair {y} {x} {apex {Bprod x y}} (proj2 {x} {y}) (proj1 {x} {y})', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '| Hom Ob Ob : \\\\Set', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\func proj2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 1) => proj {Bprod x y} 1', '| Bprod (x y : Ob) : Product {Fin 2} (at {x :: y :: nil})']<<<break>>>proj2 {y'} {x'} \u2218 prodMap {y} {y'} {x} {x'} g f \u2218 change {x} {y} = proj2 {y'} {x'} \u2218 (prodMap {y} {y'} {x} {x'} g f \u2218 change {x} {y})", "completion": "o-assoc {this}"}
{"prompt": "['h1 : Path (\\\\lam (i : I) => \\\\Pi {S : Set (Set X)} -> (\\\\Pi {U : Set X} -> S U -> (@) h1 i U) -> (@) h1 i (Union {X} S)) S.open-Union\\n  T.open-Union', 'i : I', 'X : \\\\Set', 'h1 : S.isOpen = T.isOpen']<<<break>>>['\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func Union \\\\hlevels  {X : \\\\hType} (S : Set X -> \\\\hType) : Set X => \\\\lam (a : X) => TruncP (\\\\Sigma (U : Set X) (S U) (U a))']<<<break>>>\\Pi {S : Set (Set X)} -> (\\Pi {U : Set X} -> S U -> (@) h1 i U) -> (@) h1 i (Union {X} S)", "completion": "h1 @ i"}
{"prompt": "['x : E', 'this : AbsAbGroup', 'y : E', 'n : Nat']<<<break>>>['| \\\\infix 4 <= E E : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| join-left {x y : E} : x <= x \u2228 y', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a', '\\\\lemma *n_<= \\\\hlevels  {this : PosetAddMonoid} {n : Nat} {a b : E} (_ : a <= b) : n *n a <= n *n b ']<<<break>>>n *n x <= n *n (x \u2228 y)", "completion": "*n_<= {this} (join-left {this})"}
{"prompt": "['g : Hom {\\\\this} Y Z', 'f : Hom {\\\\this} X Y', 'Z : Ob {\\\\this}', 'h : Hom {\\\\this} Z W', 'W : Ob {\\\\this}', 'C : Precat', 'D : Precat', 'X : Ob {\\\\this}', 'Y : Ob {\\\\this}']<<<break>>>['| Hom Ob Ob : \\\\Set', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z']<<<break>>>(h.1 C.\u2218 g.1 C.\u2218 f.1, h.2 D.\u2218 g.2 D.\u2218 f.2) = (h.1 C.\u2218 (g.1 C.\u2218 f.1), h.2 D.\u2218 (g.2 D.\u2218 f.2))", "completion": "rewrite o-assoc (rewrite o-assoc idp)"}
{"prompt": "['A : BoundedExPseudoNormedAbGroup', 'B : BoundedExPseudoNormedAbGroup', 'gamma : Rat', \"y' : B.E\", 'x : A.E']<<<break>>>['\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma norm>=0 \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : zro <= X.norm x ', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| norm E : ExUpperReal', '\\\\lemma rdistr \\\\plevels  \\\\hlevels  {x y z : ExUpperReal} (_ : zro <= x) (_ : zro <= y) : (x + y) * z = x * z + y * z ']<<<break>>>(norm {A} x + norm {B} y') * fromRat (gamma \u2227 ide) = norm {A} x * fromRat (gamma \u2227 ide) + norm {B} y' * fromRat (gamma \u2227 ide)", "completion": "rdistr norm>=0 norm>=0"}
{"prompt": "['r : Rat', 'l : Real', 'lz<r : l \u2228 fromRat zro < fromRat r']<<<break>>>['| zro : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '| join-left {x y : E} : x <= x \u2228 y', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>l < fromRat r", "completion": "join-left <\u2218r lz<r"}
{"prompt": "['x : X.E', 'Z : StronglyCompleteCoverSpace', 'X : CoverSpace', 'g : CoverMap X Z', 'fd : IsWeaklyDenseEmbedding {f}', 'Y : StronglyRegularCoverSpace', 'f : CoverMap X Y']<<<break>>>['| isCauchy (Set (Set E)) : \\\\Prop', '| func-weak-cauchy (F1 : WeaklyCauchyFilter Dom) : WeaklyCauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isWeaklyProper => {?hidden}\\n}', '| Cod : BaseSet', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\type \\\\infix 4 CF~ \\\\hlevels  {S : CoverSpace} (F1 G : WeaklyCauchyFilter S) : \\\\Prop \\n  => \\\\Pi {C : Set (Set S.E)} -> S.isCauchy C -> TruncP (\\\\Sigma (U : Set S.E) (C U) (\\\\Sigma (F.F U) (G.F U)))', '\\\\lemma <=<_<= \\\\hlevels  {X : PrecoverSpace} {V U : Set X.E} (_ : V <=< U) : V <= U ', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| at (j : Fin len) : A j', '| isOpen (Set E) : \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| F (E {A}) : \\\\Prop', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '\\\\func weaklyDense-lift \\\\hlevels  {X : CoverSpace} {Y : StronglyRegularCoverSpace} {Z : StronglyCompleteCoverSpace} (f : CoverMap X Y)\\n  (fd : IsWeaklyDenseEmbedding {f}) (g : CoverMap X Z) : CoverMap Y Z {\\n  | func => \\\\lam (y : E {Dom {\\\\this}}) =>\\n    weak-filter-point {Z} (g.func-weak-cauchy (weaklyDense-filter-lift {X} {Y} f fd (pointSCF {Y} y)))\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '\\\\lemma weak-filter-point-sub \\\\hlevels  {this : StronglyCompleteCoverSpace} {F1 : WeaklyCauchyFilter this} : F {pointSCF (weak-filter-point F1)} \u2286 F.F ', '\\\\func pointSCF \\\\hlevels  {S1 : StronglyRegularCoverSpace} (x : S.E) : StronglyRegularCauchyFilter S1 ((<=<) (single {S.E} x)) \\n=> \\\\new StronglyRegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isWeaklyProper => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isStronglyRegularFilter => {?hidden}\\n}', '| func (E {Dom}) : E {Cod}', \"\\\\func weaklyDense-filter-lift \\\\hlevels  {X1 Y : CoverSpace} (f : CoverMap X1 Y) (fd : IsWeaklyDenseEmbedding {f}) (F1 : WeaklyCauchyFilter Y) :\\nWeaklyCauchyFilter\\n  X1 (\\\\lam (U : E {A {\\\\this}}) => TruncP (\\\\Sigma (V' V : Set Y.E) (f.func ^-1 V \u2286 U) (V' <=< V) (F.F V'))) \\n=> \\\\new WeaklyCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isWeaklyProper => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n}\", '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '| Dom : BaseSet']<<<break>>>at {(F {pointCF {Z} (func {weaklyDense-lift {X} {Y} {Z} f fd g} (f.func x))} \u2286 F {pointCF {Z} (g.func x)}) :: (pointCF {Z} (func {weaklyDense-lift {X} {Y} {Z} f fd g} (f.func x)) CF~ pointCF {Z} (g.func x)) :: (pointCF {Z} (func {weaklyDense-lift {X} {Y} {Z} f fd g} (f.func x)) = pointCF {Z} (g.func x)) :: (\\Pi {U : Set (E {Z})} ->\n  single {E {Z}} (func {weaklyDense-lift {X} {Y} {Z} f fd g} (f.func x)) <=< U <-> single {E {Z}} (g.func x) <=< U) :: (\\Pi {U : Set (E {Z})} -> single {E {Z}} (func {weaklyDense-lift {X} {Y} {Z} f fd g} (f.func x)) <=< U -> U (g.func x)) :: (\\Pi {U V : Set (E {Z})} -> single {E {Z}} (func {weaklyDense-lift {X} {Y} {Z} f fd g} (f.func x)) <=< U ->\n  single {E {Z}} (g.func x) <=< V -> TruncP (\\Sigma (e : E {Z}) ((\u2227) U V e))) :: (\\Pi {U V : Set (E {Z})} -> isOpen {Z} U -> isOpen {Z} V ->\n  U (func {weaklyDense-lift {X} {Y} {Z} f fd g} (f.func x)) -> V (g.func x) -> TruncP (\\Sigma (e : E {Z}) ((\u2227) U V e))) :: (\\Pi {C : Set (Set (E {Z}))} -> isCauchy {Z} C ->\n  TruncP (\\Sigma (U : Set (E {Z})) (C U) (\\Sigma (U (func {weaklyDense-lift {X} {Y} {Z} f fd g} (f.func x))) (U (g.func x))))) :: nil}\n  4", "completion": "later (\\lam p0 => (\\case weak-filter-point-sub p0 \\with {\n  | inP (V', V, p, V'<=<V, fx<=<V') => p $ <=<_<= V'<=<V $ <=<_<= fx<=<V' idp\n}))"}
{"prompt": "['this : LModule', 'j : E', 'q : \\\\Pi (a : E) ->\\n  at {nub {FinFin l.len} (map {\\\\Sigma (E {R}) (Fin l.len)} {Fin l.len} (\\\\lam (p0 : \\\\Sigma (E {R}) (Fin l.len)) => p0.2) c)} a /= j', 'l : Array E', 'c : Array (\\\\Sigma (E {R}) (Fin l.len))']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\lemma /=-sym {A : \\\\Type} {a a' : A} (_ : a /= a') : a' /= a \", '| R : Ring', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| zro : E', '\\\\func count \\\\hlevels  {R : Semiring} {J : DecSet} (l : Array (\\\\Sigma R.E J.E)) (j : J.E) : R.E \\n=> BigSum {R} (map {\\\\Sigma R.E J.E} {R.E} (\\\\lam (p0 : \\\\Sigma R.E J.E) => p0.1)\\n  (keep {\\\\Sigma R.E J.E} {\\\\lam (s : \\\\Sigma R.E J.E) => j = s.2} (\\\\lam (s : \\\\Sigma R.E J.E) => J.decideEq j s.2) l))', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '\\\\lemma count_zro \\\\hlevels  {R : Semiring} {J : DecSet} {l : Array (\\\\Sigma R.E J.E)} (j : J.E) (_ : \\\\Pi (k : Fin l.len) -> j /= (l.at k).2) :\\n  count {R} {J} l j = R.zro ', '| E : \\\\Set', '\\\\func nub \\\\hlevels  {A2 : DecSet} (_ : Array A.E) : Array A.E \\n  | {A}, nil => nil\\n  | {A}, :: {n} a l => a :: removeElem {A} a (nub {A} l)', '\\\\func nub-isSurj \\\\hlevels  {A2 : DecSet} (l2 : Array A.E) (i1 : Fin l.len) : \\\\Sigma (j : Fin (len {nub {A2} l2})) (at {nub {A2} l2} j = l.at i1) \\n  | {A}, :: {n} a l, zero => (0, idp {A.E} {at {nub {A} (a :: l)} 0})\\n  | {A}, :: {n} a l, suc i => \\\\case A.decideEq a (l.at i) \\\\with {\\n    | yes e => (0, e)\\n    | no q => \\n      \\\\have | t => nub-isSurj {A} l i\\n            | s => remove-isSurj\\n              {A} a (nub {A} l) t.1 (\\\\lam (p : at {nub {A} l} t.1 = a) => q (inv {A.E} {at {nub {A} l} t.1} {a} p *> t.2))\\n      \\\\in (suc s.1, s.2 *> t.2)\\n  }']<<<break>>>count {R} {FinFin l.len} c j = zro {R}", "completion": "count_zro j (\\lam k => /=-sym (\n  \\let (i, p) => nub-isSurj (map (\\lam p0 => p0.2) c) k\n  \\in later $ rewriteI p (q i)))"}
{"prompt": "['S1 : Dec A']<<<break>>>['| #-symmetric {x y : E} (x # y) : y # x', '| \\\\infix 4 # E E : \\\\Prop', '| E : \\\\Set']<<<break>>>\\Pi {x y : S1.E} -> x S1.# y -> y S1.# x", "completion": "#-symmetric {S1}"}
{"prompt": "['r : Rat', 'q<r : U {fromRat q} r', 'q : Rat', 'q>=0 : zro <= q']<<<break>>>['| <=_*_positive-right {x y z : E} (zro <= x) (y <= z) : x * y <= x * z', '| \\\\infixl 7 * E E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>q * q <= q * r", "completion": "<=_*_positive-right {RatField} q>=0 (<=-less q<r)"}
{"prompt": "[\"p : LDiv (a * b) (a * b')\", \"b' : E\", \"d' : LDiv a b'\", 'a : E', 'd : LDiv a b', 'this : ReducedCRing', 'b : E']<<<break>>>['| \\\\infixl 7 * E E : E', '| ide-left {x : E} : ide * x = x', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| ide : E', \"\\\\lemma div_pow_div-cancel \\\\hlevels  {this : ReducedCRing} {a b b' : E} {n n' : Nat} (_ : LDiv a (pow b n)) (_ : LDiv a (pow b' n'))\\n  (p : LDiv (a * b) (a * b')) : LDiv b b' p.inv \", '| E : \\\\Set', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '| inv : E {M}']<<<break>>>LDiv b b' p.inv", "completion": "div_pow_div-cancel {_} {a} {b} {b'} {1} {1} (rewrite (ide-left {this}) d) (rewrite (ide-left {this}) d') p"}
{"prompt": "['P : StrictPoset', 'this : StrictPosetHom P P {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n  | func-< => {?hidden}\\n}']<<<break>>>['| E : \\\\Set', '| Dom : BaseSet', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>\\Pi {x y : E {Dom {\\this}}} -> x < y -> x P.< y", "completion": "\\lam leq => leq"}
{"prompt": "['this : Locale', 'a : E', 'x : E {L {\\\\this}}']<<<break>>>['\\\\func \\\\infixr 5 --> \\\\hlevels  {this : Locale} (x y : E) : E => SJoin (\\\\lam (p0 : E) => p0 \u2227 x <= y)', '| <=-refl {x : E} : x <= x', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma meet-assoc \\\\hlevels  {this : MeetSemilattice} {x y z : E} : x \u2227 y \u2227 z = x \u2227 (y \u2227 z) ', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '\\\\lemma meet-idemp \\\\hlevels  {this : MeetSemilattice} {x : E} : x \u2227 x = x ', '\\\\lemma eval \\\\hlevels  {this : Locale} {x y : E} : (x --> y) \u2227 x <= y ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma exponent \\\\hlevels  {this : Locale} {x y z : E} : x \u2227 y <= z <-> x <= y --> z ']<<<break>>>a --> a --> x <= a --> x", "completion": "(exponent {this}).1\n(transport (\\lam p0 => _ \u2227 {this} p0 <= {this} _) (meet-idemp {this}) (transport (\\lam _x => _x <= {this} _) (meet-assoc {this})\n  (meet-monotone {this} (eval {this}) (<=-refl {this}) <=\u2218 {this} eval {this})))"}
{"prompt": "['I : DirectedSet', 'fc : IsFuncConvergent {I} {X} {Y} f', 'Y : CompleteCoverSpace', 'de : IsDenseEmbedding {prod {Dom {completion {\\\\new CoverSpace I.E {\\n  | isOpen => isOpen {ClosurePrecoverSpace {I.E}\\n    (\\\\lam (C : Set (Set I.E)) => TruncP (\\\\Sigma (j : \\\\Sigma (b : CoverSpace I.E) (b <= \\\\new precover {I} {})) (isCauchy {j.1} C)))\\n    (\\\\lam {C : Set (Set I.E)}\\n      (e : TruncP (\\\\Sigma (j : \\\\Sigma (b : CoverSpace I.E) (b <= \\\\new precover {I} {})) (isCauchy {j.1} C))) (x : I.E) =>\\n    (\\\\case e \\\\with {\\n      | inP (j, Cc) => cauchy-cover {j.1} {C} Cc x\\n    }))}\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | isCauchy => Closure {I.E}\\n    (\\\\lam (C : Set (Set I.E)) => TruncP (\\\\Sigma (j : \\\\Sigma (b : CoverSpace I.E) (b <= \\\\new precover {I} {})) (isCauchy {j.1} C)))\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n}}}}\\n  {Cod {completion {\\\\new CoverSpace I.E {\\n    | isOpen => isOpen {ClosurePrecoverSpace {I.E}\\n      (\\\\lam (C : Set (Set I.E)) => TruncP (\\\\Sigma (j : \\\\Sigma (b : CoverSpace I.E) (b <= \\\\new precover {I} {})) (isCauchy {j.1} C)))\\n      (\\\\lam {C : Set (Set I.E)}\\n        (e : TruncP (\\\\Sigma (j : \\\\Sigma (b : CoverSpace I.E) (b <= \\\\new precover {I} {})) (isCauchy {j.1} C))) (x : I.E) =>\\n      (\\\\case e \\\\with {\\n        | inP (j, Cc) => cauchy-cover {j.1} {C} Cc x\\n      }))}\\n    | open-top => {?hidden}\\n    | open-inter => {?hidden}\\n    | open-Union => {?hidden}\\n    | isCauchy => Closure {I.E}\\n      (\\\\lam (C : Set (Set I.E)) => TruncP (\\\\Sigma (j : \\\\Sigma (b : CoverSpace I.E) (b <= \\\\new precover {I} {})) (isCauchy {j.1} C)))\\n    | cauchy-cover => {?hidden}\\n    | cauchy-top => {?hidden}\\n    | cauchy-refine => {?hidden}\\n    | cauchy-glue => {?hidden}\\n    | cauchy-open => {?hidden}\\n    | isRegular => {?hidden}\\n  }}}} {Dom {id {X}}} {Cod {id {X}}} (completion {\\\\new CoverSpace I.E {\\n    | isOpen => isOpen {ClosurePrecoverSpace {I.E}\\n      (\\\\lam (C : Set (Set I.E)) => TruncP (\\\\Sigma (j : \\\\Sigma (b : CoverSpace I.E) (b <= \\\\new precover {I} {})) (isCauchy {j.1} C)))\\n      (\\\\lam {C : Set (Set I.E)}\\n        (e : TruncP (\\\\Sigma (j : \\\\Sigma (b : CoverSpace I.E) (b <= \\\\new precover {I} {})) (isCauchy {j.1} C))) (x : I.E) =>\\n      (\\\\case e \\\\with {\\n        | inP (j, Cc) => cauchy-cover {j.1} {C} Cc x\\n      }))}\\n    | open-top => {?hidden}\\n    | open-inter => {?hidden}\\n    | open-Union => {?hidden}\\n    | isCauchy => Closure {I.E}\\n      (\\\\lam (C : Set (Set I.E)) => TruncP (\\\\Sigma (j : \\\\Sigma (b : CoverSpace I.E) (b <= \\\\new precover {I} {})) (isCauchy {j.1} C)))\\n    | cauchy-cover => {?hidden}\\n    | cauchy-top => {?hidden}\\n    | cauchy-refine => {?hidden}\\n    | cauchy-glue => {?hidden}\\n    | cauchy-open => {?hidden}\\n    | isRegular => {?hidden}\\n  }}) (id {X})}', 'X : CoverSpace']<<<break>>>['| cauchy-top : isCauchy (single {E -> \\\\Prop} top)', 'cauchy-lift \\\\hlevels  {X Y : CoverSpace} {Z : CompleteCoverSpace} (f : CoverMap X Y) (\\\\property fd : IsDenseEmbedding {f}) (g : CauchyMap X Z)\\n  (y : Y.E) : Z.E => filter-point {Z} (g.func-cauchy (dense-filter-lift {X} {Y} f fd (pointCF {Y} y)))', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| isCauchy (Set (Set E)) : \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D', '\\\\func isOpen \\\\hlevels  {this : PrecoverSpace} (S : Set E) : \\\\Prop => \\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S)', '| open-top : isOpen top', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\class CoverSpace \\\\extends PrecoverSpace \\\\hlevels  {\\n  | isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))\\n}', '\\\\func Total {B : \\\\Type} (F : B -> \\\\Type) : \\\\Type => \\\\Sigma (b : B) (F b)', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))', '| E : \\\\Set', '\\\\class PrecoverSpace \\\\extends TopSpace \\\\hlevels  {\\n  | isCauchy (Set (Set E)) : \\\\Prop\\n  | cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))\\n  | cauchy-top : isCauchy (single {E -> \\\\Prop} top)\\n  | cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D\\n  | cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))\\n  | cauchy-open {S : Set E} : TopSpace.isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))\\n}', '\\\\func precover \\\\hlevels  {I : DirectedSet} : PrecoverSpace I.E {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n  \\\\Sigma (TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (N : I.E) (\\\\Pi {n : I.E} -> N I.<= n -> U n)))\\n    (\\\\Pi (n : I.E) -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (C V) (V n)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func dense-lift \\\\hlevels  {X Y : CoverSpace} {Z : CompleteCoverSpace} (f : CoverMap X Y) (fd : IsDenseEmbedding {f}) (g : CoverMap X Z) :\\nCoverMap Y Z {\\n  | func => cauchy-lift {X} {Y} {Z} f {?hidden} g\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)', '| cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))', '\\\\func completion \\\\hlevels  {S : CoverSpace} : CoverMap S (coverSpace {S}) {\\n  | func => pointCF {S}\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| cauchy-open {S : Set E} : isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))', '| Join {J : \\\\Set} (J -> E) : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func coverSpace \\\\hlevels  {X1 : CoverSpace} : CoverSpace (RegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => isCCauchy {X1}\\n} => \\\\new CoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n}', '\\\\instance PrecoverLattice \\\\hlevels  (X : \\\\Set) : CompleteLattice (PrecoverSpace X) {\\n  | <= => \\\\lam (A : E {\\\\this}) (B : E {\\\\this}) => \\\\Pi {C : Set (Set X)} -> A.isCauchy C -> B.isCauchy C\\n  | meet => meet-impl\\n  | join => join-impl\\n  | top => DiscreteCover X\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n  ClosurePrecoverSpace {X} (\\\\lam (C : Set (Set X)) => TruncP (\\\\Sigma (j : J) (isCauchy {f j} C)))\\n    (\\\\lam {C : Set (Set X)} (e : TruncP (\\\\Sigma (j : J) (isCauchy {f j} C))) (x : X) => (\\\\case e \\\\with {\\n      | inP (j, Cc) => cauchy-cover {f j} {C} Cc x\\n    }))\\n  | Meet => Meet-impl\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '\\\\func ClosurePrecoverSpace \\\\hlevels  {X : \\\\Set} (A : Set (Set X) -> \\\\Prop)\\n  (CA : \\\\Pi {C : Set (Set X)} -> A C -> \\\\Pi (x : X) -> TruncP (\\\\Sigma (U : Set X) (C U) (U x))) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => Closure {X} A\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', '\\\\lemma closure-regular \\\\hlevels  {X : PrecoverSpace} (RB : RatherBelow {SetLattice X.E}) {A : Set (Set X.E) -> \\\\Prop}\\n  (_ : \\\\Pi {C : Set (Set X.E)} -> A C -> Closure {X.E} A (\\\\lam (V : Set X.E) => TruncP (\\\\Sigma (U : Set X.E) (C U) (RB.R V U))))\\n  {C : Set (Set X.E)} (_ : Closure {X.E} A C) :\\n  Closure {X.E} A (\\\\lam (V : Set X.E) => TruncP (\\\\Sigma (U : Set X.E) (C U) (RB.R V U))) ', 'closure (A C)', '| isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))', '| open-Union {S : Set (Set E)} (\\\\Pi {U : Set E} -> S U -> isOpen U) : isOpen (Union {E} S)', '\\\\func id \\\\hlevels  {X : CoverSpace} : CoverMap X X {\\n  | func => \\\\lam (x : E {Dom {id {X}}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\func IsDenseEmbedding \\\\hlevels  {this : PrecoverMap} : \\\\Prop => \\\\Sigma IsDense IsEmbedding', \"\\\\func prod \\\\hlevels  {X Y X' Y' : CoverSpace} (f : CoverMap X Y) (g : CoverMap X' Y') : CoverMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} z, func {g \u2218 proj2 {X} {X'}} z)\\n} => tuple {Y} {Y'} {X \u2a2f X'} (f \u2218 proj1 {X} {X'}) (g \u2218 proj2 {X} {X'})\", '\\\\class CoverMap \\\\extends PrecoverMap, StronglyCauchyMap \\\\hlevels  {\\n  | func-weak-cauchy => \\\\lam (F1 : WeaklyCauchyFilter Dom) =>\\n  \\\\new WeaklyCauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n    | filter-mono => {?hidden}\\n    | filter-top => {?hidden}\\n    | filter-meet => {?hidden}\\n    | isWeaklyProper => {?hidden}\\n    | isCauchyFilter => {?hidden}\\n  }\\n}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\lemma cauchy-subset \\\\hlevels  {X : PrecoverSpace} {C D : Set (Set X.E)} (_ : X.isCauchy C) (_ : \\\\Pi {U : Set X.E} -> C U -> D U) : X.isCauchy D ', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}']<<<break>>>CoverMap (coverSpace {\\new CoverSpace I.E {\n  | isOpen => isOpen {ClosurePrecoverSpace {I.E}\n    (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n    (\\lam {C : Set (Set I.E)}\n      (e : TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C))) (x : I.E) =>\n    (\\case e \\with {\n      | inP (j, Cc) => cauchy-cover {j.1} {C} Cc x\n    }))}\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | isCauchy => Closure {I.E}\n    (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n  | cauchy-cover => {?hidden}\n  | cauchy-top => {?hidden}\n  | cauchy-refine => {?hidden}\n  | cauchy-glue => {?hidden}\n  | cauchy-open => {?hidden}\n  | isRegular => {?hidden}\n}} \u2a2f X) Y {\n  | func => cauchy-lift {\\new CoverSpace I.E {\n    | isOpen => isOpen {ClosurePrecoverSpace {I.E}\n      (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n      (\\lam {C : Set (Set I.E)}\n        (e : TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C))) (x : I.E) =>\n      (\\case e \\with {\n        | inP (j, Cc) => cauchy-cover {j.1} {C} Cc x\n      }))}\n    | open-top => {?hidden}\n    | open-inter => {?hidden}\n    | open-Union => {?hidden}\n    | isCauchy => Closure {I.E}\n      (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n    | cauchy-cover => {?hidden}\n    | cauchy-top => {?hidden}\n    | cauchy-refine => {?hidden}\n    | cauchy-glue => {?hidden}\n    | cauchy-open => {?hidden}\n    | isRegular => {?hidden}\n  } \u2a2f X}\n    {coverSpace {\\new CoverSpace I.E {\n      | isOpen => isOpen {ClosurePrecoverSpace {I.E}\n        (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n        (\\lam {C : Set (Set I.E)}\n          (e : TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C))) (x : I.E) =>\n        (\\case e \\with {\n          | inP (j, Cc) => cauchy-cover {j.1} {C} Cc x\n        }))}\n      | open-top => {?hidden}\n      | open-inter => {?hidden}\n      | open-Union => {?hidden}\n      | isCauchy => Closure {I.E}\n        (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n      | cauchy-cover => {?hidden}\n      | cauchy-top => {?hidden}\n      | cauchy-refine => {?hidden}\n      | cauchy-glue => {?hidden}\n      | cauchy-open => {?hidden}\n      | isRegular => {?hidden}\n    }} \u2a2f X} {Y} (prod {\\new CoverSpace I.E {\n      | isOpen => isOpen {ClosurePrecoverSpace {I.E}\n        (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n        (\\lam {C : Set (Set I.E)}\n          (e : TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C))) (x : I.E) =>\n        (\\case e \\with {\n          | inP (j, Cc) => cauchy-cover {j.1} {C} Cc x\n        }))}\n      | open-top => {?hidden}\n      | open-inter => {?hidden}\n      | open-Union => {?hidden}\n      | isCauchy => Closure {I.E}\n        (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n      | cauchy-cover => {?hidden}\n      | cauchy-top => {?hidden}\n      | cauchy-refine => {?hidden}\n      | cauchy-glue => {?hidden}\n      | cauchy-open => {?hidden}\n      | isRegular => {?hidden}\n    }}\n      {coverSpace {\\new CoverSpace I.E {\n        | isOpen => isOpen {ClosurePrecoverSpace {I.E}\n          (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n          (\\lam {C : Set (Set I.E)}\n            (e : TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C))) (x : I.E) =>\n          (\\case e \\with {\n            | inP (j, Cc) => cauchy-cover {j.1} {C} Cc x\n          }))}\n        | open-top => {?hidden}\n        | open-inter => {?hidden}\n        | open-Union => {?hidden}\n        | isCauchy => Closure {I.E}\n          (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n        | cauchy-cover => {?hidden}\n        | cauchy-top => {?hidden}\n        | cauchy-refine => {?hidden}\n        | cauchy-glue => {?hidden}\n        | cauchy-open => {?hidden}\n        | isRegular => {?hidden}\n      }}} {X} {X} (completion {\\new CoverSpace I.E {\n        | isOpen => isOpen {ClosurePrecoverSpace {I.E}\n          (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n          (\\lam {C : Set (Set I.E)}\n            (e : TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C))) (x : I.E) =>\n          (\\case e \\with {\n            | inP (j, Cc) => cauchy-cover {j.1} {C} Cc x\n          }))}\n        | open-top => {?hidden}\n        | open-inter => {?hidden}\n        | open-Union => {?hidden}\n        | isCauchy => Closure {I.E}\n          (\\lam (C : Set (Set I.E)) => TruncP (\\Sigma (j : \\Sigma (b : CoverSpace I.E) (b <= \\new precover {I} {})) (isCauchy {j.1} C)))\n        | cauchy-cover => {?hidden}\n        | cauchy-top => {?hidden}\n        | cauchy-refine => {?hidden}\n        | cauchy-glue => {?hidden}\n        | cauchy-open => {?hidden}\n        | isRegular => {?hidden}\n      }}) (id {X})) {?hidden} fc\n}", "completion": "dense-lift (prod completion id) de fc"}
{"prompt": "['this : Dec']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 6 + E E : E', 'byLeft A', '| \\\\infix 8 #0 E : \\\\Prop', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| nonZeroApart {x : E} (x /= zro) : #0 x', '| zro-right {x : E} : x + zro = x', 'byRight B', '| zro : E', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>\\Pi {x : E} -> \\Pi {y : E} -> #0 (x + y) -> #0 x || #0 y", "completion": "\\lam {x} {y} x+y#0 => (\\scase decideEq {this} y (zro {this}) \\with {\n  | yes y=0 => byLeft (transport (#0 {this}) (pmap ((+) {this} x) y=0 *> zro-right {this}) x+y#0)\n  | no y/=0 => byRight (nonZeroApart {this} y/=0)\n})"}
{"prompt": "['G : StronglyRegularCauchyFilter X']<<<break>>>['| F (E {A}) : \\\\Prop', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| X : \\\\Set', '| bottom : E', '| isWeaklyProper : Not (F bottom)', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>G.F bottom -> Empty", "completion": "isWeaklyProper {G}"}
{"prompt": "['p : MonoidSet M.E R', 'm : M.E', \"l' : Array (\\\\Sigma R.E M.E)\", 'R : AbMonoid', 'q : Not (msCoef {M} {R} p m = R.zro)', 'M : DecSet', \"i1 : Index {M.E} m (map {\\\\Sigma R.E M.E} {M.E} (\\\\lam (p0 : \\\\Sigma R.E M.E) => p0.2) l')\", \"i2 : \\\\Sigma (j : Fin (len {nub {M} (map {\\\\Sigma R.E M.E} {M.E} (\\\\lam (p0 : \\\\Sigma R.E M.E) => p0.2) l')}))\\n  (at {nub {M} (map {\\\\Sigma R.E M.E} {M.E} (\\\\lam (p0 : \\\\Sigma R.E M.E) => p0.2) l')} j = at {map {\\\\Sigma R.E M.E} {M.E} (\\\\lam (p0 : \\\\Sigma R.E M.E) => p0.2) l'} i1.1)\"]<<<break>>>['| zro : E', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| at (j : Fin len) : A j', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '\\\\func nub \\\\hlevels  {A2 : DecSet} (_ : Array A.E) : Array A.E \\n  | {A}, nil => nil\\n  | {A}, :: {n} a l => a :: removeElem {A} a (nub {A} l)', '\\\\func msCoef \\\\hlevels  {M : DecSet} {R : AbMonoid} (p : MonoidSet M.E R) (m : M.E) : R.E => monoidSet-coefs {M.E} {R} {(=) m} (M.decideEq m) p', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>msCoef {M} {R} p (at {nub {M} (map {\\Sigma R.E M.E} {M.E} (\\lam (p0 : \\Sigma R.E M.E) => p0.2) l')} i2.1) = R.zro -> Empty", "completion": "\\lam r => q $ inv (pmap (msCoef p) $ i2.2 *> i1.2) *> r"}
{"prompt": "['eps : Rat', 'r_Fr : \\\\Sigma (x : \\\\Sigma Real A.E) (F.F (OBall (half (half eps)) x))', 'A : StoneC*PseudoAlgebra', 'this : StoneC*Algebra (\\\\Sigma Real A.E) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | cauchy-open => {?hidden}\\n  | isUniform => isUniform\\n  | uniform-cauchy => {?hidden}\\n  | dist => ExPseudoNormedAbGroup.dist\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro => (zro, zro)\\n  | + => \\\\lam (s : E) (t : E) => (s.1 AddMonoid.+ t.1, s.2 AddMonoid.+ t.2)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => \\\\lam (p0 : E) => (negative p0.1, negative p0.2)\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm => UnitC*Algebra.norm {A}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | norm-double => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isComplete => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | * => \\\\lam (p0 : E) (p1 : E) => (p0.1 Semigroup.* p1.1, p0.1 *c p1.2 AddMonoid.+ p1.1 *c p0.2 AddMonoid.+ p0.2 Semigroup.* p1.2)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | norm_*_<= => {?hidden}\\n  | ide => (ide, zro)\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl {UnitAlgebra RealField (toRealAlgebra {A})}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | c*-sum => {?hidden}\\n  | c*-square => {?hidden}\\n  | norm_ide_<= => {?hidden}\\n}', 'x : F.X', 'eps>0 : zro < eps', 'd : OBall (half (half eps)) r x']<<<break>>>['true', '\\\\lemma half<id \\\\plevels  \\\\hlevels  {a : Rat} (_ : fromInt (pos 0) < a) : half a < a ', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '| dist E E : ExUpperReal', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', '| at (j : Fin len) : A j', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| E : \\\\Set', '| join-right {x y : E} : y <= x \u2228 y', '\\\\lemma norm_*r \\\\hlevels  {this : RealBanachSpace} {r : Real} {a : E} : norm (r *r a) = abs {RealAbGroup} r * norm a ', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| len : Nat', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', \"\\\\lemma <=_* \\\\plevels  \\\\hlevels  {x x' y y' : ExUpperReal} (_ : x <= x') (_ : y <= y') : x * y <= x' * y' \", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '\\\\lemma <-rat \\\\plevels  \\\\hlevels  {x : ExUpperReal} {y : Rat} : x < fromRat y <-> x.U y ', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", 'join \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal => \\\\new ExUpperReal (\\\\lam (a : Rat) => \\\\Sigma (x.U a) (y.U a)) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '\\\\instance RealValuedRing : CompleteValuedCRing Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (+)\\n  | negative => negative\\n  | norm => abs {RealAbGroup}\\n  | * => (RealField.*)\\n  | ide => fromRat ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n} => \\\\new CompleteValuedCRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\lemma <=-upper \\\\plevels  \\\\hlevels  {x y : Real} : x Preorder.<= y <-> x ExUpperReal.<= y ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func toContr2 \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '| \\\\infixl 7 *c (E {R}) E : E', '\\\\func toContr1 \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t1, Less, t2) :: p', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\lemma norm_*-char \\\\hlevels  {this : StoneC*PseudoAlgebra} {x : E} :\\n  norm x = Join {\\\\Sigma (y : E) (norm y <= ide)} (\\\\lam (s : \\\\Sigma (y : E) (norm y <= ide)) => norm (x * s.1)) ', '| C : Semiring', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func toRealAlgebra {this1 : RealBanachPseudoAlgebra} : PseudoAlgebra RealField E {\\n  | zro => zro\\n  | + => (+)\\n  | negative => negative\\n  | *c => (*r)\\n  | * => (*)\\n} => \\\\new PseudoAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | *c-comm-right => {?hidden}\\n}', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\lemma solve=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr1 p t1 t2)) (_ : CorrectCert (toContr2 p t1 t2))\\n  (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) : interpret t1 = interpret t2 ', '\\\\func half \\\\plevels  \\\\hlevels  (a : Rat) : Rat => a * ratio (pos 1) 2', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', '| norm E : ExUpperReal', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '| \\\\infixl 6 + E E : E', '\\\\lemma *c_negative-left \\\\hlevels  {this : LModule} {r : E {R}} {a : E} : negative {R} r *c a = negative (r *c a) ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| norm-dist {x y : E} : dist x y = norm (x - y)', '\\\\lemma abs_negative \\\\hlevels  {this : LatticeAbGroup} {x : E} : abs (negative x) = abs x ', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| negative E : E', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| Join {J : \\\\Set} (J -> E) : E', '\\\\infixl 7 *r \\\\hlevels  {this : RealBanachSpace} (r : Real) (a : E) : E => func {lift} (r, a)', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '\\\\lemma norm_dist-left \\\\hlevels  {X : ExPseudoNormedAbGroup} {x y : X.E} : X.norm x <= X.dist x y + X.norm y ', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| abs>=0 {x : E} : zro <= abs x', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| join-left {x y : E} : x <= x \u2228 y', '\\\\lemma +-rat \\\\plevels  \\\\hlevels  {x y : Rat} : fromRat x ExUpperReal.+ fromRat y = fromRat (x RatField.+ y) ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\type \\\\infix 4 < \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => TruncP (\\\\Sigma (q : Rat) (x.U q) (fromRat q <= y))', '| M : Monoid', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\lemma ide-right \\\\plevels  \\\\hlevels  {x : ExUpperReal} (_ : zro <= x) : x * fromRat ide = x ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", 'var V', '\\\\instance ExUpperRealLattice \\\\hlevels  : CompleteLattice ExUpperReal {\\n  | <= => (ExUpperReal.<=)\\n  | meet => meet\\n  | join => join\\n  | top => top-impl\\n  | Join => ExUpperRealLattice.Join\\n  | Meet => ExUpperRealLattice.Meet\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| +-comm {x y : E} : x + y = y + x', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>A.norm (r.2 - x.2) < fromRat eps", "completion": "rewrite (norm_*-char {A}) (Join-univ (\\lam s => (\n  \\have | t1 => join-left <\u2218r <-rat.2 d\n        | t2 => Join-cond s <\u2218r join-right <\u2218r <-rat.2 d\n  \\in norm_dist-left {_} {_} {negative (r.1 - x.1) *r {A} s.1} <=\u2218 <=_+ (=_<= norm-dist)\n        (=_<= (norm_*r {A}) <=\u2218 <=_* (=_<= {ExUpperRealAbMonoid} (abs_negative {RealAbGroup})) s.2 <=\u2218 =_<= (ide-right $ <=-upper.1 (abs>=0 {RealAbGroup}))) <=\u2218 unfold (-)\n        (rewrite (*c_negative-left {toRealAlgebra {A}}, negative-isInv {A}, +-comm {A}) $ <=_+ (<=-less t2) (<=-less t1) <=\u2218 =_<= (+-rat *> pmap fromRat linarith)))) <\u2218r (<-rat {half eps}).2 (half<id eps>0))"}
{"prompt": "['a : E', 'this : Dec']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| ide-left {x : E} : ide * x = x', '| ide : E', 'inP A', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\lemma nonZero-left \\\\hlevels  {this : Domain} {x y : E} (_ : x /= zro) (_ : x * y = zro) : y = zro ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)', '| zro_*-left {x : E} : zro * x = zro', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>TruncP (\\Sigma (u : E) (a = u * a) (\\Pi {x : E} -> a * x = zro -> u * x = zro))", "completion": "inP (\\case decideEq {this} a 0 \\with {\n  | yes a=0 => (0, rewrite a=0 (inv (zro_*-left {this})), \\lam _ => zro_*-left {this})\n  | no a/=0 => (1, inv (ide-left {this}), \\lam p => ide-left {this} *> nonZero-left {this} a/=0 p)\n})"}
{"prompt": "['R : CRing', 'p0 : \\\\Sigma (B : Matrix R.E 1 2) (IsDiagonal {R} {1} {2} B) (A M~ B)', 'B_Bd_A~B : \\\\Sigma (B : Matrix R.E 1 2) (IsDiagonal {R} {1} {2} B) (A M~ B)']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\type IsDiagonal \\\\hlevels  {R : AddPointed} {n m : Nat} (A : Matrix R.E n m) : \\\\Prop \\n  => \\\\Pi {i : Fin n} -> \\\\Pi {j : Fin m} -> i /= j -> at {at {A} i} j = R.zro']<<<break>>>IsDiagonal {R} {1} {2} B", "completion": "\\lam q => Bd q"}
{"prompt": "['F : RegularCauchyFilter this']<<<break>>>['| F (E {A}) : \\\\Prop', '| S : CoverSpace', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| isCauchyFilter {C : Set (Set (E {S}))} (isCauchy {S} C) : TruncP (\\\\Sigma (U : Set (E {S})) (C U) (F U))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {C : Set (Set (E {F.S}))} -> isCauchy {F.S} C -> TruncP (\\Sigma (U : Set (E {F.S})) (C U) (F.F U))", "completion": "isCauchyFilter {F}"}
{"prompt": "['J : FinSet', 'this : LModule', 'g : E -> E']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma FinSum=BigSum {this : AbMonoid} {n : Nat} {x : Fin n -> E} : FinSum {FinFin n} x = BigSum (\\\\new Array E n x) ', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', 'FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1', '| finCard : Nat', '| R : Ring', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '| zro : E', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>(\\Pi (c : Array (E {R}) J.finCard) -> BigSum (\\new Array E J.finCard (\\lam (j : Fin J.finCard) => c.at j *c g j)) = zro ->\n  \\Pi (j : Fin J.finCard) -> c.at j = zro {R}) -> \\Pi (c : Fin J.finCard -> E {R}) ->\n  FinSum {FinFin J.finCard} (\\lam (j : Fin J.finCard) => c j *c g j) = zro -> \\Pi (j : Fin J.finCard) -> c j = zro {R}", "completion": "\\lam f c p j => f c (inv (FinSum=BigSum {this}) *> p) j"}
{"prompt": "['Dc : DirectProdCover {I} {X} D', 'D : Set (Set (\\\\Sigma I.E X.E))', 'I : DirectedSet', 'X : CoverSpace']<<<break>>>['\\\\func proj1 \\\\hlevels  {X Y : PrecoverSpace} :\\nPrecoverMap (PrecoverTransfer {\\\\Sigma X.E Y.E} {X} (\\\\lam (p0 : \\\\Sigma X.E Y.E) => p0.1) \u2228 PrecoverTransfer {\\\\Sigma X.E Y.E} {Y} (\\\\lam (p0 : \\\\Sigma X.E Y.E) => p0.2))\\n  X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1\\n} => \\\\new PrecoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\instance PrecoverSpaceHasProduct \\\\hlevels  : HasProduct PrecoverSpace {\\n  | Product => ProductPrecoverSpace\\n} => \\\\new HasProduct', '\\\\func PrecoverTransfer \\\\hlevels  {X : \\\\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\lemma top-cauchy \\\\hlevels  {X : PrecoverSpace} {C : Set (Set X.E)} (_ : C top) : X.isCauchy C ', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D', '| func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| top : E', '| E : \\\\Set', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '\\\\func precover \\\\hlevels  {I : DirectedSet} : PrecoverSpace I.E {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n  \\\\Sigma (TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (N : I.E) (\\\\Pi {n : I.E} -> N I.<= n -> U n)))\\n    (\\\\Pi (n : I.E) -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (C V) (V n)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\func proj2 \\\\hlevels  {X Y : PrecoverSpace} :\\nPrecoverMap (PrecoverTransfer {\\\\Sigma X.E Y.E} {X} (\\\\lam (p0 : \\\\Sigma X.E Y.E) => p0.1) \u2228 PrecoverTransfer {\\\\Sigma X.E Y.E} {Y} (\\\\lam (p0 : \\\\Sigma X.E Y.E) => p0.2))\\n  Y {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.2\\n} => \\\\new PrecoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))', 'byLeft A', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\lemma makePrecover \\\\hlevels  {I : DirectedSet} (N : I.E) : isCauchy (\\\\lam (V : Set E) => (V = (I.<=) N) || (\\\\Sigma (n : I.E) (V = single {I.E} n))) ', '\\\\instance PrecoverLattice \\\\hlevels  (X : \\\\Set) : CompleteLattice (PrecoverSpace X) {\\n  | <= => \\\\lam (A : E {\\\\this}) (B : E {\\\\this}) => \\\\Pi {C : Set (Set X)} -> A.isCauchy C -> B.isCauchy C\\n  | meet => meet-impl\\n  | join => join-impl\\n  | top => DiscreteCover X\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n  ClosurePrecoverSpace {X} (\\\\lam (C : Set (Set X)) => TruncP (\\\\Sigma (j : J) (isCauchy {f j} C)))\\n    (\\\\lam {C : Set (Set X)} (e : TruncP (\\\\Sigma (j : J) (isCauchy {f j} C))) (x : X) => (\\\\case e \\\\with {\\n      | inP (j, Cc) => cauchy-cover {f j} {C} Cc x\\n    }))\\n  | Meet => Meet-impl\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func Prod \\\\hlevels  {X Y : \\\\hType} (U : Set X) (V : Set Y) : Set (\\\\Sigma X Y) => \\\\lam (s : \\\\Sigma X Y) => \\\\Sigma (U s.1) (V s.2)', 'byRight B', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| func (E {Dom}) : E {Cod}', '\\\\lemma cauchy-subset \\\\hlevels  {X : PrecoverSpace} {C D : Set (Set X.E)} (_ : X.isCauchy C) (_ : \\\\Pi {U : Set X.E} -> C U -> D U) : X.isCauchy D ', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>Closure {\\Sigma E X.E} (\\lam (C : Set (Set (\\Sigma E X.E))) => TruncP (\\Sigma (j : Bool) (isCauchy C))) D", "completion": "cauchy-refine {precover \u2a2f X} (cauchy-glue {precover {I} \u2a2f X} (func-cover {proj2} Dc.1)\n  {\\lam U V => \u2203 (\\Sigma (U' : Set X) (N : I) (V' : D) (Prod ((<=) N) U' \u2286 V') (U = (\\lam s => s.2) ^-1 U')\n    (V \u2286 (\\lam s => s.1) ^-1 (<=) N || Given (\\Sigma (V' : D) (V \u2286 V'))))}\n  (\\lam {p0} p1 => (\\case \\elim p0, \\elim p1 \\with {\n    | _, inP (U', inP (N, U, DU, U'U), idp) => cauchy-subset {precover \u2a2f X}\n      (cauchy-glue {precover {I} \u2a2f X} (func-cover {proj1} (makePrecover N)) {\\lam U V => \u2203 (\\Sigma (U' : Set I) (U = (\\lam s => s.1) ^-1 U')\n        ((U' = (<=) N) || Given (\\Sigma (n : I) (U' = single n) (Un : Set X) (Vn : D) (Prod (single n) Un \u2286 Vn) (V = (\\lam s => s.2) ^-1 Un))))}\n        (\\lam {V} => \\lam p0 => (\\case \\elim p0 \\with {\n          | inP (V', byLeft p, VV') => top-cauchy {precover \u2a2f X} $ inP $ later (V', VV', byLeft p)\n          | inP (V', byRight (n, p), VV') =>\n          cauchy-subset {precover {I} \u2a2f X} (func-cover {proj2} (Dc.2 n)) (\\lam {W} p0 => (\\case \\elim p0 \\with {\n            | inP (W', inP (Vn, DVn, h), WW') => inP $ later (V', VV', byRight (n, p, W', Vn, DVn, \\lam p0 => (\n              \\let (p1, p2) => p0\n              \\in rewrite p1 in h p2), WW'))\n          }))\n        })))\n      (\\lam {p0} p1 => (\\case \\elim p0, \\elim p1 \\with {\n        | _, inP (U1, V, _, inP (U1', U1U1', e), idp) => \\case \\elim e \\with {\n          | byLeft p => inP $ later (U', N, U, DU, \\lam p0 => (\n            \\let (p1, p2) => p0\n            \\in U'U p1 p2), idp, byLeft $ rewrite (U1U1', p) meet-left)\n          | byRight (n, p, Un, Vn, DVn, q, r) => inP $ later (U', N, U, DU, \\lam p0 => (\n            \\let (p1, p2) => p0\n            \\in U'U p1 p2), idp, byRight (Vn, DVn, rewrite (U1U1', r, p) q))\n        }\n      }))\n  })))\n  (\\lam {p0} p1 => (\\case \\elim p0, \\elim p1 \\with {\n    | _, inP (U, V, _, inP (U', N, V', DV', U'V', p, e), idp) => \\case \\elim e \\with {\n      | byLeft q => inP (V', DV', rewrite p (\\lam p0 => (\n        \\let (p1, p2) => p0\n        \\in U'V' (q p2, p1))))\n      | byRight (V', DV', V<=V') => inP (V', DV', meet-right <=\u2218 V<=V')\n    }\n  }))"}
{"prompt": "['x : E', 'this : Locale']<<<break>>>['\\\\class Nucleus \\\\hlevels  {\\n  | L : Locale\\n  | nucleus (E {L}) : E {L}\\n  | nucleus-meet {x y : E {L}} : nucleus (x \u2227 y) = nucleus x \u2227 nucleus y\\n  | nucleus-meet>= {x y : E {L}} : nucleus x \u2227 nucleus y <= nucleus (x \u2227 y)\\n  | nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y\\n  | nucleus-unit {x : E {L}} : x <= nucleus x\\n  | nucleus-join>= {x : E {L}} : nucleus (nucleus x) <= nucleus x\\n  | nucleus-join {x : E {L}} : nucleus (nucleus x) = nucleus x\\n}', '\\\\func \\\\infixr 5 --> \\\\hlevels  {this : Locale} (x y : E) : E => SJoin (\\\\lam (p0 : E) => p0 \u2227 x <= y)', '| E : \\\\Set', '| L : Locale', '\\\\func open \\\\hlevels  {this2 : Locale} (a : E) : Nucleus ((-->) a) => \\\\new Nucleus {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}']<<<break>>>Nucleus ((-->) x)", "completion": "open {this} x"}
{"prompt": "['B : BottomDistributiveLattice', 'v : V.E', 'u : V.E', 'b : B.E', \"l'' : Array (\\\\Sigma V.E B.E)\", 'V : AddGroup']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', 'suc Nat', \"~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', \"~-perm (EPerm {\\\\Sigma V.E B.E} l l')\", '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\", '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| negative E : E', '\\\\lemma negative_+ \\\\hlevels  {this : AddGroup} {x y : E} : negative (x + y) = negative y - x ', \"\\\\func eperm-= {A1 : \\\\Type} {l1 l' : Array A1} (_ : l1 = l') : EPerm {A1} l1 l' \\n  | {A}, {l}, {l'}, idp => eperm-refl {A} {l}\"]<<<break>>>(V.negative (at {(u, b) :: (v, b) :: l''} 1).1, (at {(u, b) :: (v, b) :: l''} 1).2) :: (V.negative (at {(u, b) :: (v, b) :: l''} 0).1, (at {(u, b) :: (v, b) :: l''} 0).2) :: \\new Array (\\Sigma V.E B.E) l''.len (\\lam (j : Fin l''.len) =>\n  (V.negative (at {(u, b) :: (v, b) :: l''} (suc (suc j))).1, (at {(u, b) :: (v, b) :: l''} (suc (suc j))).2)) ~ map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (V.negative s.1, s.2)) ((u V.+ v, b) :: l'')", "completion": "~-trans (~-+-left idp idp) (~-perm $ eperm-= $ path (\\lam i => (inv (negative_+ {V}) i, _) :: _))"}
{"prompt": "['X : OrderedC*Algebra', 'f : OrderedC*AlgebraHom X Y', 's : E {toBanach {X} \u2a2f toBanach {X}}']<<<break>>>['| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| \\\\infixl 7 * E E : E', '\\\\func proj1 \\\\hlevels  {X Y : TopSpace} : ContMap (X \u2a2f Y) X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '| Cod : BaseSet', '\\\\func toBanach \\\\hlevels  {this107 : OrderedC*Algebra} : RealPreBanachAlgebra E {\\n  | isOpen => isOpen\\n  | isCauchy => isCauchy\\n  | isUniform => isUniform\\n  | dist => ExPseudoNormedAbGroup.dist\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | negative => negative\\n  | norm => OrderedC*Algebra.toBanach.norm\\n  | * => (Semigroup.*)\\n  | ide => ide\\n  | natCoef => natCoef\\n} => \\\\new RealPreBanachAlgebra {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | norm-double => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | norm_*_<= => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_ide_<= => {?hidden}\\n}', '\\\\func proj2 \\\\hlevels  {X Y : TopSpace} : ContMap (X \u2a2f Y) Y {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.2\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| Dom : BaseSet']<<<break>>>f.func (func {proj1 {toBanach {X}} {toBanach {X}}} s * func {proj2 {toBanach {X}} {toBanach {X}}} s) = f.func (func {proj1 {toBanach {X}} {toBanach {X}}} s) * f.func (func {proj2 {toBanach {X}} {toBanach {X}}} s)", "completion": "func-* {f}"}
{"prompt": "['eh : R.isHomogen e ed', 'R : GradedCRing', 'g : Carrier R', 'l : Nat', 'y : R.E', 'k : Nat', 'n : Nat', 'm : Nat', 'e : R.E', 'ed : Nat', 'a : Carrier R', 'yh : R.isHomogen y (suc g.2 * l)']<<<break>>>['| \\\\infixl 7 * E E : E', '| homogen-* {n m : Nat} {a b : E} (isHomogen a n) (isHomogen b m) : isHomogen (a * b) (n + m)', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', 'suc Nat', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma homogen-pow \\\\hlevels  {this : GradedCRing} {a : E} {n m : Nat} (_ : isHomogen a n) : isHomogen (pow a m) (n * m) ', '| isHomogen E Nat : \\\\Prop', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>R.isHomogen (pow {R} g.1 (k Semigroup.* n) R.* y R.* pow {R} g.1 m R.* e R.* pow {R} a.1 n)\n  (suc g.2 Nat.* (k Nat.* n) + suc g.2 Nat.* l + suc g.2 Nat.* m + ed + suc a.2 Nat.* n)", "completion": "homogen-* (homogen-* (homogen-* (homogen-* (homogen-pow {R} g.3) yh) (homogen-pow {R} g.3)) eh) (homogen-pow {R} a.3)"}
{"prompt": "['C : Precat', 'D : Cat', 'this : Embedding {VPresheaf D C} {Ob} (\\\\lam (P : A {\\\\this}) => P.F) {\\n  | isEmb => \\\\lam (a : A {\\\\this}) (a1 : A {\\\\this}) =>\\n  \\\\new Retraction {a = a1} {f {\\\\this} a = f {\\\\this} a1} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {a} {a1}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new VPresheaf D C (p @ i))\\n    | f_sec => idpe {F = F}\\n  }\\n}']<<<break>>>['| A : \\\\Type', '| f A : B', '\\\\class Functor \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F (Ob {C}) : Ob {D}\\n  | Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)\\n  | Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)\\n  | Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f\\n}', '| F : Functor (op {C}) D', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\class Retraction \\\\extends Map {\\n  | sec B : A\\n  | f_sec (y : B) : f (sec y) = y\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func idpe {A : \\\\Type} (a : A) : a = a => idp {A} {a}', '| B : \\\\Type', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\class VPresheaf \\\\hlevels  {\\n  | D : Cat\\n  | C : Precat\\n  | F : Functor (op {C}) D\\n}']<<<break>>>\\Pi (a : A {\\this}) -> \\Pi (a1 : A {\\this}) ->\n  Retraction {a = a1} {f {\\this} a = f {\\this} a1} (pmap {A {\\this}} {B {\\this}} (f {\\this}) {a} {a1}) {\n    | sec => \\lam (p : B {\\this}) => path (\\lam (i : I) => \\new VPresheaf D C (p @ i))\n    | f_sec => idpe {F = F}\n  }", "completion": "\\lam _ _ => \\new Retraction {\n  | sec => \\lam p => ext p\n  | f_sec => idpe\n}"}
{"prompt": "['B : BooleanRing', 'j : Fin l.len', 'l : PFunc {V} {B}', 'V : PosetQModule']<<<break>>>['| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\lemma BigJoin-cond \\\\hlevels  {this : BottomJoinSemilattice} {l : Array E} (j : Fin l.len) : l.at j <= BigJoin l ', '\\\\type \\\\infix 4 <= \\\\hlevels  {R : Semigroup} (x y : R.E) : \\\\Prop => x R.* y = x', '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>at {map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l} j <= BigJoin {B} (map {\\Sigma V.E B.E} {B.E} (\\lam (p0 : \\Sigma V.E B.E) => p0.2) l)", "completion": "BigJoin-cond {B} {map (\\lam p0 => p0.2) l} j"}
{"prompt": "['this : FrameHom (SetLattice B) (SetLattice A) {\\n  | func => (^-1) f\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}', 'A : \\\\hType']<<<break>>>['| Join {J : \\\\Set} (J -> E) : E', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Cod : BaseSet', '| Dom : BaseSet']<<<break>>>\\Pi {J : \\Set} -> \\Pi {f : J -> E {Dom {\\this}}} ->\n  func {\\this} (Join {Dom {\\this}} {J} f) \u2286 Join {Cod {\\this}} {J} (\\lam (j : J) => func {\\this} (f j))", "completion": "\\lam c => c"}
{"prompt": "['Y : Ob {C {\\\\this}}', 'Z : Ob {C {\\\\this}}', 'null : Ob {C {\\\\this}}', 'C : Precat', 'J : Precat', 'j : Ob {J {D.limit {J1} (functor-at-point {C} {D} {J1} {G} Z)}}', 'G : Functor J (VPresheafCat D C)', 'f : Hom {C {\\\\this}} o Y', 'g : Hom {C {\\\\this}} Y Z', 'D : CompleteCat']<<<break>>>['| apex : Ob {D}', '| limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex', '| Hom Ob Ob : \\\\Set', '\\\\func L \\\\hlevels  {C : Precat} {D : CompleteCat} {J : Precat} {G : Functor J (VPresheafCat D C)} (c : C.Ob) :\\n  Limit {J} {D} (functor-at-point {C} {D} {J} {G} c) => D.limit {J} (functor-at-point {C} {D} {J} {G} c)', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| G : Functor J D', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j', '| F (Ob {C}) : Ob {D}', '\\\\func cone \\\\hlevels  {C : Precat} {D : CompleteCat} {J1 : Precat} {G : Functor J1 (VPresheafCat D C)} {X Y : C.Ob} (f : C.Hom Y X) :\\nCone {J1} {D} (functor-at-point {C} {D} {J1} {G} Y) apex {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => Func {VPresheaf.F {G.F j}} {X} {Y} f D.\u2218 coneMap j\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| D : Precat']<<<break>>>coneMap j \u2218 limMap {apex} (cone {C} {D1} {J} {G1} {o} {Z} (f C.\u2218 g)) = coneMap j", "completion": "limBeta {L {C} {D} {J} {G} Z} (cone {C} {D} {J} {G} (f \u2218 g)) j"}
{"prompt": "['b : E', 'this : BooleanAlgebra', 'a : E']<<<break>>>['| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', '| ldistr>= {x y z : E} : x \u2227 (y \u2228 z) <= x \u2227 y \u2228 x \u2227 z', '\\\\lemma \\\\infixr 9 =<= \\\\hlevels  {E1 : Preorder} {x y z : E.E} (_ : x = y) (_ : y E.<= z) : x E.<= z ', '| compl-meet {a : E} : a \u2227 compl a <= bottom', '\\\\lemma compl-adj \\\\hlevels  {this : BooleanAlgebra} {a b : E} (_ : a \u2227 b <= bottom) : a <= compl b ', '| bottom : E', '| top : E', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\lemma compl-mono \\\\hlevels  {this : BooleanAlgebra} {a b : E} (_ : a <= b) : compl b <= compl a ', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma meet-comm \\\\hlevels  {this : MeetSemilattice} {x y : E} : x \u2227 y = y \u2227 x ', '| <=-refl {x : E} : x <= x', '\\\\lemma meet-assoc \\\\hlevels  {this : MeetSemilattice} {x y z : E} : x \u2227 y \u2227 z = x \u2227 (y \u2227 z) ', '| compl-join {a : E} : top <= a \u2228 compl a', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '| compl E : E', '\\\\lemma join-comm \\\\hlevels  {this : JoinSemilattice} {x y : E} : x \u2228 y = y \u2228 x ', '| meet-left {x y : E} : x \u2227 y <= x', '| top-univ {x : E} : x <= top', '| join-univ {x y z : E} (x <= z) (y <= z) : x \u2228 y <= z', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y', \"\\\\lemma join-monotone \\\\hlevels  {this : JoinSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2228 y <= x' \u2228 y' \", '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>compl (a \u2227 b) = compl a \u2228 compl b", "completion": "<=-antisymmetric {this}\n  (meet-univ {this} (<=-refl {this}) (top-univ {this}) <=\u2218 {this} meet-monotone {this} (<=-refl {this}) (compl-join {this}) <=\u2218 {this} ldistr>= {this} <=\u2218 {this} join-comm {this} =<= join-monotone {this} (meet-right {this})\n    (compl-adj {this} $ =_<= (meet-assoc {this}) <=\u2218 {this} meet-comm {this} =<= compl-meet {this}))\n  (join-univ {this} (compl-mono {this} (meet-left {this})) (compl-mono {this} (meet-right {this})))"}
{"prompt": "['this : StrictDomain', 'p : BigProd nil = zro']<<<break>>>['| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '| ide : E', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '| zro/=ide : zro /= ide']<<<break>>>TruncP (\\Sigma (j : Fin 0) (at {nil} j = zro))", "completion": "absurd (zro/=ide {this} (inv p))"}
{"prompt": "['n : Nat', 'R : GradedCRing', \"y'1h : R.isHomogen y'.1 m\", \"y' : SType {R} S\", 'm : Nat', \"x' : SType {R} S\", \"x'2h : R.isHomogen x'.2 n\"]<<<break>>>['| \\\\infixl 7 * E E : E', '| homogen-* {n m : Nat} {a b : E} (isHomogen a n) (isHomogen b m) : isHomogen (a * b) (n + m)', '| isHomogen E Nat : \\\\Prop', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)']<<<break>>>R.isHomogen (y'.1 R.* x'.2) (m + n)", "completion": "homogen-* y'1h x'2h"}
{"prompt": "['b : C.Ob', 'h : C.Hom b a', 'S2 : Presieve {C} a']<<<break>>>['| C : Precat', '| Hom Ob Ob : \\\\Set', '| x : Ob {C}', '\\\\func pullback \\\\plevels obj >= hom \\\\hlevels  {this1 : Presieve} {y : Ob {C}} (h : Hom {C} y x) :\\n  Presieve {C} y (\\\\lam {y1 : Ob {C {\\\\this}}} (g : Hom {C {\\\\this}} y1 (x {\\\\this})) => S {y1} (h \u2218 g)) => \\\\new Presieve', '| Ob : \\\\hType', '| S {y : Ob {C}} (Hom {C} y x) : \\\\Prop', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\class Presieve \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | x : Ob {C}\\n  | S {y : Ob {C}} (Hom {C} y x) : \\\\Prop\\n}']<<<break>>>Presieve {S2.C} b (\\lam {y : Ob {C {\\this}}} (g : Hom {C {\\this}} y (x {\\this})) => S2.S {y} (h \u2218 g))", "completion": "pullback {S2} h"}
{"prompt": "['a : Fin n', 'n : Nat', 'e : Sym (suc n)']<<<break>>>['\\\\func transposition1 \\\\plevels  \\\\hlevels  {n : Nat} (a : Fin n) : Sym (suc n) => transposition {suc n} {a} {suc a} (id/=suc {a})', '\\\\func inversions \\\\plevels  \\\\hlevels  {n1 : Nat} (_ : Sym n1) : Nat \\n  | {0}, e => 0\\n  | {suc n}, e => f {e} 0 + inversions {n} (reduce {n} e)', '| \\\\infixl 7 * E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| f A : B', 'suc Nat', '\\\\func \\\\infixl 8 mod \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n mod m', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', \"\\\\func reduce {n : Nat} (e : Sym (suc n)) : Sym n => isEquiv {FinFin n}\\n  (\\\\lam (j : E) => skip {n} (f {e} 0) (f {e} (suc j)) (\\\\lam (p : f {e} 0 = f {e} (suc j)) => (\\\\case isInj {e} {0} {suc j} p \\\\with {})))\\n  (\\\\lam {a a' : E}\\n    (p : skip {n} (f {e} 0) (f {e} (suc a)) (\\\\lam (p : f {e} 0 = f {e} (suc a)) => (\\\\case isInj {e} {0} {suc a} p \\\\with {})) = skip {n} (f {e} 0) (f {e} (suc a')) (\\\\lam (p : f {e} 0 = f {e} (suc a')) => (\\\\case isInj {e} {0} {suc a'} p \\\\with {}))) =>\\n  unfsuc {n} {a} {a'} (isInj {e} {suc a} {suc a'} (skip-isInj {n} {f {e} 0} {f {e} (suc a)} {f {e} (suc a')}\\n    {\\\\lam (p : f {e} 0 = f {e} (suc a)) => (\\\\case isInj {e} {0} {suc a} p \\\\with {})}\\n    {\\\\lam (p : f {e} 0 = f {e} (suc a')) => (\\\\case isInj {e} {0} {suc a'} p \\\\with {})} p)))\", '\\\\instance SymmetricGroup \\\\hlevels  (n : Nat) : Group (Sym n) {\\n  | ide => idEquiv {Fin n}\\n  | * => transEquiv {Fin n} {Fin n} {Fin n}\\n  | inverse => \\\\lam (e : E {\\\\this}) => symQEquiv {Fin n} {Fin n} (fromEquiv e)\\n} => \\\\new Group {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | inverse-right => {?hidden}\\n}', '\\\\lemma n*_+_mod_n=mod \\\\plevels  \\\\hlevels  {n q r : Nat} : (suc n * q + r) mod suc n = r mod suc n ']<<<break>>>(2 + (f {e} (f {transposition1 {n} a} 0) + inversions {n} (reduce {n} (transposition1 {n} a * e)))) mod 2 = (f {e} (f {transposition1 {n} a} 0) + inversions {n} (reduce {n} (transposition1 {n} a * e))) mod 2", "completion": "n*_+_mod_n=mod {1} {1}"}
{"prompt": "['h : Hom {C {\\\\this}} L M', 'x : M.E', 'M : Ob {C {\\\\this}}']<<<break>>>['\\\\func wclosed-image \\\\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\\\lam (x : E {L {\\\\this}}) => Meet {Dom}\\n  {\\\\Sigma (j : Nucleus {Dom}) (\\\\Pi {P : \\\\Prop} -> \\\\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\\n  (\\\\lam (j : \\\\Sigma (j : Nucleus {Dom}) (\\\\Pi {P : \\\\Prop} -> \\\\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\\n    nucleus {j.1} x)) => \\\\new Nucleus {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}', '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop', '| nucleus-unit {x : E {L}} : x <= nucleus x']<<<break>>>x M.<= nucleus {wclosed-image {h}} x", "completion": "nucleus-unit {wclosed-image {h}}"}
{"prompt": "['idx : rule-J {tc.rules color} s', \"s : tc.Sort'\", 'tc : TheoremContext', 'color : E {tc.Color}']<<<break>>>['| rules (c : E {Color}) : LinearRegistry (envs c)', '\\\\func SumFSignature \\\\hlevels  {J Sort1 : \\\\Set} (S : J -> FSignature {\\n  | Sort => Sort1\\n}) : FSignature {\\n  | Sort => Sort1\\n  | symbol => \\\\lam (s : Sort {\\\\this}) => \\\\Sigma (j : J) (symbol {S j} s)\\n  | domain => \\\\lam {s : Sort {\\\\this}} (symb : symbol {\\\\this} s) => domain {S symb.1} {s} symb.2\\n} => \\\\new FSignature', '| Sort : \\\\Set', \"| Sort' : \\\\Set\", '\\\\func inject-term \\\\hlevels  {J3 Sort4 : \\\\Set} (S3 : J3 -> FSignature {\\n  | Sort => Sort4\\n}) {s3 : Sort4} {c3 : List Sort4} {mc3 : MetaContext Sort4} {j2 : J3} (_ : Term (S3 j2) c3 s3 mc3) :\\n  Term (SumFSignature {J3} {Sort4} S3) c3 s3 mc3 \\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, var index p => var {SumFSignature {J} {Sort1} S} {c} {s} {mc} index p\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, metavar m args =>\\n  metavar {SumFSignature {J} {Sort1} S} {c} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term (SumFSignature {J} {Sort1} S) c (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => inject-term {J} {Sort1} S {mc.m-domain {s} m !! i} {c} {mc} {j} (args.at i)))\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, func f args => func {SumFSignature {J} {Sort1} S} {c} {s} {mc} (j, f)\\n    (\\\\new DArray {FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f)}\\n      (\\\\lam (index : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        Term (SumFSignature {J} {Sort1} S) (c ++ (j, f) !!domain index) ((j, f) !!sort index) mc)\\n      (\\\\lam (i : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        inject-term {J} {Sort1} S {(j, f) !!sort i} {c ++ (j, f) !!domain i} {mc} {j} (args.at i)))', 'nil', '| rr-pattern : LinearPattern env (nil {Sort {env}}) s', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\func convert-to-term \\\\hlevels  {env3 : FSignature} {context3 : List env.Sort} {s3 : env.Sort} {allowVariables3 : \\\\Prop}\\n  (term : GenericLinearTerm env3 context3 s3 allowVariables3) :\\n  Term env3 context3 s3 (LinearMetaContext {env3} {context3} {s3} {allowVariables3} term) \\n  | {env}, {context}, {s}, {allowVariables}, l-func f arguments => func {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-func {env} {context} {s} {allowVariables} f arguments)} f\\n    (\\\\new DArray {FSignature.arity {env} {s} f}\\n      (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index)\\n        (LinearMetaContext {env} {context} {s} {allowVariables} (l-func {env} {context} {s} {allowVariables} f arguments)))\\n      (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => upgrade-metavariables\\n        {env} {context ++ f !!domain i} {f !!sort i} {length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f)} {i}\\n          (\\\\lam (i : Fin (length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f))) =>\\n            LinearMetaContext {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))\\n          (convert-to-term {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))))\\n  | {env}, {context}, {s}, {allowVariables}, l-var index p a => var {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-var {env} {context} {s} {allowVariables} index p a)} index p\\n  | {env}, {context}, {s}, {allowVariables}, l-full-metavar => metavar {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})}\\n    (idp {env.Sort} {s}) (\\\\new DArray {MetaContext.arity\\n      {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n        (idp {env.Sort} {s})}\\n        (\\\\lam (index : Fin (MetaContext.arity\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}))) => Term env context\\n          (m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}) !! index)\\n          (LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})))\\n        (\\\\lam (i : Fin (MetaContext.arity\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}))) => var {env} {context}\\n          {m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}) !! i}\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} i\\n          (idp {env.Sort}\\n            {m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n              (idp {env.Sort} {s}) !! i})))', \"\\\\func convert-to-injected-term \\\\hlevels  {tc3 : TheoremContext} {allow-variables3 : \\\\Prop} (color3 : E {tc.Color}) {context3 : List tc.Sort'} {s3 : tc.Sort'}\\n  (term : GenericLinearTerm (tc.envs color3) context3 s3 allow-variables3) :\\n  Term (env {tc3}) context3 s3 (LinearMetaContext {tc.envs color3} {context3} {s3} {allow-variables3} term) \\n  | {tc}, {allow-variables}, color, {context}, {s}, l-func f arguments => func {env {tc}} {context} {s} {LinearMetaContext\\n    {tc.envs color} {context} {s} {allow-variables} (l-func {tc.envs color} {context} {s} {allow-variables} f arguments)}\\n    (color, f)\\n    (\\\\new DArray {FSignature.arity {env {tc}} {s} (color, f)} (\\\\lam (index : Fin (FSignature.arity {env {tc}} {s} (color, f))) =>\\n      Term (env {tc}) (context ++ (color, f) !!domain index) ((color, f) !!sort index) (LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-func {tc.envs color} {context} {s} {allow-variables} f arguments)))\\n        (\\\\lam (i : Fin (FSignature.arity {env {tc}} {s} (color, f))) =>\\n        upgrade-metavariables {env {tc}} {context ++ (color, f) !!domain i} {(color, f) !!sort i}\\n          {length {\\\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f)} {i}\\n          (\\\\lam (i : Fin (length {\\\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f))) =>\\n            LinearMetaContext {tc.envs color} {context ++ f !!domain i} {f !!sort i} {allow-variables} (arguments.at i))\\n          (convert-to-injected-term {tc} {allow-variables} color {context ++ f !!domain i} {f !!sort i} (arguments.at i))))\\n  | {tc}, {allow-variables}, color, {context}, {s}, l-full-metavar => metavar {env {tc}} {context} {s} {LinearMetaContext\\n    {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})}\\n    (idp {tc.Sort'} {s}) (\\\\new DArray {MetaContext.arity {LinearMetaContext\\n      {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n      (idp {tc.Sort'} {s})}\\n      (\\\\lam (index : Fin (MetaContext.arity {LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n        (idp {tc.Sort'} {s}))) => Term (env {tc}) context (m-domain {LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n        (idp {tc.Sort'} {s}) !! index)\\n        (LinearMetaContext\\n          {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})))\\n      (\\\\lam (i : Fin (MetaContext.arity {LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n        (idp {tc.Sort'} {s}))) => var {env {tc}} {context} {m-domain {LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n        (idp {tc.Sort'} {s}) !! i}\\n        {LinearMetaContext\\n          {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} i\\n        (idp {tc.Sort'} {m-domain {LinearMetaContext\\n          {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n          (idp {tc.Sort'} {s}) !! i})))\\n  | {tc}, {allow-variables}, color, {context}, {s}, l-var index p a => var {env {tc}} {context} {s} {LinearMetaContext\\n    {tc.envs color} {context} {s} {allow-variables} (l-var {tc.envs color} {context} {s} {allow-variables} index p a)} index\\n    p\", '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| Color : DecSet', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| rule-container {s : Sort {env}} (rule-J s) : RewriteRule {env} s', \"\\\\lemma unwrap-injection \\\\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {context : List tc.Sort'} {s : tc.Sort'} {allow-variables : \\\\Prop}\\n  (t : GenericLinearTerm (tc.envs color) context s allow-variables) :\\ninject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {LinearMetaContext {tc.envs color} {context} {s} {allow-variables} t}\\n  {color} (convert-to-term {tc.envs color} {context} {s} {allow-variables} t) = convert-to-injected-term {tc} {allow-variables} color {context} {s} t \", \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", '\\\\func LinearMetaContext \\\\hlevels  {env3 : FSignature} {context2 : List env.Sort} {s2 : env.Sort} {allowVariables1 : \\\\Prop}\\n  (_ : GenericLinearTerm env3 context2 s2 allowVariables1) : MetaContext env.Sort \\n  | {env}, {context}, {s}, {allowVariables}, l-func f arguments =>\\n  ModularMetaContext {env} {length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f)}\\n    (\\\\lam (i : Fin (length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f))) =>\\n      LinearMetaContext {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))\\n  | {env}, {context}, {s}, {allowVariables}, l-var index p a => EmptyMetaContext {env}\\n  | {env}, {context}, {s}, {allowVariables}, l-full-metavar => SingularMetaContext {env} s context', '| E : \\\\Set']<<<break>>>inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {nil {Sort}}\n  {LinearMetaContext {tc.envs color} {nil {Sort}} {s} {Empty} (rr-pattern {rule-container {tc.rules color} {s} idx})}\n  {color}\n  (convert-to-term {tc.envs color} {nil {Sort}} {s} {Empty} (rr-pattern {rule-container {tc.rules color} {s} idx})) = convert-to-injected-term {tc} {Empty} color {nil {Sort}} {s} (rr-pattern {rule-container {tc.rules color} {s} idx})", "completion": "unwrap-injection {_} {color} _"}
{"prompt": "['v : Array V.E', 'V : LModule R', 'R : Ring']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func arrayLinearMap \\\\hlevels  {R1 : Ring} {V : LModule R1} (v : Array V.E) : LinearMap {R1} (ArrayLModule {R1} v.len (RingLModule R1)) V {\\n  | func => \\\\lam (c : E {Dom {\\\\this}}) => BigSum {V} (\\\\new Array V.E v.len (\\\\lam (j : Fin v.len) => c.at j V.*c v.at j))\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\func IsSurj {A B : \\\\Type} (f : A -> B) : \\\\Prop => \\\\Pi (y : B) -> TruncP (\\\\Sigma (x : A) (f x = y))', '\\\\func map {A B1 : \\\\Type} (_ : TruncP A) (_ : A -> B1) : TruncP B1 \\n  | {A}, {B}, inP a, f => inP {B} (f a)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infixl 7 *c (E {R}) E : E', '\\\\type IsGenerated \\\\hlevels  {this : LModule} (l : Array E) : \\\\Prop \\n  => \\\\Pi (x : E) -> TruncP (\\\\Sigma (c : Array (E {R}) l.len) (x = BigSum (\\\\new Array E l.len (\\\\lam (i : Fin l.len) => c.at i *c l.at i))))', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}']<<<break>>>IsSurj {Array R.E v.len} {V.E} (func {arrayLinearMap {R} {V} v}) -> IsGenerated {V} v", "completion": "\\lam s x => map (s x) (\\lam t => (t.1, inv t.2))"}
{"prompt": "['s : SType {R} (positiveSubset R)', 'p : in~ {SType {R} (positiveSubset R)}\\n  {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} s < meet {R} (in~ {SType {R} (positiveSubset R)}\\n  {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} s)\\n  (in~ {SType {R} (positiveSubset R)}\\n    {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} t)', 't : SType {R} (positiveSubset R)', 'R : OrderedCRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '| isPos E : \\\\Prop', '| negative E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>R.isPos (s.1 R.* t.2 R.\u2227 (t.1 R.* s.2) R.* s.2 R.+ R.negative s.1 R.* (s.2 R.* t.2))", "completion": "unfolds p"}
{"prompt": "['R : Domain']<<<break>>>['| zro#ide : #0 ide', '| \\\\infix 8 #0 E : \\\\Prop', '| ide : E']<<<break>>>R.#0 R.ide", "completion": "zro#ide {R}"}
{"prompt": "['x : H.E', 'G : Group', 'f : GroupHom G H', 'p : IsIsomorphism {f}', 'y : H.E']<<<break>>>['| \\\\infixl 7 * E E : E', '| Cod : BaseSet', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\lemma inv_this_ap \\\\hlevels  {G H : Group} {f : GroupHom G H} (p : IsIsomorphism {f}) (g : G.E) : g = inve {G} {H} {f} p (f.func g) ', '\\\\func inve \\\\hlevels  {G H : Group} {f : GroupHom G H} (p : IsIsomorphism {f}) :\\n  Hom {C {this_iso {G} {H} {f} p}} (cod {this_iso {G} {H} {f} p}) (dom {this_iso {G} {H} {f} p}) \\n  => hinv {this_iso {G} {H} {f} p}']<<<break>>>inve {Dom {f}} {Cod {f}} {f} p x G.* inve {Dom {f}} {Cod {f}} {f} p y = inve {f.Dom} {f.Cod} {f} p (f.func (inve {Dom {f}} {Cod {f}} {f} p x G.* inve {Dom {f}} {Cod {f}} {f} p y))", "completion": "inv_this_ap p (inve p x * {G} inve p y)"}
{"prompt": "['R : GradedCRing', 'm0 : Nat', 'n : Nat', \"e0' : R.E\", 'l1 : Nat', 'g1^l1=0 : pow {R} g1.1 l1 = R.zro', 'm1 : Nat', 'k0 : Nat', 'd : R.E', 'g1 : Carrier R', 'g0^l0=0 : pow {R} g0.1 l0 = R.zro', 'l0 : Nat', \"e1' : R.E\", 'k1 : Nat', 'u : Nat', 'g0 : Carrier R', 'a : Carrier R']<<<break>>>['| \\\\infixl 6 + E E : E', 'suc Nat', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma pow_+ \\\\hlevels  {this : Monoid} {a : E} {n m : Nat} : pow a (n + m) = pow a n * pow a m ', '| isHomogen E Nat : \\\\Prop', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '| homogen-zro {n : Nat} : isHomogen zro n', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro_*-right {x : E} : x * zro = zro', '| zro-left {x : E} : zro + x = x', '| E : \\\\Set', '| zro_*-left {x : E} : zro * x = zro', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>R.isHomogen (d R.* (pow {R} g0.1 (k0 Nat.* n Nat.+ l0 AddMonoid.+ m0) R.* e0' R.+ pow {R} g1.1 (k1 Semigroup.* n AddMonoid.+ l1 AddMonoid.+ m1) R.* e1'))\n  (suc a.2 Semigroup.* (u AddMonoid.+ n))", "completion": "rewrite pow_+ (rewrite pow_+ (rewrite pow_+ (rewrite pow_+ (rewrite g0^l0=0 (rewrite g1^l1=0 (simplify homogen-zro))))))"}
{"prompt": "['p : \\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (C1 V) (mkSet {X} U \u2286 V))', 'C : Set (Set (E {\\\\this}))', 'this : StronglyCompleteUniformSpace (StronglyRegularCauchyFilter X1) {\\n  | isOpen => isOpen {coverSpace {X1}}\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | isCauchy => isCCauchy {X1}\\n  | cauchy-open => {?hidden}\\n  | isUniform => \\\\lam (D : Set (Set (E {\\\\this}))) => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C)\\n    (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (D V) (mkSet {X1} U \u2286 V))))\\n  | uniform-cover => {?hidden}\\n  | uniform-top => {?hidden}\\n  | uniform-refine => {?hidden}\\n  | uniform-inter => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | uniform-strongly-star => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}', 'U : Set (E {F.S})', 'CU : C U', 'X : StronglyRegularUniformSpace']<<<break>>>['\\\\func mkSet \\\\hlevels  {X : StronglyRegularCoverSpace} (U : Set X.E) : Set (StronglyRegularCauchyFilter X) \\n  => \\\\lam (F1 : StronglyRegularCauchyFilter X) => F.F U', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\class StronglyRegularCauchyFilter \\\\extends WeaklyCauchyFilter \\\\hlevels  {\\n  | isStronglyRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V s<=< U) (F V))\\n}']<<<break>>>TruncP (\\Sigma (V : Set (E {\\this})) (C V) (mkSet {X} U \u2286 V))", "completion": "p CU"}
{"prompt": "['y : Rat', 'y>=0 : zro <= y', 'xy<d : U {fromRat x * fromRat y} d', 'd : Rat', 'x : Rat']<<<break>>>['\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma *_U \\\\plevels  \\\\hlevels  {x y : ExUpperReal} {a : Rat} :\\n  U {x ExUpperReal.* y} a <-> TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b RatField.* c < a)) ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| <=_*_positive-left {x y z : E} (x <= y) (zro <= z) : x * z <= y * z', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', '| \\\\infixl 7 * E E : E', '| <_*_positive-right {x y z : E} (x > zro) (y < z) : x * y < x * z', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| U Rat : \\\\Prop', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3']<<<break>>>U {fromRat (x * y)} d", "completion": "\\case *_U.1 xy<d \\with {\n  | inP (a, x<a, a>0, b, y<b, b>0, ab<d) =>\n    <=_*_positive-left {RatField} (<=-less x<a) y>=0 <\u2218r <=-less (<_*_positive-right a>0 y<b) <\u2218r ab<d\n}"}
{"prompt": "['P : LocallyRingedFramePres']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| predDomain PredSymb : Array Sort', '| \\\\infix 4 <= E E : \\\\Prop', '| L : Locale', '\\\\func SJoin \\\\hlevels  {this : CompleteLattice} (U : E -> \\\\Prop) : E => Join {\\\\Sigma (b : E) (U b)} (\\\\lam (t : Total {E} U) => t.1)', '\\\\lemma cover-trans1 \\\\hlevels  {P : FramePres} {x : P.E} {J : \\\\Set} {g : J -> P.E} {y : P.E} (_ : Cover1 {P} x y) (_ : Cover {P} y {J} g) :\\n  Cover {P} x {J} g ', '\\\\instance CRingCat : Cat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {RingCat} {CRing} (\\\\new Embedding {CRing} {Ob} (\\\\lam (R : A {\\\\this}) => R) {\\n  | isEmb => \\\\lam (R S : A {\\\\this}) =>\\n  \\\\new Retraction {R = S} {f {\\\\this} R = f {\\\\this} S} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {R} {S}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new CRing (E {p @ i}) {\\n      | zro => zro {p @ i}\\n      | + => (+) {p @ i}\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*) {p @ i}\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | negative => negative {p @ i}\\n      | negative-left => {?hidden}\\n      | ide => ide {p @ i}\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef {p @ i}\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n    })\\n    | f_sec => idpe {R = S}\\n  }\\n})', '| func-op {r : Sort {ModelHom.T}} (h : Symb {ModelHom.T} r) (d : DArray {len {domain {ModelHom.T} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {ModelHom.T} {r} h})) => E {Dom} (at {domain {ModelHom.T} {r} h} j))) : funcs {r} (operation {Dom} {r} h d) = operation {Cod} {r} h (\\\\new DArray {len {domain {Structure.T {Cod}} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => E {Cod} (at {domain {Structure.T {Cod}} {r} h} j))\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => funcs {at {domain {ModelHom.T} {r} h} j} (d.at j)))', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', '| domain {s : Sort} (Symb s) : Array Sort', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', \"\\\\func framePresSite \\\\hlevels  (P : FramePres) : SiteWithBasis P.E {\\n  | Hom => Cover1 {P}\\n  | id => <=-refl\\n  | o => \\\\lam {X Y Z : Ob} (f : Hom Y Z) (g : Hom X Y) => g <=\u2218 f\\n  | pullback => \\\\lam {x1 y1 z1 : P.E} (f1 : Cover1 {P} x1 z1) (g1 : Cover1 {P} y1 z1) => \\\\new Pullback {x1} {y1} {z1} f1 g1 (P.conj x1 y1) {\\n    | pbProj1 => cover-proj1 {P} {apex {\\\\this}} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x {\\\\this}} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {x1})\\n    | pbProj2 => cover-proj2 {P} {P.conj x1 y1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => y1} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {y1})\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {D {\\\\this}}} (p1 : Hom {D {\\\\this}} w (x {\\\\this})) (p2 : Hom {D {\\\\this}} w (y {\\\\this}))\\n      (_ : f {\\\\this} \u2218 p1 = g {\\\\this} \u2218 p2) => cover-prod {P} {w} {x1} {y1} p1 p2\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | isBasicCover => \\\\lam (x : Ob {\\\\this}) {J : \\\\Set} (g : J -> Ob) =>\\n  TruncP (\\\\Sigma (y : P.E) (Cover1 {P} x y) (g' : J -> P.E) (P.BasicCover {J} y g')\\n    (\\\\Pi (j : J) -> \\\\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (g j).1)))\\n} => \\\\new SiteWithBasis {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | basicCover-stable => {?hidden}\\n}\", '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\func modToRing (M : Model theory) : CRing (M.E ()) {\\n  | zro => M.operation {()} 0 nil\\n  | + => \\\\lam (x : BaseSet.E {\\\\this}) (y : BaseSet.E {\\\\this}) => M.operation {()} 2 (x :: y :: nil)\\n  | * => \\\\lam (x : BaseSet.E {\\\\this}) (y : BaseSet.E {\\\\this}) => M.operation {()} 3 (x :: y :: nil)\\n  | negative => \\\\lam (x : BaseSet.E {\\\\this}) => M.operation {()} 4 (x :: nil)\\n  | ide => M.operation {()} 1 nil\\n  | natCoef => natCoefImpl\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| Symb Sort : \\\\Set', '\\\\func catEquiv : CatEquiv (ModelCat theory) CRingCat modToRing {\\n  | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) =>\\n  \\\\new RingHom (Functor.F {\\\\this} X) (Functor.F {\\\\this} Y) {\\n    | func => f.funcs {()}\\n    | func-+ => {?hidden}\\n    | func-ide => {?hidden}\\n    | func-* => {?hidden}\\n  }\\n  | LAdj => functor\\n  | eta => \\\\new NatTrans {D {\\\\this}} {D {\\\\this}} (Id {D {\\\\this}})\\n    (Comp {D {\\\\this}} {Functor.C {\\\\this}} {D {\\\\this}} (\\\\new this6 {}) (LAdj {\\\\this})) {\\n    | trans => id\\n    | natural => {?hidden}\\n  }\\n  | epsilon => \\\\new NatTrans {Functor.C {\\\\this}} {Functor.C {\\\\this}}\\n    (Comp {Functor.C {\\\\this}} {D {\\\\this}} {Functor.C {\\\\this}} (LAdj {\\\\this}) (\\\\new this6 {})) (Id {Functor.C {\\\\this}}) {\\n    | trans => \\\\lam (M : Ob {NatTrans.C {\\\\this}}) => \\\\new ModelHom {theory} (Functor.F {NatTrans.F {\\\\this}} M) (Functor.F {G {\\\\this}} M) {\\n      | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : Structure.E {ModelHom.Dom {\\\\this}} s) => x\\n      | func-op => {?hidden}\\n      | func-rel => {?hidden}\\n    }\\n    | natural => {?hidden}\\n  }\\n  | eta-iso => \\\\lam {X : Ob {D {\\\\this}}} =>\\n  \\\\new Iso {D {\\\\this}} {X} {Functor.F {\\\\this} (Functor.F {LAdj {\\\\this}} X)} (trans {eta {\\\\this}} X) {\\n    | hinv => id X\\n    | hinv_f => {?hidden}\\n    | f_hinv => {?hidden}\\n  }\\n  | epsilon-iso => \\\\lam {Y : Ob {Functor.C {\\\\this}}} =>\\n  \\\\new Iso {Functor.C {\\\\this}} {Functor.F {LAdj {\\\\this}} (Functor.F {\\\\this} Y)} {Y} (trans {epsilon {\\\\this}} Y) {\\n    | hinv => \\\\new ModelHom {theory} (cod {\\\\this}) (dom {\\\\this}) {\\n      | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (y : Structure.E {ModelHom.Dom {\\\\this}} s) => y\\n      | func-op => {?hidden}\\n      | func-rel => {?hidden}\\n    }\\n    | hinv_f => {?hidden}\\n    | f_hinv => {?hidden}\\n  }\\n} => \\\\new CatEquiv {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | eta_epsilon-left => {?hidden}\\n  | eta_epsilon-right => {?hidden}\\n}', '| len : Nat', '| Hom Ob Ob : \\\\Set', '\\\\func EitherInv (L1 : RingedLocale) {a b : E {L.L}} (p : b <= a) (x : E {Functor.F {VPresheaf.F {L.R}} a}) : \\\\Prop \\n  => Inv {Functor.F {VPresheaf.F {L.R}} b} (func {Func {VPresheaf.F {L.R}} {a} {b} p} x) || Inv {Functor.F {VPresheaf.F {L.R}} b} (func {Func {VPresheaf.F {L.R}} {a} {b} p} x + ide {Functor.F {VPresheaf.F {L.R}} b})', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| F (Ob {C}) : Ob {D}', '| R : VSheaf CRingCat L', '\\\\lemma dir \\\\plevels  \\\\hlevels  {A B : \\\\Prop} (_ : A = B) (_ : A) : B ', '| R : VSheaf CRingCat (framePresSite P)', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func limitStructure (T : Theory) {J : Precat} (G : Functor J (ModelPrecat T)) :\\nStructure T (\\\\lam (s : Sort {Structure.T {\\\\this}}) => \\\\Sigma (P : \\\\Pi (j : J.Ob) -> E {G.F j} s)\\n  (\\\\Pi {j j' : J.Ob} -> \\\\Pi (h : J.Hom j j') -> funcs {G.Func {j} {j'} h} {s} (P j) = P j')) {\\n  | operation => \\\\lam {r : Sort {Structure.T {\\\\this}}} (h : Symb {Structure.T {\\\\this}} r)\\n    (d : DArray {len {domain {Structure.T {\\\\this}} {r} h}}\\n      (\\\\lam (j : Fin (len {domain {Structure.T {\\\\this}} {r} h})) => E {\\\\this} (at {domain {Structure.T {\\\\this}} {r} h} j))) =>\\n  (\\\\lam (j : J.Ob) => operation {G.F j} {r} h (\\\\new DArray {len {domain {Structure.T {G.F j}} {r} h}}\\n    (\\\\lam (j1 : Fin (len {domain {Structure.T {G.F j}} {r} h})) => E {G.F j} (at {domain {Structure.T {G.F j}} {r} h} j1))\\n    (\\\\lam (k : Fin (len {domain {Structure.T {G.F j}} {r} h})) => (d.at k).1 j)),\\n    \\\\lam {j : J.Ob} {j' : J.Ob} (f : J.Hom j j') =>\\n    func-op {G.Func {j} {j'} f} {r} h (\\\\new DArray {len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h}}\\n      (\\\\lam (j1 : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) =>\\n        E {Dom {G.Func {j} {j'} f}} (at {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h} j1))\\n      (\\\\lam (k : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) => (d.at k).1 j)) *> path (\\\\lam (i : I) => operation {G.F j'} {r} h\\n      (\\\\new DArray {len {T.domain {r} h}} (\\\\lam (j : Fin (len {T.domain {r} h})) => E {G.F j'} (T.domain {r} h !! j))\\n        (\\\\lam (j1 : Fin (len {T.domain {r} h})) => (d.at j1).2 {j} {j'} f @ i))))\\n  | relation => \\\\lam (P : PredSymb {Structure.T {\\\\this}}) (d : DArray {len {predDomain {Structure.T {\\\\this}} P}}\\n    (\\\\lam (j : Fin (len {predDomain {Structure.T {\\\\this}} P})) => E {\\\\this} (at {predDomain {Structure.T {\\\\this}} P} j))) =>\\n  \\\\Pi (j : J.Ob) -> relation {G.F j} P (\\\\new DArray {len {predDomain {Structure.T {G.F j}} P}}\\n    (\\\\lam (j1 : Fin (len {predDomain {Structure.T {G.F j}} P})) => E {G.F j} (at {predDomain {Structure.T {G.F j}} P} j1))\\n    (\\\\lam (k : Fin (len {predDomain {Structure.T {G.F j}} P})) => (d.at k).1 j))\\n} => \\\\new Structure\", '| P : FramePres', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func (E {Dom}) : E {Cod}', '\\\\lemma limitStructureTruth {T1 : Theory} {J : Precat} {G : Functor J (ModelPrecat T1)} {V : T.Sort -> \\\\Set} {rho : Env {limitStructure T1 {J} G} V}\\n  (phi : Formula {T1} V) :\\n  isFormulaTrue {limitStructure T1 {J} G} {V} rho phi = (\\\\Pi (j : J.Ob) -> isFormulaTrue {G.F j} {V} (\\\\lam {s : Sort {T {G.F j}}} (v : V s) => (rho {s} v).1 j) phi) ', '\\\\func limFunctor \\\\hlevels  {P : FramePres} {D : CompleteCat} {F : VSheaf D (framePresSite P)} (b : E) :\\nFunctor (Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})\\n  D (\\\\lam (X : Ob {C {\\\\this}}) => Functor.F {F.F} (Functor.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => Func {F.F} {Functor.F X} {Functor.F Y} (Func {X} {Y} f)\\n} => Comp {Precat.op {subPrecat {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)}}\\n  {Precat.op {framePresSite P}} {D} F.F\\n  (Functor.op {embedding {framePresSite P} {\\\\Sigma (x : P.E) (embed {P} x <= b)} (\\\\lam (t : \\\\Sigma (x : P.E) (embed {P} x <= b)) => t.1)})', '| Sort : \\\\Set', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func Cover1 \\\\hlevels  {P : FramePres} (x y : P.E) : \\\\Prop => Cover {P} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => y)', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', \"\\\\instance ModelCat (T : Theory) : BicompleteCat (Model T) {\\n  | Hom => ModelHom {T}\\n  | id => \\\\lam (M : Ob) => \\\\new ModelHom {T} M M {\\n    | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => x\\n    | func-op => {?hidden}\\n    | func-rel => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => \\\\new ModelHom {T} X Z {\\n    | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => g.funcs {s} (f.funcs {s} x)\\n    | func-op => {?hidden}\\n    | func-rel => {?hidden}\\n  }\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => Product.fromLimit {Empty} (limit {\\\\this} {DiscretePrecat Empty} (Product.functor {Empty} (absurd {Ob {\\\\this}})))\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G1 : Functor J this6) =>\\n  \\\\new Limit {J} G1 (\\\\new Model T (\\\\lam (s : Sort {Structure.T}) => \\\\Sigma (P : \\\\Pi (j : J.Ob) -> E {G.F j} s)\\n    (\\\\Pi {j j' : J.Ob} -> \\\\Pi (h : J.Hom j j') -> funcs {G.Func {j} {j'} h} {s} (P j) = P j')) {\\n    | operation => \\\\lam {r : Sort {Structure.T}} (h : Symb {Structure.T} r) (d : DArray {len {domain {Structure.T} {r} h}}\\n      (\\\\lam (j : Fin (len {domain {Structure.T} {r} h})) => E (at {domain {Structure.T} {r} h} j))) =>\\n    (\\\\lam (j : J.Ob) => operation {G.F j} {r} h (\\\\new DArray {len {domain {Structure.T {G.F j}} {r} h}}\\n      (\\\\lam (j1 : Fin (len {domain {Structure.T {G.F j}} {r} h})) => E {G.F j} (at {domain {Structure.T {G.F j}} {r} h} j1))\\n      (\\\\lam (k : Fin (len {domain {Structure.T {G.F j}} {r} h})) => (d.at k).1 j)),\\n      \\\\lam {j : J.Ob} {j' : J.Ob} (f : J.Hom j j') =>\\n      func-op {G.Func {j} {j'} f} {r} h (\\\\new DArray {len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h}}\\n        (\\\\lam (j1 : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) =>\\n          E {Dom {G.Func {j} {j'} f}} (at {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h} j1))\\n        (\\\\lam (k : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) => (d.at k).1 j)) *> path (\\\\lam (i : I) => operation {G.F j'} {r} h\\n        (\\\\new DArray {len {T.domain {r} h}} (\\\\lam (j : Fin (len {T.domain {r} h})) => E {G.F j'} (T.domain {r} h !! j))\\n          (\\\\lam (j1 : Fin (len {T.domain {r} h})) => (d.at j1).2 {j} {j'} f @ i))))\\n    | relation => \\\\lam (P : PredSymb {Structure.T}) (d : DArray {len {predDomain {Structure.T} P}}\\n      (\\\\lam (j : Fin (len {predDomain {Structure.T} P})) => E (at {predDomain {Structure.T} P} j))) =>\\n    \\\\Pi (j : J.Ob) -> relation {G.F j} P (\\\\new DArray {len {predDomain {Structure.T {G.F j}} P}}\\n      (\\\\lam (j1 : Fin (len {predDomain {Structure.T {G.F j}} P})) => E {G.F j} (at {predDomain {Structure.T {G.F j}} P} j1))\\n      (\\\\lam (k : Fin (len {predDomain {Structure.T {G.F j}} P})) => (d.at k).1 j))\\n    | isModel => {?hidden}\\n  }) {\\n    | coneMap => \\\\lam (j : Ob {Cone.J {\\\\this}}) => \\\\new ModelHom {T} (apex {\\\\this}) (F {G {\\\\this}} j) {\\n      | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (P : E {Dom {\\\\this}} s) => P.1 j\\n      | func-op => {?hidden}\\n      | func-rel => {?hidden}\\n    }\\n    | coneCoh => {?hidden}\\n    | isLimit => {?hidden}\\n    | limMap => \\\\lam {z : Ob {D {\\\\this}}} (c : Cone {Cone.J {\\\\this}} {D {\\\\this}} (G {\\\\this}) z) => \\\\new ModelHom {T} z (apex {\\\\this}) {\\n      | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => (\\\\lam (j : J.Ob) => funcs {c.coneMap j} {s} x,\\n        \\\\lam {j j' : J.Ob} (f : J.Hom j j') => path (\\\\lam (p0 : I) => funcs {c.coneCoh {j} {j'} f @ p0} {s} x))\\n      | func-op => {?hidden}\\n      | func-rel => {?hidden}\\n    }\\n    | limBeta => {?hidden}\\n    | limUnique => {?hidden}\\n  }\\n  | colimit => \\\\lam {J : Precat} (G1 : Functor J this6) => (\\n    \\\\let data => \\\\new ColimitData {J} {T} G1\\n    \\\\in \\\\new Limit {Precat.op {J}} {Precat.op} (Functor.op {G1}) (Colimit {data}) {\\n          | coneMap => colimitMap {data}\\n          | coneCoh => {?hidden}\\n          | isLimit => {?hidden}\\n          | limMap => limMap-impl\\n          | limBeta => {?hidden}\\n          | limUnique => {?hidden}\\n        })\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}\", '\\\\func Sequent {S : Signature} : \\\\1-Type \\n  => \\\\Sigma (V : S.Sort -> \\\\Set) (FinSet (\\\\Sigma (s : S.Sort) (V s))) (Array (Formula {S} V)) (Formula {S} V)', '\\\\instance theory : Theory {\\n  | Sort => \\\\Sigma\\n  | Symb => \\\\lam (_ : Sort {\\\\this}) => Fin 5\\n  | domain => \\\\lam {s : Sort {\\\\this}} (p0 : Symb {\\\\this} s) => (\\\\case p0 \\\\with {\\n    | zero => nil\\n    | suc zero => nil\\n    | suc (suc zero) => () :: () :: nil\\n    | suc (suc (suc zero)) => () :: () :: nil\\n    | suc (suc (suc (suc zero))) => () :: nil\\n  })\\n  | PredSymb => Empty\\n  | predDomain => absurd {Array (Sort {\\\\this})}\\n  | axioms => arraySubset {Sequent} ((\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n    | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n  }) (SigmaFin UnitFin (\\\\lam (_ : E) => UnitFin)) right} {}, nil,\\n    equality {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 2\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 0} 0 nil :: var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 1} () :: nil))\\n      (var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} ())) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 3, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n    }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 3)) right} {}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()}\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 2 (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 0} 2\\n        (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 2} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 2} 1} 1 :: nil) :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 1} 2 :: nil))\\n      (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 2\\n        (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 0} 0 :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 1} 2\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 2} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 2} 1} 2 :: nil) :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n      | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n    }) (SigmaFin UnitFin (\\\\lam (_ : E) => UnitFin)) right} {}, nil,\\n      equality {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 3\\n        (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 3} 0} 1 nil :: var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 3} 1} () :: nil))\\n        (var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} ())) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 3, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n      }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 3)) right} {}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()}\\n        (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 3 (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 0} 3\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 0} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 0} 3} 1} 1 :: nil) :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 1} 2 :: nil))\\n        (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 3\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 0} 0 :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 1} 3\\n            (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 3} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 3} 1} 2 :: nil) :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 2, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n        | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n      }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 2)) right} {}, nil,\\n        equality {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 2\\n          (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 1} 1 :: nil))\\n          (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 2\\n            (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 2} 1} 0 :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 2, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n          | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n        }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 2)) right} {}, nil,\\n          equality {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 3\\n            (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 1} 1 :: nil))\\n            (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {()} 3\\n              (var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 2} {at {domain {\\\\this} {()} 3} 1} 0 :: nil))) :: (\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n          }) (SigmaFin UnitFin (\\\\lam (_ : E) => UnitFin)) right} {}, nil, equality {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()}\\n            (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 2 (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 0} 4\\n              (var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 4} 0} () :: nil) :: var {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {at {domain {\\\\this} {()} 2} 1} () :: nil))\\n            (apply {\\\\lam (_ : Sort {\\\\this}) => \\\\Sigma} {()} 0 nil)) :: (\\\\lam (_ : Sort {\\\\this}) => Fin 3, \\\\new finSet {coe (\\\\lam (i : I) => FinSet (\\\\Sigma E E) {\\n            | finCard => FinSum_replicate {NatSemiring} {UnitFin} {finCard} @ i\\n          }) (SigmaFin UnitFin (\\\\lam (_ : E) => FinFin 3)) right} {}, nil,\\n            equality {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 3\\n              (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 0} 0 :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 3} 1} 2\\n                (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 2} 0} 1 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 3} 1} 2} 1} 2 :: nil) :: nil))\\n              (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {()} 2 (apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 0} 3\\n                (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 0} 3} 1} 1 :: nil) :: apply {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {()} 2} 1} 3\\n                (var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 3} 0} 0 :: var {\\\\lam (_ : Sort {\\\\this}) => Fin 3} {at {domain {\\\\this} {at {domain {\\\\this} {()} 2} 1} 3} 1} 2 :: nil) :: nil))) :: nil)\\n} => \\\\new Theory', '| isModel (S : Sequent {T}) (axioms {T} S) : isSequentTrue S', \"\\\\func isFormulaTrue \\\\hlevels  {this2 : Structure} {V2 : Sort {T} -> \\\\Set} (_ : Env V2) (_ : Formula {T} V2) : \\\\Prop \\n  | {this}, {V}, rho, equality {s} t t' => interpret {V} rho {s} t = interpret {V} rho {s} t'\\n  | {this}, {V}, rho, predicate P d =>\\n  relation P (\\\\new DArray {len {predDomain {T} P}} (\\\\lam (j : Fin (len {predDomain {T} P})) => E (at {predDomain {T} P} j))\\n    (\\\\lam (j : Fin (len {predDomain {T} P})) => interpret {V} rho {at {predDomain {T} P} j} (d.at j)))\", '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| bottom : E', '\\\\func subPrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} {X : \\\\hType} (f : X -> C.Ob) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => C.Hom (f x) (f y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => C.id (f x)\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} => (C.\u2218)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Env \\\\hlevels  {this : Structure} (V : Sort {T} -> \\\\Set) : \\\\Set => \\\\Pi {s : Sort {T}} -> V s -> E s', '| isLocallyRingedPres (a : E {P}) (x : E {Functor.F {VPresheaf.F {R}} a}) : SCover {P} a (\\\\lam (b : E {P}) => \\\\Sigma (p : Cover1 {P} b a)\\n  (Inv {Functor.F {VPresheaf.F {R}} b} (func {Func {VPresheaf.F {R}} {a} {b} p} x) || Inv {Functor.F {VPresheaf.F {R}} b} (func {Func {VPresheaf.F {R}} {a} {b} p} x + ide {Functor.F {VPresheaf.F {R}} b})))', '\\\\instance CRingBicat : BicompleteCat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => Product.fromLimit {Empty} (limit {\\\\this} {DiscretePrecat Empty} (Product.functor {Empty} (absurd {Ob {\\\\this}})))\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => CompletePrecat.applyEquiv {ModelCat theory} catEquiv\\n  | colimit => CocompletePrecat.applyEquiv {ModelCat theory} catEquiv\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| PredSymb : \\\\Set', '\\\\func ringtoMod (R : CRing) : Model theory (\\\\lam (_ : Sort {T {\\\\this}}) => R.E) {\\n  | operation => \\\\lam {r : Sort {T {\\\\this}}} (p0 : Symb {T {\\\\this}} r) => (\\\\case p0 \\\\with {\\n    | zero => \\\\lam (_ : Array R.E (len {domain {r} 0})) => R.zro\\n    | suc zero => \\\\lam (_ : Array R.E (len {domain {r} 1})) => R.ide\\n    | suc (suc zero) => \\\\lam (l : Array R.E (len {domain {r} 2})) => l.at 0 R.+ l.at 1\\n    | suc (suc (suc zero)) => \\\\lam (l : Array R.E (len {domain {r} 3})) => l.at 0 R.* l.at 1\\n    | suc (suc (suc (suc zero))) => \\\\lam (l : Array R.E (len {domain {r} 4})) => R.negative (l.at 0)\\n  })\\n  | relation => \\\\lam (p0 : PredSymb {T {\\\\this}}) => (\\\\case p0 \\\\with {})\\n} => \\\\new Model {\\n  | isModel => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func toPresented {P3 : RingedFramePres} {a2 b2 : E {P.P}} (p2 : Cover1 {P.P} b2 a2) (U2 : E) (Ua2 : U2.1 a2) (x2 : E {apex})\\n  (_ : LocallyRingedFramePres.EitherInv P3 {a2} {b2} p2 (x2.1 (a2, \\\\lam {z : E {P.P}} (c : (embed {P.P} a2).1 z) =>\\n    U2.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U2.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U2.1 x)) => t.1} {a2} c\\n      (cover-inj {P.P} {a2} {\\\\Sigma (x : E {P.P}) (U2.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U2.1 x)) => t.1} (a2, Ua2)\\n        (idp {E {P.P}} {a2})))))) : LocallyRingedLocale.EitherInv\\n  (ringedLocaleFromPres P3) {U2} {embed {P.P} b2} (\\\\lam {z : E {P.P}} (c : (embed {P.P} b2).1 z) =>\\n  U2.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U2.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U2.1 x)) => t.1} {b2} c\\n    (cover-trans1 {P.P} {b2} {\\\\Sigma (x : E {P.P}) (U2.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U2.1 x)) => t.1} {a2} p2\\n      (cover-inj {P.P} {a2} {\\\\Sigma (x : E {P.P}) (U2.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U2.1 x)) => t.1} (a2, Ua2)\\n        (idp {E {P.P}} {a2}))))) x2 \\n  | {P1}, {a}, {b}, p, U, Ua, x, byLeft i =>\\n  byLeft {Inv {Functor.F {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} (embed {P.P} b)}\\n    (func {Func {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} {U} {embed {P.P} b}\\n      (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n      U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n        (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n          (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))}\\n      x)}\\n    {Inv {Functor.F {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} (embed {P.P} b)}\\n      (func {Func {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} {U} {embed {P.P} b}\\n        (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n        U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n          (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n            (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))}\\n        x + ide {Functor.F {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} (embed {P.P} b)})}\\n    (limInv {P.P} P.R b {func {Func {U} {embed {P.P} b} (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n      U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n        (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n          (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))}\\n      x}\\n      (transport {E {Functor.F {VPresheaf.F {P.R}} b}}\\n        (\\\\lam (val : E {Functor.F {VPresheaf.F {P.R}} b}) => Inv {Functor.F {VPresheaf.F {P.R}} b} val)\\n        {funcs {Func {(a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n          U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n            (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))}\\n            {(b, <=-refl {embed {P.P} b} <=\u2218 (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n            U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n              (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n                (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))))}\\n            p} {()} (x.1 (a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n          U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n            (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))}\\n        {x.1 (b, <=-refl {embed {P.P} b} <=\u2218 (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n          U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n            (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n              (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))))}\\n        (x.2 {(a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n          U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n            (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))}\\n            {(b, <=-refl {embed {P.P} b} <=\u2218 (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n            U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n              (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n                (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))))}\\n            p) i))\\n  | {P1}, {a}, {b}, p, U, Ua, x, byRight i =>\\n  byRight {Inv {Functor.F {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} (embed {P.P} b)}\\n    (func {Func {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} {U} {embed {P.P} b}\\n      (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n      U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n        (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n          (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))}\\n      x)}\\n    {Inv {Functor.F {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} (embed {P.P} b)}\\n      (func {Func {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} {U} {embed {P.P} b}\\n        (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n        U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n          (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n            (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))}\\n        x + ide {Functor.F {VPresheaf.F {RingedLocale.R {ringedLocaleFromPres P1}}} (embed {P.P} b)})}\\n    (limInv {P.P} P.R b {func {Func {U} {embed {P.P} b} (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n      U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n        (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n          (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))}\\n      x + ide}\\n      (transport {E {Functor.F {VPresheaf.F {P.R}} b}}\\n        (\\\\lam (val : E {Functor.F {VPresheaf.F {P.R}} b}) => Inv {Functor.F {VPresheaf.F {P.R}} b} val)\\n        {funcs {Func {(a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n          U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n            (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))}\\n            {(b, <=-refl {embed {P.P} b} <=\u2218 (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n            U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n              (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n                (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))))}\\n            p} {()} (x.1 (a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n          U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n            (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))) + ide {Functor.F {VPresheaf.F {P.R}} b}}\\n        {x.1 (b, <=-refl {embed {P.P} b} <=\u2218 (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n          U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n            (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n              (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))) + ide {Functor.F {VPresheaf.F {P.R}} b}}\\n        (pmap {E {Functor.F {VPresheaf.F {P.R}} b}} {E {Functor.F {VPresheaf.F {P.R}} b}}\\n          (\\\\lam (_x : E {Functor.F {VPresheaf.F {P.R}} b}) => _x + ide {Functor.F {VPresheaf.F {P.R}} b})\\n          {funcs {Func {(a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n            U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n              (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))}\\n              {(b, <=-refl {embed {P.P} b} <=\u2218 (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n              U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n                (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n                  (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))))}\\n              p} {()} (x.1 (a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n            U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n              (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))}\\n          {x.1 (b, <=-refl {embed {P.P} b} <=\u2218 (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n            U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n              (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n                (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))))}\\n          (x.2 {(a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n            U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n              (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))}\\n              {(b, <=-refl {embed {P.P} b} <=\u2218 (\\\\lam {z : E {P.P}} (c : (embed {P.P} b).1 z) =>\\n              U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {b} c\\n                (cover-trans1 {P.P} {b} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} p\\n                  (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))))}\\n              p)) i))', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| F : Functor (op {C}) D', '| LAdj : Functor D C', '| axioms Sequent : \\\\Prop', '| ide : E', '\\\\class Model \\\\extends Structure {\\n  | isModel (S : Sequent {T}) (axioms {T} S) : isSequentTrue S\\n}', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '| zro : E', '\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '| operation {r : Sort {T}} (h : Symb {T} r)\\n  (DArray {len {domain {T} {r} h}} (\\\\lam (j : Fin (len {domain {T} {r} h})) => E (at {domain {T} {r} h} j))) : E r', '\\\\lemma conv \\\\plevels  \\\\hlevels  {A B : \\\\Prop} (_ : A = B) (_ : B) : A ', 'cover-inj (j : J) (g j = x)', '\\\\class LocallyRingedLocale \\\\extends RingedLocale {\\n  | isNonTrivial (a : E {L}) (zro {Functor.F {VPresheaf.F {R}} a} = ide {Functor.F {VPresheaf.F {R}} a}) : a <= bottom {L}\\n  | isLocallyRinged (a : E {L}) (x : E {Functor.F {VPresheaf.F {R}} a}) : a <= SJoin {L} (\\\\lam (b : E {L}) => \\\\Sigma (p : b <= a) (EitherInv \\\\this {a} {b} p x))\\n}', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\lemma sheafOnPresentedFrame \\\\hlevels  {P : FramePres} {D : CompleteCat} (F : VSheaf D (framePresSite P)) : VSheaf D (PresentedFrame P) (extend {P} {D} {F}) ', '| funcs {s : Sort {T}} (E {Dom} s) : E {Cod} s', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| isNonTrivialPres (a : E {P}) (zro {Functor.F {VPresheaf.F {R}} a} = ide {Functor.F {VPresheaf.F {R}} a}) : Cover {P} a {Empty} (absurd {E {P}})', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| relation (P : PredSymb {T})\\n  (DArray {len {predDomain {T} P}} (\\\\lam (j : Fin (len {predDomain {T} P})) => E (at {predDomain {T} P} j))) : \\\\Prop']<<<break>>>LocallyRingedLocale (PresentedFrame P.P) (sheafOnPresentedFrame {P.P} {CRingBicat} P.R) {\n  | isNonTrivial => {?hidden}\n  | isLocallyRinged => {?hidden}\n}", "completion": "\\new LocallyRingedLocale {\n  | RingedLocale => ringedLocaleFromPres P\n  | isNonTrivial => \\lam U t {x} Ux =>\n    cover-trans (isNonTrivialPres x $ pmap (\\lam p0 => p0.1 (x, \\lam {y} c => U.2 y $ cover-trans1 c $ cover-inj (x, Ux) idp)) t) (\\lam p0 => (\\case p0 \\with {}))\n  | isLocallyRinged => \\lam U x {a} Ua =>\n  cover-trans (isLocallyRingedPres a (x.1 (a, \\lam {z} c => U.2 z $ cover-trans1 c $ cover-inj (a, Ua) idp))) (\\lam t => cover-inj ((embed t.1,\n    (\\lam {z} c => U.2 z $ cover-trans1 c $ cover-trans1 t.2.1 $ cover-inj (a, Ua) idp, toPresented t.2.1 U Ua x t.2.2)),\n    t.1, cover-inj () idp) idp)\n}"}
{"prompt": "['p : suc (suc (suc m)) <= 2', 'n : Nat', 'R : CRing', 'm : Nat']<<<break>>>['true', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\lemma solveContrProblem \\\\hlevels  {this : LinearData} (p : Problem) (_ : CorrectCert p) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) : Empty ', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'LessOrEquals', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', '\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', ':ide', '| at (j : Fin len) : A j', ':zro', '| E : \\\\Set', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\class LinearSemiringData \\\\extends LinearData, SemiringData \\\\hlevels ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '| zro : E', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\type IsDiagonal \\\\hlevels  {R : AddPointed} {n m : Nat} (A : Matrix R.E n m) : \\\\Prop \\n  => \\\\Pi {i : Fin n} -> \\\\Pi {j : Fin m} -> i /= j -> at {at {A} i} j = R.zro', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\type \\\\infix 4 M~ \\\\hlevels  {R : Ring} {n m : Nat} (A B : Matrix R.E n m) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (B = C.val product A product D.val))']<<<break>>>\\Pi (A : Matrix R.E n (suc (suc (suc m)))) ->\n  TruncP (\\Sigma (B : Matrix R.E n (suc (suc (suc m)))) (IsDiagonal {R} {n} {suc (suc (suc m))} B) (A M~ B))", "completion": "absurd linarith"}
{"prompt": "['p : Big {E} {E} (\u2228) (l.at 0) (tail {E} l) < l !! j + eps', 'lj<x+2eps : l.at j < x + natCoef 2 * eps', 'y : Real', 'A : Set Real', 'lt : Array Real n', 'l : Array Real (suc n)', 'j : Fin l.len', 'x : Real', 'eps : Real', 'n : Nat', 'lb : \\\\Pi {x : Real} -> A x -> TruncP (\\\\Sigma (j : Fin (suc lt.len)) (abs {RealField} (x - (lh :: lt) !! j) < eps))', 'lh : Real']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set', '| negative E : E', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '\\\\lemma Big_<=_join \\\\hlevels  {this : JoinSemilattice} {n : Nat} {l : Array E (suc n)} (i : Fin (suc n)) :\\n  l.at i <= Big {E} {E} (\u2228) (l.at 0) (tail {E} l) ', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', 'join \\\\plevels  \\\\hlevels  (x y : Real) : Real => \\\\new Real (L {InfRealAbMonoid.join x y}) (U {InfRealAbMonoid.join x y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\data Empty \\\\plevels  \\\\hlevels  ', 'LessOrEquals', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\lemma abs>=id \\\\hlevels  {this : LatticeAbGroup} {x : E} : x <= abs x ', '| \\\\infix 4 < E E : \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'byRight B', 'pos Nat', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>(\\Sigma (a1 : Real) (A a1) (x < a1)) || (\\Pi {a1 : Real} -> A a1 -> a1 < y)", "completion": "byRight (\\lam {a} Aa => (\\case lb Aa \\with {\n  | inP (k, q) => linarith (abs>=id {_} {a - l k}, Big_<=_join {RealAbGroup} k)\n}))"}
{"prompt": "['e : Sym (suc n)', 'n : Nat']<<<break>>>['\\\\func inversions \\\\plevels  \\\\hlevels  {n1 : Nat} (_ : Sym n1) : Nat \\n  | {0}, e => 0\\n  | {suc n}, e => f {e} 0 + inversions {n} (reduce {n} e)', '| A : \\\\Type', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\lemma <_skip \\\\plevels  \\\\hlevels  {n : Nat} {x0 x x' : Fin (suc n)} {d : x0 /= x} {d' : x0 /= x'} (_ : x < x') : skip {n} x0 x d < skip {n} x0 x' d' \", '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '| ret B : A', '\\\\func \\\\infixr 3 transEquiv {A1 B1 C : \\\\Type} (e1 : Equiv {A1} {B1}) (e2 : Equiv {B1} {C}) : Equiv {A1} {C} (\\\\lam (x : A {\\\\this}) => e2.f (e1.f x)) {\\n  | ret => \\\\lam (y : B {\\\\this}) => e1.ret (e2.ret y)\\n  | ret_f => \\\\lam (x : A {\\\\this}) => pmap {B1} {A1} e1.ret {e2.ret (e2.f (e1.f x))} {e1.f x} (e2.ret_f (e1.f x)) *> e1.ret_f x\\n  | sec => \\\\lam (y : B {\\\\this}) => e1.sec (e2.sec y)\\n  | f_sec => \\\\lam (y : B {\\\\this}) => pmap {B1} {C} e2.f {e1.f (e1.sec (e2.sec y))} {e2.sec y} (e1.f_sec (e2.sec y)) *> e2.f_sec y\\n} => \\\\new Equiv', 'inr B', \"\\\\func toFin' \\\\plevels  \\\\hlevels  {k1 n1 : Nat} (_ : k1 < n1) : Fin n1 \\n  | {k}, {suc n}, p => k mod suc n\", \"\\\\func aux {n1 : Nat} (e2 : Sym n1) : Equiv {Fin (inversions {n1} e2)} {Inversions {n1} e2} \\n  | {0}, e => \\\\new QEquiv {Fin (inversions {0} e)} {Inversions {0} e} (\\\\lam (p0 : A {\\\\this}) => (\\\\case p0 \\\\with {})) {\\n    | ret => \\\\lam (t : B {\\\\this}) => t.1\\n    | ret_f => \\\\lam (p0 : A {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | f_sec => \\\\lam (t : B {\\\\this}) => (\\\\case t.1 \\\\with {})\\n  }\\n  | {suc n}, e => transEquiv {Fin (f {e} 0 + inversions {n} (reduce {n} e))} {Or (Fin (f {e} 0)) (Fin (inversions {n} (reduce {n} e)))}\\n    {\\\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)} (OrFin.aux {f {e} 0} {inversions {n} (reduce {n} e)})\\n    (transEquiv {Or (Fin (f {e} 0)) (Fin (inversions {n} (reduce {n} e)))} {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\\n      {\\\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\\n      (Or_Equiv (idEquiv {Fin (f {e} 0)}) (sign.InversionsFin.aux {n} (reduce {n} e))) (\\n        \\\\have lem => \\\\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\\n        \\\\in \\\\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\\n              (\\\\lam (p0 : A {\\\\this}) => (\\\\case p0 \\\\with {\\n                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\\n                  (\\\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\\n                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\\n                    (fin_< {f {e} 0} a))),\\n                  transportInv {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\\n                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\\n                  {\\\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\\\case isInj {e} {0} {suc b.2} p \\\\with {})}\\n                  {\\\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\\\case isInj {e} {0} {suc b.1} p \\\\with {})} b.4)\\n              })) {\\n              | ret => \\\\lam (p0 : B {\\\\this}) => (\\\\case p0 \\\\with {\\n                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\\n                | (suc i, zero, (), _x)\\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\\n                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\\n                  {\\\\lam (p : f {e} 0 = f {e} (suc j)) => (\\\\case isInj {e} {0} {suc j} p \\\\with {})}\\n                  {\\\\lam (p : f {e} 0 = f {e} (suc i)) => (\\\\case isInj {e} {0} {suc i} p \\\\with {})} ej+1<ei+1)\\n              })\\n              | ret_f => \\\\lam (p0 : A {\\\\this}) => (\\\\case p0 \\\\with {\\n                | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\\n                  (inl {Fin (f {e} 0)} {\\\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\\n                  {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\\n                    (transportInv {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\\n                  {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\\n                    (transportInv {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\\n                    {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\\n                      (transportInv {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\\n                | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\\n                  {\\\\case \\\\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\\\with {\\n                    | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\\n                      (\\\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\\n                        (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\\n                        (fin_< {f {e} 0} a))),\\n                      transportInv {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\\n                    | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\\n                      {\\\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\\\case isInj {e} {0} {suc b.2} p \\\\with {})}\\n                      {\\\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\\\case isInj {e} {0} {suc b.1} p \\\\with {})} b.4)\\n                  } \\\\with {\\n                    | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\\n                    | (suc i, zero, (), _x)\\n                    | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\\n                    inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\\n                      {\\\\lam (p : f {e} 0 = f {e} (suc j)) => (\\\\case isInj {e} {0} {suc j} p \\\\with {})}\\n                      {\\\\lam (p : f {e} 0 = f {e} (suc i)) => (\\\\case isInj {e} {0} {suc i} p \\\\with {})} ej+1<ei+1)\\n                  }}\\n              })\\n              | f_sec => \\\\lam (p0 : B {\\\\this}) => (\\\\case p0 \\\\with {\\n                | (zero, j, j>0, ej<e0) => path (\\\\lam (i : I) => (\\n                  \\\\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\\n                          (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\\n                            (transportInv {Nat} (\\\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\\n                              (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\\n                  \\\\in \\n                        \\\\let | h1 => arg.1\\n                             | h2 => arg.2\\n                        \\\\in (h1 @ i, h2 @ i, prop-dpi (\\\\lam (i : I) => h1 @ i < h2 @ i) (\\\\case \\\\case (0, j, j>0, ej<e0) \\\\with {\\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\\n                              | (suc i, zero, (), _x)\\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\\n                                {\\\\lam (p : f {e} 0 = f {e} (suc j)) => (\\\\case isInj {e} {0} {suc j} p \\\\with {})}\\n                                {\\\\lam (p : f {e} 0 = f {e} (suc i)) => (\\\\case isInj {e} {0} {suc i} p \\\\with {})} ej+1<ei+1)\\n                            } \\\\with {\\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\\n                                (\\\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\\n                                  (fin_< {f {e} 0} a))),\\n                                transportInv {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\\n                                {\\\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\\\case isInj {e} {0} {suc b.2} p \\\\with {})}\\n                                {\\\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\\\case isInj {e} {0} {suc b.1} p \\\\with {})} b.4)\\n                            }).3 j>0 @ i,\\n                              prop-dpi (\\\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\\\case \\\\case (0, j, j>0, ej<e0) \\\\with {\\n                                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\\n                                | (suc i, zero, (), _x)\\n                                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\\n                                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc j)) => (\\\\case isInj {e} {0} {suc j} p \\\\with {})}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc i)) => (\\\\case isInj {e} {0} {suc i} p \\\\with {})} ej+1<ei+1)\\n                              } \\\\with {\\n                                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\\n                                  (\\\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\\n                                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\\n                                    (fin_< {f {e} 0} a))),\\n                                  transportInv {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\\n                                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\\\case isInj {e} {0} {suc b.2} p \\\\with {})}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\\\case isInj {e} {0} {suc b.1} p \\\\with {})} b.4)\\n                              }).4 ej<e0 @ i)))\\n                | (suc i, zero, (), _x)\\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\\\lam (i1 : I) => (\\n                  \\\\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\\n                  \\\\in \\n                        \\\\let | h1 => arg.1\\n                             | h2 => arg.2\\n                        \\\\in (h1 @ i1, h2 @ i1,\\n                              prop-dpi (\\\\lam (i : I) => h1 @ i < h2 @ i) (\\\\case \\\\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\\\with {\\n                                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\\n                                | (suc i, zero, (), _x)\\n                                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\\n                                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc j)) => (\\\\case isInj {e} {0} {suc j} p \\\\with {})}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc i)) => (\\\\case isInj {e} {0} {suc i} p \\\\with {})} ej+1<ei+1)\\n                              } \\\\with {\\n                                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\\n                                  (\\\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\\n                                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\\n                                    (fin_< {f {e} 0} a))),\\n                                  transportInv {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\\n                                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\\\case isInj {e} {0} {suc b.2} p \\\\with {})}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\\\case isInj {e} {0} {suc b.1} p \\\\with {})} b.4)\\n                              }).3 (suc<suc {i} {j} i<j) @ i1,\\n                              prop-dpi (\\\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\\\case \\\\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\\\with {\\n                                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\\n                                | (suc i, zero, (), _x)\\n                                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\\n                                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc j)) => (\\\\case isInj {e} {0} {suc j} p \\\\with {})}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc i)) => (\\\\case isInj {e} {0} {suc i} p \\\\with {})} ej+1<ei+1)\\n                              } \\\\with {\\n                                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\\n                                  (\\\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\\n                                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\\n                                    (fin_< {f {e} 0} a))),\\n                                  transportInv {Nat} (\\\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\\n                                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\\\case isInj {e} {0} {suc b.2} p \\\\with {})}\\n                                  {\\\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\\\case isInj {e} {0} {suc b.1} p \\\\with {})} b.4)\\n                              }).4 ej+1<ei+1 @ i1)))\\n              })\\n            }))\", \"\\\\func isInj {this : Equiv} {a a' : A} (p : f a = f a') : a = a' \\n  => inv {A} {ret (f a)} {a} (ret_f a) *> pmap {B} {A} ret {f a} {f a'} p *> ret_f a'\", '\\\\func f_ret {this : Equiv} (y : B) : f (ret y) = y \\n  => pmap {B} {B} (\\\\lam (y : B) => f (ret y)) {y} {f (sec y)} (inv {B} {f (sec y)} {y} (f_sec y)) *> pmap {A} {B} f {ret (f (sec y))} {sec y} (ret_f (sec y)) *> f_sec y', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '| f_sec (y : B) : f (sec y) = y', '\\\\func Or_Equiv (e1 e2 : Equiv) :\\nQEquiv {Or e1.A e2.A} {Or e1.B e2.B} (\\\\lam (p0 : A {\\\\this}) => map {e1.A} {e2.A} {e1.B} {e2.B} p0 e1.f e2.f) {\\n  | ret => \\\\lam (p0 : B {\\\\this}) => map {e1.B} {e2.B} {e1.A} {e2.A} p0 e1.ret e2.ret\\n  | ret_f => \\\\lam (p0 : A {\\\\this}) => (\\\\case p0 \\\\with {\\n    | inl a => pmap {e1.A} {Or e1.A e2.A} (inl {e1.A} {e2.A}) {e1.ret (e1.f a)} {a} (e1.ret_f a)\\n    | inr b => pmap {e2.A} {Or e1.A e2.A} (inr {e1.A} {e2.A}) {e2.ret (e2.f b)} {b} (e2.ret_f b)\\n  })\\n  | f_sec => \\\\lam (p0 : B {\\\\this}) => (\\\\case p0 \\\\with {\\n    | inl a => pmap {e1.B} {Or e1.B e2.B} (inl {e1.B} {e2.B}) {e1.f (e1.ret a)} {a} (f_ret {e1} a)\\n    | inr b => pmap {e2.B} {Or e1.B e2.B} (inr {e1.B} {e2.B}) {e2.f (e2.ret b)} {b} (f_ret {e2} b)\\n  })\\n} => \\\\new QEquiv', '| ret_f (x : A) : ret (f x) = x', 'inl A', '| f A : B', '\\\\lemma nonZero>0 \\\\plevels  \\\\hlevels  {n : Nat} (_ : n /= 0) : 0 < n ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 8 mod \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n mod m', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', 'suc<suc (n < m)', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| sec B : A', '\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', 'suc Nat', '\\\\func idEquiv {A1 : \\\\Type} : QEquiv {A1} {A1} (\\\\lam (x : A {\\\\this}) => x) {\\n  | ret => \\\\lam (x : B {\\\\this}) => x\\n  | ret_f => \\\\lam (a : A {\\\\this}) => idp {A1} {ret {\\\\this} a}\\n  | f_sec => \\\\lam (b : B {\\\\this}) => idp {A1} {sec {\\\\this} b}\\n} => \\\\new QEquiv', \"\\\\lemma skip_< \\\\plevels  \\\\hlevels  {n : Nat} {x0 x x' : Fin (suc n)} {d : x0 /= x} {d' : x0 /= x'} (_ : skip {n} x0 x d < skip {n} x0 x' d') : x < x' \", '| <-transitive \\\\alias \\\\infixr 9 <\u2218 {x y z : E} (x < y) (y < z) : x < z', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\lemma nat_fin_= \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : x = y) : x = y ', \"\\\\func reduce {n : Nat} (e : Sym (suc n)) : Sym n => isEquiv {FinFin n}\\n  (\\\\lam (j : E) => skip {n} (f {e} 0) (f {e} (suc j)) (\\\\lam (p : f {e} 0 = f {e} (suc j)) => (\\\\case isInj {e} {0} {suc j} p \\\\with {})))\\n  (\\\\lam {a a' : E}\\n    (p : skip {n} (f {e} 0) (f {e} (suc a)) (\\\\lam (p : f {e} 0 = f {e} (suc a)) => (\\\\case isInj {e} {0} {suc a} p \\\\with {})) = skip {n} (f {e} 0) (f {e} (suc a')) (\\\\lam (p : f {e} 0 = f {e} (suc a')) => (\\\\case isInj {e} {0} {suc a'} p \\\\with {}))) =>\\n  unfsuc {n} {a} {a'} (isInj {e} {suc a} {suc a'} (skip-isInj {n} {f {e} 0} {f {e} (suc a)} {f {e} (suc a')}\\n    {\\\\lam (p : f {e} 0 = f {e} (suc a)) => (\\\\case isInj {e} {0} {suc a} p \\\\with {})}\\n    {\\\\lam (p : f {e} 0 = f {e} (suc a')) => (\\\\case isInj {e} {0} {suc a'} p \\\\with {})} p)))\", \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func Inversions \\\\plevels  \\\\hlevels  {n : Nat} (e : Sym n) : \\\\Set0 => \\\\Sigma (i j : Fin n) (i < j) (f {e} j < f {e} i)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func skip \\\\plevels  \\\\hlevels  {n2 : Nat} (x2 x3 : Fin (suc n2)) (_ : x2 /= x3) : Fin n2 \\n  | {n}, zero, zero, d => absurd {Fin n} (d (idp {Fin (suc n)} {0}))\\n  | {n}, zero, suc x, d => x\\n  | {suc n}, suc x0, zero, d => 0\\n  | {suc n}, suc x0, suc x, d =>\\n    suc (skip {n} x0 x (\\\\lam (x0=x : x0 = x) => d (pmap {Fin (suc n)} {Fin (suc (suc n))} suc {x0} {x} x0=x)))', '| <-irreflexive {x : E} : Not (x < x)', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func divMod \\\\plevels  \\\\hlevels  (_ _ : Nat) : \\\\Sigma Nat Nat ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\lemma mod_< \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < m) : n mod m = n ', '| B : \\\\Type', '\\\\class Equiv \\\\extends Section, Retraction', \"\\\\lemma toFin'=id \\\\plevels  \\\\hlevels  {k n : Nat} (p : k < n) : toFin' {k} {n} p = k \"]<<<break>>>Equiv {Or (Fin (f {e} 0)) (Fin (inversions {n} (reduce {n} e)))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n  (\\lam (x : A {\\this}) => f {\n    \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n    \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n          (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                (fin_< {f {e} 0} a))),\n              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n          })) {\n          | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n          })\n          | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n              (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n              {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n              {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n            | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n              {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                    (fin_< {f {e} 0} a))),\n                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n              } \\with {\n                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                | (suc i, zero, (), _x)\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n              }}\n          })\n          | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n              \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                      (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                        (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                          (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                          | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                          | (suc i, zero, (), _x)\n                          | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                          inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                            {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                        } \\with {\n                          | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                            (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                              (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                              (fin_< {f {e} 0} a))),\n                            transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                          | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                        }).3 j>0 @ i,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej<e0 @ i)))\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n              \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i1, h2 @ i1,\n                          prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).3 (suc<suc {i} {j} i<j) @ i1,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej+1<ei+1 @ i1)))\n          })\n        }} (f {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))} x)) {\n  | ret => \\lam (y : B {\\this}) => ret {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))} (ret {\n    \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n    \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n          (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                (fin_< {f {e} 0} a))),\n              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n          })) {\n          | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n          })\n          | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n              (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n              {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n              {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n            | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n              {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                    (fin_< {f {e} 0} a))),\n                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n              } \\with {\n                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                | (suc i, zero, (), _x)\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n              }}\n          })\n          | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n              \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                      (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                        (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                          (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                          | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                          | (suc i, zero, (), _x)\n                          | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                          inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                            {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                        } \\with {\n                          | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                            (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                              (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                              (fin_< {f {e} 0} a))),\n                            transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                          | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                        }).3 j>0 @ i,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej<e0 @ i)))\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n              \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i1, h2 @ i1,\n                          prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).3 (suc<suc {i} {j} i<j) @ i1,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej+1<ei+1 @ i1)))\n          })\n        }} y)\n  | ret_f => \\lam (x : A {\\this}) =>\n  pmap {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {Or (Fin (f {e} 0)) (Fin (inversions {n} (reduce {n} e)))}\n    (ret {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))}) {ret {\n      \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n      \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n            (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                  (fin_< {f {e} 0} a))),\n                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n            })) {\n            | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n              | (suc i, zero, (), _x)\n              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n            })\n            | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n              | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n                (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n                {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                  {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                    (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n              | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n                {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                  | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                    (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                      (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                      (fin_< {f {e} 0} a))),\n                    transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                  | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                    {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                    {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                } \\with {\n                  | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                  | (suc i, zero, (), _x)\n                  | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                  inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                    {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                    {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                }}\n            })\n            | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n              | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n                \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                        (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                          (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                            (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n                \\in \n                      \\let | h1 => arg.1\n                           | h2 => arg.2\n                      \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).3 j>0 @ i,\n                            prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).4 ej<e0 @ i)))\n              | (suc i, zero, (), _x)\n              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n                \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n                \\in \n                      \\let | h1 => arg.1\n                           | h2 => arg.2\n                      \\in (h1 @ i1, h2 @ i1,\n                            prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).3 (suc<suc {i} {j} i<j) @ i1,\n                            prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).4 ej+1<ei+1 @ i1)))\n            })\n          }}\n      (f {\n        \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n        \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n              (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                    (fin_< {f {e} 0} a))),\n                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n              })) {\n              | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                | (suc i, zero, (), _x)\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n              })\n              | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n                | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n                  (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n                  {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                    (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                  {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                    (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                    {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                      (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n                | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n                  {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                    | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                      (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                        (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                        (fin_< {f {e} 0} a))),\n                      transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                    | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                      {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                      {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                  } \\with {\n                    | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                    | (suc i, zero, (), _x)\n                    | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                    inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                      {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                      {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                  }}\n              })\n              | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n                | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n                  \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                          (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                            (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                              (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n                  \\in \n                        \\let | h1 => arg.1\n                             | h2 => arg.2\n                        \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).3 j>0 @ i,\n                              prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                                | (suc i, zero, (), _x)\n                                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                              } \\with {\n                                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                    (fin_< {f {e} 0} a))),\n                                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                              }).4 ej<e0 @ i)))\n                | (suc i, zero, (), _x)\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n                  \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n                  \\in \n                        \\let | h1 => arg.1\n                             | h2 => arg.2\n                        \\in (h1 @ i1, h2 @ i1,\n                              prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                                | (suc i, zero, (), _x)\n                                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                              } \\with {\n                                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                    (fin_< {f {e} 0} a))),\n                                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                              }).3 (suc<suc {i} {j} i<j) @ i1,\n                              prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                                | (suc i, zero, (), _x)\n                                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                              } \\with {\n                                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                    (fin_< {f {e} 0} a))),\n                                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                              }).4 ej+1<ei+1 @ i1)))\n              })\n            }} (f {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))} x))}\n    {f {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))} x} (ret_f {\n      \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n      \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n            (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                  (fin_< {f {e} 0} a))),\n                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n            })) {\n            | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n              | (suc i, zero, (), _x)\n              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n            })\n            | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n              | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n                (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n                {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                  {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                    (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n              | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n                {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                  | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                    (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                      (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                      (fin_< {f {e} 0} a))),\n                    transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                  | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                    {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                    {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                } \\with {\n                  | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                  | (suc i, zero, (), _x)\n                  | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                  inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                    {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                    {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                }}\n            })\n            | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n              | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n                \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                        (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                          (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                            (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n                \\in \n                      \\let | h1 => arg.1\n                           | h2 => arg.2\n                      \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).3 j>0 @ i,\n                            prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).4 ej<e0 @ i)))\n              | (suc i, zero, (), _x)\n              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n                \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n                \\in \n                      \\let | h1 => arg.1\n                           | h2 => arg.2\n                      \\in (h1 @ i1, h2 @ i1,\n                            prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).3 (suc<suc {i} {j} i<j) @ i1,\n                            prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).4 ej+1<ei+1 @ i1)))\n            })\n          }} (f {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))} x)) *> ret_f {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))} x\n  | sec => \\lam (y : B {\\this}) => sec {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))} (sec {\n    \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n    \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n          (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                (fin_< {f {e} 0} a))),\n              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n          })) {\n          | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n          })\n          | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n              (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n              {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n              {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n            | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n              {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                    (fin_< {f {e} 0} a))),\n                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n              } \\with {\n                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                | (suc i, zero, (), _x)\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n              }}\n          })\n          | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n              \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                      (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                        (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                          (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                          | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                          | (suc i, zero, (), _x)\n                          | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                          inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                            {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                        } \\with {\n                          | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                            (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                              (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                              (fin_< {f {e} 0} a))),\n                            transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                          | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                        }).3 j>0 @ i,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej<e0 @ i)))\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n              \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i1, h2 @ i1,\n                          prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).3 (suc<suc {i} {j} i<j) @ i1,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej+1<ei+1 @ i1)))\n          })\n        }} y)\n  | f_sec => \\lam (y : B {\\this}) =>\n  pmap {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)} (f {\n    \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n    \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n          (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                (fin_< {f {e} 0} a))),\n              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n          })) {\n          | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n          })\n          | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n              (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n              {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n              {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n            | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n              {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                    (fin_< {f {e} 0} a))),\n                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n              } \\with {\n                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                | (suc i, zero, (), _x)\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n              }}\n          })\n          | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n              \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                      (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                        (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                          (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                          | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                          | (suc i, zero, (), _x)\n                          | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                          inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                            {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                        } \\with {\n                          | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                            (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                              (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                              (fin_< {f {e} 0} a))),\n                            transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                          | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                        }).3 j>0 @ i,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej<e0 @ i)))\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n              \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i1, h2 @ i1,\n                          prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).3 (suc<suc {i} {j} i<j) @ i1,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej+1<ei+1 @ i1)))\n          })\n        }})\n    {f {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))}\n      (sec {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))} (sec {\n        \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n        \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n              (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                    (fin_< {f {e} 0} a))),\n                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n              })) {\n              | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                | (suc i, zero, (), _x)\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n              })\n              | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n                | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n                  (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n                  {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                    (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                  {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                    (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                    {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                      (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n                | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n                  {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                    | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                      (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                        (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                        (fin_< {f {e} 0} a))),\n                      transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                    | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                      {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                      {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                  } \\with {\n                    | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                    | (suc i, zero, (), _x)\n                    | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                    inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                      {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                      {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                  }}\n              })\n              | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n                | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n                  \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                          (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                            (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                              (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n                  \\in \n                        \\let | h1 => arg.1\n                             | h2 => arg.2\n                        \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).3 j>0 @ i,\n                              prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                                | (suc i, zero, (), _x)\n                                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                              } \\with {\n                                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                    (fin_< {f {e} 0} a))),\n                                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                              }).4 ej<e0 @ i)))\n                | (suc i, zero, (), _x)\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n                  \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n                  \\in \n                        \\let | h1 => arg.1\n                             | h2 => arg.2\n                        \\in (h1 @ i1, h2 @ i1,\n                              prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                                | (suc i, zero, (), _x)\n                                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                              } \\with {\n                                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                    (fin_< {f {e} 0} a))),\n                                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                              }).3 (suc<suc {i} {j} i<j) @ i1,\n                              prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                                | (suc i, zero, (), _x)\n                                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                              } \\with {\n                                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                    (fin_< {f {e} 0} a))),\n                                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                              }).4 ej+1<ei+1 @ i1)))\n              })\n            }} y))}\n    {sec {\n      \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n      \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n            (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                  (fin_< {f {e} 0} a))),\n                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n            })) {\n            | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n              | (suc i, zero, (), _x)\n              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n            })\n            | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n              | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n                (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n                {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                  {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                    (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n              | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n                {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                  | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                    (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                      (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                      (fin_< {f {e} 0} a))),\n                    transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                  | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                    {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                    {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                } \\with {\n                  | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                  | (suc i, zero, (), _x)\n                  | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                  inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                    {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                    {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                }}\n            })\n            | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n              | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n                \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                        (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                          (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                            (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n                \\in \n                      \\let | h1 => arg.1\n                           | h2 => arg.2\n                      \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).3 j>0 @ i,\n                            prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).4 ej<e0 @ i)))\n              | (suc i, zero, (), _x)\n              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n                \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n                \\in \n                      \\let | h1 => arg.1\n                           | h2 => arg.2\n                      \\in (h1 @ i1, h2 @ i1,\n                            prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).3 (suc<suc {i} {j} i<j) @ i1,\n                            prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).4 ej+1<ei+1 @ i1)))\n            })\n          }} y}\n    (f_sec {Or_Equiv (idEquiv {Fin (f {e} 0)}) (aux {n} (reduce {n} e))} (sec {\n      \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n      \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n            (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                  (fin_< {f {e} 0} a))),\n                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n            })) {\n            | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n              | (suc i, zero, (), _x)\n              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n            })\n            | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n              | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n                (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n                {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                  {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                    (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n              | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n                {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                  | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                    (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                      (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                      (fin_< {f {e} 0} a))),\n                    transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                  | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                    {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                    {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                } \\with {\n                  | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                  | (suc i, zero, (), _x)\n                  | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                  inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                    {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                    {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                }}\n            })\n            | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n              | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n                \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                        (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                          (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                            (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n                \\in \n                      \\let | h1 => arg.1\n                           | h2 => arg.2\n                      \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).3 j>0 @ i,\n                            prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).4 ej<e0 @ i)))\n              | (suc i, zero, (), _x)\n              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n                \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n                \\in \n                      \\let | h1 => arg.1\n                           | h2 => arg.2\n                      \\in (h1 @ i1, h2 @ i1,\n                            prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).3 (suc<suc {i} {j} i<j) @ i1,\n                            prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                              | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                              | (suc i, zero, (), _x)\n                              | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                              inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                                {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                            } \\with {\n                              | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                                (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                  (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                  (fin_< {f {e} 0} a))),\n                                transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                              | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                                {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                            }).4 ej+1<ei+1 @ i1)))\n            })\n          }} y)) *> f_sec {\n    \\have lem => \\lam (a : Fin (f {e} 0)) => f_ret {e} (a mod suc n) *> mod_< {a} {suc n} (fin_< {f {e} 0} a <\u2218 fin_< {suc n} (f {e} 0))\n    \\in \\new QEquiv {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))} {\\Sigma (i j : Fin (suc n)) (i < j) (f {e} j < f {e} i)}\n          (\\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                (fin_< {f {e} 0} a))),\n              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n          })) {\n          | ret => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n          })\n          | ret_f => \\lam (p0 : A {\\this}) => (\\case p0 \\with {\n            | inl a => pmap {Fin (f {e} 0)} {Or (Fin (f {e} 0)) (\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i))}\n              (inl {Fin (f {e} 0)} {\\Sigma (i j : Fin n) (i < j) (f {reduce {n} e} j < f {reduce {n} e} i)})\n              {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n              {a} (nat_fin_= {f {e} 0} {toFin' {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))}\n                {a} (toFin'=id {f {e} (ret {e} (a mod suc n))} {f {e} 0}\n                  (transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a)) *> lem a))\n            | inr b => idp {Or (Fin (f {e} 0)) (Inversions {n} (reduce {n} e))}\n              {\\case \\case inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} b \\with {\n                | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                  (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                    (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                    (fin_< {f {e} 0} a))),\n                  transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n              } \\with {\n                | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                | (suc i, zero, (), _x)\n                | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                  {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                  {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n              }}\n          })\n          | f_sec => \\lam (p0 : B {\\this}) => (\\case p0 \\with {\n            | (zero, j, j>0, ej<e0) => path (\\lam (i : I) => (\n              \\have arg => (idp {Fin (suc n)} {0}, pmap {Fin (suc n)} {Fin (suc n)} (ret {e}) {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                      (nat_fin_= {suc n} {toFin' {f {e} j} {f {e} 0} ej<e0 mod suc n} {f {e} j}\n                        (transportInv {Nat} (\\lam (x : Nat) => x mod suc n = f {e} j) {toFin' {f {e} j} {f {e} 0} ej<e0} {f {e} j}\n                          (toFin'=id {f {e} j} {f {e} 0} ej<e0) (mod_< {f {e} j} {suc n} (fin_< {suc n} (f {e} j))))) *> ret_f {e} j)\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i, h2 @ i, prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                          | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                          | (suc i, zero, (), _x)\n                          | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                          inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                            {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                        } \\with {\n                          | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                            (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                              (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                              (fin_< {f {e} 0} a))),\n                            transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                          | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                            {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                        }).3 j>0 @ i,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (0, j, j>0, ej<e0) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej<e0 @ i)))\n            | (suc i, zero, (), _x)\n            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => path (\\lam (i1 : I) => (\n              \\have arg => (idp {Fin (suc n)} {suc i}, idp {Fin (suc n)} {suc j})\n              \\in \n                    \\let | h1 => arg.1\n                         | h2 => arg.2\n                    \\in (h1 @ i1, h2 @ i1,\n                          prop-dpi (\\lam (i : I) => h1 @ i < h2 @ i) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).3 (suc<suc {i} {j} i<j) @ i1,\n                          prop-dpi (\\lam (i : I) => f {e} (h2 @ i) < f {e} (h1 @ i)) (\\case \\case (suc i, suc j, suc<suc {i} {j} i<j, ej+1<ei+1) \\with {\n                            | (zero, j, j>0, ej<e0) => inl {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (toFin' {f {e} j} {f {e} 0} ej<e0)\n                            | (suc i, zero, (), _x)\n                            | (suc i, suc j, suc<suc i<j, ej+1<ei+1) =>\n                            inr {Fin (f {e} 0)} {Inversions {n} (reduce {n} e)} (i, j, i<j, <_skip {n} {f {e} 0} {f {e} (suc j)} {f {e} (suc i)}\n                              {\\lam (p : f {e} 0 = f {e} (suc j)) => (\\case isInj {e} {0} {suc j} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc i)) => (\\case isInj {e} {0} {suc i} p \\with {})} ej+1<ei+1)\n                          } \\with {\n                            | inl a => (0, ret {e} (a mod suc n), nonZero>0 {ret {e} (a mod suc n)}\n                              (\\lam (p : ret {e} (a mod suc n) = 0) => <-irreflexive {f {e} 0} (transport {Nat} (\\lam (x : Nat) => x < f {e} 0) {a} {f {e} 0}\n                                (inv {Nat} {f {e} (ret {e} (a mod suc n))} {a} (lem a) *> pmap {Fin (suc n)} {Fin (suc n)} (f {e}) {ret {e} (a mod suc n)} {0} (nat_fin_= {suc n} {ret {e} (a mod suc n)} {0} p))\n                                (fin_< {f {e} 0} a))),\n                              transportInv {Nat} (\\lam (x : Nat) => x < f {e} 0) {f {e} (ret {e} (a mod suc n))} {a} (lem a) (fin_< {f {e} 0} a))\n                            | inr b => (suc b.1, suc b.2, suc<suc {b.1} {b.2} b.3, skip_< {n} {f {e} 0} {f {e} (suc b.2)} {f {e} (suc b.1)}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.2)) => (\\case isInj {e} {0} {suc b.2} p \\with {})}\n                              {\\lam (p : f {e} 0 = f {e} (suc b.1)) => (\\case isInj {e} {0} {suc b.1} p \\with {})} b.4)\n                          }).4 ej+1<ei+1 @ i1)))\n          })\n        }} y\n}", "completion": "transEquiv (Or_Equiv idEquiv (aux (reduce e))) (later (\n  \\have lem (a : Fin (e 0)) : e (ret {e} (a mod suc n)) = {Nat} a => f_ret {e} _ *> mod_< (fin_< a <\u2218 fin_< (e 0))\n  \\in \\new QEquiv {\n        | f => \\lam p0 => (\\case p0 \\with {\n          | inl a => (0, ret {e} (a mod suc n), nonZero>0 (\\lam p => <-irreflexive $ rewrite (inv (lem a) *> pmap e (nat_fin_= p)) in fin_< a),\n            rewrite lem (fin_< a))\n          | inr b => (suc b.1, suc b.2, suc<suc b.3, skip_< b.4)\n        })\n        | ret => \\lam p0 => (\\case p0 \\with {\n          | (0, j, j>0, ej<e0) => inl (toFin' ej<e0)\n          | (suc i, 0, (), _)\n          | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => inr (i, j, i<j, <_skip ej+1<ei+1)\n        })\n        | ret_f => \\lam p0 => (\\case \\elim p0 \\with {\n          | inl a => pmap inl $ nat_fin_= (toFin'=id _ *> lem a)\n          | inr b => idp\n        })\n        | f_sec => \\lam p0 => (\\case \\elim p0 \\with {\n          | (0, j, j>0, ej<e0) =>\n            ext (idp, pmap (ret {e}) (nat_fin_= $ later $ rewrite (toFin'=id ej<e0) $ mod_< $ fin_< (e j)) *> ret_f {e} j)\n          | (suc i, 0, (), _)\n          | (suc i, suc j, suc<suc i<j, ej+1<ei+1) => ext (idp, idp)\n        })\n      }))"}
{"prompt": "['S : Ring X']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| zro-left {x : E} : zro + x = x', '| E : \\\\Set']<<<break>>>\\Pi {x : S.E} -> S.zro S.+ x = x", "completion": "zro-left {S}"}
{"prompt": "['y : E', 'y>=0 : zro <= y', 'x<=0 : x <= zro', 'this : PosetSemiring', 'x : E']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', '| \\\\infix 4 <= E E : \\\\Prop', '| <=_*_positive-left {x y z : E} (x <= y) (zro <= z) : x * z <= y * z']<<<break>>>x * y <= zro * y", "completion": "<=_*_positive-left {this} x<=0 y>=0"}
{"prompt": "['f : RingHom K E', \"d : EuclideanRingData (Poly K) {\\n  | zro => pzero {K}\\n  | + => (+)\\n  | * => (*)\\n  | ide => padd {K} (pzero {K}) K.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {K} (pzero {K}) (K.natCoef n)\\n  | # => (#)\\n  | decideEq => PolyDecRing.decideEq {K}\\n  | euclideanMap => degree {K}\\n  | divMod => \\\\lam (p : E {\\\\this}) (q : E {\\\\this}) => (\\\\case DecSet.decideEq (degree {K} q) 0 \\\\with {\\n    | yes p1 => \\\\case DecSet.decideEq q zro \\\\with {\\n      | yes p1 => (zro, p)\\n      | no n => (K.finv (leadCoef {K} q) *c p, zro)\\n    }\\n    | no n => divMod_fuel {K} p q (suc' (degree {K} p))\\n  })\\n  | negative => negative {K}\\n}\", 'K : DiscreteField', 'E : CRing', 'p : Poly K', 'a : E.E', 'q : Poly K']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 6 + E E : E', '\\\\func degree \\\\hlevels  {R1 : Ring.Dec} (_ : Poly R1) : Nat \\n  | {R}, pzero => 0\\n  | {R}, padd p e => \\\\case decideEq p zro \\\\with {\\n    | yes p => 0\\n    | no n => suc (degree {R} p)\\n  }\\n  | {R}, peq i => idp {Nat} {0} @ i', '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| Cod : BaseSet', '\\\\func \\\\infixl 7 *c \\\\hlevels  {R3 : Ring} (_ : R.E) (_ : Poly R3) : Poly R3 \\n  | {R}, r, pzero => pzero {R}\\n  | {R}, r, padd p e => padd {R} (r *c p) (r R.* e)\\n  | {R}, r, peq i =>\\n    (pmap {R.E} {Poly R} (padd {R} (pzero {R})) {r R.* R.zro} {R.zro} (R.zro_*-right {r}) *> path (peq {R})) @ i', '\\\\instance PolyDecRing \\\\hlevels  (R : Dec) : Dec (Poly R) {\\n  | zro => pzero {R}\\n  | + => (+)\\n  | negative => negative {R}\\n  | #0 => #0\\n  | decideEq => decideEq {R}\\n  | * => (*)\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | #0-zro => {?hidden}\\n  | nonZeroApart => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\func * {R3 : Ring} (_ _ : Poly R3) : Poly R3 \\n  | {R}, pzero, q => pzero {R}\\n  | {R}, padd p e, q => padd {R} (p * q) R.zro + e *c q\\n  | {R}, peq i, q =>\\n    (pmap {Poly R} {Poly R} ((+) (padd {R} (pzero {R}) R.zro)) {R.zro *c q} {pzero {R}} (zro_*c {R} {q}) *> path (peq {R})) @ i', '\\\\func leadCoef \\\\hlevels  {R3 : Ring.Dec} (_ : Poly R3) : R.E \\n  | {R}, pzero => R.zro\\n  | {R}, padd p e => \\\\case decideEq p zro \\\\with {\\n    | yes p => e\\n    | no n => leadCoef {R} p\\n  }\\n  | {R}, peq i => idp {R.E} {\\\\case decideEq (pzero {R}) zro \\\\with {\\n    | yes p => R.zro\\n    | no n => R.zro\\n  }} @ i', '\\\\func polyMapEvalRingHom \\\\hlevels  {R : Ring} {S : CRing} (f : RingHom R S) (a : S.E) : RingHom (PolyRing R) S {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => func {polyEvalRingHom {S} a} (func {polyMapRingHom f} x)\\n} => polyEvalRingHom {S} a \u2218 polyMapRingHom f', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| divMod E E : \\\\Sigma E E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| zro : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| finv E : E', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', \"\\\\func divMod_fuel {R2 : DiscreteField} (_ _ : Poly R2) (_ : Nat) : \\\\Sigma (Poly R2) (Poly R2) \\n  | {R}, p, q, 0 => (zro, zro)\\n  | {R}, p, q, suc n => \\\\case dec<_<= {NatSemiring} (degree {R} p) (degree {R} q) \\\\with {\\n    | inl _x => (zro, p)\\n    | inr _x => \\n      \\\\let | m => monomial {R} (leadCoef {R} p R.* R.finv (leadCoef {R} q)) (degree {R} p -' degree {R} q)\\n           | (d, r) => divMod_fuel {R} (p - m * q) q n\\n      \\\\in (d + m, r)\\n  }\", '| func (E {Dom}) : E {Cod}', '\\\\field decideEq (x y : E) : Dec (x = y)', '| Dom : BaseSet', \"\\\\func suc' \\\\plevels  \\\\hlevels  (_ : Nat) : Nat \\n  | 0 => 1\\n  | suc n => suc (suc n)\"]<<<break>>>func {polyMapEvalRingHom {K} {E1} f a} (p * (d.divMod q p).1 + (\\case decideEq (degree {K} p) 0 \\with {\n  | yes p1 => \\case decideEq p zro \\with {\n    | yes p => (zro, q)\n    | no n => (K.finv (leadCoef {K} p) *c q, zro)\n  }\n  | no n => divMod_fuel {K} q p (suc' (degree {K} q))\n}).2) = func {polyMapEvalRingHom {K} {E1} f a} (p * (d.divMod q p).1) + func {polyMapEvalRingHom {K} {E1} f a} (\\case decideEq (degree {K} p) 0 \\with {\n  | yes p1 => \\case decideEq p zro \\with {\n    | yes p => (zro, q)\n    | no n => (K.finv (leadCoef {K} p) *c q, zro)\n  }\n  | no n => divMod_fuel {K} q p (suc' (degree {K} q))\n}).2", "completion": "func-+ {polyMapEvalRingHom f a}"}
{"prompt": "['a : Real', 'x : Real', 'x>=a : a <= x']<<<break>>>['true', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', 'LessOrEquals', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', ':zro', '| E : \\\\Set', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>interpret {\\new LinearRatAlgebraData {RealField} (a :: zro :: x :: zro :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (:zro {Rat} {Fin 4}) <= interpret {\\new LinearRatAlgebraData {RealField} (a :: zro :: x :: zro :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 4} 2 :+ :negative {E} {Fin 4} (var {E} {Fin 4} 0))", "completion": "solve<=Problem {\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => a :: zro :: x :: zro :: nil\n}} ((var 0, LessOrEquals, var 2) :: nil) :zro (var 2 :+ :negative (var 0)) (1 :: 1 :: nil, 0, idp, idp {Bool} {true})\n  (x>=a :: nil)"}
{"prompt": "['B : E -> \\\\Set', 'this : FinSet', 'e : Equiv {Fin finCard} {E}']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma finiteAC {n : Nat} {A : Fin n -> \\\\Type} (_ : \\\\Pi (i : Fin n) -> TruncP (A i)) : TruncP (\\\\Pi (i : Fin n) -> A i) ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func Equiv-to-= {A B : \\\\Type} (e : Equiv {A} {B}) : A = B => QEquiv-to-= {A} {B} (fromEquiv e)', '| E : \\\\Set', '| finCard : Nat', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>(\\Pi (i : E) -> TruncP (B i)) -> TruncP (\\Pi (i : E) -> B i)", "completion": "rewrite (Equiv-to-= e) (finiteAC {finCard {this}}) {B}"}
{"prompt": "['this : PrecatWithBprod', 'x : Ob', 'y : Ob']<<<break>>>['\\\\func change \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom (apex {Bprod x y}) (apex {Bprod y x}) \\n  => pair {y} {x} {apex {Bprod x y}} (proj2 {x} {y}) (proj1 {x} {y})', '| Hom Ob Ob : \\\\Set', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\func proj2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 1) => proj {Bprod x y} 1', '| Bprod (x y : Ob) : Product {Fin 2} (at {x :: y :: nil})', '| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '| apex : Ob {D}', '| id (X : Ob) : Hom X X', '\\\\func proj1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y : Ob} : Hom {D {Bprod x y}} (apex {Bprod x y}) (G {Bprod x y} 0) => proj {Bprod x y} 0', '\\\\lemma beta2 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : proj2 {x} {y} \u2218 pair {x} {y} {z} f g = g ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma beta1 \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : proj1 {x} {y} \u2218 pair {x} {y} {z} f g = f ', '\\\\func pair \\\\plevels obj >= hom \\\\hlevels  {this : PrecatWithBprod} {x y z : Ob} (f : Hom z x) (g : Hom z y) : Hom z (apex {Bprod x y}) \\n=> tupleMap {Bprod x y} {z} (\\\\lam (p0 : J {Bprod x y}) => (\\\\case p0 \\\\with {\\n  | zero => f\\n  | suc zero => g\\n}))']<<<break>>>proj2 {x} {y} \u2218 pair {x} {y} {apex {Bprod y x}} (proj2 {y} {x}) (proj1 {y} {x}) \u2218 change {x} {y} = proj2 {x} {y} \u2218 id (apex {Bprod x y})", "completion": "rewrite (beta2 {this} _ _) (rewrite (beta1 {this} _ _) (rewrite (id-right {this}) idp))"}
{"prompt": "['x : E', 'l : Array E n', 'this : BottomDistributiveLattice', 'a : E']<<<break>>>['\\\\lemma meet-ldistr \\\\hlevels  {this : DistributiveLattice} {x y z : E} : x \u2227 (y \u2228 z) = x \u2227 y \u2228 x \u2227 z ', '| bottom : E', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>x \u2227 (a \u2228 Big {E} {E} (\u2228) bottom l) = x \u2227 a \u2228 x \u2227 Big {E} {E} (\u2228) bottom l", "completion": "meet-ldistr {this}"}
{"prompt": "['e : \\\\Pi {U : Set X.E} -> C U -> D U', 'CU : C U', 'U : Set X.E', 'D : Set (Set X.E)']<<<break>>>[]<<<break>>>D U", "completion": "e CU"}
{"prompt": "['a : E', 'y : Interval RatField', 'x : Interval RatField', 'r : x < y']<<<break>>>['true', '\\\\type Interval \\\\hlevels  (Q : Poset) : \\\\Set => \\\\Sigma Q.E Q.E', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', '| join-left {x y : E} : x <= x \u2228 y', \"\\\\lemma cover-conj1 \\\\hlevels  {P : FramePres} {a a' b b' : P.E} (_ : Cover1 {P} a a') (_ : Cover1 {P} b b') : Cover1 {P} (P.conj a b) (P.conj a' b') \", '\\\\lemma cover-pair \\\\hlevels  {Q : Dec} {x : Interval Q} {z1 z2 : Q.E} (_ : z1 Q.< z2) :\\nCover {RealPres Q} x {Fin 2} (\\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n  | zero => (x.1, z2)\\n  | suc zero => (z1, x.2)\\n})) ', '\\\\func neg \\\\hlevels  {this : Locale} (x : E) : E => x --> bottom', 'false', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| bottom : E', '| E : \\\\Set', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| join-right {x y : E} : y <= x \u2228 y', '\\\\instance RealPres \\\\hlevels  (Q : Dec) : FramePres (Interval Q) {\\n  | conj => (\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))} {Interval Q}\\n    (\\\\lam (p0 : \\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))) =>\\n    (\\\\case p0 \\\\with {\\n      | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n        | zero => (p, q)\\n        | suc zero => (r, s)\\n      }))\\n      | (false, (p, q)) => (\\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\\n        \\\\lam (t : \\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\\n    }))\\n} => \\\\new FramePres', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma cover-empty \\\\hlevels  {Q : Dec} {x : Interval Q} (_ : x.2 Q.<= x.1) {J : \\\\Set} {g : J -> Interval Q} : Cover {RealPres Q} x {J} g ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| conj E E : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '| meet-left {x y : E} : x \u2227 y <= x', 'cover-inj (j : J) (g j = x)', '\\\\instance PresentedFrame \\\\hlevels  (P : FramePres) : Locale (Opens P) {\\n  | <= => (PresentedFrame.<=)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (a b : P.E) (U.1 a) (V.1 b)} (\\\\lam (t : \\\\Sigma (a b : P.E) (U.1 a) (V.1 b)) => P.conj t.1 t.2)\\n  | top => (\\\\lam (_ : P.E) => \\\\Sigma, \\\\lam (e : P.E) (_ : SCover {P} e (\\\\lam (_ : P.E) => \\\\Sigma)) => ())\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    closure {P} {\\\\Sigma (j : J) (x : P.E) ((f j).1 x)} (\\\\lam (p0 : \\\\Sigma (j : J) (x : P.E) ((f j).1 x)) => p0.2)\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\instance IntervalSemilattice \\\\hlevels  (Q : Lattice) : MeetSemilattice (Interval Q) {\\n  | <= => (IntervalPoset.<=)\\n  | meet => \\\\lam (a : E {\\\\this}) (b : E {\\\\this}) => (a.1 Q.\u2228 b.1, a.2 Q.\u2227 b.2)\\n} => \\\\new MeetSemilattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n}', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>Cover {RealPres RatField} a {\\Sigma (j : Bool) (x1 : E)\n  ((if {E} j (neg {PresentedFrame (RealPres RatField)} (embed {RealPres RatField} x)) (embed {RealPres RatField} y)).1 x1)}\n  (\\lam (p0 : \\Sigma (j : Bool) (x1 : E)\n    ((if {E} j (neg {PresentedFrame (RealPres RatField)} (embed {RealPres RatField} x)) (embed {RealPres RatField} y)).1 x1)) => p0.2)", "completion": "cover-trans (cover-pair r.1) (\\lam p0 => (\\case \\elim p0 \\with {\n  | 0 => cover-inj (true, (a.1, x.1), cover-inj ((embed (later (a.1, x.1)),\n    \\lam p0 => cover-trans p0 (\\lam i => cover-trans (cover-conj1 i.3 i.4) (\\lam _ => cover-empty $ unfold $ meet-left <=\u2218 join-right))),\n    (a.1, x.1), cover-inj () idp) idp) idp\n  | 1 => cover-trans (cover-pair r.2) (\\lam p0 => (\\case \\elim p0 \\with {\n    | 0 => cover-inj (false, y, cover-inj () idp) idp\n    | 1 => cover-inj (true, (x.2, a.2), cover-inj ((embed (later (x.2, a.2)),\n      \\lam p0 => cover-trans p0 (\\lam i => cover-trans (cover-conj1 i.3 i.4) (\\lam _ => cover-empty $ unfold $ meet-right <=\u2218 join-left))),\n      (x.2, a.2), cover-inj () idp) idp) idp\n  }))\n}))"}
{"prompt": "['e : R.E', 'R : Ring']<<<break>>>['| \\\\infixl 7 * E E : E', '| ide : E', '| E : \\\\Set', '| ide-right {x : E} : x * ide = x']<<<break>>>e R.* R.ide = e", "completion": "ide-right {_} {e}"}
{"prompt": "['a : Fin (len {vars})', 'l : List (Fin (len {vars}))', 'this : CMonoidData', 'n : Nat', 'is : List Nat']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma cons \\\\hlevels  {this : MonoidData} (x : Fin (len {vars})) (l : List (Fin (len {vars}))) :\\n  interpretNF (x :: l) = at {vars} x * interpretNF l ', '\\\\func removeIndices {A3 : \\\\Type} (_ : List Nat) (_ : List A3) : List A3 \\n  | {A}, nil, l => l\\n  | {A}, n :: l, nil => nil {A}\\n  | {A}, 0 :: is, a :: l => removeIndices {A} is l\\n  | {A}, suc n :: is, a :: l => a :: removeIndices {A} (n :: is) l', '| vars : Array (E {M})', '| \\\\infixl 7 * E E : E', '\\\\func indices {A4 : \\\\Type} (_ : List Nat) (_ : List A4) : List A4 \\n  | {A}, nil, l => nil {A}\\n  | {A}, n :: l, nil => nil {A}\\n  | {A}, 0 :: is, a :: l => a :: indices {A} is l\\n  | {A}, suc n :: is, a :: l => indices {A} (n :: is) l', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\func interpretNF \\\\hlevels  {this3 : MonoidData} (_ : List (Fin (len {vars}))) : E {M} \\n  | {this}, nil => ide {M}\\n  | {this}, x :: nil => at {vars} x\\n  | {this}, x :: l => at {vars} x * interpretNF l', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\infixr 5 :: A (List A)']<<<break>>>interpretNF (a :: indices {Fin (len {vars})} (n :: is) l ++ removeIndices {Fin (len {vars})} (n :: is) l) = at {vars} a * interpretNF (indices {Fin (len {vars})} (n :: is) l ++ removeIndices {Fin (len {vars})} (n :: is) l)", "completion": "cons {this} a _"}
{"prompt": "['this : QModule', 'a : E']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| zro-left {x : E} : zro + x = x', '| E : \\\\Set']<<<break>>>zro + a = a", "completion": "zro-left {this}"}
{"prompt": "['m : Nat', 'q : suc k <= m', 'k : Nat']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func toFin \\\\plevels  \\\\hlevels  (k1 : Nat) {n1 : Nat} (\\\\property _ : k1 < n1) : Fin n1 \\n  | 0, {suc n}, p => 0\\n  | suc k, {suc n}, p => suc (toFin k {n} {?hidden})', 'suc Nat', '\\\\lemma id<suc \\\\plevels  \\\\hlevels  {n : Nat} : n < suc n ', '\\\\lemma toFin=id \\\\plevels  \\\\hlevels  {k n : Nat} {p : k < n} : toFin k {n} {?hidden} = k ', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '\\\\func divMod \\\\plevels  \\\\hlevels  (_ _ : Nat) : \\\\Sigma Nat Nat ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma nat_fin_= \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : x = y) : x = y ', '\\\\lemma mod_< \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < m) : n mod m = n ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>toFin (k mod suc k) {m} {?hidden} = toFin k {m} {?hidden}", "completion": "nat_fin_= (toFin=id *> later (mod_< id<suc) *> inv toFin=id)"}
{"prompt": "['y : X.E', 'X : ExPseudoNormedAbGroup', 'h1 : (<=<) (single {X.E} x) = (<=<) (single {X.E} y)', 'x : X.E']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| filter-mono {a b : E {A}} (F a) (a <= b) : F b', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>Path (\\lam (i : I) => \\Pi {a b : E} -> (@) h1 i a -> a <= b -> (@) h1 i b) (filter-mono {pointCF {X} x})\n  (filter-mono {pointCF {X} y})", "completion": "prop-dpi (\\lam i => ext_coe) (filter-mono {pointCF {X} x}) (filter-mono {pointCF {X} y})"}
{"prompt": "['a<=x : S.2 <= x', 'fm : IsStrictlyMonotone {ElemStrictPoset {RealField} S.1} {RealField} f', 'f : Elem {Real} S.1 -> Real', 'x<=b : x <= S.3', 'y<=fb : y <= f (right S)', 'fa<=y : f (left S) <= y', 'S : IntervalSubset', 'fc : IsContAt {ElemTopSpace {RealNormed} S.1} {RealNormed} f (x, S.5 {x} a<=x x<=b)', 'x : Real', 'y : Real', 'x<=p : x <= point {S} {f} {y} {fa<=y} {y<=fb} fm']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\instance EmptyNegated \\\\plevels  \\\\hlevels  : NegatedProp Empty => \\\\new NegatedProp {\\n  | isNegated => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\type Elem {X : \\\\Type} (U : Set X) : \\\\Type => \\\\Sigma (x : X) (\\\\property (U x))', '\\\\lemma point>-cont-char {S : IntervalSubset} {f : Elem {Real} S.1 -> Real} {y : Real} {fa<=y : f (left S) <= y} {y<=fb : y <= f (right S)}\\n  (fm : IsStrictlyMonotone {ElemStrictPoset {RealField} S.1} {RealField} f) {x : Real} (a<x : S.2 < x) (x<=b : x <= S.3)\\n  (_ : IsContAt {ElemTopSpace {RealNormed} S.1} {RealNormed} f (x, S.5 {x} (<=-less {S.2} {x} a<x) x<=b))\\n  (_ : y < f (x, S.5 {x} (<=-less {S.2} {x} a<x) x<=b)) : point {S} {f} {y} {fa<=y} {y<=fb} fm < x ', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\lemma negated-dec \\\\plevels  \\\\hlevels  (E : \\\\Prop) {P1 : NegatedProp} (_ : Dec E -> P.P) : P.P ', '| P : \\\\Prop', '| \\\\infix 4 < E E : \\\\Prop', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func left (S : IntervalSubset) : Elem {Real} S.1 => (S.2, S.5 {S.2} (<=-refl {S.2}) (<=-less {S.2} {S.3} S.4))', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>f (x, S.5 {x} a<=x x<=b) <= y", "completion": "\\lam y<fx => negated-dec (S.2 < x) (\\lam p0 => (\\case p0 \\with {\n  | yes a<x => x<=p $ point>-cont-char {S} {f} {y} {fa<=y} {y<=fb} fm a<x x<=b fc y<fx\n  | no x<=a => fa<=y $ transport (\\lam p0 => y < f p0) (ext $ <=-antisymmetric x<=a a<=x) y<fx\n}))"}
{"prompt": "['B1 : Rat', 'x : E {\\\\this}', '|x1|<B1 : U {abs {RealAbGroup} x.1} B1']<<<break>>>['| zro : E', '\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '\\\\lemma <=-upper \\\\plevels  \\\\hlevels  {x y : Real} : x Preorder.<= y <-> x ExUpperReal.<= y ', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| abs>=0 {x : E} : zro <= abs x', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>fromRat zro <= fromRat B1", "completion": "<=-rat.1 (<=-less $ <=-upper.1 (abs>=0 {RealAbGroup}) |x1|<B1)"}
{"prompt": "['b : Rat', 'q : y < b', 'y : Rat']<<<break>>>['| isDense {x z : E} (x < z) : TruncP (\\\\Sigma (y : E) (x < y) (y < z))', '\\\\instance RatDenseOrder \\\\hlevels  : UnboundedDenseLinearOrder.Dec Rat {\\n  | < => (OrderedAddGroup.<)\\n  | meet => meet\\n  | join => join\\n  | # => \\\\lam (x : E) (y : E) => #0 (x - y)\\n  | decideEq => \\\\lam (x : E) (y : E) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | trichotomy => \\\\lam (x : E) (y : E) => (\\\\case +_trichotomy (x - y) \\\\with {\\n    | less x-y<0 => less {RatField} {x} {y} (fromNeg {RatField} {x} {y} (<0_neg {RatField} {x - y} x-y<0))\\n    | equals x-y=0 => equals {RatField} {x} {y} (fromZero {RatField} {x} {y} x-y=0)\\n    | greater x-y>0 => greater {RatField} {x} {y} (>0_pos {RatField} {x - y} x-y>0)\\n  })\\n} => \\\\new UnboundedDenseLinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | isDense => {?hidden}\\n  | withoutUpperBound => {?hidden}\\n  | withoutLowerBound => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>TruncP (\\Sigma (y1 : E) (y < y1) (y1 < b))", "completion": "isDense q"}
{"prompt": "['a : Poly R', 'd : Array Nat l.len', 'l : Array (Poly R) n', 'n : Nat', 'p : \\\\Pi (j : Fin (suc l.len)) -> degree<= {R} (at {a :: l} j) (at {n :: d} j)', 'R : Ring']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '| at (j : Fin len) : A j', '\\\\func degree<= \\\\hlevels  {R3 : AddPointed} (_ : Poly R3) (_ : Nat) : \\\\Prop \\n  | {R}, pzero, n => \\\\Sigma\\n  | {R}, padd p a, 0 => p = pzero {R}\\n  | {R}, padd p a, suc n => degree<= {R} p n\\n  | {R}, peq i, 0 =>\\n    propExt {pzero {R} = pzero {R}} {\\\\Sigma} (\\\\lam (_ : pzero {R} = pzero {R}) => ()) (\\\\lam (_ : \\\\Sigma) => idp {Poly R} {pzero {R}}) @ i\\n  | {R}, peq i, suc n => idp {\\\\Prop} {\\\\Sigma} @ i', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat']<<<break>>>degree<= {R} a (at {n :: d} 0)", "completion": "p 0"}
{"prompt": "['n : E', 'eps>0 : zro < eps', 'B<=n : B.1 <= n', 'r : eps <= ide - rfunc n', 'B : \\\\Sigma (n : Nat) (pow {RatField} (ide - ratio (pos 1) 2 * eps) n < eps)', 'null : \\\\Pi {n : Nat} -> zro <= rfunc n', 'eps : Rat']<<<break>>>['true', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', 'rfunc \\\\hlevels  (_ : Nat) : Rat \\n  | 0 => zro\\n  | suc n => ratio (pos 1) 2 * (ide + rfunc n * rfunc n)', '| len : Nat', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', 'coef C', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', 'LessOrEquals', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\lemma pow_<=-degree \\\\hlevels  {this : PosetSemiring} {a : E} (_ : zro <= a) (_ : a <= ide) {n k : Nat} (_ : n <= k) : pow a k <= pow a n ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>pow {RatField} (ide - ratio (pos 1) 2 * eps) n <= pow {RatField} (ide - ratio (pos 1) 2 * eps) B.1", "completion": "pow_<=-degree {RatField} (linarith rfunc>=0) linarith B<=n"}
{"prompt": "['R : CRing']<<<break>>>['true', '| \\\\infixl 6 + E E : E', '\\\\func matchingFamily \\\\hlevels  {C1 : SiteWithBasis} {F1 : Functor (op {C1}) SetCat} (x : C.Ob) {J1 : \\\\Set} (g : J1 -> Ob) (e : F.F x) :\\nMatchingFamily {C1} {F1} x {J1} g {\\n  | family => \\\\lam (j : J {\\\\this}) => F.Func {x} {(g j).1} (g j).2 e\\n} => \\\\new MatchingFamily {\\n  | isMatching => {?hidden}\\n}', '\\\\data Maybe \\\\Type \\n  | nothing\\n  | just A', '\\\\func forget : Functor CRingCat SetCat (\\\\lam (R : Ob {C {\\\\this}}) => R.E) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f.func\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\lemma closure2-lem \\\\hlevels  {R : CRing} {a : R.E} (f : Bool -> R.E) : contains a <-> TruncP (\\\\Sigma (c d : R.E) (a = f true R.* c R.+ f false R.* d)) ', '\\\\instance LocRing \\\\hlevels  {R : CRing} (S : SubMonoid R) : CRing (Type {R} {S}) {\\n  | zro => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.zro, R.ide, S.contains_ide)\\n  | + => ++ {R} {S}\\n  | * => ** {R} {S}\\n  | negative => neg {R} {S}\\n  | ide => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2} (R.ide, R.ide, S.contains_ide)\\n  | natCoef => \\\\lam (n : Nat) => in~ {SType {R} S} {\\\\lam (a : SType {R} S) (b : SType {R} S) => a.1 R.* b.2 = b.1 R.* a.2}\\n    (R.natCoef n, R.ide, S.contains_ide)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\lemma cover-trans1 \\\\hlevels  {P : FramePres} {x : P.E} {J : \\\\Set} {g : J -> P.E} {y : P.E} (_ : Cover1 {P} x y) (_ : Cover {P} y {J} g) :\\n  Cover {P} x {J} g ', '\\\\lemma localization-lem {R : CRing} {e : R.E} {c d : R.E} (g : Bool -> Ob) {n : Nat} (_ : pow {R} e n = (g true).1 R.* c R.+ (g false).1 R.* d) :\\nEquiv {Quotient {SType {R} (powers {R} e)}\\n  (\\\\lam (a : SType {R} (powers {R} e)) (b : SType {R} (powers {R} e)) => a.1 R.* b.2 = b.1 R.* a.2)}\\n  {MatchingFamily\\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool} g}\\n  (matchingFamily\\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingBicat} {SetCat} forget (functor R)} e {Bool} g) ', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'just A', '| \\\\infixl 7 * E E : E', '\\\\instance CRingCat : Cat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {RingCat} {CRing} (\\\\new Embedding {CRing} {Ob} (\\\\lam (R : A {\\\\this}) => R) {\\n  | isEmb => \\\\lam (R S : A {\\\\this}) =>\\n  \\\\new Retraction {R = S} {f {\\\\this} R = f {\\\\this} S} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {R} {S}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new CRing (E {p @ i}) {\\n      | zro => zro {p @ i}\\n      | + => (+) {p @ i}\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*) {p @ i}\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | negative => negative {p @ i}\\n      | negative-left => {?hidden}\\n      | ide => ide {p @ i}\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef {p @ i}\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n    })\\n    | f_sec => idpe {R = S}\\n  }\\n})', '\\\\lemma contr-equiv (A1 B : Contr) {f : A.A -> B.A} : Equiv {A.A} {B.A} f ', '\\\\lemma BigSum_zro \\\\hlevels  {this : AddMonoid} {l : Array E} (_ : \\\\Pi (j : Fin l.len) -> l.at j = zro) : BigSum l = zro ', \"\\\\func framePresSite \\\\hlevels  (P : FramePres) : SiteWithBasis P.E {\\n  | Hom => Cover1 {P}\\n  | id => <=-refl\\n  | o => \\\\lam {X Y Z : Ob} (f : Hom Y Z) (g : Hom X Y) => g <=\u2218 f\\n  | pullback => \\\\lam {x1 y1 z1 : P.E} (f1 : Cover1 {P} x1 z1) (g1 : Cover1 {P} y1 z1) => \\\\new Pullback {x1} {y1} {z1} f1 g1 (P.conj x1 y1) {\\n    | pbProj1 => cover-proj1 {P} {apex {\\\\this}} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x {\\\\this}} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {x1})\\n    | pbProj2 => cover-proj2 {P} {P.conj x1 y1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => y1} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {y1})\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {D {\\\\this}}} (p1 : Hom {D {\\\\this}} w (x {\\\\this})) (p2 : Hom {D {\\\\this}} w (y {\\\\this}))\\n      (_ : f {\\\\this} \u2218 p1 = g {\\\\this} \u2218 p2) => cover-prod {P} {w} {x1} {y1} p1 p2\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | isBasicCover => \\\\lam (x : Ob {\\\\this}) {J : \\\\Set} (g : J -> Ob) =>\\n  TruncP (\\\\Sigma (y : P.E) (Cover1 {P} x y) (g' : J -> P.E) (P.BasicCover {J} y g')\\n    (\\\\Pi (j : J) -> \\\\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (g j).1)))\\n} => \\\\new SiteWithBasis {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | basicCover-stable => {?hidden}\\n}\", '| at (j : Fin len) : A j', '\\\\func SpecPres \\\\hlevels  (R : CRing) : FramePres R.E {\\n  | conj => (R.*)\\n  | BasicCover => Indexing {Maybe (\\\\Sigma R.E R.E)} {R.E} (\\\\lam (p0 : Maybe (\\\\Sigma R.E R.E)) => (\\\\case p0 \\\\with {\\n    | just (a, b) => (Bool, a R.+ b, \\\\lam (p0 : Bool) => if {R.E} p0 a b)\\n    | nothing => (Empty, R.zro, absurd {R.E})\\n  }))\\n} => \\\\new FramePres', '| E : \\\\Set', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '\\\\lemma indexing-make \\\\hlevels  {I X : \\\\Set} {h : I -> \\\\Sigma (J : \\\\Set) X (J -> X)} (i : I) : Indexing {I} {X} h {(h i).1} (h i).2 (h i).3 ', '| contains (E {S}) : \\\\Prop', '| len : Nat', '| conj E E : E', '\\\\func IsNilpotent \\\\hlevels  {this : Ring} (x : E) : \\\\Prop => TruncP (\\\\Sigma (n : Nat) (pow x n = zro))', '| ide-left {x : E} : ide * x = x', 'nothing', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func powers \\\\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (pow {M} a n = x))) \\n=> \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\lemma cover-prod \\\\hlevels  {P : FramePres} {x y z : P.E} (_ : Cover1 {P} x y) (_ : Cover1 {P} x z) : Cover1 {P} x (P.conj y z) ', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', \"\\\\class MatchingFamily \\\\hlevels  {\\n  | C : SiteWithBasis\\n  | F : Functor (op {C}) SetCat\\n  | x : Ob {C}\\n  | J : \\\\Set\\n  | g J : Ob\\n  | family (j : J) : Functor.F {sheafOnSiteWithBasis.MatchingFamily.F} (g j).1\\n  | isMatching (j j' : J) : Func {sheafOnSiteWithBasis.MatchingFamily.F} {(g j).1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n    (pbProj1 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) (family j) = Func {sheafOnSiteWithBasis.MatchingFamily.F} {(g j').1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n    (pbProj2 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) (family j')\\n}\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'inP A', '\\\\func Cover1 \\\\hlevels  {P : FramePres} (x y : P.E) : \\\\Prop => Cover {P} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => y)', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', 'cover-basic (P.BasicCover {J} x g)', '\\\\lemma cover_ideal \\\\hlevels  {R : CRing} {x : R.E} {J : \\\\Set} {g : J -> R.E} (_ : Cover {SpecPres R} x {J} g) : contains x ', 'false', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\lemma emptyMatchingFamily \\\\hlevels  {C : SiteWithBasis} {F : Functor (op {C}) SetCat} {x : C.Ob} {g : Empty -> Ob} :\\n  Contr (MatchingFamily {C} {F} x {Empty} g) ', '\\\\lemma trivial \\\\hlevels  {R : CRing} {S : SubMonoid R} {x : R.E} (_ : IsNilpotent {R} x) (_ : S.contains x) : Contr E ', '\\\\instance SlicePrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : Precat (ObOver {C} x) {\\n  | Hom => \\\\lam (p0 : Ob {\\\\this}) (p1 : Ob {\\\\this}) => \\\\Sigma (h : C.Hom p0.1 p1.1) (p1.2 C.\u2218 h = p0.2)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (C.id p0.1, C.id-right {p0.1} {x} {p0.2})\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) => (p0.1 C.\u2218 p1.1,\\n    inv {C.Hom X.1 x} {Z.2 C.\u2218 p0.1 C.\u2218 p1.1} {Z.2 C.\u2218 (p0.1 C.\u2218 p1.1)} (C.o-assoc {X.1} {Y.1} {Z.1} {x} {Z.2} {p0.1} {p1.1}) *> pmap {C.Hom Y.1 x} {C.Hom X.1 x} (\\\\lam (_x : C.Hom Y.1 x) => _x C.\u2218 p1.1) {Z.2 C.\u2218 p0.1} {Y.2} p0.2 *> p1.2)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', 'cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func functor (R : CRing) : Functor (op {framePresSite (SpecPres R)}) CRingBicat (\\\\lam (a : Ob {C {\\\\this}}) => LocRing {R} (powers {R} a)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (c : Hom {C {\\\\this}} X Y) =>\\n    (functorial {R} {X} {Y} (cover_ideal {R} {Y} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => X} c)).1\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func closure \\\\hlevels  {R : CRing} {J : \\\\Set} (g : J -> R.E) : Ideal R (\\\\lam (e : E {S {\\\\this}}) =>\\n  TruncP (\\\\Sigma (l : Array (\\\\Sigma R.E J)) (e = BigSum {R} (map {\\\\Sigma R.E J} {R.E} (\\\\lam (p : \\\\Sigma R.E J) => p.1 R.* g p.2) l)))) \\n=> \\\\new Ideal {\\n  | contains_zro => {?hidden}\\n  | contains_+ => {?hidden}\\n  | ideal-left => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '| zro : E', '\\\\func radical \\\\hlevels  {this2 : Ideal} : Ideal S (\\\\lam (a : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (contains (pow {S} a n)))) \\n=> \\\\new Ideal {\\n  | contains_zro => {?hidden}\\n  | contains_+ => {?hidden}\\n  | ideal-left => {?hidden}\\n}', 'cover-inj (j : J) (g j = x)', '| zro_*-right {x : E} : x * zro = zro', '| Ob : \\\\hType', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| S : BaseSet', '\\\\class Equiv \\\\extends Section, Retraction', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>\\Pi (p0 : Maybe (\\Sigma R.E R.E)) -> \\Pi (y : R.E) -> \\Pi (g : (\\case p0 \\with {\n  | just (a, b) => (Bool, a R.+ b, \\lam (p0 : Bool) => if {R.E} p0 a b)\n  | nothing => (Empty, R.zro, absurd {R.E})\n}).1 -> Ob) -> Cover1 {SpecPres R} y (\\case p0 \\with {\n  | just (a, b) => (Bool, a R.+ b, \\lam (p0 : Bool) => if {R.E} p0 a b)\n  | nothing => (Empty, R.zro, absurd {R.E})\n}).2 -> (\\Pi (j : (\\case p0 \\with {\n  | just (a, b) => (Bool, a R.+ b, \\lam (p0 : Bool) => if {R.E} p0 a b)\n  | nothing => (Empty, R.zro, absurd {R.E})\n}).1) -> Cover1 {SpecPres R} (conj y ((\\case p0 \\with {\n  | just (a, b) => (Bool, a R.+ b, \\lam (p0 : Bool) => if {R.E} p0 a b)\n  | nothing => (Empty, R.zro, absurd {R.E})\n}).3 j)) (g j).1) -> Equiv {F y} {MatchingFamily\n  {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingCat} {SetCat} forget (functor R)} y\n    {(\\case p0 \\with {\n      | just (a, b) => (Bool, a R.+ b, \\lam (p0 : Bool) => if {R.E} p0 a b)\n      | nothing => (Empty, R.zro, absurd {R.E})\n    }).1} g}\n    (matchingFamily\n    {framePresSite (SpecPres R)} {Comp {op {framePresSite (SpecPres R)}} {CRingCat} {SetCat} forget (functor R)} y\n      {(\\case p0 \\with {\n        | just (a, b) => (Bool, a R.+ b, \\lam (p0 : Bool) => if {R.E} p0 a b)\n        | nothing => (Empty, R.zro, absurd {R.E})\n      }).1} g)", "completion": "\\lam p0 => (\\case \\elim p0 \\with {\n  | nothing => \\lam z ef z<=0 _ => contr-equiv (trivial (\\case cover_ideal z<=0 \\with {\n    | inP (n, inP p) => inP (n, p.2 *> BigSum_zro {R} (\\lam j => zro_*-right))\n  }) $ later $ inP (1, ide-left)) emptyMatchingFamily\n  | just (a, b) => \\lam z g z<=a+b q =>\n    (\\case cover_ideal $ cover-trans1 (cover-prod (cover-inj () idp) z<=a+b) $ cover-trans (cover-ldistr idp (cover-basic $ indexing-make $ just (a, b)) (\\lam j => idp)) (\\lam j => cover-trans1 (q j) $ cover-inj j idp) \\with {\n      | inP (n, p) => \\case (closure2-lem (\\lam j => (g j).1)).1 p \\with {\n        | inP (c, d, z^n=g1c+g2d) => localization-lem g z^n=g1c+g2d\n      }\n    })\n})"}
{"prompt": "['F : RegularCauchyFilter X', 'X : CoverSpace', 'V<=<U : V <=< U', 'V : Set (E {F.S})', 'FV : F.F V', 'U : Set X.E']<<<break>>>['| <=-refl {x : E} : x <= x', '| X : \\\\Set', '\\\\func mkSet \\\\hlevels  {X : CoverSpace} (U : Set X.E) : Set (RegularCauchyFilter X) => \\\\lam (F1 : RegularCauchyFilter X) => F.F U', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '\\\\lemma mkSet_<= \\\\hlevels  {X : CoverSpace} {U V : Set X.E} (_ : U \u2286 V) : mkSet {X} U \u2286 mkSet {X} V ', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| isProper {U : Set X} (F U) : TruncP (\\\\Sigma (x : X) (U x))', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\instance Completion \\\\hlevels  (X : CoverSpace) : CompleteCoverSpace (RegularCauchyFilter X) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X}}\\n  | isCauchy => isCCauchy {X}\\n} => \\\\new CompleteCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)']<<<break>>>single {RegularCauchyFilter X} F <=< mkSet {X} U", "completion": "inP (_, V<=<U, \\lam {W} g => inP (mkSet {X} W, \\lam p0 => (\\case \\elim p0 \\with {\n  | (_, (idp, FW)) => mkSet_<= {X} $ (\\case isProper (filter-meet FV FW) \\with {\n    | inP s => g s\n  })\n}), <=-refl))"}
{"prompt": "[\"g : CoverMap X' Y'\", 'f : CoverMap X Y', 'fde : IsDenseEmbedding {f}', 'gde : IsDenseEmbedding {g}']<<<break>>>[\"\\\\lemma isEmbedding \\\\hlevels  {X Y X' Y' : CoverSpace} {f : CoverMap X Y} {g : CoverMap X' Y'} (_ : IsEmbedding {f}) (_ : IsEmbedding {g}) :\\n  IsEmbedding {prod {X} {Y} {X'} {Y'} f g} \", \"\\\\func prod \\\\hlevels  {X Y X' Y' : CoverSpace} (f : CoverMap X Y) (g : CoverMap X' Y') : CoverMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} z, func {g \u2218 proj2 {X} {X'}} z)\\n} => tuple {Y} {Y'} {X \u2a2f X'} (f \u2218 proj1 {X} {X'}) (g \u2218 proj2 {X} {X'})\", '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| Cod : BaseSet', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {C : Set (Set (E {Dom {prod {f.Dom} {f.Cod} {g.Dom} {g.Cod} f g}}))} ->\n  isCauchy {Dom {prod {f.Dom} {f.Cod} {g.Dom} {g.Cod} f g}} C ->\n  isCauchy {Cod {prod {f.Dom} {f.Cod} {g.Dom} {g.Cod} f g}} (\\lam (V : Set (E {Cod {prod {f.Dom} {f.Cod} {g.Dom} {g.Cod} f g}})) =>\n    TruncP (\\Sigma (U : Set (E {Dom {prod {f.Dom} {f.Cod} {g.Dom} {g.Cod} f g}})) (C U)\n      (func {prod {f.Dom} {f.Cod} {g.Dom} {g.Cod} f g} ^-1 V \u2286 U)))", "completion": "isEmbedding fde.2 gde.2"}
{"prompt": "['lr : GroupTerm V', 'll : GroupTerm V', 'this : NatData', 'fstLeafToRemoveInd : Nat', 'r : GroupTerm V', 'p : (remove-pair (ll :* lr :* r) fstLeafToRemoveInd).2 = true']<<<break>>>['true', '| V : \\\\Set', \"\\\\func rp-returns-true-lemma''' \\\\hlevels  {this : NatData} (l r : GroupTerm V) (fstLeafToRemoveInd : Nat) : (remove-pair (l :* r) fstLeafToRemoveInd).2 = true ->\\n  \\\\Sigma ((remove-pair l fstLeafToRemoveInd).2 = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l) \\n=> \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n  | greater _x => \\\\case (remove-pair r (fstLeafToRemoveInd -' count-leaves l)).2 \\\\with {\\n    | true => absurd {\\\\Sigma ((remove-pair l fstLeafToRemoveInd).2 = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n    | false => absurd {\\\\Sigma ((remove-pair l fstLeafToRemoveInd).2 = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n  }\\n  | less _x => \\\\case (remove-pair l fstLeafToRemoveInd).2 \\\\with {\\n    | true => absurd {\\\\Sigma (true = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n    | false => absurd {\\\\Sigma (false = true) ((remove-pair r 0).2 = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n  }\\n  | equals p => \\\\case (remove-pair l fstLeafToRemoveInd).2, idp {Bool} {(remove-pair l fstLeafToRemoveInd).2}, (remove-pair r 0).2,\\n    idp {Bool} {(remove-pair r 0).2} \\\\with {\\n      | true, p1, true, q => \\\\lam (_ : (\\\\case true, true \\\\with {\\n        | true, true => (:ide {Nat}, true)\\n        | true, false => remove-pair r 0\\n        | false, true => remove-pair l fstLeafToRemoveInd\\n        | false, false => ((remove-pair l fstLeafToRemoveInd).1 :* (remove-pair r 0).1, false)\\n      }).2 = true) => (idp {Bool} {true}, idp {Bool} {true}, p)\\n      | true, p, false, q => \\\\lam (p : (\\\\case true, false \\\\with {\\n        | true, true => (:ide {Nat}, true)\\n        | true, false => remove-pair r 0\\n        | false, true => remove-pair l fstLeafToRemoveInd\\n        | false, false => ((remove-pair l fstLeafToRemoveInd).1 :* (remove-pair r 0).1, false)\\n      }).2 = true) => absurd {\\\\Sigma (true = true) (false = true) (fstLeafToRemoveInd = count-leaves l)}\\n        (true/=false (inv {Bool} {(remove-pair r 0).2} {true} p *> q))\\n      | false, q, true, p => \\\\lam (p : (\\\\case false, true \\\\with {\\n        | true, true => (:ide {Nat}, true)\\n        | true, false => remove-pair r 0\\n        | false, true => remove-pair l fstLeafToRemoveInd\\n        | false, false => ((remove-pair l fstLeafToRemoveInd).1 :* (remove-pair r 0).1, false)\\n      }).2 = true) => absurd {\\\\Sigma (false = true) (true = true) (fstLeafToRemoveInd = count-leaves l)}\\n        (true/=false (inv {Bool} {(remove-pair l fstLeafToRemoveInd).2} {true} p *> q))\\n      | false, p, false, p =>\\n        absurd {\\\\Sigma (false = true) (false = true) (fstLeafToRemoveInd = count-leaves l)} o true/=false o inv {Bool} {false} {true}\\n    }\\n}\", '\\\\infixl 6 :* (_ _ : GroupTerm V)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\func remove-pair \\\\hlevels  {this5 : NatData} (_ : GroupTerm V) (_ : Nat) : \\\\Sigma (GroupTerm V) Bool \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | less _x => \\n      \\\\let res-l => remove-pair l fstLeafToRemoveInd\\n      \\\\in \\\\case res-l.2 \\\\with {\\n            | true => (r, false)\\n            | false => (res-l.1 :* r, false)\\n          }\\n    | equals p => \\n      \\\\let | res-l => remove-pair l fstLeafToRemoveInd\\n           | res-r => remove-pair r 0\\n      \\\\in \\\\case res-l.2, res-r.2 \\\\with {\\n            | true, true => (:ide {Nat}, true)\\n            | true, false => res-r\\n            | false, true => res-l\\n            | false, false => (res-l.1 :* res-r.1, false)\\n          }\\n    | greater _x => \\n      \\\\let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l)\\n      \\\\in \\\\case res-r.2 \\\\with {\\n            | true => (l, false)\\n            | false => (l :* res-r.1, false)\\n          }\\n  }\\n  | {this}, :inv (var x), fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :inv g, fstLeafToRemoveInd => (:inv {V} g, false)\\n  | {this}, var x, fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :ide, fstLeafToRemoveInd => (:ide {Nat}, false)\"]<<<break>>>(remove-pair (ll :* lr) fstLeafToRemoveInd).2 = true", "completion": "(rp-returns-true-lemma''' {this} l r fstLeafToRemoveInd p).1"}
{"prompt": "['a : E', \"a'<a : a' < a\", \"a' : Rat\"]<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '| ide-left {x : E} : ide * x = x', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 < E E : \\\\Prop', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)']<<<break>>>ide * a' < a", "completion": "transportInv (\\lam _x => _x < _) ide-left a'<a"}
{"prompt": "['s : contains x', 'n : Nat', 'this : SubMonoid', 'x : E {S}']<<<break>>>['\\\\lemma contains_pow \\\\hlevels  {this : SubMonoid} {x : E {S}} (_ : contains x) {n : Nat} : contains (pow {S} x n) ', '| S : BaseSet', '| contains (E {S}) : \\\\Prop', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>contains (pow {S} x n)", "completion": "contains_pow s"}
{"prompt": "['j : Nucleus {L}', 'L : Locale', 'k : Nucleus {L}']<<<break>>>['| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)', '| \\\\infix 4 <= E E : \\\\Prop', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| Cod : BaseSet', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func map \\\\hlevels  {this2 : Nucleus} : FrameHom L locale {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (nucleus x, nucleus-join>= {x})\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}', '\\\\instance locale \\\\hlevels  {this2 : Nucleus} : Locale Subtype {\\n  | <= => \\\\lam (p0 : E {\\\\this}) (p1 : E {\\\\this}) => p0.1 <= p1.1\\n  | meet => \\\\lam (p0 : E {\\\\this}) (p1 : E {\\\\this}) => (p0.1 \u2227 p1.1,\\n    transportInv {E {L}} (\\\\lam (x : E {L}) => x <= p0.1 \u2227 p1.1) {nucleus (p0.1 \u2227 p1.1)} {nucleus p0.1 \u2227 nucleus p1.1}\\n      (nucleus-meet {p0.1} {p1.1}) (meet-monotone {L} {nucleus p0.1} {nucleus p1.1} {p0.1} {p1.1} p0.2 p1.2))\\n  | top => (top {L}, top-univ {L} {nucleus (top {L})})\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    (nucleus (Join {L} {J} (\\\\lam (p0 : J) => (f p0).1)), nucleus-join>= {Join {L} {J} (\\\\lam (p0 : J) => (f p0).1)})\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', \"\\\\instance NucleusFrame (L1 : Locale) : Locale (Nucleus {L1}) {\\n  | <= => \\\\lam (j : E {\\\\this}) (j' : E {\\\\this}) => \\\\Pi {x : L.E} -> j.nucleus x L.<= j'.nucleus x\\n  | meet => NucleusFrame.meet {L1}\\n  | top => \\\\new Nucleus {L1} (\\\\lam (_ : E {L {\\\\this}}) => L.top) {\\n    | nucleus-meet => {?hidden}\\n    | nucleus-meet>= => {?hidden}\\n    | nucleus-<= => {?hidden}\\n    | nucleus-unit => {?hidden}\\n    | nucleus-join>= => {?hidden}\\n    | nucleus-join => {?hidden}\\n  }\\n  | Join => \\\\lam {J : \\\\Set} (g : J -> E {\\\\this}) => \\\\new Nucleus {L1} (\\\\lam (x : E {L {\\\\this}}) =>\\n    L.Meet {\\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j : J) -> \\\\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)}\\n      (\\\\lam (p : \\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j : J) -> \\\\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)) => nucleus {p.1} x)) {\\n    | nucleus-meet => {?hidden}\\n    | nucleus-meet>= => {?hidden}\\n    | nucleus-<= => {?hidden}\\n    | nucleus-unit => {?hidden}\\n    | nucleus-join>= => {?hidden}\\n    | nucleus-join => {?hidden}\\n  }\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}\", '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| join-right {x y : E} : y <= x \u2228 y', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| Dom : BaseSet', \"\\\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}\"]<<<break>>>\\Pi {x y : E {Dom {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})}}} ->\n  func {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})} x \u2227 func {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})} y <= func {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {NucleusFrame L} {j} {k})} (x \u2227 y)", "completion": "func-meet>= {map {k} \u2218 <=-map {L} k (j \u2228 k) (join-right {j} {k})}"}
{"prompt": "['s : B {\\\\this}', 'H : SubGroup', 'e : \\\\Pi (x : c.E) -> \\\\Sigma (y : E {H.S}) (x = in~ {E {H.S}} {(~)} y)']<<<break>>>['| \\\\infixl 7 * E E : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\lemma inverse-isInv \\\\hlevels  {this : Group} {x : E} : inverse (inverse x) = x ', '| ide : E', '| E : \\\\Set', '| inverse-left {x : E} : inverse x * x = ide', '| S : BaseSet', '| inverse E : E', '\\\\lemma inverse_* \\\\hlevels  {this : Group} {x y : E} : inverse (x * y) = inverse y * inverse x ', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', '| contains (E {S}) : \\\\Prop', '| ide-right {x : E} : x * ide = x']<<<break>>>(\\lam (x : E {H.S}) (y : E {H.S}) => H.contains (inverse {H.S} x * y)) ((e s.1).1 * inverse {H.S} s.2.1) (e s.1).1", "completion": "later (rewrite (inverse_*, inverse-isInv, *-assoc, inverse-left, ide-right) s.2.2)"}
{"prompt": "['n : Nat', 'x : Fin n', 'i : Fin l.len', 'e : Sym n', 'l : Array (Sym n1) n', 'p : \\\\Pi (j : Fin (suc l.len)) -> j < suc i -> f {at {e :: l} j} x = x', 'n : Nat']<<<break>>>['| len : Nat', '\\\\type Sym \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => Equiv {Fin n} {Fin n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '| f A : B', 'suc<suc (n < m)', '| at (j : Fin len) : A j', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)']<<<break>>>\\Pi (j : Fin l.len) -> j < i -> f {at {e :: l} (suc j)} x = x", "completion": "\\lam j s => p (suc j) (suc<suc s)"}
{"prompt": "['U1 : Set (\\\\Sigma I.E X.E)', \"U1' : Set I.E\", \"U1U1' : U1 = (\\\\lam (s : \\\\Sigma I.E X.E) => s.1) ^-1 U1'\", \"p : U1' = (I.<=) N\", 'N : I.E', 'D : Set (Set (\\\\Sigma I.E X.E))', 'I : DirectedSet', 'V : Set (\\\\Sigma I.E X.E)', 'X : CoverSpace']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| meet-left {x y : E} : x \u2227 y <= x', 'byLeft A', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>U1 \u2227 V \u2286 (\\lam (s : \\Sigma I.E X.E) => s.1) ^-1 (I.<=) N || (\\Sigma (V' : Set (\\Sigma I.E X.E)) (D V') (U1 \u2227 V \u2286 V'))", "completion": "byLeft (rewrite (U1U1', p) meet-left)"}
{"prompt": "['this : DistributiveLattice', 'z : E', 'y : E', 'x : E']<<<break>>>['\\\\lemma meet-ldistr \\\\hlevels  {this : DistributiveLattice} {x y z : E} : x \u2227 (y \u2228 z) = x \u2227 y \u2228 x \u2227 z ', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>(x \u2228 y) \u2227 (x \u2228 z) = (x \u2228 y) \u2227 x \u2228 (x \u2228 y) \u2227 z", "completion": "meet-ldistr {this}"}
{"prompt": "['V : AddMonoid', 'vs : Array V.E bs.len', 'bs : Array B.E', 'B : BottomDistributiveLattice']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| A (Fin len) : \\\\Type', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray']<<<break>>>Array (\\Sigma V.E B.E) bs.len (\\lam (j : Fin bs.len) => (vs.at j, bs.at j))", "completion": "mkArray (\\lam j => (vs j, bs j))"}
{"prompt": "['x<b : x < S.3', 'S : IntervalSubset', 'x : Real', 'delta : Real', 'f : Elem {Real} S.1 -> Real', 'a<=x : S.2 <= x', \"x' : E\", \"a<=x' : S.2 <= x'\", 'y : Real']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '| C : Semiring', '| M : Monoid', '| R : Semiring', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| vars : Array (E {M})', '\\\\func half \\\\hlevels  (x : Real) : Real => x * fromRat (ratio (pos 1) 2)', '| zro : E', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\field mData : MonoidData {R} vars', '| E : \\\\Set', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '| meet-right {x y : E} : x \u2227 y <= y', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>LinearRatAlgebraData {RealField}\n  (zro :: y :: zro :: zro :: zro :: zro :: f (x, S.5 {x} a<=x (<=-less {x} {S.3} x<b)) :: zro :: zro :: zro :: f (x', S.5 {x'} a<=x' (meet-right {x + half delta} {S.3})) :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => zro :: y :: zro :: zro :: zro :: zro :: f (x, S.5 {x} a<=x (<=-less {x} {S.3} x<b)) :: zro :: zro :: zro :: f (x', S.5 {x'} a<=x' (meet-right {x + half delta} {S.3})) :: nil\n}"}
{"prompt": "['this : OrderedSemiring', 'm : Nat']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\lemma natCoef_< \\\\hlevels  {this : OrderedSemiring} {n m : Nat} (_ : n NatOrder.< m) : natCoef n StrictPoset.< natCoef m ', 'suc Nat', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma <_+ \\\\hlevels  {this : OrderedAddMonoid} {a b c d : E} (_ : a < c) (_ : b < d) : a + b < c + d ', '| ide : E', '| zro-right {x : E} : x + zro = x', '| natCoefZero : natCoef 0 = zro', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', 'zero<suc', '| zro<ide : zro < ide', '| natCoef Nat : E', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>zro < natCoef (suc m) + ide", "completion": "transport (\\lam _x => _x < {this} _) (zro-right {this} *> natCoefZero {this}) (<_+ {this} (natCoef_< zero<suc) (zro<ide {this}))"}
{"prompt": "['S : SubMonoid R', 'loc : \\\\Pi (x y : R.E) ->\\n  S.contains y -> (\\\\Sigma (r : R.E) (S.contains (x R.* r))) || (\\\\Sigma (r : R.E) (S.contains ((x R.+ y) R.* r)))', 'x : SType {R} S', 'R : CRing']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '| E : \\\\Set', '| contains (E {S}) : \\\\Prop']<<<break>>>(\\Sigma (r : R.E) (S.contains (x.1 R.* r))) || (\\Sigma (r : R.E) (S.contains ((x.1 R.+ x.2) R.* r)))", "completion": "loc x.1 x.2 x.3"}
{"prompt": "['l2 : List A.E', 'l1 : List A.E', 'A : Preorder', 's : Sorted {A} (l1 ++ l2)']<<<break>>>['\\\\lemma tailSorted \\\\hlevels  {A : Preorder} (l1 l2 : List A.E) (_ : Sorted {A} (l1 ++ l2)) : Sorted {A} l2 ', '\\\\data Sorted \\\\hlevels  {A : Preorder} (List A.E) \\\\with\\n  | {A}, nil => sorted-nil\\n  | {A}, x :: xs => sorted-cons (x A.<= headDef {A.E} x xs) (Sorted {A} xs)']<<<break>>>Sorted {A} l2", "completion": "tailSorted l1 l2 s"}
{"prompt": "[\"S : VSheaf {\\n  | C => C'\\n}\", \"e : Iso {f.D} {f.F (apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2})}\\n  {apex {pullback {f.D} {f.F (g1 j).1} {f.F (g1 j').1} {f.F x1} (f.Func {(g1 j).1} {x1} (g1 j).2) (f.Func {(g1 j').1} {x1} (g1 j').2)}}\\n  (pbMap {pullback {f.D} {f.F (g1 j).1} {f.F (g1 j').1} {f.F x1} (f.Func {(g1 j).1} {x1} (g1 j).2) (f.Func {(g1 j').1} {x1} (g1 j').2)}\\n    {f.F (apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2})}\\n    (f.Func {apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}} {(g1 j).1}\\n      (pbProj1 {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}))\\n    (f.Func {apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}} {(g1 j').1}\\n      (pbProj2 {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}))\\n    (inv {Hom {f.D} (f.F (apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2})) (f.F x1)}\\n      {f.Func {apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}} {x1}\\n        ((g1 j).2 \u2218 pbProj1 {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2})}\\n      {f.Func {(g1 j).1} {x1} (g1 j).2 \u2218 f.Func {apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}} {(g1 j).1}\\n        (pbProj1 {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2})}\\n      (f.Func-o {apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}} {(g1 j).1} {x1} {(g1 j).2}\\n        {pbProj1 {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}}) *> pmap {Hom {f.C} (apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}) x1}\\n      {Hom {f.D} (f.F (apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2})) (f.F x1)}\\n      (f.Func {apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}} {x1})\\n      {f {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2} \u2218 pbProj1 {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}}\\n      {g {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2} \u2218 pbProj2 {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}}\\n      (pbCoh {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}) *> f.Func-o {apex {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}} {(g1 j').1} {x1} {(g1 j').2}\\n      {pbProj2 {pullback {f.C} {(g1 j).1} {(g1 j').1} {x1} (g1 j).2 (g1 j').2}}))\"]<<<break>>>['| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| F : Functor (op {C}) D', '| hinv : Hom {C} cod dom', '| D : Precat', '| f : Hom {C} dom cod', '\\\\func Func-iso \\\\plevels obj >= hom \\\\hlevels  {this1 : Functor} (e : Iso {C}) : Iso {D} {F e.dom} {F e.cod} (Func {e.dom} {e.cod} e.f) {\\n  | hinv => Func {e.cod} {e.dom} e.hinv\\n} => \\\\new Iso {\\n  | hinv_f => {?hidden}\\n  | f_hinv => {?hidden}\\n}', '| dom : Ob {C}', '\\\\class Iso \\\\extends SplitMono \\\\plevels obj >= hom \\\\hlevels  {\\n  | f_hinv : f \u2218 hinv = id {C} cod\\n}', '| F (Ob {C}) : Ob {D}', '| cod : Ob {C}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this : Iso} : Iso {op {C}} {cod} {dom} f {\\n  | hinv => hinv\\n} => \\\\new Iso {\\n  | hinv_f => {?hidden}\\n  | f_hinv => {?hidden}\\n}']<<<break>>>Iso {D {S.F}} {Functor.F {S.F} (dom {op {e}})} {Functor.F {S.F} (cod {op {e}})}\n  (Func {S.F} {dom {op {e}}} {cod {op {e}}} (f {op {e}})) {\n  | hinv => Func {S.F} {cod {op {e}}} {dom {op {e}}} (hinv {op {e}})\n}", "completion": "Func-iso {F {S}} (op {e})"}
{"prompt": "['C : PrecatWithPullbacks', 'h : Mono {C} {w} {z}', 'x : C.Ob', 'f : Mono {C} {x} {z}', 'w : C.Ob', 'z : C.Ob']<<<break>>>['| Hom Ob Ob : \\\\Set', '| pullback {x y z : Ob} (f : Hom x z) (g : Hom y z) : Pullback {x} {y} {z} f g', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| f : Hom {C} dom cod', '| pbProj2 : Hom {D} apex y', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| pbProj1 : Hom {D} apex x', '| apex : Ob {D}', '| pbCoh : f \u2218 pbProj1 = g \u2218 pbProj2', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| z : Ob {D}', '| D : Precat']<<<break>>>f.f C.\u2218 pbProj1 {C.pullback {x} {w} {z} f.f h.f} = h.f C.\u2218 pbProj2 {C.pullback {x} {w} {z} f.f h.f}", "completion": "rewrite (pbCoh {pullback (f {f}) (f {h})}) idp"}
{"prompt": "['dq : degree<= {f.Dom} q m', 'R : StrictDomain', 'p : Poly R', 'n : Nat', 'm<n : n > m', 'p|q : LDiv {PolyRing f.Dom} p q', 'q : Poly R', 'm : Nat']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\func polyCoef \\\\hlevels  {R4 : AddPointed} (_ : Poly R4) (_ : Nat) : R.E \\n  | {R}, pzero, n => R.zro\\n  | {R}, padd p e, 0 => e\\n  | {R}, padd p e, suc n => polyCoef {R} p n\\n  | {R}, peq i, 0 => idp {R.E} {R.zro} @ i\\n  | {R}, peq i, suc n => idp {R.E} {R.zro} @ i', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| inv : E {M}', '| inv-right : val * inv = elem', '\\\\lemma toCoefs \\\\hlevels  {R : AddPointed} (p : Poly R) (n : Nat) (_ : degree<= {R} p n) {k : Nat} (_ : n < k) : polyCoef {R} p k = R.zro ']<<<break>>>polyCoef {R} (p * p|q.inv) n = R.zro", "completion": "rewrite (inv (inv-right {p|q})) (toCoefs q m dq m<n)"}
{"prompt": "['V0 : V zro', 'h : \\\\Pi (x : E) -> TruncP (\\\\Sigma (V1 : Set E) (D V1) (\\\\Pi {y : E} -> V (x - y) -> V1 y))', 'this : TopAbGroup', 'Vo : isOpen V', 'V : Set E', 'Uo : isOpen U', 'C : Set (Set E)', 'D : Set (Set E)', 'U : Set E', 'g : \\\\Pi (x : E) -> TruncP (\\\\Sigma (V : Set E) (C V) (\\\\Pi {y : E} -> U (x - y) -> V y))', 'U0 : U zro']<<<break>>>['| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| isOpen (Set E) : \\\\Prop', '| E : \\\\Set', '\\\\func CoverInter \\\\hlevels  {X : \\\\hType} (C : Set (Set X)) (D : Set (Set X)) : Set (Set X) \\n  => \\\\lam (W : Set X) => TruncP (\\\\Sigma (U : Set X) (C U) (V : Set X) (D V) (W = U \u2227 V))', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>TruncP (\\Sigma (U : Set E) (isOpen U) (U zro)\n  (\\Pi (x : E) -> TruncP (\\Sigma (V : Set E) (CoverInter {E} C D V) (\\Pi {y : E} -> U (x - y) -> V y))))", "completion": "inP (U \u2227 V, open-inter {this} Uo Vo, (U0, V0), \\lam x => (\\case g x, h x \\with {\n  | inP (W, CW, f), inP (W', DW', f') => inP (W \u2227 W', inP $ later (W, CW, W', DW', idp), \\lam p0 => (\n    \\let (u, u') => p0\n    \\in (f u, f' u')))\n}))"}
{"prompt": "['color : E {tc.Color}', \"core-context : List tc.Sort'\", \"pattern-context : List tc.Sort'\", 't : Term (tc.envs color) (core-context ++ pattern-context) s inner-mc', \"s : tc.Sort'\", \"inner-mc : MetaContext tc.Sort'\", 'tc : TheoremContext']<<<break>>>['\\\\func apply \\\\hlevels  {env2 : FSignature} {s2 : env.Sort} {old-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\\n  (_ : Term env2 old-context2 s2 mc2) {new-context2 : List env.Sort}\\n  (_ : Substitution {env2} old-context2 new-context2 mc2) : Term env2 new-context2 s2 mc2 \\n  | {env}, {s}, {old-context}, {mc}, var index idp, {new-context}, map => map index\\n  | {env}, {s}, {old-context}, {mc}, metavar m arguments, {new-context}, map =>\\n  metavar {env} {new-context} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term env new-context (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) =>\\n      apply {env} {mc.m-domain {s} m !! i} {old-context} {mc} (arguments.at i) {new-context} map))\\n  | {env}, {s}, {old-context}, {mc}, func f arguments, {new-context}, map =>\\n  func {env} {new-context} {s} {mc} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (new-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) =>\\n    apply {env} {f !!sort i} {old-context ++ f !!domain i} {mc} (arguments.at i) {new-context ++ f !!domain i}\\n      (append-context-right {env} {old-context} {new-context} {mc} map {f !!domain i})))', '| Sort : \\\\Set', '\\\\lemma plain-identity-effect \\\\hlevels  {env : FSignature} {context : List env.Sort} {s : env.Sort} {mc : MetaContext env.Sort} (t : Term env context s mc) :\\n  apply {env} {s} {context} {mc} t {context} (plain-identity {env} {context} {mc}) = t ', \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", '\\\\func plain-identity \\\\hlevels  {env : FSignature} {context : List env.Sort} {mc : MetaContext env.Sort} : Substitution {env} context context mc \\n  => \\\\lam (i : Index {env.Sort} context) => var {env} {context} {context !! i} {mc} i (idp {env.Sort} {context !! i})', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))']<<<break>>>apply {tc.envs color} {s} {core-context ++ pattern-context} {inner-mc} t {core-context ++ pattern-context}\n  (plain-identity {tc.envs color} {core-context ++ pattern-context} {inner-mc}) = t", "completion": "plain-identity-effect {envs color} _"}
{"prompt": "['n : Nat', 'm : Nat']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', 'suc Nat', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '\\\\func \\\\infixl 6 - \\\\plevels  \\\\hlevels  (_ _ : Nat) : Int \\n  | 0, m => neg m\\n  | n, 0 => pos n\\n  | suc n, suc m => n - m', '\\\\lemma fin_nat-inj \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : x = y) : x = y ', 'yes E', '| \\\\infixl 7 * E E : E', '\\\\instance FinRing \\\\hlevels  {n : Nat} : CRing.Dec (Fin (suc n)) {\\n  | zro => 0\\n  | + => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => fromNat {n} (x AddMonoid.+ y)\\n  | negative => \\\\lam (x : E {\\\\this}) => fromNat {n} (iabs (suc n - x))\\n  | #0 => #0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq x y \\\\with {\\n    | yes x=y => yes {x = y} (fin_nat-inj {suc n} {x} {y} x=y)\\n    | no x/=y => no {x = y} x/=y\\n  })\\n  | * => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => fromNat {n} (x Semigroup.* y)\\n  | ide => fromNat {n} 1\\n  | natCoef => fromNat {n}\\n} => \\\\new CRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | #0-zro => {?hidden}\\n  | nonZeroApart => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', 'no (Not E)', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\class Dec \\\\extends Dec, With# \\\\hlevels ', '| E : \\\\Set', '\\\\func #0 \\\\hlevels  {this : Dec} (x : E) : \\\\Prop => x /= zro', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>CRing.Dec (Fin (suc (suc n Nat.* m Nat.+ n))) {\n  | zro => 0\n  | + => \\lam (x : E {\\this}) (y : E {\\this}) => fromNat {suc n Nat.* m Nat.+ n} (x AddMonoid.+ y)\n  | negative => \\lam (x : E {\\this}) => fromNat {suc n Nat.* m Nat.+ n} (iabs (suc (suc n Nat.* m Nat.+ n) - x))\n  | #0 => #0\n  | decideEq => \\lam (x : E {\\this}) (y : E {\\this}) => (\\case decideEq x y \\with {\n    | yes x=y => yes {x = y} (fin_nat-inj {suc (suc n Nat.* m Nat.+ n)} {x} {y} x=y)\n    | no x/=y => no {x = y} x/=y\n  })\n  | * => \\lam (x : E {\\this}) (y : E {\\this}) => fromNat {suc n Nat.* m Nat.+ n} (x Semigroup.* y)\n  | ide => fromNat {suc n Nat.* m Nat.+ n} 1\n  | natCoef => fromNat {suc n Nat.* m Nat.+ n}\n}", "completion": "FinRing {_}"}
{"prompt": "['X : PreBanachSpace A', 'A : RatValue']<<<break>>>['cauchy-lift \\\\hlevels  {X Y : CoverSpace} {Z : CompleteCoverSpace} (f : CoverMap X Y) (\\\\property fd : IsDenseEmbedding {f}) (g : CauchyMap X Z)\\n  (y : Y.E) : Z.E => filter-point {Z} (g.func-cauchy (dense-filter-lift {X} {Y} f fd (pointCF {Y} y)))', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma embedding->coverEmbedding \\\\hlevels  {this : UniformMap} (_ : IsUniformEmbedding) : IsEmbedding ', \"\\\\type Quot \\\\hlevels  (X : ExPseudoNormedAbGroup) : \\\\Set => Quotient {X.E} (\\\\lam (x : X.E) (x' : X.E) => X.norm (x - x') = zro)\", '| \\\\infixl 7 * E E : E', '| finv-right {x : E} (x /= zro) : x * finv x = ide', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '\\\\func id \\\\hlevels  {X : RegularPreuniformSpace} : UniformMap X X {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new UniformMap {\\n  | func-cont => {?hidden}\\n  | func-uniform => {?hidden}\\n}', '| dist-uniform {C : Set (Set E)} : isUniform C <-> TruncP (\\\\Sigma (eps : Rat) (zro < eps) (\\\\Pi (x : E) -> TruncP (\\\\Sigma (U1 : Set E) (C U1) (\\\\Pi {y : E} -> U {dist x y} eps -> U1 y))))', '\\\\lemma *q-right-uniform \\\\hlevels  {X : SeparatedPreBanachSpace} {q : Rat} : UniformNormedAbGroupMap X X {\\n  | func => (*q) q\\n} ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '| zro-right {x : E} : x + zro = x', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\lemma dense-lift-char \\\\hlevels  {X Y : CoverSpace} {Z : CompleteCoverSpace} {f : CoverMap X Y} (fd : IsDenseEmbedding {f}) {g : CoverMap X Z} (x : X.E) :\\n  cauchy-lift {X} {Y} {Z} f {?hidden} g (f.func x) = g.func x ', '\\\\instance TopAbGroupCompletion \\\\hlevels  (X1 : TopAbGroup) : CompleteTopAbGroup (RegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X1}}\\n  | zro => pointCF {X1} X.zro\\n  | + => +-func {X1}\\n  | negative => func {negative-cover {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set E)) =>\\n    TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set E) (D V) (mkSet {X1} U \u2286 V))))\\n} => \\\\new CompleteTopAbGroup {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | +-cont => {?hidden}\\n  | negative-cont => {?hidden}\\n  | neighborhood-uniform => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '| isComplete : IsCompleteCoverSpace \\\\this', '\\\\func dist {X1 : ExPseudoMetricSpace} (F1 G : RegularCauchyFilter X1) :\\nExUpperReal (\\\\lam (q : Rat) => TruncP (\\\\Sigma (r : Rat) (r < q) (U1 : E {F.A}) (F.F U1) (V : E {G.A}) (G.F V)\\n  (\\\\Pi {x : F.X} -> U1 x -> \\\\Pi {y : G.X} -> V y -> U {X.dist x y} r))) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| zro<ide : zro < ide', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| zro-left {x : E} : zro + x = x', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| negative-left {x : E} : negative x + x = zro', '| dist-triang {x y z : E} : dist x z <= dist x y + dist y z', '\\\\func +-func \\\\hlevels  {X : TopAbGroup} (x y : RegularCauchyFilter X) : E {Cod {+-cover {X}}} => func {+-cover {X}} (x, y)', '\\\\lemma *_U \\\\plevels  \\\\hlevels  {x y : ExUpperReal} {a : Rat} :\\n  U {x ExUpperReal.* y} a <-> TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b RatField.* c < a)) ', '\\\\func isOpen \\\\hlevels  {this : PrecoverSpace} (S : Set E) : \\\\Prop => \\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S)', '\\\\lemma ide_*q \\\\hlevels  {this : QModule} {a : E} : fromInt (pos 1) *q a = a ', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '| dist-refl {x : E} : dist x x = zro', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func IsBounded \\\\plevels  \\\\hlevels  {this : ExUpperReal} : \\\\Prop => TruncP (\\\\Sigma (r : Rat) (U r))', '\\\\func completion-topAb \\\\hlevels  {X : TopAbGroup} : TopAbGroupMap X (TopAbGroupCompletion X) {\\n  | func => pointCF {X}\\n} => \\\\new TopAbGroupMap {\\n  | func-cont => {?hidden}\\n  | func-+ => {?hidden}\\n  | func-uniform => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '| uniform-cauchy {C : Set (Set E)} : isCauchy C <-> Closure {E} isUniform C', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma completion-lift-unique \\\\hlevels  {X : CoverSpace} {Z : SeparatedCoverSpace} (g h : PrecoverMap (Completion X) Z)\\n  (_ : \\\\Pi (x : X.E) -> g.func (pointCF {X} x) = h.func (pointCF {X} x)) (y : E) : g.func y = h.func y ', '| norm_negative {x : E} : norm (negative x) = norm x', '| dist-ext {x y : E} (dist x y = zro) : x = y', '\\\\func coverSpace \\\\hlevels  {X1 : CoverSpace} : CoverSpace (RegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => isCCauchy {X1}\\n} => \\\\new CoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n}', '| norm E : ExUpperReal', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '| zro : E', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '\\\\lemma *q-assoc \\\\hlevels  {this : QModule} {q r : Rat} {a : E} : q * r *q a = q *q (r *q a) ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\lemma norm-metric-map \\\\hlevels  {X : ExPseudoNormedAbGroup} : MetricMap X ExUpperRealMetric {\\n  | func => X.norm\\n} ', '| finv E : E', '| isHausdorff {x y : E} (\\\\Pi {U V : Set E} -> isOpen U -> isOpen V -> U x -> V y -> TruncP (\\\\Sigma (e : E) ((\u2227) U V e))) : x = y', '\\\\instance UniformCompletion \\\\hlevels  (X1 : UniformSpace) : CompleteUniformSpace (RegularCauchyFilter X1) {\\n  | isOpen => isOpen {coverSpace {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set (E {\\\\this}))) => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C)\\n    (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (D V) (mkSet {X1} U \u2286 V))))\\n} => \\\\new CompleteUniformSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cover => {?hidden}\\n  | uniform-top => {?hidden}\\n  | uniform-refine => {?hidden}\\n  | uniform-inter => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | uniform-star => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '| U Rat : \\\\Prop', '\\\\lemma upper-*-left-uniform \\\\hlevels  {a : ExUpperReal} (_ : IsBounded {a}) : UniformMetricMap ExUpperRealMetric ExUpperRealMetric {\\n  | func => (*) a\\n} ', '\\\\func norm {X1 : ExPseudoNormedAbGroup} (F1 : RegularCauchyFilter X1) :\\n  ExUpperReal (\\\\lam (q : Rat) => TruncP (\\\\Sigma (r : Rat) (r < q) (U1 : E {F.A}) (F.F U1) (\\\\Pi {x : F.X} -> U1 x -> U {X.norm x} r))) \\n=> \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\lemma func-*n \\\\hlevels  {this : AddMonoidHom} {n : Nat} {x : E {Dom}} : func (n *n x) = n *n func x ', '\\\\func mkSet \\\\hlevels  {X : CoverSpace} (U : Set X.E) : Set (RegularCauchyFilter X) => \\\\lam (F1 : RegularCauchyFilter X) => F.F U', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| norm-dist {x y : E} : dist x y = norm (x - y)', '\\\\lemma isDense {X : ExPseudoNormedAbGroup} : IsDense {separated-completion {X}} ', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : RegularPreuniformSpace} (g : UniformMap Y Z) (f : UniformMap X Y) : UniformMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new UniformMap {\\n  | func-cont => {?hidden}\\n  | func-uniform => {?hidden}\\n}', '\\\\lemma dense->uniformEmbedding \\\\hlevels  {this : IsometricMap} (_ : IsDense) : IsDenseUniformEmbedding ', '| isSeparatedCoverSpace {x y : E} (\\\\Pi {C : Set (Set E)} -> isCauchy C -> TruncP (\\\\Sigma (U : Set E) (C U) (\\\\Sigma (U x) (U y)))) : x = y', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| cauchy-open {S : Set E} : isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| dist-symm {x y : E} : dist x y = dist y x', '| norm_*n {n : Nat} {x : E} : norm (n *n x) = norm {A} (fromInt (pos n)) * norm x', '| func-norm-isometry {x : E {Dom}} : norm {Cod} (func x) = norm {Dom} x', '\\\\func separated-completion {X : ExPseudoNormedAbGroup} : NormedIsometricMap (SeparatedNormedAbGroupReflection X) (ExNormedAbGroupCompletion X) {\\n  | func => separated-completion.func {X}\\n} => \\\\new NormedIsometricMap {\\n  | func-+ => {?hidden}\\n  | func-isometry => {?hidden}\\n  | func-norm-isometry => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\func IsDenseEmbedding \\\\hlevels  {this : PrecoverMap} : \\\\Prop => \\\\Sigma IsDense IsEmbedding', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\func IsDense \\\\hlevels  {this : ContMap} : \\\\Prop => IsDenseSet {Cod} (\\\\lam (y : E {Cod}) => TruncP (\\\\Sigma (x : E {Dom}) (func x = y)))', '| norm-ext {x : E} (norm x = zro) : x = zro', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\lemma natRat/=0 \\\\plevels  \\\\hlevels  {n : Nat} (_ : n /= 0) : fromInt (pos n) /= fromInt (pos 0) ', \"\\\\instance SeparatedNormedAbGroupReflection (X : ExPseudoNormedAbGroup) : ExNormedAbGroup (Quot X) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => ExPseudoNormedAbGroup.dist\\n  | zro => in~ {X.E} {\\\\lam (x : X.E) (x' : X.E) => X.norm (x - x') = zro} X.zro\\n  | + => (SeparatedNormedAbGroupReflection.+)\\n  | negative => SeparatedNormedAbGroupReflection.negative {X}\\n  | norm => SeparatedNormedAbGroupReflection.norm {X}\\n} => \\\\new ExNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}\", '\\\\func dense-uniform-lift \\\\hlevels  {X Y : UniformSpace} {Z : CompleteUniformSpace} (f : UniformMap X Y) (fd : IsDenseUniformEmbedding {f})\\n  (g : UniformMap X Z) : UniformMap Y Z {\\n  | func => cauchy-lift {X} {Y} {Z} f {?hidden} g\\n} => \\\\new UniformMap {\\n  | func-cont => {?hidden}\\n  | func-uniform => {?hidden}\\n}', \"\\\\instance SeparatedBanachReflection {A1 : RatValue} (X : PreBanachSpace A1) : SeparatedPreBanachSpace A1 (Quot X) {\\n  | isOpen => isOpen {SeparatedNormedAbGroupReflection X}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {SeparatedNormedAbGroupReflection X}\\n  | dist => dist {SeparatedNormedAbGroupReflection X}\\n  | zro => in~ {X.E} {\\\\lam (x : X.E) (x' : X.E) => X.norm (x - x') = zro} X.zro\\n  | + => (+)\\n  | negative => negative {X}\\n  | norm => SeparatedNormedAbGroupReflection.norm {X}\\n} => \\\\new SeparatedPreBanachSpace {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}\", 'inP A', '| norm_+ {x y : E} : norm (x AddMonoid.+ y) <= norm x ExUpperReal.+ norm y', '| Cod : BaseSet', '| A : RatValue', '\\\\lemma dense-lift-unique \\\\hlevels  {X Y : TopSpace} {Z : HausdorffTopSpace} (f : ContMap X Y) (_ : IsDense {f}) (g h : ContMap Y Z)\\n  (_ : \\\\Pi (x : X.E) -> g.func (f.func x) = h.func (f.func x)) (y : Y.E) : g.func y = h.func y ', '| norm_zro : norm zro = zro', '\\\\instance ExUpperRealMetric \\\\hlevels  : CompleteExMetricSpace ExUpperReal {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => ExUpperRealMetric.dist\\n} => \\\\new CompleteExMetricSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | isComplete => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n}', '\\\\func completion-exNormed-isometry {X : ExPseudoNormedAbGroup} : NormedIsometricMap X (ExNormedAbGroupCompletion X) {\\n  | func => pointCF {X}\\n} => \\\\new NormedIsometricMap {\\n  | func-+ => {?hidden}\\n  | func-isometry => {?hidden}\\n  | func-norm-isometry => {?hidden}\\n}', '| isCompleteMetric (F1 : ProperFilter E) (\\\\Pi {eps : Rat} -> zro < eps -> TruncP (\\\\Sigma (x : E) (F.F (OBall eps x)))) : TruncP (\\\\Sigma (x : E) (\\\\Pi {eps : Rat} -> zro < eps -> F.F (OBall eps x)))', '\\\\class BanachSpace \\\\extends SeparatedPreBanachSpace, CompleteExNormedAbGroup \\\\hlevels ', 'negative-cover \\\\hlevels  {X : TopAbGroup} : CoverMap (UniformCompletion X) (Completion X) \\n=> subtract-cover {X} \u2218 tuple {UniformCompletion X} {UniformCompletion X} {UniformCompletion X}\\n  (const {UniformCompletion X} {UniformCompletion X} (pointCF {X} X.zro)) (id {UniformCompletion X})', '\\\\lemma natUnit \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n * m = 1) : m = 1 ', '| ide : E', '\\\\func IsEmbedding \\\\hlevels  {this : PrecoverMap} : \\\\Prop => \\\\Pi {C : Set (Set (E {Dom}))} -> isCauchy {Dom} C ->\\n  isCauchy {Cod} (\\\\lam (V : Set (E {Cod})) => TruncP (\\\\Sigma (U : Set (E {Dom})) (C U) (func ^-1 V \u2286 U)))', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\lemma *q_*n \\\\hlevels  {this : QModule} {n : Nat} {a : E} : fromInt (pos n) *q a = n *n a ', '| norm-bounded (x : E) : IsBounded {norm x}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\instance ExNormedAbGroupCompletion (X : ExPseudoNormedAbGroup) : CompleteExNormedAbGroup (RegularCauchyFilter X) {\\n  | isOpen => isOpen {coverSpace {X}}\\n  | isCauchy => isCCauchy {X}\\n  | isUniform => \\\\lam (D : Set (Set E)) =>\\n    TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set E) (D V) (mkSet {X} U \u2286 V))))\\n  | dist => ExMetricCompletion.dist {X}\\n  | zro => pointCF {X} X.zro\\n  | + => +-func {X}\\n  | negative => func {negative-cover {X}}\\n  | norm => ExNormedAbGroupCompletion.norm {X}\\n} => \\\\new CompleteExNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isComplete => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n}', '\\\\func isCCauchy \\\\hlevels  {X : CoverSpace} (D : Set (Set (RegularCauchyFilter X))) : \\\\Prop => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isCauchy C)\\n  (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (RegularCauchyFilter X)) (D V) (mkSet {X} U \u2286 V))))', '| +-comm {x y : E} : x + y = y + x', '\\\\lemma *n-uniform \\\\hlevels  {X : TopAbGroup} {n : Nat} : TopAbGroupMap X X {\\n  | func => (*n) n\\n} ']<<<break>>>BanachSpace A1 (RegularCauchyFilter X) {\n  | isOpen => isOpen {coverSpace {X}}\n  | isCauchy => isCCauchy {X}\n  | cauchy-open => {?hidden}\n  | isUniform => \\lam (D : Set (Set E)) =>\n    TruncP (\\Sigma (C : Set (Set X.E)) (X.isUniform C) (\\Pi {U : Set X.E} -> C U -> TruncP (\\Sigma (V : Set E) (D V) (mkSet {X} U \u2286 V))))\n  | uniform-cauchy => {?hidden}\n  | dist => dist {X}\n  | dist-refl => {?hidden}\n  | dist-symm => {?hidden}\n  | dist-triang => {?hidden}\n  | dist-uniform => {?hidden}\n  | zro => pointCF {X} X.zro\n  | + => +-func {X}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | negative => func {negative-cover {X}}\n  | negative-left => {?hidden}\n  | +-comm => {?hidden}\n  | norm => ExNormedAbGroupCompletion.norm {X}\n  | norm_zro => {?hidden}\n  | norm_negative => {?hidden}\n  | norm_+ => {?hidden}\n  | norm-dist => {?hidden}\n  | norm-bounded => {?hidden}\n  | isDivisible => {?hidden}\n  | norm_*n => {?hidden}\n  | isHausdorff => {?hidden}\n  | isSeparatedCoverSpace => {?hidden}\n  | dist-ext => {?hidden}\n  | norm-ext => {?hidden}\n  | isComplete => {?hidden}\n  | isCompleteMetric => {?hidden}\n}", "completion": "\\new BanachSpace {\n  | A => A\n  | CompleteExNormedAbGroup => ExNormedAbGroupCompletion X\n  | isDivisible => \\lam F {n} n/=0 => (\n    \\have *q-lift => dense-uniform-lift separated-completion (dense->uniformEmbedding {separated-completion} isDense)\n            (separated-completion \u2218 *q-right-uniform {SeparatedBanachReflection X} {finv n})\n    \\in inP (*q-lift F, dense-lift-unique separated-completion isDense (*n-uniform {_} {n} \u2218 *q-lift) id\n          (\\lam x => pmap ((*n) n) (dense-lift-char ((dense->uniformEmbedding isDense).1, embedding->coverEmbedding _) x) *> inv (func-*n {separated-completion}) *> pmap separated-completion\n            (inv *q_*n *> inv *q-assoc *> pmap (\\lam _x => _x *q _) (finv-right {RatField} $ natRat/=0 n/=0) *> ide_*q)) F))\n  | norm_*n => \\lam {n} {F} => completion-lift-unique (norm-metric-map {ExNormedAbGroupCompletion X} \u2218 *n-uniform)\n    (upper-*-left-uniform (norm-bounded {A} _) \u2218 norm-metric-map {ExNormedAbGroupCompletion X})\n    (\\lam x => pmap norm (inv (func-*n {completion-topAb})) *> func-norm-isometry {completion-exNormed-isometry} *> norm_*n *> pmap ((*) _) (inv (func-norm-isometry {completion-exNormed-isometry})))\n    F\n}"}
{"prompt": "['X : RealPreBanachAlgebra']<<<break>>>['\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : CoverSpace} (g : CoverMap Y Z) (f : CoverMap X Y) : CoverMap X Z {\\n  | func => \\\\lam (x : E {Dom {g \u2218 f}}) => g.func (f.func x)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '\\\\instance ProductTopAbGroup \\\\hlevels  (X Y : TopAbGroup) : TopAbGroup (\\\\Sigma X.E Y.E) {\\n  | isOpen => \\\\lam (W : Set E) => \\\\Pi {s : E} -> W s -> TruncP (\\\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\\n    (\\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)))\\n  | zro => (X.zro, Y.zro)\\n  | + => \\\\lam (s : E {\\\\this}) (t : E {\\\\this}) => (s.1 X.+ t.1, s.2 Y.+ t.2)\\n  | negative => \\\\lam (s : E {\\\\this}) => (X.negative s.1, Y.negative s.2)\\n  | isCauchy => Closure {\\\\Sigma X.E Y.E} (\\\\lam (C : Set (Set (\\\\Sigma X.E Y.E))) => TruncP (\\\\Sigma (j : Bool) (isCauchy C)))\\n  | isUniform => \\\\lam (E1 : Set (Set E)) =>\\n  TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (D : Set (Set Y.E)) (Y.isUniform D) (Refines {\\\\Sigma X.E Y.E}\\n    (\\\\lam (W : Set (\\\\Sigma X.E Y.E)) => TruncP (\\\\Sigma (U : Set X.E) (C U) (V : Set Y.E) (D V) (W = Prod {X.E} {Y.E} U V)))\\n    E1))\\n} => \\\\new TopAbGroup {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | +-cont => {?hidden}\\n  | negative-cont => {?hidden}\\n  | neighborhood-uniform => {?hidden}\\n}', '\\\\func tuple \\\\hlevels  {X Y Z : CoverSpace} (f : CoverMap Z X) (g : CoverMap Z Y) : CoverMap Z (X \u2a2f Y) {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (f.func z, g.func z)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\class CoverMap \\\\extends PrecoverMap, StronglyCauchyMap \\\\hlevels  {\\n  | func-weak-cauchy => \\\\lam (F1 : WeaklyCauchyFilter Dom) =>\\n  \\\\new WeaklyCauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n    | filter-mono => {?hidden}\\n    | filter-top => {?hidden}\\n    | filter-meet => {?hidden}\\n    | isWeaklyProper => {?hidden}\\n    | isCauchyFilter => {?hidden}\\n  }\\n}', '\\\\lemma proj1 \\\\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) X {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} ', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\instance TopAbGroupCompletion \\\\hlevels  (X1 : TopAbGroup) : CompleteTopAbGroup (RegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X1}}\\n  | zro => pointCF {X1} X.zro\\n  | + => +-func {X1}\\n  | negative => func {negative-cover {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set E)) =>\\n    TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set E) (D V) (mkSet {X1} U \u2286 V))))\\n} => \\\\new CompleteTopAbGroup {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | +-cont => {?hidden}\\n  | negative-cont => {?hidden}\\n  | neighborhood-uniform => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\lemma proj2 \\\\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) Y {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.2\\n} ']<<<break>>>CoverMap (TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X)\n  (TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X) {\n  | func => \\lam (z : E {Dom {\\this}}) =>\n  (func {proj2 {TopAbGroupCompletion X} {TopAbGroupCompletion X} \u2218 proj1 {TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X} {TopAbGroupCompletion X}}\n    z, func {proj2 {ProductTopAbGroup (TopAbGroupCompletion X) (TopAbGroupCompletion X)} {TopAbGroupCompletion X}} z)\n}", "completion": "tuple (proj2 \u2218 proj1) proj2"}
{"prompt": "['c : Cover {P} x {J} g', 'x : P.E', 'J : \\\\Set', 'P : FramePres', 'g : J -> P.E']<<<break>>>[\"cover-trans' {I : \\\\Set} {f : I -> P.E} (Cover' {P} x {I} f) (\\\\Pi (i : I) -> Cover' {P} (f i) {J} g)\", '| conj E E : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\data Cover' \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic' {a b : P.E} (x = P.conj a b) {f : J -> P.E} (P.BasicCover {J} b f) (\\\\Pi (j : J) -> g j = P.conj a (f j))\\n  | cover-inj' (j : J) (g j = x)\\n  | cover-trans' {I : \\\\Set} {f : I -> P.E} (Cover' {P} x {I} f) (\\\\Pi (i : I) -> Cover' {P} (f i) {J} g)\\n  | cover-proj1-inj' {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-proj2-inj' {a b : P.E} (x = P.conj a b) (j : J) (g j = b)\\n  | cover-prod-inj' {a b : P.E} (Cover' {P} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => a)) (Cover' {P} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => b)) (j : J) (g j = P.conj a b)\", '| E : \\\\Set', \"cover-proj2-inj' {a b : P.E} (x = P.conj a b) (j : J) (g j = b)\", \"\\\\lemma cover-ldistr' \\\\hlevels  {P : FramePres} {J : \\\\Set} {g : J -> P.E} {a b : P.E} {f : J -> P.E} (_ : Cover {P} b {J} f)\\n  (_ : \\\\Pi (j : J) -> g j = P.conj a (f j)) : Cover' {P} (P.conj a b) {J} g \"]<<<break>>>\\Sigma -> Cover' {P} (P.conj x x) {J} g", "completion": "\\lam _ => cover-trans' (cover-ldistr' c (\\lam j => idp)) (\\lam j => cover-proj2-inj' idp j idp)"}
{"prompt": "['this : Dec', 'c : \\\\Sigma (a b : E) (b#0 : #0 b) (GCD {\\\\new this {}} a b ide) (x = inl~ {\\\\new this {}} {subMonoid} (a, b, b#0))', 'c1#0 : #0 c.1']<<<break>>>['\\\\lemma ldiv_nonZero \\\\hlevels  {this : Domain} {a b : E} (_ : LDiv a.1 b.1) : LDiv {nonZeroMonoid} a b ', '| res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res', '| \\\\infix 8 #0 E : \\\\Prop', '\\\\func nonZero_ldiv \\\\hlevels  {this : Domain} {a b : E} (a|b : LDiv {nonZeroMonoid} a b) : LDiv a.1 b.1 a|b.inv.1 => \\\\new LDiv {\\n  | inv-right => {?hidden}\\n}', '\\\\func nonZeroGCDMonoid \\\\hlevels  {this5 : GCDDomain} : CancelGCDMonoid (\\\\Sigma (x : E) (#0 x)) {\\n  | ide => (ide, zro#ide)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, #0-* {x.1} {y.1} x.2 y.2)\\n} => \\\\new CancelGCDMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n  | isGCD => {?hidden}\\n  | cancel_*-left => {?hidden}\\n}', '| ide : E', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\lemma ide-div \\\\hlevels  {M : Monoid} {x : M.E} : LDiv {M} M.ide x x ', '| val1 : E {M}', '\\\\class GCD \\\\hlevels  {\\n  | M : CMonoid\\n  | val1 : E {M}\\n  | val2 : E {M}\\n  | res : E {M}\\n  | res|val1 : LDiv {M} res val1\\n  | res|val2 : LDiv {M} res val2\\n  | res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res\\n}', '| val2 : E {M}', '| E : \\\\Set', '| M : CMonoid']<<<break>>>GCD {nonZeroGCDMonoid} (c.2, c.3) (c.1, c1#0) ide (ide-div {nonZeroGCDMonoid} {(c.2, c.3)})\n  (ide-div {nonZeroGCDMonoid} {(c.1, c1#0)})\n  (\\lam (g : E {M {\\this}}) (g|c2 : LDiv {M {\\this}} g (val1 {\\this})) (g|c1 : LDiv {M {\\this}} g (val2 {\\this})) =>\n    ldiv_nonZero {g} {ide} (res-univ {c.4} g.1 (nonZero_ldiv {g} {(c.1, c1#0)} g|c1) (nonZero_ldiv {g} {(c.2, c.3)} g|c2)))", "completion": "\\new GCD {\n  | res|val1 => ide-div\n  | res|val2 => ide-div\n  | res-univ => \\lam g g|c2 g|c1 => ldiv_nonZero {this} $ res-univ {c.4} g.1 (nonZero_ldiv {this} g|c1) (nonZero_ldiv {this} g|c2)\n}"}
{"prompt": "['R : CRing', 'r : R.E', 'a : SType {R} S']<<<break>>>['| len : Nat', '\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', '| C : Semiring', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '| vars : Array (E {M})', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', ':ide', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new CRingData {R} (a.2 :: r :: a.1 :: nil) {\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 3} 0 :* var {E} {Fin 3} 1 :* var {E} {Fin 3} 2 :* :ide {Int} {Fin 3}) = interpret {\\new CRingData {R} (a.2 :: r :: a.1 :: nil) {\n  | interpretNF_negate => {?hidden}\n}} (:ide {Int} {Fin 3} :* (var {E} {Fin 3} 2 :* var {E} {Fin 3} 1 :* var {E} {Fin 3} 0))", "completion": "\n  \\let d => \\new CRingData {\n         | R => R\n         | vars => a.2 :: r :: a.1 :: nil\n       }\n  \\in terms-equality {d} (var 0 :* var 1 :* var 2 :* :ide) (:ide :* (var 2 :* var 1 :* var 0)) idp"}
{"prompt": "['delta : Rat', 'this : OrderedC*AlgebraHom', 'delta<eps : delta < eps', 'y-x<=delta : y - func {toNormed} x <= delta *q ide {Cod}', 'x : E {Dom {toNormed}}', 'y : E {Cod}', 'eps : Rat']<<<break>>>['\\\\lemma <=_*q-left \\\\hlevels  {this : PosetQModule} {q r : Rat} (_ : q <= r) {a : E} (_ : zro <= a) : q *q a <= r *q a ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\lemma zro<=ide \\\\hlevels  {this : OrderedC*Algebra} : zro <= ide ', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>y - func x <= eps *q ide {Cod}", "completion": "y-x<=delta <=\u2218 <=_*q-left (<=-less {RatField} delta<eps) zro<=ide"}
{"prompt": "['Y : TopSpace', 'U : Set X.E', 'X : TopSpace', 'this : ContMap (TopSub {X} U) (TopSub {Y} V) {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => (f.func s.1, p {s.1} s.2)\\n  | func-cont => {?hidden}\\n}', 'V : Set Y.E', 'f : ContMap X Y', 'p : \\\\Pi {x : X.E} -> U x -> V (f.func x)']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| isOpen (Set E) : \\\\Prop', '\\\\func TopSub \\\\hlevels  {X : TopSpace} (S : Set X.E) : TopSpace (\\\\Sigma (x : X.E) (\\\\property (S x))) {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) =>\\n    TruncP (\\\\Sigma (V : Set X.E) (X.isOpen V) (U = (\\\\lam (p0 : \\\\Sigma (x : X.E) (\\\\property (S x))) => p0.1) ^-1 V))\\n} => TopTransfer {\\\\Sigma (x : X.E) (\\\\property (S x))} {X} (\\\\lam (p0 : \\\\Sigma (x : X.E) (\\\\property (S x))) => p0.1)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))', '| Dom : BaseSet']<<<break>>>\\Pi {_x : E {Cod {\\this}} -> \\Prop} ->\n  isOpen {Cod {\\this}} _x -> isOpen {Dom {\\this}} (\\lam (x : E {Dom {\\this}}) => _x (func {\\this} x))", "completion": "\\lam {_} p0 => (\\scase \\elim _, \\elim p0 \\with {\n  | _, inP (V, Vo, idp) => inP (f ^-1 V, func-cont Vo, idp)\n})"}
{"prompt": "['V : Set Y.E', 'Y : PrecoverSpace', 'X : PrecoverSpace', 'f : PrecoverMap X Y', 'U : Set Y.E']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', 'byLeft A', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func Compl \\\\hlevels  {X : \\\\hType} (U : Set X) : Set X => \\\\lam (x : X) => Not (U x)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'byRight B']<<<break>>>\\Pi {U1 : Set X.E} -> TruncP (\\Sigma (V1 : Set Y.E) ((V1 = Compl {Y.E} U) || (V1 = V)) (U1 = f.func ^-1 V1)) ->\n  (\\lam (U1 : Set X.E) => (U1 = f.func ^-1 Compl {Y.E} U) || (U1 = f.func ^-1 V)) U1", "completion": "\\lam p0 => (\\case p0 \\with {\n  | inP (_, byLeft idp, p) => byLeft p\n  | inP (_, byRight idp, p) => byRight p\n})"}
{"prompt": "['k : Fin l.len', 'this : GradedCRing', 'p2 : k /= fin-inc-right {suc n} {suc m} (fromNat {m} m)', 'a : E', 'n : Nat', 'm : Nat', 'p1 : k /= fin-inc {suc n} {suc m} (fromNat {n} n)']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', 'suc Nat', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '\\\\lemma char_nat \\\\plevels  \\\\hlevels  {n : Nat} (i : Nat) : fin-inc {suc i} {n} (fromNat {i} i) = i ', 'no (Not E)', '\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', '| E : \\\\Set', '| negative E : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func toFin \\\\plevels  \\\\hlevels  (k1 : Nat) {n1 : Nat} (\\\\property _ : k1 < n1) : Fin n1 \\n  | 0, {suc n}, p => 0\\n  | suc k, {suc n}, p => suc (toFin k {n} {?hidden})', '| <=-refl {x : E} : x <= x', '\\\\lemma decideEq/=_reduce \\\\hlevels  {A : DecSet} {x y : A.E} (p : x /= y) : A.decideEq x y = no {x = y} p ', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '\\\\lemma fin_nat-inj \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : x = y) : x = y ', '| zro : E', '\\\\func divMod \\\\plevels  \\\\hlevels  (_ _ : Nat) : \\\\Sigma Nat Nat ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma char_nat \\\\plevels  \\\\hlevels  {n : Nat} (i : Nat) : fin-inc-right {n} {suc i} (fromNat {i} i) = i ', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\func fin-inc \\\\plevels  \\\\hlevels  {n1 m1 : Nat} (_ : Fin n1) : Fin (n1 + m1) \\n  | {suc n}, {m}, zero => 0\\n  | {suc n}, {m}, suc i => suc (fin-inc {n} {m} i)', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>(\\case decideEq n k, decideEq m k \\with {\n  | yes p, d => a\n  | no n, yes p => negative a\n  | no n, no n => zro\n}) = zro", "completion": "rewrite (decideEq/=_reduce (\\lam p => p1 $ fin_nat-inj $ inv $ char_nat {suc m} n *> p))\n  (rewrite (decideEq/=_reduce (\\lam p => p2 $ fin_nat-inj $ inv $ char_nat {suc n} m *> p)) idp)"}
{"prompt": "['y : Real', 'x : Real']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| M : Monoid', '| R : Semiring', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| vars : Array (E {M})', '| zro : E', '\\\\field mData : MonoidData {R} vars', '| E : \\\\Set', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>LinearRatAlgebraData {RealField} (x :: y :: zro :: zro :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => x :: y :: zro :: zro :: nil\n}"}
{"prompt": "['C : Set (Set X.E)', 'X : CoverSpace', 'Cc : X.isCauchy C']<<<break>>>['| isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>X.isCauchy (\\lam (V : Set X.E) => TruncP (\\Sigma (U : Set X.E) (C U) (V <=< U)))", "completion": "isRegular Cc"}
{"prompt": "['Y : RegularPreuniformSpace', 'CU : C U', 'V : Set X', 'f : X -> Y.E', \"V' : Set Y.E\", \"Vp : f ^-1 V' \u2286 V\", 'X : \\\\Set', 'D : Set (Set (E {\\\\this}))', 'U : Set X', 'C : Set (Set (E {\\\\this}))', 'DV : D V', \"U' : Set Y.E\", \"Up : f ^-1 U' \u2286 U\"]<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '\\\\func CoverInter \\\\hlevels  {X : \\\\hType} (C : Set (Set X)) (D : Set (Set X)) : Set (Set X) \\n  => \\\\lam (W : Set X) => TruncP (\\\\Sigma (U : Set X) (C U) (V : Set X) (D V) (W = U \u2227 V))', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U : Set X) (CoverInter {X} C D U) (f ^-1 (U' \u2227 V') \u2286 U))", "completion": "inP (later (U \u2227 V, inP (U, CU, V, DV, idp), meet-monotone Up Vp))"}
{"prompt": "['m : Nat', 'R : CRing']<<<break>>>['\\\\instance M~-equiv \\\\hlevels  {R : Ring} {n m : Nat} : Equivalence (Matrix R.E n m) {\\n  | ~ => (M~)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', '| E : \\\\Set', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '\\\\class Equivalence \\\\extends Transitive \\\\hlevels  {\\n  | ~-reflexive {x : A} : x ~ x\\n  | ~-symmetric {x y : A} (x ~ y) : y ~ x\\n}', '\\\\type \\\\infix 4 M~ \\\\hlevels  {R : Ring} {n m : Nat} (A B : Matrix R.E n m) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (B = C.val product A product D.val))']<<<break>>>Equivalence (Matrix (E {R}) 0 m) {\n  | ~ => (M~)\n}", "completion": "M~-equiv {_} {_} {_}"}
{"prompt": "['l : GroupTerm V', 'this : NatData', 'r : GroupTerm V', 'p : count-leaves (l :* r) = 0']<<<break>>>['| \\\\infixl 6 + E E : E', '| <=-refl {x : E} : x <= x', '\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func count-leaves \\\\hlevels  {this1 : NatData} (_ : GroupTerm V) : Nat \\n  | {this}, l :* r => count-leaves l + count-leaves r\\n  | {this}, :inv (var x) => 1\\n  | {this}, :inv g => 0\\n  | {this}, var x => 1\\n  | {this}, t => 0', '\\\\infixl 6 :* (_ _ : GroupTerm V)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| \\\\infix 4 <= E E : \\\\Prop', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>count-leaves l + 0 <= 0", "completion": "rewrite p (<=_+ (<=-refl {_} {count-leaves {this} l}) (zero<=_ {count-leaves {this} r}))"}
{"prompt": "['x : E', 'p0 : zro <= x', 'this : StoneC*Algebra']<<<break>>>['| zro : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| E : \\\\Set', '\\\\func IsSquare \\\\hlevels  {this : Semigroup} (x : E) : \\\\Prop => TruncP (\\\\Sigma (y : E) (y * y = x))', '\\\\lemma minus_zro \\\\hlevels  {this : AddGroup} {x : E} : x - zro = x ']<<<break>>>IsSquare x", "completion": "transport (IsSquare {this}) (minus_zro {this}) p0"}
{"prompt": "['f : env.symbol s', 'index : Fin (arity {env} {s} f)', 's : env.Sort', 'mc : MetaContext env.Sort', 'env : FSignature', 'arguments : DArray {arity {env} {s} f}\\n  (\\\\lam (index : Fin (arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc)', 'context : List env.Sort']<<<break>>>['\\\\func apply \\\\hlevels  {env2 : FSignature} {s2 : env.Sort} {old-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\\n  (_ : Term env2 old-context2 s2 mc2) {new-context2 : List env.Sort}\\n  (_ : Substitution {env2} old-context2 new-context2 mc2) : Term env2 new-context2 s2 mc2 \\n  | {env}, {s}, {old-context}, {mc}, var index idp, {new-context}, map => map index\\n  | {env}, {s}, {old-context}, {mc}, metavar m arguments, {new-context}, map =>\\n  metavar {env} {new-context} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term env new-context (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) =>\\n      apply {env} {mc.m-domain {s} m !! i} {old-context} {mc} (arguments.at i) {new-context} map))\\n  | {env}, {s}, {old-context}, {mc}, func f arguments, {new-context}, map =>\\n  func {env} {new-context} {s} {mc} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (new-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) =>\\n    apply {env} {f !!sort i} {old-context ++ f !!domain i} {mc} (arguments.at i) {new-context ++ f !!domain i}\\n      (append-context-right {env} {old-context} {new-context} {mc} map {f !!domain i})))', '\\\\lemma plain-identity-effect \\\\hlevels  {env : FSignature} {context : List env.Sort} {s : env.Sort} {mc : MetaContext env.Sort} (t : Term env context s mc) :\\n  apply {env} {s} {context} {mc} t {context} (plain-identity {env} {context} {mc}) = t ', '\\\\func append-context-right \\\\hlevels  {env3 : FSignature} {old-context2 new-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Substitution {env3} old-context2 new-context3 mc3) {additional-context3 : List env.Sort}\\n  (index2 : Index {env.Sort} (old-context2 ++ additional-context3)) :\\n  Term env3 (new-context3 ++ additional-context3) ((old-context2 ++ additional-context3) !! index2) mc3 \\n  | {env}, {nil}, {new-context}, {mc}, subst, {additional-context}, index =>\\n  weakening {env} {(nil {env.Sort} ++ additional-context) !! index} {additional-context} {new-context ++ additional-context} {mc}\\n    (var {env} {additional-context} {(nil {env.Sort} ++ additional-context) !! index} {mc} index\\n      (idp {env.Sort} {(nil {env.Sort} ++ additional-context) !! index}))\\n    (id+left {env.Sort} {additional-context} {new-context})\\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, zero =>\\n  weakening {env} {((a :: old-context) ++ additional-context) !! 0} {new-context} {new-context ++ additional-context} {mc} (subst 0)\\n    (id+right {env.Sort} {new-context} {additional-context})\\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, suc index => append-context-right\\n    {env} {old-context} {new-context} {mc} (\\\\lam (i : Index {env.Sort} old-context) => subst (suc i)) {additional-context}\\n      index', '\\\\func Index {A : \\\\Type} (list : List A) : \\\\Type => Fin (length {A} list)', '\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', '\\\\func \\\\infix 7 !!sort \\\\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\\\Sigma (List Sort) Sort} (domain {s} m)) : Sort \\n  => (domain {s} m !! index).2', '| Sort : \\\\Set', '\\\\func plain-identity \\\\hlevels  {env : FSignature} {context : List env.Sort} {mc : MetaContext env.Sort} : Substitution {env} context context mc \\n  => \\\\lam (i : Index {env.Sort} context) => var {env} {context} {context !! i} {mc} i (idp {env.Sort} {context !! i})', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\lemma to-identity \\\\hlevels  {env : FSignature} {old-context : List env.Sort} {mc : MetaContext env.Sort} {additional-context : List env.Sort} :\\nappend-context-right\\n  {env} {old-context} {old-context} {mc} (plain-identity {env} {old-context} {mc}) {additional-context} = plain-identity {env} {old-context ++ additional-context} {mc} ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func \\\\infix 7 !!domain \\\\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\\\Sigma (List Sort) Sort} (domain {s} m)) : List Sort \\n  => (domain {s} m !! index).1', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys']<<<break>>>apply {env} {f !!sort index} {context ++ f !!domain index} {mc} (arguments !! index) {context ++ f !!domain index}\n  (append-context-right {env} {context} {context} {mc} (plain-identity {env} {context} {mc}) {f !!domain index}) = arguments !! index", "completion": "rewrite to-identity (plain-identity-effect (arguments index))"}
{"prompt": "['G : Functor J this', 'J : Precat', 'data : ColimitData {J} {T} G', \"this : BicompleteCat (Model T) {\\n  | Hom => ModelHom {T}\\n  | id => \\\\lam (M : Ob) => \\\\new ModelHom {T} M M {\\n    | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => x\\n    | func-op => {?hidden}\\n    | func-rel => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => \\\\new ModelHom {T} X Z {\\n    | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => g.funcs {s} (f.funcs {s} x)\\n    | func-op => {?hidden}\\n    | func-rel => {?hidden}\\n  }\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => Product.fromLimit {Empty} (limit {\\\\this} {DiscretePrecat Empty} (Product.functor {Empty} (absurd {Ob {\\\\this}})))\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G1 : Functor J this16) =>\\n  \\\\new Limit {J} G1 (\\\\new Model T (\\\\lam (s : Sort {Structure.T}) => \\\\Sigma (P : \\\\Pi (j : J.Ob) -> E {G.F j} s)\\n    (\\\\Pi {j j' : J.Ob} -> \\\\Pi (h : J.Hom j j') -> funcs {G.Func {j} {j'} h} {s} (P j) = P j')) {\\n    | operation => \\\\lam {r : Sort {Structure.T}} (h : Symb {Structure.T} r) (d : DArray {len {domain {Structure.T} {r} h}}\\n      (\\\\lam (j : Fin (len {domain {Structure.T} {r} h})) => E (at {domain {Structure.T} {r} h} j))) =>\\n    (\\\\lam (j : J.Ob) => operation {G.F j} {r} h (\\\\new DArray {len {domain {Structure.T {G.F j}} {r} h}}\\n      (\\\\lam (j1 : Fin (len {domain {Structure.T {G.F j}} {r} h})) => E {G.F j} (at {domain {Structure.T {G.F j}} {r} h} j1))\\n      (\\\\lam (k : Fin (len {domain {Structure.T {G.F j}} {r} h})) => (d.at k).1 j)),\\n      \\\\lam {j : J.Ob} {j' : J.Ob} (f : J.Hom j j') =>\\n      func-op {G.Func {j} {j'} f} {r} h (\\\\new DArray {len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h}}\\n        (\\\\lam (j1 : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) =>\\n          E {Dom {G.Func {j} {j'} f}} (at {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h} j1))\\n        (\\\\lam (k : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) => (d.at k).1 j)) *> path (\\\\lam (i : I) => operation {G.F j'} {r} h\\n        (\\\\new DArray {len {T.domain {r} h}} (\\\\lam (j : Fin (len {T.domain {r} h})) => E {G.F j'} (T.domain {r} h !! j))\\n          (\\\\lam (j1 : Fin (len {T.domain {r} h})) => (d.at j1).2 {j} {j'} f @ i))))\\n    | relation => \\\\lam (P : PredSymb {Structure.T}) (d : DArray {len {predDomain {Structure.T} P}}\\n      (\\\\lam (j : Fin (len {predDomain {Structure.T} P})) => E (at {predDomain {Structure.T} P} j))) =>\\n    \\\\Pi (j : J.Ob) -> relation {G.F j} P (\\\\new DArray {len {predDomain {Structure.T {G.F j}} P}}\\n      (\\\\lam (j1 : Fin (len {predDomain {Structure.T {G.F j}} P})) => E {G.F j} (at {predDomain {Structure.T {G.F j}} P} j1))\\n      (\\\\lam (k : Fin (len {predDomain {Structure.T {G.F j}} P})) => (d.at k).1 j))\\n    | isModel => {?hidden}\\n  }) {\\n    | coneMap => \\\\lam (j : Ob {Cone.J {\\\\this}}) => \\\\new ModelHom {T} (apex {\\\\this}) (F {G {\\\\this}} j) {\\n      | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (P : E {Dom {\\\\this}} s) => P.1 j\\n      | func-op => {?hidden}\\n      | func-rel => {?hidden}\\n    }\\n    | coneCoh => {?hidden}\\n    | isLimit => {?hidden}\\n    | limMap => \\\\lam {z : Ob {D {\\\\this}}} (c : Cone {Cone.J {\\\\this}} {D {\\\\this}} (G {\\\\this}) z) => \\\\new ModelHom {T} z (apex {\\\\this}) {\\n      | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => (\\\\lam (j : J.Ob) => funcs {c.coneMap j} {s} x,\\n        \\\\lam {j j' : J.Ob} (f : J.Hom j j') => path (\\\\lam (p0 : I) => funcs {c.coneCoh {j} {j'} f @ p0} {s} x))\\n      | func-op => {?hidden}\\n      | func-rel => {?hidden}\\n    }\\n    | limBeta => {?hidden}\\n    | limUnique => {?hidden}\\n  }\\n  | univalence => {?hidden}\\n  | colimit => \\\\lam {J : Precat} (G1 : Functor J this16) => (\\n    \\\\let data => \\\\new ColimitData {J} {T} G1\\n    \\\\in \\\\new Limit {Precat.op {J}} {Precat.op} (Functor.op {G1}) (Colimit {data}) {\\n          | coneMap => colimitMap {data}\\n          | coneCoh => {?hidden}\\n          | isLimit => {?hidden}\\n          | limMap => limMap-impl\\n          | limBeta => {?hidden}\\n          | limUnique => {?hidden}\\n        })\\n}\"]<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| J : Precat', '| D : Precat', '\\\\func colimitCone {this2 : ColimitData} : Cone {Precat.op {ModelCat.ColimitData.J}} {Precat.op {ModelPrecat ModelCat.ColimitData.T}}\\n  (Functor.op {ModelCat.ColimitData.G}) Colimit {\\n  | coneMap => colimitMap\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| G : Functor J D', '| J : Precat', '| isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\\\new \\\\this {}) z)', \"\\\\func Colimit {this1 : ColimitData} : Model ModelCat.ColimitData.T (QTerm {thExt}) {\\n  | operation => \\\\lam {r : Sort {Structure.T}} (h : Symb {Structure.T} r) =>\\n    qapply {thExt} {r} (inl {Symb {ModelCat.ColimitData.T} r} {Trunc0 (\\\\Sigma (j : Ob {J}) (Structure.E {F {G} j} r))} h)\\n  | relation => \\\\lam (P : PredSymb {Structure.T}) (args : DArray {len {predDomain {Structure.T} P}}\\n    (\\\\lam (j : Fin (len {predDomain {Structure.T} P})) => Structure.E (at {predDomain {Structure.T} P} j))) =>\\n  TruncP (\\\\Sigma (args' : DArray {len {predDomain {ModelCat.ColimitData.T} P}}\\n    (\\\\lam (i : Fin (len {predDomain {ModelCat.ColimitData.T} P})) => Term {thExt} (\\\\lam (_ : Sort) => Empty) (at {predDomain P} i)))\\n    (isTheorem {thExt} {\\\\lam (_ : Sort) => Empty} nil (predicate {thExt} {\\\\lam (_ : Sort) => Empty} P args'))\\n    (\\\\Pi (i : Fin (len {predDomain P})) -> qinj {thExt} {at {predDomain P} i} (args'.at i) = args.at i))\\n} => \\\\new Model {\\n  | isModel => {?hidden}\\n}\", '\\\\func colimitMap {this2 : ColimitData} (j : Ob {J}) : ModelHom {ModelCat.ColimitData.T} (F {G} j) Colimit {\\n  | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) =>\\n  qapply {thExt} {s} (inr {Symb {ModelCat.ColimitData.T} s} {Trunc0 (\\\\Sigma (j : Ob {J}) (E {F {G} j} s))}\\n    (in0 {\\\\Sigma (j : Ob {J}) (E {F {G} j} s)} (j, x))) nil\\n} => \\\\new ModelHom {\\n  | func-op => {?hidden}\\n  | func-rel => {?hidden}\\n}', '\\\\func limMap-impl \\\\plevels obj >= hom \\\\hlevels  {this : Limit} {z : Ob {D}} (c : Cone {J} {D} G z) : Hom {D} z apex => ret {isLimit z} c', '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\func isInj {this : Equiv} {a a' : A} (p : f a = f a') : a = a' \\n  => inv {A} {ret (f a)} {a} (ret_f a) *> pmap {B} {A} ret {f a} {f a'} p *> ret_f a'\", \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", '\\\\lemma isColimit {this : ColimitData} (M : Model T) :\\nEquiv {ModelHom {T} Colimit M} {Cone {Precat.op {J}} {Precat.op {ModelPrecat T}} (Functor.op {G}) M}\\n  (conePullback {Precat.op {J}} {Precat.op {ModelPrecat T}} {Functor.op {G}} colimitCone M) ', '\\\\class Model \\\\extends Structure {\\n  | isModel (S : Sequent {T}) (axioms {T} S) : isSequentTrue S\\n}', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', \"\\\\class Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | J : Precat\\n  | D : Precat\\n  | G : Functor J D\\n  | apex : Ob {D}\\n  | coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)\\n  | coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\\n}\", '\\\\lemma limBeta-impl \\\\plevels obj >= hom \\\\hlevels  {this : Limit} {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap-impl {z} c = c.coneMap j \\n  => path (\\\\lam (i : I) => coneMap {f_ret {isLimit z} c @ i} j)', '| F (Ob {C}) : Ob {D}', '\\\\class Limit \\\\extends Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\\\new \\\\this {}) z)\\n  | limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex\\n  | limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j\\n  | limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g\\n}', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| T : Theory', '| Ob : \\\\hType', '| B : \\\\Type', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}']<<<break>>>Limit {Precat.op {J}} {Precat.op} (Functor.op {G1}) (Colimit {data}) {\n  | coneMap => colimitMap {data}\n  | coneCoh => {?hidden}\n  | isLimit => {?hidden}\n  | limMap => limMap-impl\n  | limBeta => {?hidden}\n  | limUnique => {?hidden}\n}", "completion": "\\new Limit {\n  | apex => Colimit\n  | coneMap => colimitMap\n  | coneCoh => coneCoh {colimitCone}\n  | isLimit => isColimit\n}"}
{"prompt": "[\"h : \\\\Pi {x : G.X} -> V' x -> \\\\Pi {y : H.X} -> W y -> U {X.dist x y} r\", 'r : Rat', 'z : H.X', \"V'y : V' y\", 'X : ExPseudoMetricSpace', 'Wz : W z', 'y : G.X']<<<break>>>['| U Rat : \\\\Prop', '| dist E E : ExUpperReal']<<<break>>>U {X.dist y z} r", "completion": "h V'y Wz"}
{"prompt": "['eps : Rat', 'this : UniformNormedAbGroupMap']<<<break>>>['| zro : E', '| isOpen (Set E) : \\\\Prop', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '| func-cont {U : E {Cod} -> \\\\Prop} (isOpen {Cod} U) : isOpen {Dom} (\\\\lam (x : E {Dom}) => U (func x))', '\\\\func OBall \\\\hlevels  {X : ExPseudoMetricSpace} (eps : Rat) (x : X.E) : Set X.E => \\\\lam (y : X.E) => U {X.dist x y} eps', '| Dom : BaseSet', '\\\\lemma OBall-open \\\\hlevels  {X : ExPseudoMetricSpace} {eps : Rat} {x : X.E} : X.isOpen (OBall {X} eps x) ']<<<break>>>isOpen {Dom} (\\lam (x : E {Dom}) => OBall {Cod} eps (func (zro {Dom})) (func x))", "completion": "func-cont {this} OBall-open"}
{"prompt": "['C : Matrix R.E k s', 's : Nat', 'k : Nat', 'A : Matrix R.E m k', 'm : Nat', 'n : Nat', 'R : CRing', 'B : Matrix R.E n m']<<<break>>>['\\\\func transpose {R : \\\\Type} {n m : Nat} (M : Matrix R n m) : Matrix R m n \\n  => mkMatrix {R} {m} {n} (\\\\lam (i : Fin m) (j : Fin n) => at {at {M} j} i)', '| E : \\\\Set', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', \"\\\\lemma product \\\\hlevels  {R : CRing} {n m k : Nat} {M : Matrix R.E n m} {M' : Matrix R.E m k} :\\n  transpose {R.E} {n} {k} (M product M') = transpose {R.E} {m} {k} M' product transpose {R.E} {n} {m} M \", '\\\\func \\\\infixl 7 product \\\\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))']<<<break>>>transpose {R.E} {n} {s} (B product A product C) = transpose {R.E} {k} {s} C product transpose {R.E} {n} {k} (B product A)", "completion": "product {_} {_} {_} {_} {B product A}"}
{"prompt": "['a : Rat', 'z : Rat', 'b : Rat']<<<break>>>['| len : Nat', '\\\\field mData : MonoidData {R} vars', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| M : Monoid', '| R : Semiring', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '| E : \\\\Set', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '| vars : Array (E {M})', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ']<<<break>>>LinearRatData (b :: a :: z :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new LinearRatData {\n  | R => RatField\n  | vars => b :: a :: z :: nil\n}"}
{"prompt": "['x<=x0b+1 : x <= fromRat (x0b + fromInt (pos 1))', 'y0b>0 : zro < y0b', 'eps : Rat', 'x0b>0 : zro < x0b', 'gamma-m : fromRat (y0b + fromInt (pos 1) + fromInt (pos 1) + (x0b + fromInt (pos 1) + fromInt (pos 1))) * fromRat gamma <= fromRat (half eps)', 'y0b : Rat', 'gamma : Rat', 'y<=y0b+1 : y <= fromRat (y0b + fromInt (pos 1))', \"x' : E\", 'x0b : Rat', 'y : E', \"xx'<gamma : \\\\Sigma (a : Rat) (a < gamma \u2227 fromInt (pos 1)) (zro <= a) (x <= x' + fromRat a) (x' <= x + fromRat a)\", \"yy'<gamma : \\\\Sigma (a : Rat) (a < gamma \u2227 fromInt (pos 1)) (zro <= a) (y <= y' + fromRat a) (y' <= y + fromRat a)\", 'x : E']<<<break>>>['true', '\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| E : \\\\Set', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance RatNormed \\\\hlevels  : NormedAbGroup Rat {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | negative => RatField.negative\\n  | norm => \\\\lam (a : E {\\\\this}) => Real.fromRat (abs {RatField} a)\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| len : Nat', '\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\lemma <=_* \\\\plevels  \\\\hlevels  {x x' y y' : ExUpperReal} (_ : x <= x') (_ : y <= y') : x * y <= x' * y' \", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| meet-right {x y : E} : x \u2227 y <= y', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '| *-comm {x y : E} : x * y = y * x', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', '\\\\lemma +-rat \\\\plevels  \\\\hlevels  {x y : Rat} : fromRat x ExUpperReal.+ fromRat y = fromRat (x RatField.+ y) ', ':ide', ':zro', '\\\\func half \\\\plevels  \\\\hlevels  (a : Rat) : Rat => a * ratio (pos 1) 2', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\lemma rdistr \\\\plevels  \\\\hlevels  {x y z : ExUpperReal} (_ : zro <= x) (_ : zro <= y) : (x + y) * z = x * z + y * z ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>x * y ExUpperReal.+ fromRat xx'<gamma.1 * y AddMonoid.+ x' * fromRat yy'<gamma.1 <= x * y AddMonoid.+ fromRat (half eps)", "completion": "=_<= +-assoc <=\u2218 <=_+ <=-refl (<=_+ (=_<= *-comm <=\u2218 <=_* (y<=y0b+1 <=\u2218 <=-rat.1 linarith) (<=-rat.1 $ <=-less xx'<gamma.2 <=\u2218 meet-left))\n  (<=_* (transport ((<=) _) +-rat $ xx'<gamma.5 <=\u2218 <=_+ x<=x0b+1 (<=-rat.1 $ <=-less xx'<gamma.2 <=\u2218 meet-right))\n    (<=-rat.1 $ <=-less yy'<gamma.2 <=\u2218 meet-left)) <=\u2218 gamma-m)"}
{"prompt": "['this : Group']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\class Semigroup \\\\extends BaseSet \\\\hlevels  {\\n  | \\\\infixl 7 * E E : E\\n  | *-assoc {x y z : E} : x * y * z = x * (y * z)\\n}', '\\\\func op \\\\hlevels  {this2 : Semigroup} : Semigroup E {\\n  | * => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => y * x\\n} => \\\\new Semigroup {\\n  | *-assoc => {?hidden}\\n}', '| E : \\\\Set']<<<break>>>Semigroup E {\n  | * => \\lam (x : E {\\this}) (y : E {\\this}) => y * x\n}", "completion": "op {this}"}
{"prompt": "['e : Equiv {A} {B}', 'A : \\\\Type', 'C : \\\\Type', 'g : B -> C', 'B : \\\\Type']<<<break>>>['\\\\func fromEquiv (e : Equiv) : QEquiv {e.A} {e.B} e.f {\\n  | ret => e.ret\\n  | ret_f => e.ret_f\\n  | f_sec => f_ret {e}\\n} => \\\\new QEquiv', '\\\\func leftFactor {A1 B1 C : \\\\Type} (e1 : Retraction {A1} {B1}) (g : B1 -> C) (e3 : QEquiv {A1} {C} (g o e1.f)) : QEquiv {B1} {C} g {\\n  | ret => \\\\lam (c : B {\\\\this}) => e1.f (e3.ret c)\\n  | ret_f => \\\\lam (b : A {\\\\this}) => (==<) {B1} (e1.f (e3.ret (g b))) {(o) e1.f (e3.ret o g) (e1.f (e1.sec b))}\\n    (pmap {B1} {B1} (e1.f o e3.ret o g) {b} {e1.f (e1.sec b)} (inv {B1} {e1.f (e1.sec b)} {b} (e1.f_sec b))) >== (==<) {B1} (e1.f (e3.ret (g (e1.f (e1.sec b))))) {e1.f (e1.sec b)}\\n    (pmap {A1} {B1} e1.f {e3.ret ((o) g e1.f (e1.sec b))} {e1.sec b} (e3.ret_f (e1.sec b))) >== (==<) {B1} (e1.f (e1.sec b)) {b} (e1.f_sec b) >== qed {B1} b\\n  | f_sec => e3.f_sec\\n} => \\\\new QEquiv', '| f A : B', '\\\\func \\\\infixr 3 transEquiv {A1 B1 C : \\\\Type} (e1 : Equiv {A1} {B1}) (e2 : Equiv {B1} {C}) : Equiv {A1} {C} (\\\\lam (x : A {\\\\this}) => e2.f (e1.f x)) {\\n  | ret => \\\\lam (y : B {\\\\this}) => e1.ret (e2.ret y)\\n  | ret_f => \\\\lam (x : A {\\\\this}) => pmap {B1} {A1} e1.ret {e2.ret (e2.f (e1.f x))} {e1.f x} (e2.ret_f (e1.f x)) *> e1.ret_f x\\n  | sec => \\\\lam (y : B {\\\\this}) => e1.sec (e2.sec y)\\n  | f_sec => \\\\lam (y : B {\\\\this}) => pmap {B1} {C} e2.f {e1.f (e1.sec (e2.sec y))} {e2.sec y} (e1.f_sec (e2.sec y)) *> e2.f_sec y\\n} => \\\\new Equiv', '\\\\lemma propExt \\\\hlevels  {A B : \\\\Prop} (_ : A -> B) (_ : B -> A) : A = B ', '\\\\class Equiv \\\\extends Section, Retraction', '\\\\func \\\\infixr 8 o {A B C : \\\\Type} (g : B -> C) (f : A -> B) : \\\\Pi (x : A) -> C => \\\\lam (x : A) => g (f x)']<<<break>>>Equiv {B} {C} g = Equiv {A} {C} (g o e.f)", "completion": "propExt (\\lam e2 => transEquiv e e2) (\\lam e3 => leftFactor e g e3)"}
{"prompt": "['n : Nat', 'l : Array (\\\\Sigma Int (t s : Term n) (interpret {G} {n} env.at t = interpret {G} {n} env.at s))']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| len : Nat', '\\\\func normalize \\\\plevels  \\\\hlevels  {n4 : Nat} (_ : Term n4) : Array Int n4 \\n  | {n}, var v => singleAt {Int} {n} v (pos 1) (pos 0)\\n  | {n}, :ide => replicate {Int} n (pos 0)\\n  | {n}, :inverse t => map {Int} {Int} negative (normalize {n} t)\\n  | {n}, t :* s => mkArray {Int} {n} (\\\\lam (j : Fin n) => at {normalize {n} t} j + at {normalize {n} s} j)', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l']<<<break>>>Array Int n (\\lam (j : Fin n) => BigSum {IntRing}\n  (\\new Array Int l.len (\\lam (i : Fin l.len) => (l.at i).1 * (at {normalize {n} (l.at i).2} j - at {normalize {n} (l.at i).3} j))))", "completion": "mkArray (\\lam j => BigSum {IntRing} (\\lam i => (l i).1 * (normalize (l i).2 j - normalize (l i).3 j)))"}
{"prompt": "[\"F : Functor NatSemiring CRingCat (\\\\lam (n : Nat) => (S n).1) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (p : Hom {C {\\\\this}} X Y) =>\\n    natHom {CRingCat} {\\\\lam (n : Nat) => (S n).1} {\\\\lam {n : Nat} => (sf n).3} {X} {Y} (Y -' X, <=_exists {X} {Y} p)\\n}\", 'n : Ob']<<<break>>>['| Hom Ob Ob : \\\\Set', \"\\\\instance RingLatticeColimit {D : BottomJoinSemilattice} (F1 : Functor D RingCat) :\\nRing (SetColimit {D} (Comp {D} {RingCat} {SetCat} RingCat.forget F1)) {\\n  | zro => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, zro {F D.bottom})\\n  | + => (AddMonoidLatticeColimit.+)\\n  | * => (MonoidLatticeColimit.*)\\n  | negative => negative {D} {Comp {D} {AbGroupCat} {AddGroupCat} forgetToAddGroup (Comp {D} {RingCat} {AbGroupCat} forgetToAbGroup F1)}\\n  | ide => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, ide {F D.bottom})\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}\", '| F (Ob {C}) : Ob {D}', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func forget : Functor RingCat SetCat (\\\\lam (R : Ob {C {\\\\this}}) => R.E) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f.func\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func inMap {D : BottomJoinSemilattice} {F1 : Functor D RingCat} (d : D.E) : RingHom (F.F d) (RingLatticeColimit {D} F1) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) =>\\n  in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (d, a)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}\", '\\\\instance NatBSemilattice \\\\hlevels  : BottomJoinSemilattice Nat {\\n  | <= => (<=)\\n  | join => join {NatSemiring}\\n  | bottom => 0\\n} => \\\\new BottomJoinSemilattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | bottom-univ => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| Ob : \\\\hType', '| E : \\\\Set', '| Dom : BaseSet', '\\\\instance RingCat : Cat Ring {\\n  | Hom => RingHom\\n  | id => RingHom.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', 'in~ A']<<<break>>>RingHom (F.F n) (RingLatticeColimit {NatBSemilattice} F1) {\n  | func => \\lam (a : E {Dom {\\this}}) => in~ {\\Sigma (j : Ob) (F j)}\n    {\\lam (s : \\Sigma (j : Ob) (F j)) (s' : \\Sigma (j : Ob) (F j)) => \\Sigma (p : Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\n    (n, a)\n}", "completion": "inMap {_} {F} n"}
{"prompt": "['k : Nat', 'p : 2 * suc (suc n) + 1 < suc k', 'A : Matrix R.E (suc (suc n)) 1', 'S : \\\\Pi {n m : Nat} ->\\n  n <= m -> m <= 2 -> \\\\Pi (A : Matrix R.E n m) -> TruncP (\\\\Sigma (B : Matrix R.E n m) (IsDiagonal {R} {n} {m} B) (A M~ B))', 'n : Nat', 'R : CRing']<<<break>>>['true', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', 'LessOrEquals', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', '\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', ':ide', '| at (j : Fin len) : A j', ':zro', '| E : \\\\Set', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\class LinearSemiringData \\\\extends LinearData, SemiringData \\\\hlevels ', '\\\\func transpose {R : \\\\Type} {n m : Nat} (M : Matrix R n m) : Matrix R m n \\n  => mkMatrix {R} {m} {n} (\\\\lam (i : Fin m) (j : Fin n) => at {at {M} j} i)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma aux \\\\hlevels  {R : CRing} {k m n : Nat} (_ : \\\\Pi {n m : Nat} ->\\n  n <= m -> m <= 2 -> \\\\Pi (A : Matrix R.E n m) -> TruncP (\\\\Sigma (B : Matrix R.E n m) (IsDiagonal {R} {n} {m} B) (A M~ B)))\\n  (_ : 2 * n + m < k) (A : Matrix R.E n m) : TruncP (\\\\Sigma (B : Matrix R.E n m) (IsSmith {R} {n} {m} B) (A M~ B)) ', '\\\\type IsSmith \\\\hlevels  {R : Semiring} {n m : Nat} (A : Matrix R.E n m) : \\\\Prop \\n=> \\\\Sigma (IsDiagonal {R} {n} {m} A) (\\\\Pi (i : Nat) -> \\\\Pi (p : suc i StrictPoset.< n) ->\\n  \\\\Pi (q : suc i StrictPoset.< m) -> TruncP (LDiv {R} (at {at {A} (toFin i {n} {?hidden})} (toFin i {m} {?hidden}))\\n    (at {at {A} (toFin (suc i) {n} {?hidden})} (toFin (suc i) {m} {?hidden}))))', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\type \\\\infix 4 M~ \\\\hlevels  {R : Ring} {n m : Nat} (A B : Matrix R.E n m) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (B = C.val product A product D.val))']<<<break>>>TruncP (\\Sigma (B : Matrix R.E 1 (suc (suc n))) (IsSmith {R} {1} {suc (suc n)} B) (transpose {R.E} {suc (suc n)} {1} A M~ B))", "completion": "aux {_} {k} S linarith (transpose A)"}
{"prompt": "['q : Not ((Pe.f i).1.1 = (Pe.f j).1.1)', 'i : Fin (len {map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) (\\\\new Array (\\\\Sigma V.E B.E) P.finCard\\n  (\\\\lam (j : Fin P.finCard) => ((b.at (Pe.f j).1.1).1, (b.at (Pe.f j).1.1).2 B.* (c.at (Pe.f j).1.2).2)))})', 'Pe : Equiv {Fin P.finCard} {P.E}', 'br : IsReduced {V} {B} b', 'j : Fin (len {map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) (\\\\new Array (\\\\Sigma V.E B.E) P.finCard\\n  (\\\\lam (j : Fin P.finCard) => ((b.at (Pe.f j).1.1).1, (b.at (Pe.f j).1.1).2 B.* (c.at (Pe.f j).1.2).2)))})', 'env : Array B.E 4', 'B : BooleanRing']<<<break>>>['true', \"\\\\func multiply \\\\plevels  \\\\hlevels  {n2 : Nat} (_ _ : NF n2) : NF n2 \\n  | {n}, l1, nil => nil {Array Bool n}\\n  | {n}, l1, l2 => multiply' {n} l1 l2 (nil {Array Bool n})\", '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'nil', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', \"\\\\func interpretNF \\\\hlevels  {B : BooleanRing} {n : Nat} (env : Fin n -> B.E) (l : NF n) : B.E \\n  => interpretNF' {B} {n} (\\\\new Array B.E n env) (collapse {n} (sort {LexicographicalArray {n} BoolOpPoset} l))\", '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\infixl 7 :* (_ _ : Term n)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'false', '| at (j : Fin len) : A j', \"\\\\func interpretNF' \\\\hlevels  {B3 : BooleanRing} {n2 : Nat} (_ : Array B.E n2) (_ : NF n2) : B.E \\n  | {B}, {n}, env, nil => B.zro\\n  | {B}, {n}, env, x :: nil => interpretMonomial {B} {n} env x\\n  | {B}, {n}, env, x :: l => interpretMonomial {B} {n} env x B.+ interpretNF' {B} {n} env l\", '| E : \\\\Set', 'var (Fin n)', '\\\\data Term \\\\plevels  \\\\hlevels  Nat \\n  | var (Fin n)\\n  | :zro\\n  | :negative (Term n)\\n  | \\\\infixl 6 :+ (_ _ : Term n)\\n  | \\\\infixl 7 :* (_ _ : Term n)', '\\\\func interpret \\\\hlevels  {B4 : BooleanRing} (env4 : Array B.E) (_ : Term env.len) : B.E \\n  | {B}, env, var j => env.at j\\n  | {B}, env, :zro => B.zro\\n  | {B}, env, :negative t => B.negative (interpret {B} env t)\\n  | {B}, env, t :+ s => interpret {B} env t B.+ interpret {B} env s\\n  | {B}, env, t :* s => interpret {B} env t B.* interpret {B} env s', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', ':zro', \"\\\\lemma apply-axioms \\\\hlevels  {B : BooleanRing} {n : Nat} (env : Array B.E n)\\n  (l : Array (\\\\Sigma (NF n) (t s : Term n) (interpret {B} env t = interpret {B} env s))) (add : NF n) :\\ninterpretNF {B} {n} env.at (Big {List (Array Bool n)} {List (Array Bool n)} (++) add\\n  (map {\\\\Sigma (NF n) (t s : Term n) (interpret {B} env t = interpret {B} env s)} {List (Array Bool n)}\\n    (\\\\lam (s : \\\\Sigma (NF n) (t s : Term n) (interpret {B} env t = interpret {B} env s)) =>\\n      multiply {n} s.1 (normalize {n} (s.2 :+ s.3))) l)) = interpretNF' {B} {n} env add \", '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func normalize {n5 : Nat} (_ : Term n5) : NF n5 \\n  | {n}, var j => singleAt {Bool} {n} j true false :: nil {Array Bool n}\\n  | {n}, :zro => nil {Array Bool n}\\n  | {n}, :negative t => normalize {n} t\\n  | {n}, t :+ s => normalize {n} t ++ normalize {n} s\\n  | {n}, t :* s => multiply {n} (normalize {n} t) (normalize {n} s)', '\\\\infixl 6 :+ (_ _ : Term n)', '\\\\func NF \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => List (Array Bool n)', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpretNF {B} {4} env.at (Big {List (Array Bool 4)} {List (Array Bool 4)} (++) (nil {Array Bool 4})\n  (map {\\Sigma (NF 4) (t s : Term 4) (interpret {B} env t = interpret {B} env s)} {List (Array Bool 4)}\n    (\\lam (s : \\Sigma (NF 4) (t s : Term 4) (interpret {B} env t = interpret {B} env s)) =>\n      multiply {4} s.1 (normalize {4} (s.2 :+ s.3)))\n    (((false :: true :: false :: true :: nil) :: nil {Array Bool 4}, var {4} 0 :* var {4} 2, :zro {4},\n      br {(Pe.f i).1.1} {(Pe.f j).1.1} q) :: nil))) = interpretNF' {B} {4} env (nil {Array Bool 4})", "completion": "apply-axioms\nenv (((false :: true :: false :: true :: nil) :: nil, var 0 :* var 2, :zro, br {(Pe.f i).1.1} {(Pe.f j).1.1} q) :: nil)\n  nil"}
{"prompt": "['n : Nat', 'a^n=c : pow {R} a n = c', 'R : CRing', 'd : CRingData {R} (pow {S} a n :: c :: nil) {\\n  | interpretNF_negate => {?hidden}\\n}', 'zro=c : R.zro R.* R.ide R.* c = R.ide R.* R.ide R.* c', 'a : E {P {\\\\this}}', 'c : R.E']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '\\\\func idealElem \\\\hlevels  {R2 : CRing} (_ : List (\\\\Sigma R.E R.E)) : R.E \\n  | {R}, nil => R.zro\\n  | {R}, (c, gen) :: xs => c R.* gen R.+ idealElem {R} xs', '| C : Semiring', '| ide : E', 'coef C', 'nil', '\\\\func map {A1 B2 : \\\\Type} (_ : A1 -> B2) (_ : List A1) : List B2 \\n  | {A}, {B}, f, nil => nil {B}\\n  | {A}, {B}, f, a :: l => f a :: map {A} {B} f l', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', 'pos Nat', '| zro : E', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\field mData : MonoidData {R} vars', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', '| E : \\\\Set', '| negative E : E', '\\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>idealElem {R}\n  (map {\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\Sigma R.E R.E} (\\lam (x : \\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\n    ((interpret {d} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1)), pow {R} a n R.+ R.negative c,\n      toZero {R} {pow {R} a n} {c} a^n=c) :: (interpret {d} (:negative {E {d.C}} {Fin (len {vars {d.mData}})} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1))),\n        R.zro R.* R.ide R.* c R.+ R.negative (R.ide R.* R.ide R.* c),\n        toZero {R} {R.zro R.* R.ide R.* c} {R.ide R.* R.ide R.* c} zro=c) :: nil {\\Sigma R.E (gen : R.E) (gen = R.zro)})) = R.zro", "completion": "gensZeroToIdealZero\n((interpret {d} (coef 1), pow {R} a n + negative c, toZero {R} {pow {R} a n} {c} a^n=c) :: (interpret {d} (:negative (coef 1)), R.zro R.* R.ide R.* c + negative (R.ide R.* R.ide R.* c),\n  toZero {R} {R.zro R.* R.ide R.* c} {R.ide R.* R.ide R.* c} zro=c) :: nil)"}
{"prompt": "['n : Nat', 'i<j : i < j', 'a : Fin n', 'q : i = suc a', 'j : Fin (suc n)', 'i : Fin (suc n)']<<<break>>>['\\\\func transposition1 \\\\plevels  \\\\hlevels  {n : Nat} (a : Fin n) : Sym (suc n) => transposition {suc n} {a} {suc a} (id/=suc {a})', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma transposition1_/= \\\\plevels  \\\\hlevels  {n : Nat} {a : Fin n} {i : Fin (suc n)} (_ : i /= a) (_ : i /= suc a) : f {transposition1 {n} a} i = i ', 'suc Nat', '\\\\lemma id<suc \\\\plevels  \\\\hlevels  {n : Nat} : n < suc n ', '\\\\lemma id/=suc \\\\plevels  \\\\hlevels  {n : Nat} : n /= suc n ', '\\\\lemma <-irreflexive {n : Nat} (_ : n < n) : Empty ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '| <-transitive \\\\alias \\\\infixr 9 <\u2218 {x y z : E} (x < y) (y < z) : x < z', '| \\\\infix 4 < E E : \\\\Prop', '\\\\lemma transposition1-right \\\\plevels  \\\\hlevels  {n : Nat} {a : Fin n} : f {transposition1 {n} a} (suc a) = a ', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| f A : B', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| E : \\\\Set', '\\\\lemma <-transitive {n m k : Nat} (_ : n < m) (_ : m < k) : n < k ', 'transposition \\\\plevels  \\\\hlevels  {n : Nat} {a b : Fin n} (a/=b : a /= b) : Sym n => cycle {n} {2} (a :: b :: nil) (inj {n} {a} {b} {a/=b})', \"\\\\func transport2 {A B : \\\\Type} (C : A -> B -> \\\\Type) {a a' : A} {b b' : B} (_ : a = a') (_ : b = b') (_ : C a b) : C a' b' \\n  | {A}, {B}, C, {a}, {a'}, {b}, {b'}, idp, idp, c => c\"]<<<break>>>f {transposition {suc n} {a} {suc a} (id/=suc {a})} (suc a) < f {transposition1 {n} a} j", "completion": "rewrite transposition1-right (rewrite (transposition1_/= (\\lam r => <-irreflexive $ id<suc <\u2218 transport2 {Nat} {Nat} (<) q r i<j)\n  (\\lam r => <-irreflexive $ transport2 {Nat} {Nat} (<) q r i<j)) (<-transitive (rewrite q id<suc) i<j))"}
{"prompt": "[\"this : Ring (SetColimit {D} (Comp {D} {RingCat} {SetCat} RingCat.forget F1)) {\\n  | zro => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, zro {F D.bottom})\\n  | + => (AddMonoidLatticeColimit.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (MonoidLatticeColimit.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => negative {D} {Comp {D} {AbGroupCat} {AddGroupCat} forgetToAddGroup (Comp {D} {RingCat} {AbGroupCat} forgetToAbGroup F1)}\\n  | negative-left => {?hidden}\\n  | ide => in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)} (D.bottom, ide {F D.bottom})\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}\", 'F : Functor D RingCat', 'D : BottomJoinSemilattice']<<<break>>>[\"\\\\type SetColimit \\\\hlevels  {J : Precat} (F1 : Functor J SetCat) : \\\\Set \\n=> Quotient {\\\\Sigma (j : J.Ob) (F.F j)} (\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2))\", '| \\\\infixl 6 + E E : E', '\\\\func forgetToAddMonoid : Functor AddGroupCat AddMonoidCat (\\\\lam (A : Ob {C {\\\\this}}) => A) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func forgetToAddGroup : Functor AbGroupCat AddGroupCat (\\\\lam (A : Ob {C {\\\\this}}) => A) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\lemma Func-app {D : BottomJoinSemilattice} {F1 : Functor D RingCat} {j1 j2 j3 : D.E} {f : D.Hom j1 j2} {g : D.Hom j2 j3}\\n  {a : E {F.F j1}} : func {F.Func {j1} {j3} (g D.\u2218 f)} a = func {F.Func {j2} {j3} g} (func {F.Func {j1} {j2} f} a) ', '\\\\instance AddGroupCat : Cat AddGroup {\\n  | Hom => AddGroupHom\\n  | id => AddGroupHom.id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new AddGroupHom X Z {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n    | func-+ => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| Cod : BaseSet', '\\\\func forgetToMonoid : Functor RingCat MonoidCat (\\\\lam (R : Ob {C {\\\\this}}) => R) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| join-left {x y : E} : x <= x \u2228 y', '| \\\\infixl 7 * E E : E', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', \"\\\\func * {D3 : BottomJoinSemilattice} {F4 : Functor D3 MonoidCat}\\n  (_ _ : SetColimit {D3} (Comp {D3} {MonoidCat} {SetCat} forget F4)) :\\n  SetColimit {D3} (Comp {D3} {MonoidCat} {SetCat} forget F4) \\n  | {D}, {F1}, in~ a, in~ b =>\\n  in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n    (a.1 D.\u2228 b.1,\\n      func {F.Func {a.1} {a.1 D.\u2228 b.1} (D.join-left {a.1} {b.1})} a.2 * func {F.Func {b.1} {a.1 D.\u2228 b.1} (D.join-right {a.1} {b.1})} b.2)\\n  | {D}, {F1}, in~ a, ~-equiv x y r i => ~-cequiv {D} {Comp {D} {MonoidCat} {SetCat} forget F1} {(a.1 D.\u2228 x.1,\\n    func {F.Func {a.1} {a.1 D.\u2228 x.1} (D.join-left {a.1} {x.1})} a.2 * func {F.Func {x.1} {a.1 D.\u2228 x.1} (D.join-right {a.1} {x.1})} x.2)}\\n    {(a.1 D.\u2228 y.1,\\n      func {F.Func {a.1} {a.1 D.\u2228 y.1} (D.join-left {a.1} {y.1})} a.2 * func {F.Func {y.1} {a.1 D.\u2228 y.1} (D.join-right {a.1} {y.1})} y.2)}\\n    (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)\\n    (func-* {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n      {func {F.Func {a.1} {a.1 D.\u2228 x.1} (D.join-left {a.1} {x.1})} a.2}\\n      {func {F.Func {x.1} {a.1 D.\u2228 x.1} (D.join-right {a.1} {x.1})} x.2} *> pmap2 {E {F.F (a.1 D.\u2228 y.1)}} {E {F.F (a.1 D.\u2228 y.1)}} {E {F.F (a.1 D.\u2228 y.1)}} ((*) {F.F (a.1 D.\u2228 y.1)})\\n      {func {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n        (func {F.Func {a.1} {a.1 D.\u2228 x.1} (D.join-left {a.1} {x.1})} a.2)}\\n      {func {F.Func {a.1} {a.1 D.\u2228 y.1} (D.join-left {a.1} {y.1})} a.2} (inv {E {F.F (a.1 D.\u2228 y.1)}}\\n        {func {F.Func {a.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1 D.\u2218 D.join-left {a.1} {x.1})}\\n          a.2}\\n        {func {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n          (func {F.Func {a.1} {a.1 D.\u2228 x.1} (D.join-left {a.1} {x.1})} a.2)}\\n        (Func-app {D} {F1} {a.1} {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} {D.join-left {a.1} {x.1}}\\n          {join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1} {a.2}) *> poset-app {D} {F1} {a.1} {a.1 D.\u2228 y.1}\\n        {join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1 D.\u2218 D.join-left {a.1} {x.1}} {D.join-left {a.1} {y.1}}\\n        {a.2})\\n      {func {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n        (func {F.Func {x.1} {a.1 D.\u2228 x.1} (D.join-right {a.1} {x.1})} x.2)}\\n      {func {F.Func {y.1} {a.1 D.\u2228 y.1} (D.join-right {a.1} {y.1})} y.2} (inv {E {F.F (a.1 D.\u2228 y.1)}}\\n        {func {F.Func {x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1 D.\u2218 D.join-right {a.1} {x.1})}\\n          x.2}\\n        {func {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n          (func {F.Func {x.1} {a.1 D.\u2228 x.1} (D.join-right {a.1} {x.1})} x.2)}\\n        (Func-app {D} {F1} {x.1} {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} {D.join-right {a.1} {x.1}}\\n          {join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1} {x.2}) *> poset-app {D} {F1} {x.1} {a.1 D.\u2228 y.1}\\n        {join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1 D.\u2218 D.join-right {a.1} {x.1}}\\n        {D.join-right {a.1} {y.1} D.\u2218 r.1} {x.2} *> Func-app {D} {F1} {x.1} {y.1} {a.1 D.\u2228 y.1} {r.1} {D.join-right {a.1} {y.1}} {x.2} *> pmap {E {F.F y.1}} {E {F.F (a.1 D.\u2228 y.1)}} (func {F.Func {y.1} {a.1 D.\u2228 y.1} (D.join-right {a.1} {y.1})})\\n        {Func {x.1} {y.1} r.1 x.2} {y.2} r.2)) @ i\\n  | {D}, {F1}, ~-equiv x y r i, in~ b => ~-cequiv {D} {Comp {D} {MonoidCat} {SetCat} forget F1} {(x.1 D.\u2228 b.1,\\n    func {F.Func {x.1} {x.1 D.\u2228 b.1} (D.join-left {x.1} {b.1})} x.2 * func {F.Func {b.1} {x.1 D.\u2228 b.1} (D.join-right {x.1} {b.1})} b.2)}\\n    {(y.1 D.\u2228 b.1,\\n      func {F.Func {y.1} {y.1 D.\u2228 b.1} (D.join-left {y.1} {b.1})} y.2 * func {F.Func {b.1} {y.1 D.\u2228 b.1} (D.join-right {y.1} {b.1})} b.2)}\\n    (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))\\n    (func-* {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n      {func {F.Func {x.1} {x.1 D.\u2228 b.1} (D.join-left {x.1} {b.1})} x.2}\\n      {func {F.Func {b.1} {x.1 D.\u2228 b.1} (D.join-right {x.1} {b.1})} b.2} *> pmap2 {E {F.F (y.1 D.\u2228 b.1)}} {E {F.F (y.1 D.\u2228 b.1)}} {E {F.F (y.1 D.\u2228 b.1)}} ((*) {F.F (y.1 D.\u2228 b.1)})\\n      {func {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n        (func {F.Func {x.1} {x.1 D.\u2228 b.1} (D.join-left {x.1} {b.1})} x.2)}\\n      {func {F.Func {y.1} {y.1 D.\u2228 b.1} (D.join-left {y.1} {b.1})} y.2} (inv {E {F.F (y.1 D.\u2228 b.1)}}\\n        {func {F.Func {x.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}) D.\u2218 D.join-left {x.1} {b.1})}\\n          x.2}\\n        {func {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n          (func {F.Func {x.1} {x.1 D.\u2228 b.1} (D.join-left {x.1} {b.1})} x.2)}\\n        (Func-app {D} {F1} {x.1} {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} {D.join-left {x.1} {b.1}}\\n          {join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1})} {x.2}) *> poset-app {D} {F1} {x.1} {y.1 D.\u2228 b.1}\\n        {join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}) D.\u2218 D.join-left {x.1} {b.1}}\\n        {D.join-left {y.1} {b.1} D.\u2218 r.1} {x.2} *> Func-app {D} {F1} {x.1} {y.1} {y.1 D.\u2228 b.1} {r.1} {D.join-left {y.1} {b.1}} {x.2} *> pmap {E {F.F y.1}} {E {F.F (y.1 D.\u2228 b.1)}} (func {F.Func {y.1} {y.1 D.\u2228 b.1} (D.join-left {y.1} {b.1})})\\n        {Func {x.1} {y.1} r.1 x.2} {y.2} r.2)\\n      {func {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n        (func {F.Func {b.1} {x.1 D.\u2228 b.1} (D.join-right {x.1} {b.1})} b.2)}\\n      {func {F.Func {b.1} {y.1 D.\u2228 b.1} (D.join-right {y.1} {b.1})} b.2} (inv {E {F.F (y.1 D.\u2228 b.1)}}\\n        {func {F.Func {b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}) D.\u2218 D.join-right {x.1} {b.1})}\\n          b.2}\\n        {func {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n          (func {F.Func {b.1} {x.1 D.\u2228 b.1} (D.join-right {x.1} {b.1})} b.2)}\\n        (Func-app {D} {F1} {b.1} {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} {D.join-right {x.1} {b.1}}\\n          {join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1})} {b.2}) *> poset-app {D} {F1} {b.1} {y.1 D.\u2228 b.1}\\n        {join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}) D.\u2218 D.join-right {x.1} {b.1}}\\n        {D.join-right {y.1} {b.1}} {b.2})) @ i\", '\\\\instance AbGroupCat : Cat AbGroup {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {AddGroupCat} {AbGroup} (\\\\new Embedding {AbGroup} {Ob} (\\\\lam (A : A {\\\\this}) => A) {\\n  | isEmb => \\\\lam (A1 : A {\\\\this}) (B1 : A {\\\\this}) =>\\n  \\\\new Retraction {A1 = B1} {f {\\\\this} A1 = f {\\\\this} B1} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {A1} {B1}) {\\n    | sec => equals A1 B1\\n    | f_sec => idpe {A1 = B1}\\n  }\\n})', '| join-right {x y : E} : y <= x \u2228 y', '\\\\instance RingCat : Cat Ring {\\n  | Hom => RingHom\\n  | id => RingHom.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", \"\\\\lemma ~-cequiv \\\\hlevels  {J : Precat} {F1 : Functor J SetCat} {s s' : \\\\Sigma (j : J.Ob) (F.F j)} (f : J.Hom s.1 s'.1)\\n  (_ : F.Func {s.1} {s'.1} f s.2 = s'.2) :\\nin~ {\\\\Sigma (j : J.Ob) (F.F j)} {\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2)} s = in~ {\\\\Sigma (j : J.Ob) (F.F j)} {\\\\lam (s : \\\\Sigma (j : J.Ob) (F.F j)) (s' : \\\\Sigma (j : J.Ob) (F.F j)) =>\\n  \\\\Sigma (p : J.Hom s.1 s'.1) (F.Func {s.1} {s'.1} p s.2 = s'.2)} s' \", \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}', '\\\\func forget : Functor RingCat SetCat (\\\\lam (R : Ob {C {\\\\this}}) => R.E) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f.func\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\lemma poset-app {D : BottomJoinSemilattice} {F1 : Functor D RingCat} {j j' : D.E} {f g : j D.<= j'} {a : E {F.F j}} :\\n  func {F.Func {j} {j'} f} a = func {F.Func {j} {j'} g} a \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func + {D3 : BottomJoinSemilattice} {F4 : Functor D3 AddMonoidCat}\\n  (_ _ : SetColimit {D3} (Comp {D3} {AddMonoidCat} {SetCat} forget F4)) :\\n  SetColimit {D3} (Comp {D3} {AddMonoidCat} {SetCat} forget F4) \\n  | {D}, {F1}, in~ a, in~ b =>\\n  in~ {\\\\Sigma (j : D.Ob) (F j)} {\\\\lam (s : \\\\Sigma (j : D.Ob) (F j)) (s' : \\\\Sigma (j : D.Ob) (F j)) =>\\n    \\\\Sigma (p : D.Hom s.1 s'.1) (Func {s.1} {s'.1} p s.2 = s'.2)}\\n    (a.1 D.\u2228 b.1,\\n      func {F.Func {a.1} {a.1 D.\u2228 b.1} (D.join-left {a.1} {b.1})} a.2 + func {F.Func {b.1} {a.1 D.\u2228 b.1} (D.join-right {a.1} {b.1})} b.2)\\n  | {D}, {F1}, in~ a, ~-equiv x y r i => ~-cequiv {D} {Comp {D} {AddMonoidCat} {SetCat} forget F1} {(a.1 D.\u2228 x.1,\\n    func {F.Func {a.1} {a.1 D.\u2228 x.1} (D.join-left {a.1} {x.1})} a.2 + func {F.Func {x.1} {a.1 D.\u2228 x.1} (D.join-right {a.1} {x.1})} x.2)}\\n    {(a.1 D.\u2228 y.1,\\n      func {F.Func {a.1} {a.1 D.\u2228 y.1} (D.join-left {a.1} {y.1})} a.2 + func {F.Func {y.1} {a.1 D.\u2228 y.1} (D.join-right {a.1} {y.1})} y.2)}\\n    (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)\\n    (func-+ {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n      {func {F.Func {a.1} {a.1 D.\u2228 x.1} (D.join-left {a.1} {x.1})} a.2}\\n      {func {F.Func {x.1} {a.1 D.\u2228 x.1} (D.join-right {a.1} {x.1})} x.2} *> pmap2 {E {F.F (a.1 D.\u2228 y.1)}} {E {F.F (a.1 D.\u2228 y.1)}} {E {F.F (a.1 D.\u2228 y.1)}} ((+) {F.F (a.1 D.\u2228 y.1)})\\n      {func {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n        (func {F.Func {a.1} {a.1 D.\u2228 x.1} (D.join-left {a.1} {x.1})} a.2)}\\n      {func {F.Func {a.1} {a.1 D.\u2228 y.1} (D.join-left {a.1} {y.1})} a.2} (inv {E {F.F (a.1 D.\u2228 y.1)}}\\n        {func {F.Func {a.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1 D.\u2218 D.join-left {a.1} {x.1})}\\n          a.2}\\n        {func {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n          (func {F.Func {a.1} {a.1 D.\u2228 x.1} (D.join-left {a.1} {x.1})} a.2)}\\n        (Func-app {D} {F1} {a.1} {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} {D.join-left {a.1} {x.1}}\\n          {join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1} {a.2}) *> poset-app {D} {F1} {a.1} {a.1 D.\u2228 y.1}\\n        {join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1 D.\u2218 D.join-left {a.1} {x.1}} {D.join-left {a.1} {y.1}}\\n        {a.2})\\n      {func {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n        (func {F.Func {x.1} {a.1 D.\u2228 x.1} (D.join-right {a.1} {x.1})} x.2)}\\n      {func {F.Func {y.1} {a.1 D.\u2228 y.1} (D.join-right {a.1} {y.1})} y.2} (inv {E {F.F (a.1 D.\u2228 y.1)}}\\n        {func {F.Func {x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1 D.\u2218 D.join-right {a.1} {x.1})}\\n          x.2}\\n        {func {F.Func {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} (join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1)}\\n          (func {F.Func {x.1} {a.1 D.\u2228 x.1} (D.join-right {a.1} {x.1})} x.2)}\\n        (Func-app {D} {F1} {x.1} {a.1 D.\u2228 x.1} {a.1 D.\u2228 y.1} {D.join-right {a.1} {x.1}}\\n          {join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1} {x.2}) *> poset-app {D} {F1} {x.1} {a.1 D.\u2228 y.1}\\n        {join-monotone {D} {a.1} {x.1} {a.1} {y.1} (D.<=-refl {a.1}) r.1 D.\u2218 D.join-right {a.1} {x.1}}\\n        {D.join-right {a.1} {y.1} D.\u2218 r.1} {x.2} *> Func-app {D} {F1} {x.1} {y.1} {a.1 D.\u2228 y.1} {r.1} {D.join-right {a.1} {y.1}} {x.2} *> pmap {E {F.F y.1}} {E {F.F (a.1 D.\u2228 y.1)}} (func {F.Func {y.1} {a.1 D.\u2228 y.1} (D.join-right {a.1} {y.1})})\\n        {Func {x.1} {y.1} r.1 x.2} {y.2} r.2)) @ i\\n  | {D}, {F1}, ~-equiv x y r i, in~ b => ~-cequiv {D} {Comp {D} {AddMonoidCat} {SetCat} forget F1} {(x.1 D.\u2228 b.1,\\n    func {F.Func {x.1} {x.1 D.\u2228 b.1} (D.join-left {x.1} {b.1})} x.2 + func {F.Func {b.1} {x.1 D.\u2228 b.1} (D.join-right {x.1} {b.1})} b.2)}\\n    {(y.1 D.\u2228 b.1,\\n      func {F.Func {y.1} {y.1 D.\u2228 b.1} (D.join-left {y.1} {b.1})} y.2 + func {F.Func {b.1} {y.1 D.\u2228 b.1} (D.join-right {y.1} {b.1})} b.2)}\\n    (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))\\n    (func-+ {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n      {func {F.Func {x.1} {x.1 D.\u2228 b.1} (D.join-left {x.1} {b.1})} x.2}\\n      {func {F.Func {b.1} {x.1 D.\u2228 b.1} (D.join-right {x.1} {b.1})} b.2} *> pmap2 {E {F.F (y.1 D.\u2228 b.1)}} {E {F.F (y.1 D.\u2228 b.1)}} {E {F.F (y.1 D.\u2228 b.1)}} ((+) {F.F (y.1 D.\u2228 b.1)})\\n      {func {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n        (func {F.Func {x.1} {x.1 D.\u2228 b.1} (D.join-left {x.1} {b.1})} x.2)}\\n      {func {F.Func {y.1} {y.1 D.\u2228 b.1} (D.join-left {y.1} {b.1})} y.2} (inv {E {F.F (y.1 D.\u2228 b.1)}}\\n        {func {F.Func {x.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}) D.\u2218 D.join-left {x.1} {b.1})}\\n          x.2}\\n        {func {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n          (func {F.Func {x.1} {x.1 D.\u2228 b.1} (D.join-left {x.1} {b.1})} x.2)}\\n        (Func-app {D} {F1} {x.1} {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} {D.join-left {x.1} {b.1}}\\n          {join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1})} {x.2}) *> poset-app {D} {F1} {x.1} {y.1 D.\u2228 b.1}\\n        {join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}) D.\u2218 D.join-left {x.1} {b.1}}\\n        {D.join-left {y.1} {b.1} D.\u2218 r.1} {x.2} *> Func-app {D} {F1} {x.1} {y.1} {y.1 D.\u2228 b.1} {r.1} {D.join-left {y.1} {b.1}} {x.2} *> pmap {E {F.F y.1}} {E {F.F (y.1 D.\u2228 b.1)}} (func {F.Func {y.1} {y.1 D.\u2228 b.1} (D.join-left {y.1} {b.1})})\\n        {Func {x.1} {y.1} r.1 x.2} {y.2} r.2)\\n      {func {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n        (func {F.Func {b.1} {x.1 D.\u2228 b.1} (D.join-right {x.1} {b.1})} b.2)}\\n      {func {F.Func {b.1} {y.1 D.\u2228 b.1} (D.join-right {y.1} {b.1})} b.2} (inv {E {F.F (y.1 D.\u2228 b.1)}}\\n        {func {F.Func {b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}) D.\u2218 D.join-right {x.1} {b.1})}\\n          b.2}\\n        {func {F.Func {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} (join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}))}\\n          (func {F.Func {b.1} {x.1 D.\u2228 b.1} (D.join-right {x.1} {b.1})} b.2)}\\n        (Func-app {D} {F1} {b.1} {x.1 D.\u2228 b.1} {y.1 D.\u2228 b.1} {D.join-right {x.1} {b.1}}\\n          {join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1})} {b.2}) *> poset-app {D} {F1} {b.1} {y.1 D.\u2228 b.1}\\n        {join-monotone {D} {x.1} {b.1} {y.1} {b.1} r.1 (D.<=-refl {b.1}) D.\u2218 D.join-right {x.1} {b.1}}\\n        {D.join-right {y.1} {b.1}} {b.2})) @ i\", '\\\\instance AddMonoidCat : Cat AddMonoid {\\n  | Hom => AddMonoidHom\\n  | id => AddMonoidHom.id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => \\\\new AddMonoidHom X Z {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n    | func-zro => {?hidden}\\n    | func-+ => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| join-univ {x y z : E} (x <= z) (y <= z) : x \u2228 y <= z', '| rdistr {x y z : E} : (x + y) * z = x * z + y * z', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| func (E {Dom}) : E {Cod}', \"\\\\lemma join-monotone \\\\hlevels  {this : JoinSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2228 y <= x' \u2228 y' \", '| Dom : BaseSet', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\instance MonoidCat : Cat Monoid {\\n  | Hom => MonoidHom\\n  | id => MonoidHom.id\\n  | o => \\\\lam {x y z : Ob {\\\\this}} (g : Hom {\\\\this} y z) (f : Hom {\\\\this} x y) => \\\\new MonoidHom x z {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n    | func-ide => {?hidden}\\n    | func-* => {?hidden}\\n  }\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func forgetToAbGroup : Functor RingCat AbGroupCat (\\\\lam (R : Ob {C {\\\\this}}) => R) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => f\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>\\Pi {x : E {\\this}} -> \\Pi {y : E {\\this}} -> \\Pi {z : E {\\this}} -> (x + y) * z = x * z + y * z", "completion": "\\lam {x} {y} {z} => (\\scase \\elim x, \\elim y, \\elim z \\with {\n  | in~ a, in~ b, in~ c =>\n  ~-cequiv (join-univ (join-monotone {D} join-left join-left) (join-right <=\u2218 join-right)) $ pmap (\\lam x => Func {F} _ (x * _)) func-+ *> pmap (Func {F} _) rdistr *> func-+ *> pmap2 (+)\n    (func-* *> pmap2 (*) (inv Func-app *> inv Func-app *> poset-app *> Func-app) (inv Func-app *> poset-app *> Func-app) *> inv func-*)\n    (func-* *> pmap2 (*) (inv Func-app *> inv Func-app *> poset-app *> Func-app) (inv Func-app *> poset-app *> Func-app) *> inv func-*)\n})"}
{"prompt": "['t : \\\\Sigma (x1 : E {P.P}) (\\\\Sigma (p : Cover1 {P.P} x1 a) (Inv {Functor.F {VPresheaf.F {P.R}} x1}\\n  (func {Func {VPresheaf.F {P.R}} {a} {x1} p} (x.1 (a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n    U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n      (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a})))))) || Inv {Functor.F {VPresheaf.F {P.R}} x1}\\n  (func {Func {VPresheaf.F {P.R}} {a} {x1} p} (x.1 (a, \\\\lam {z : E {P.P}} (c : (embed {P.P} a).1 z) =>\\n    U.2 z (cover-trans1 {P.P} {z} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} {a} c\\n      (cover-inj {P.P} {a} {\\\\Sigma (x : E {P.P}) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : E {P.P}) (U.1 x)) => t.1} (a, Ua) (idp {E {P.P}} {a}))))) + ide {Functor.F {VPresheaf.F {P.R}} x1})))', 'a : E {P.P}', 'P : LocallyRingedFramePres', 'Ua : U.1 a', 'U : E {L {\\\\this}}']<<<break>>>['\\\\func embed \\\\hlevels  {P : FramePres} (x : P.E) : E => closure {P} {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => x)', '| P : FramePres', 'cover-inj (j : J) (g j = x)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| E : \\\\Set', '\\\\lemma cover-trans1 \\\\hlevels  {P : FramePres} {x : P.E} {J : \\\\Set} {g : J -> P.E} {y : P.E} (_ : Cover1 {P} x y) (_ : Cover {P} y {J} g) :\\n  Cover {P} x {J} g ', '\\\\type \\\\infix 4 <= \\\\hlevels  {P : FramePres} (U V : Opens P) : \\\\Prop => \\\\Pi {x : P.E} -> U.1 x -> V.1 x']<<<break>>>embed {P.P} t.1 <= U", "completion": "\\lam {z} c => U.2 z $ cover-trans1 c $ cover-trans1 t.2.1 $ cover-inj (a, Ua) idp"}
{"prompt": "['T : Theory', \"this : Limit {J1} G1 (\\\\new Model T (\\\\lam (s : Sort {Structure.T}) => \\\\Sigma (P : \\\\Pi (j : J.Ob) -> E {G.F j} s)\\n  (\\\\Pi {j j' : J.Ob} -> \\\\Pi (h : J.Hom j j') -> funcs {G.Func {j} {j'} h} {s} (P j) = P j')) {\\n  | operation => \\\\lam {r : Sort {Structure.T}} (h : Symb {Structure.T} r) (d : DArray {len {domain {Structure.T} {r} h}}\\n    (\\\\lam (j : Fin (len {domain {Structure.T} {r} h})) => E (at {domain {Structure.T} {r} h} j))) =>\\n  (\\\\lam (j : J.Ob) => operation {G.F j} {r} h (\\\\new DArray {len {domain {Structure.T {G.F j}} {r} h}}\\n    (\\\\lam (j1 : Fin (len {domain {Structure.T {G.F j}} {r} h})) => E {G.F j} (at {domain {Structure.T {G.F j}} {r} h} j1))\\n    (\\\\lam (k : Fin (len {domain {Structure.T {G.F j}} {r} h})) => (d.at k).1 j)),\\n    \\\\lam {j : J.Ob} {j' : J.Ob} (f : J.Hom j j') =>\\n    func-op {G.Func {j} {j'} f} {r} h (\\\\new DArray {len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h}}\\n      (\\\\lam (j1 : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) =>\\n        E {Dom {G.Func {j} {j'} f}} (at {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h} j1))\\n      (\\\\lam (k : Fin (len {domain {ModelHom.T {G.Func {j} {j'} f}} {r} h})) => (d.at k).1 j)) *> path (\\\\lam (i : I) => operation {G.F j'} {r} h\\n      (\\\\new DArray {len {T.domain {r} h}} (\\\\lam (j : Fin (len {T.domain {r} h})) => E {G.F j'} (T.domain {r} h !! j))\\n        (\\\\lam (j1 : Fin (len {T.domain {r} h})) => (d.at j1).2 {j} {j'} f @ i))))\\n  | relation => \\\\lam (P : PredSymb {Structure.T}) (d : DArray {len {predDomain {Structure.T} P}}\\n    (\\\\lam (j : Fin (len {predDomain {Structure.T} P})) => E (at {predDomain {Structure.T} P} j))) =>\\n  \\\\Pi (j : J.Ob) -> relation {G.F j} P (\\\\new DArray {len {predDomain {Structure.T {G.F j}} P}}\\n    (\\\\lam (j1 : Fin (len {predDomain {Structure.T {G.F j}} P})) => E {G.F j} (at {predDomain {Structure.T {G.F j}} P} j1))\\n    (\\\\lam (k : Fin (len {predDomain {Structure.T {G.F j}} P})) => (d.at k).1 j))\\n  | isModel => {?hidden}\\n}) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => \\\\new ModelHom {T} (apex {\\\\this}) (F {G {\\\\this}} j) {\\n    | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (P : E {Dom {\\\\this}} s) => P.1 j\\n    | func-op => {?hidden}\\n    | func-rel => {?hidden}\\n  }\\n  | coneCoh => {?hidden}\\n  | isLimit => {?hidden}\\n  | limMap => \\\\lam {z : Ob {D {\\\\this}}} (c : Cone {J {\\\\this}} {D {\\\\this}} (G {\\\\this}) z) => \\\\new ModelHom {T} z (apex {\\\\this}) {\\n    | funcs => \\\\lam {s : Sort {ModelHom.T {\\\\this}}} (x : E {Dom {\\\\this}} s) => (\\\\lam (j : J.Ob) => funcs {c.coneMap j} {s} x,\\n      \\\\lam {j j' : J.Ob} (f : J.Hom j j') => path (\\\\lam (p0 : I) => funcs {c.coneCoh {j} {j'} f @ p0} {s} x))\\n    | func-op => {?hidden}\\n    | func-rel => {?hidden}\\n  }\\n  | limBeta => {?hidden}\\n  | limUnique => {?hidden}\\n}\", 'J : Precat', 'G : Functor J this']<<<break>>>['| E (Sort {T}) : \\\\Set', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| predDomain PredSymb : Array Sort', '| Sort : \\\\Set', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| D : Precat', '| T : Theory', '| func-op {r : Sort {ModelHom.T}} (h : Symb {ModelHom.T} r) (d : DArray {len {domain {ModelHom.T} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {ModelHom.T} {r} h})) => E {Dom} (at {domain {ModelHom.T} {r} h} j))) : funcs {r} (operation {Dom} {r} h d) = operation {Cod} {r} h (\\\\new DArray {len {domain {Structure.T {Cod}} {r} h}}\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => E {Cod} (at {domain {Structure.T {Cod}} {r} h} j))\\n  (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => funcs {at {domain {ModelHom.T} {r} h} j} (d.at j)))', '| G : Functor J D', '| domain {s : Sort} (Symb s) : Array Sort', '| J : Precat', '| at (j : Fin len) : A j', '| Symb Sort : \\\\Set', '| PredSymb : \\\\Set', '| T : Signature', '\\\\class ModelHom {\\n  | T : Theory\\n  | Dom : Model ModelHom.T\\n  | Cod : Model ModelHom.T\\n  | funcs {s : Sort {ModelHom.T}} (E {Dom} s) : E {Cod} s\\n  | func-op {r : Sort {ModelHom.T}} (h : Symb {ModelHom.T} r) (d : DArray {len {domain {ModelHom.T} {r} h}}\\n    (\\\\lam (j : Fin (len {domain {ModelHom.T} {r} h})) => E {Dom} (at {domain {ModelHom.T} {r} h} j))) : funcs {r} (operation {Dom} {r} h d) = operation {Cod} {r} h (\\\\new DArray {len {domain {Structure.T {Cod}} {r} h}}\\n    (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => E {Cod} (at {domain {Structure.T {Cod}} {r} h} j))\\n    (\\\\lam (j : Fin (len {domain {Structure.T {Cod}} {r} h})) => funcs {at {domain {ModelHom.T} {r} h} j} (d.at j)))\\n  | func-rel (P : PredSymb {ModelHom.T}) (d : DArray {len {predDomain {ModelHom.T} P}}\\n    (\\\\lam (j : Fin (len {predDomain {ModelHom.T} P})) => E {Dom} (at {predDomain {ModelHom.T} P} j))) (relation {Dom} P d) : relation {Cod} P (\\\\new DArray {len {predDomain {Structure.T {Cod}} P}}\\n    (\\\\lam (j : Fin (len {predDomain {Structure.T {Cod}} P})) => E {Cod} (at {predDomain {Structure.T {Cod}} P} j))\\n    (\\\\lam (j : Fin (len {predDomain {Structure.T {Cod}} P})) => funcs {at {predDomain {ModelHom.T} P} j} (d.at j)))\\n}', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '| func-rel (P : PredSymb {ModelHom.T}) (d : DArray {len {predDomain {ModelHom.T} P}}\\n  (\\\\lam (j : Fin (len {predDomain {ModelHom.T} P})) => E {Dom} (at {predDomain {ModelHom.T} P} j))) (relation {Dom} P d) : relation {Cod} P (\\\\new DArray {len {predDomain {Structure.T {Cod}} P}}\\n  (\\\\lam (j : Fin (len {predDomain {Structure.T {Cod}} P})) => E {Cod} (at {predDomain {Structure.T {Cod}} P} j))\\n  (\\\\lam (j : Fin (len {predDomain {Structure.T {Cod}} P})) => funcs {at {predDomain {ModelHom.T} P} j} (d.at j)))', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", \"\\\\class Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | J : Precat\\n  | D : Precat\\n  | G : Functor J D\\n  | apex : Ob {D}\\n  | coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)\\n  | coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\\n}\", '| F (Ob {C}) : Ob {D}', '| Dom : Model T', '| operation {r : Sort {T}} (h : Symb {T} r)\\n  (DArray {len {domain {T} {r} h}} (\\\\lam (j : Fin (len {domain {T} {r} h})) => E (at {domain {T} {r} h} j))) : E r', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| Cod : Model T', '| Ob : \\\\hType', '| funcs {s : Sort {T}} (E {Dom} s) : E {Cod} s', '| relation (P : PredSymb {T})\\n  (DArray {len {predDomain {T} P}} (\\\\lam (j : Fin (len {predDomain {T} P})) => E (at {predDomain {T} P} j))) : \\\\Prop']<<<break>>>\\Pi {z : Ob {D {\\this}}} -> \\Pi (c : Cone {J {\\this}} {D {\\this}} (G {\\this}) z) -> ModelHom {T} z (apex {\\this}) {\n  | funcs => \\lam {s : Sort {ModelHom.T {\\this}}} (x : E {Dom {\\this}} s) => (\\lam (j : J.Ob) => funcs {c.coneMap j} {s} x,\n    \\lam {j j' : J.Ob} (f : J.Hom j j') => path (\\lam (p0 : I) => funcs {c.coneCoh {j} {j'} f @ p0} {s} x))\n  | func-op => {?hidden}\n  | func-rel => {?hidden}\n}", "completion": "\\lam (c : Cone) => \\new ModelHom {\n  | funcs => \\lam x => (\\lam j => coneMap {c} j x, \\lam f => \\lam p0 => (@) (coneCoh {c} f) p0 x)\n  | func-op => \\lam h d => ext $ ext (\\lam j => func-op h d)\n  | func-rel => \\lam P d x j => func-rel P d x\n}"}
{"prompt": "['C : Set (Set E)', 'this : CoverSpace']<<<break>>>['| <=<-right {U V W : E {A}} (U <= V) (R V W) : R U W', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| E : \\\\Set', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma single_<= \\\\hlevels  {X : \\\\Set} {a : X} {U : Set X} (_ : U a) : single {X} a \u2286 U ']<<<break>>>\\Pi {V : Set E} -> TruncP (\\Sigma (U : Set E) (C U) (V <=< U)) ->\n  TruncP (\\Sigma (V1 : Set E) (TruncP (\\Sigma (U : Set E) (C U) (V1 = (\\lam (x : E) => single {E} x <=< U)))) (V \u2286 V1))", "completion": "\\lam {V} p0 => (\\case \\elim p0 \\with {\n  | inP (U, CU, V<=<U) => inP $ (_, inP (U, CU, idp), \\lam Vx => <=<-right (single_<= Vx) V<=<U)\n})"}
{"prompt": "['x0 : E', 'x0<x0b : x0.U x0b', 'x0b : Rat']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\lemma <_<= \\\\plevels  \\\\hlevels  {x : ExUpperReal} {q : Rat} (_ : x.U q) : x <= fromRat q ', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}']<<<break>>>x0 <= fromRat x0b", "completion": "<_<= x0<x0b"}
{"prompt": "['R : CRing', 'm : Nat', 'A : E', 'B : E', 'n : Nat']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '\\\\func Trace \\\\hlevels  {R1 : Ring} {n : Nat} : LinearMap {R1} (MatrixModule R1 n n) (RingLModule R1) {\\n  | func => \\\\lam (M : E {Dom {\\\\this}}) => func {BigSumHom {R1} {n}} (func {diag {R1} {n}} M)\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\lemma Trace-prod-unfold \\\\hlevels  {R : Ring} {n m : Nat} (X : E) (Y : E) : func {Trace {R} {n}} (X product Y) = BigSum {R}\\n  (\\\\new Array R.E n (\\\\lam (i : Fin n) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {X} i} j R.* at {at {Y} j} i)))) ', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\func \\\\infixl 7 product \\\\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))']<<<break>>>func {Trace {R} {n}} (A product B) = BigSum {R}\n  (\\new Array R.E n (\\lam (i : Fin n) => BigSum {R} (\\new Array R.E m (\\lam (j : Fin m) => at {at {A} i} j R.* at {at {B} j} i))))", "completion": "Trace-prod-unfold A B"}
{"prompt": "['R : CRing']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| zro-right {x : E} : x + zro = x', '| negative E : E', '| E : \\\\Set']<<<break>>>negative {R} (zro {R}) R.+ R.zro = negative {R} (zro {R})", "completion": "zro-right {_} {R.negative R.zro}"}
{"prompt": "['this : HeytingAlebra', 'y : E', 'z : E', 'x : E']<<<break>>>['\\\\lemma \\\\infixr 9 =<= \\\\hlevels  {E1 : Preorder} {x y z : E.E} (_ : x = y) (_ : y E.<= z) : x E.<= z ', '\\\\lemma meet-comm \\\\hlevels  {this : MeetSemilattice} {x y : E} : x \u2227 y = y \u2227 x ', '| \\\\infix 4 <= E E : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| join-right {x y : E} : y <= x \u2228 y', '| implies \\\\alias \\\\infixr 5 --> E E : E', '| exponent-left {x a b : E} (x \u2227 a <= b) : x <= a --> b']<<<break>>>z <= x --> x \u2227 y \u2228 x \u2227 z", "completion": "exponent-left {this} (meet-comm {this} =<= join-right {this})"}
{"prompt": "['R : AddMonoid', 'l : Array (\\\\Sigma R.E M)', 'l1 : Array (\\\\Sigma R.E M)', 'z : Array (\\\\Sigma R.E M)', 'M : \\\\Set', 'e1 : Closure {Array (\\\\Sigma R.E M)} (~) l1 z']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '\\\\data Closure {A : \\\\Type} (A -> A -> \\\\Type) (_ _ : A) : \\\\Prop \\n  | cin (R x y)\\n  | ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', '\\\\lemma ~_++-right \\\\hlevels  {M : \\\\Set} {R : AddMonoid} {l l1 l2 : Array (\\\\Sigma R.E M)} (_ : Closure {Array (\\\\Sigma R.E M)} (~) l1 l2) :\\n  Closure {Array (\\\\Sigma R.E M)} (~) (l ++ l1) (l ++ l2) ']<<<break>>>Closure {Array (\\Sigma R.E M)} (~) (l ++ l1) (l ++ z)", "completion": "~_++-right e1"}
{"prompt": "['X : \\\\Set', 'CA : \\\\Pi {C : Set (Set X)} -> A C -> \\\\Pi (x : X) -> TruncP (\\\\Sigma (U : Set X) (C U) (U x))', \"AI : \\\\Pi {C : Set (Set X)} -> A C -> TruncP (\\\\Sigma (D : Set (Set X)) (A D) (\\\\Pi {V : Set X} ->\\n  D V -> TruncP (\\\\Sigma (U : Set X) (C U) (\\\\Pi {V' : Set X} -> D V' -> \\\\Sigma (x : X) ((\u2227) V V' x) -> V' \u2286 U))))\", 'A : Set (Set X) -> \\\\Prop']<<<break>>>['| R (E {A}) (E {A}) : \\\\Prop', '\\\\lemma Union-cond \\\\hlevels  {X : \\\\hType} {S : Set X -> \\\\hType} {U : Set X} (_ : S U) : U \u2286 Union {X} S ', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '\\\\func Union \\\\hlevels  {X : \\\\hType} (S : Set X -> \\\\hType) : Set X => \\\\lam (a : X) => TruncP (\\\\Sigma (U : Set X) (S U) (U a))', '\\\\func ClosurePrecoverSpace \\\\hlevels  {X : \\\\Set} (A : Set (Set X) -> \\\\Prop)\\n  (CA : \\\\Pi {C : Set (Set X)} -> A C -> \\\\Pi (x : X) -> TruncP (\\\\Sigma (U : Set X) (C U) (U x))) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => Closure {X} A\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| A : TopMeetSemilattice', '\\\\lemma closure-subset \\\\hlevels  {X : \\\\Set} {A : Set (Set X) -> \\\\Prop} {C D : Set (Set X)} (_ : Closure {X} A D) (_ : D \u2286 C) : Closure {X} A C ', '\\\\data Closure \\\\hlevels  {X : \\\\Set} (Set (Set X) -> \\\\Prop) (Set (Set X)) : \\\\Prop \\n  | closure (A C)\\n  | closure-top (C = single {X -> \\\\Prop} top)\\n  | closure-refine {D : Set (Set X)} (Closure {X} A D) (Refines {X} D C)\\n  | closure-trans {D : Set (Set X)} (Closure {X} A D) {E : Set X -> Set (Set X)} (\\\\Pi {U : Set X} -> D U -> Closure {X} A (E U)) (C = (\\\\lam (U : Set X) => TruncP (\\\\Sigma (V W : Set X) (D V) (E V W) (U = V \u2227 W))))', 'closure (A C)', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Interpolative \\\\hlevels  {this1 : RatherBelow} : RatherBelow {A} (<=<c) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', \"\\\\type \\\\infix 4 <=<c \\\\hlevels  {this : RatherBelow} (V U : E {A}) : \\\\Prop \\n=> TruncP (\\\\Sigma (R' : E {A} -> E {A} -> \\\\Prop) (\\\\Pi {V U : E {A}} -> R' V U -> R V U)\\n  (\\\\Pi {V U : E {A}} -> R' V U -> TruncP (\\\\Sigma (W : E {A}) (R' V W) (R' W U))) (R' V U))\", '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>\\Pi {C : Set (Set E)} -> A C -> Closure {E} A (\\lam (V : Set E) => TruncP (\\Sigma (U : Set E) (C U) (R V U)))", "completion": "\\lam p0 => (\\case AI p0 \\with {\n  | inP (D, AD, f) => closure-subset (closure AD) (\\lam p0 => (\\case f p0 \\with {\n    | inP (U, CU, g) => inP (U, CU,\n      inP (\\lam V' U' => \u2203 (\\Sigma (E : A) (\u2200 (\\Pi {W : E} -> Given (V' \u2227 W) -> W \u2286 U'))), \\lam p0 => (\\case \\elim p0 \\with {\n        | inP (E, AE, h) => closure-subset (closure AE) (\\lam EW => h EW)\n      }),\n        \\lam {V'} p0 => (\\case \\elim p0 \\with {\n          | inP (E, AE, h) => \\case AI AE \\with {\n            | inP (F, AF, k) =>\n            inP (Union (\\lam W => Given (\\Sigma (F W) (V' \u2227 W))), inP (F, AF, \\lam c s => Union-cond $ later (c, s.1, s.2)),\n              inP (F, AF, \\lam FW p0 => (\\case \\elim p0 \\with {\n                | (x, (inP (W', (FW', y, (V'y, W'y)), W'x), Wx)) => \\case k FW' \\with {\n                  | inP (U, EU, l) => l FW (x, (W'x, Wx)) <=\u2218 h EU (y, (V'y, l FW' (y, (W'y, W'y)) W'y))\n                }\n              })))\n          }\n        }), inP (D, AD, g)))\n  }))\n})"}
{"prompt": "[\"arg : (func {<=-map {L} j j' j<=j'} (y.1, j<=j' {y.1} L.<=\u2218 y.2)).1 = y.1\", \"y : Subtype {j'}\", 'j : Nucleus {L}', 'L : Locale', 'i : I', \"j' : Nucleus {L}\", \"j<=j' : j <= j'\"]<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '| L : Locale', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', \"\\\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}\"]<<<break>>>j'.nucleus (arg @ i) L.<= arg @ i", "completion": "prop-dpi (\\lam i => ext_coe) (func {<=-map {L1} j j' j<=j'} (y.1, j<=j' {y.1} L.<=\u2218 y.2)).2 y.2 @ i"}
{"prompt": "['R : Ring', 'this : PreAdditivePrecat (\\\\Sigma) {\\n  | Hom => \\\\lam (_ : Ob {\\\\this}) (_ : Ob {\\\\this}) => R.E\\n  | id => \\\\lam (_ : Ob {\\\\this}) => R.ide\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (R.*)\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | AbHom => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} => \\\\new R {}\\n  | l-bilinear => {?hidden}\\n  | r-bilinear => {?hidden}\\n}']<<<break>>>['| \\\\infixl 7 * E E : E', '| ide-left {x : E} : ide * x = x', '| Hom Ob Ob : \\\\Set', '| ide : E', '| Ob : \\\\hType', '| E : \\\\Set']<<<break>>>\\Pi {X : Ob {\\this}} -> \\Pi {Y : Ob {\\this}} -> \\Pi {f : Hom {\\this} X Y} -> R.ide R.* f = f", "completion": "\\lam {X} {Y} {f} => ide-left {R}"}
{"prompt": "['s : Sorted {A} (toList {A.E} (rbBranch {A.E} c t1 a1 t2))', 'A : Dec', 't1 : RBTree A.E', 'a1 : A.E', 't2 : RBTree A.E']<<<break>>>['\\\\lemma tailSorted \\\\hlevels  {A : Preorder} (l1 l2 : List A.E) (_ : Sorted {A} (l1 ++ l2)) : Sorted {A} l2 ', '\\\\data Sorted \\\\hlevels  {A : Preorder} (List A.E) \\\\with\\n  | {A}, nil => sorted-nil\\n  | {A}, x :: xs => sorted-cons (x A.<= headDef {A.E} x xs) (Sorted {A} xs)', '\\\\func toList {A2 : \\\\Type} (_ : RBTree A2) : List A2 \\n  | {A}, rbLeaf => nil {A}\\n  | {A}, rbBranch c t1 a t2 => toList {A} t1 ++ a :: toList {A} t2', 'nil', '| E : \\\\Set', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\infixr 5 :: A (List A)']<<<break>>>Sorted {A} ((a1 :: nil {A.E}) ++ toList {A.E} t2)", "completion": "tailSorted _ _ s"}
{"prompt": "['b : A.E', 'l : Array A.E (suc n)', 'a : A.E', 'A : DecSet', 'q : Not (a = b)', 'n : Nat']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'no (Not E)', '\\\\data Empty \\\\plevels  \\\\hlevels  ', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', \"\\\\func remove1 \\\\hlevels  {A2 : DecSet} (_ : A.E) {n1 : Nat} (_ : Array A.E (suc n1)) : Array A.E n1 \\n  | {A}, a, {0}, l => nil\\n  | {A}, a, {suc n}, a' :: l => \\\\case A.decideEq a a' \\\\with {\\n    | yes p => l\\n    | no n1 => a' :: remove1 {A} a {n} l\\n  }\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| E : \\\\Set']<<<break>>>(\\case no {a = b} q \\with {\n  | yes p => l\n  | no n1 => b :: remove1 {A} a {n} l\n}) !! 0 = a -> Empty", "completion": "\\lam p => q (inv p)"}
{"prompt": "['p : in~ {SType {R} (positiveSubset R)}\\n  {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} u < join {R} (in~ {SType {R} (positiveSubset R)}\\n  {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} s)\\n  (in~ {SType {R} (positiveSubset R)}\\n    {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} t)', 'u : SType {R} (positiveSubset R)', 's : SType {R} (positiveSubset R)', 't : SType {R} (positiveSubset R)', 'R : OrderedCRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '| isPos E : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| negative E : E']<<<break>>>R.isPos ((s.1 R.* t.2 R.\u2228 t.1 R.* s.2) R.* u.2 R.+ R.negative u.1 R.* (s.2 R.* t.2))", "completion": "unfolds p"}
{"prompt": "['h : MonoidHom']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| ide : E', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| func-ide : func (ide {Dom}) = ide {Cod}', '| Dom : BaseSet']<<<break>>>h.func (ide {h.Dom}) = ide {h.Cod}", "completion": "func-ide {h}"}
{"prompt": "['B : A -> \\\\Type', 'A : \\\\Type', \"f' : \\\\Pi (a : A) -> B a\", 'f : \\\\Pi (a : A) -> B a']<<<break>>>['| A : \\\\Type', '| ret B : A', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', '| sec B : A', '| B : \\\\Type', \"\\\\func piEquiv {A1 : \\\\Type} (B1 : A1 -> \\\\Type) (f f' : \\\\Pi (a : A1) -> B1 a) :\\nQEquiv {f = f'} {\\\\Pi (a : A1) -> f a = f' a} (\\\\lam (p : A {\\\\this}) (a : A1) => path (\\\\lam (p0 : I) => (@) p p0 a)) {\\n  | ret => \\\\lam (g : B {\\\\this}) => path (\\\\lam (i : I) (a : A1) => g a @ i)\\n  | ret_f => \\\\lam (a : A {\\\\this}) => idp {f = f'} {ret {\\\\this} (\\\\lam (a1 : A1) => path (\\\\lam (p0 : I) => (@) a p0 a1))}\\n  | f_sec => \\\\lam (b : B {\\\\this}) => idp {\\\\Pi (a : A1) -> f a = f' a} {\\\\lam (a : A1) => path (\\\\lam (p0 : I) => (@) (sec {\\\\this} b) p0 a)}\\n} => \\\\new QEquiv\"]<<<break>>>QEquiv {f = f'} {\\Pi (a : A1) -> f a = f' a} (\\lam (p : A {\\this}) (a : A1) => path (\\lam (p0 : I) => (@) p p0 a)) {\n  | ret => \\lam (g : B {\\this}) => path (\\lam (i : I) (a : A1) => g a @ i)\n  | ret_f => \\lam (a : A {\\this}) => idp {f = f'} {ret {\\this} (\\lam (a1 : A1) => path (\\lam (p0 : I) => (@) a p0 a1))}\n  | f_sec => \\lam (b : B {\\this}) => idp {\\Pi (a : A1) -> f a = f' a} {\\lam (a : A1) => path (\\lam (p0 : I) => (@) (sec {\\this} b) p0 a)}\n}", "completion": "piEquiv B f f'"}
{"prompt": "['y : A.S', 'x : A.S', 'A : Local {U}']<<<break>>>['\\\\class Pullback {\\n  | square : Square\\n  | pullback-univ {Z : \\\\Type} : Equiv {Z -> U {square}} {Square Z (V {square}) (X {square}) (Y {square}) {\\n    | vy => vy {square}\\n    | xy => xy {square}\\n  }} (pull square {Z})\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| U : \\\\Type', '\\\\func pathPullback {A1 : \\\\Type} (x y : A1) :\\nPullback (\\\\new Square (x = y) (\\\\Sigma) (\\\\Sigma) A1 (\\\\lam (_ : U {\\\\this}) => ()) (\\\\lam (_ : V {\\\\this}) => x) (\\\\lam (_ : U {\\\\this}) => ())\\n  (\\\\lam (_ : X {\\\\this}) => y) (\\\\lam (p : U {\\\\this}) => p)) => \\\\new Pullback {\\n  | pullback-univ => {?hidden}\\n}', '| V : \\\\Type', '| X : \\\\Type', '| S : \\\\hType', '\\\\class Square {\\n  | U : \\\\Type\\n  | V : \\\\Type\\n  | X : \\\\Type\\n  | Y : \\\\Type\\n  | ux U : X\\n  | vy V : Y\\n  | uv U : V\\n  | xy X : Y\\n  | sqcomm (u : U) : vy (uv u) = xy (ux u)\\n}']<<<break>>>Pullback (\\new Square (x = y) (\\Sigma) (\\Sigma) A.S (\\lam (_ : U {\\this}) => ()) (\\lam (_ : V {\\this}) => x) (\\lam (_ : U {\\this}) => ())\n  (\\lam (_ : X {\\this}) => y) (\\lam (p : U {\\this}) => p))", "completion": "pathPullback x y"}
{"prompt": "['j : Nucleus {L}', 'p : \\\\Sigma (y : L.E) (x L.<= y)', \"j' : Nucleus {L}\", 'L : Locale']<<<break>>>['| meet-left {x y : E} : x \u2227 y <= x', '| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', '\\\\func \\\\infixr 5 --> \\\\hlevels  {this : Locale} (x y : E) : E => SJoin (\\\\lam (p0 : E) => p0 \u2227 x <= y)', '| <=-refl {x : E} : x <= x', '| nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y', '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| nucleus-unit {x : E {L}} : x <= nucleus x', '\\\\lemma exponent \\\\hlevels  {this : Locale} {x y z : E} : x \u2227 y <= z <-> x <= y --> z ']<<<break>>>nucleus {j} p.1 <= nucleus {j} (j.nucleus p.1 --> nucleus {j'} p.1) \u2227 nucleus {j} p.1", "completion": "meet-univ (nucleus-<= $ exponent.1 $ meet-left <=\u2218 nucleus-unit) <=-refl"}
{"prompt": "[\"so : So (not (a A.== a'))\", 'A : DecSet', \"a' : A.E\", 'a : A.E']<<<break>>>['\\\\func decToBool \\\\plevels  \\\\hlevels  {E : \\\\Prop} (_ : Dec E) : Bool \\n  | {E}, yes e => true\\n  | {E}, no n => false', '\\\\func not \\\\plevels  \\\\hlevels  (_ : Bool) : Bool \\n  | true => false\\n  | false => true', '\\\\func So \\\\plevels  \\\\hlevels  (_ : Bool) : \\\\Prop \\n  | true => \\\\Sigma\\n  | false => Empty', '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>So (not (decToBool {a = a'} (A.decideEq a a')))", "completion": "unfold (==) so"}
{"prompt": "['R : CRing', 'f : RingHom R E', 't : \\\\Sigma (p : Poly R) (isMonic {R} p) (polyEval {E1} (polyMap f p) a.1 = E.zro)', 'E : CRing', 'a : E {Cod {integralClosure-left {R} {E1} f}}']<<<break>>>['\\\\func integralClosure-subring \\\\hlevels  {R E1 : CRing} (f : RingHom R E1) : SubRing E1 (isIntegral f) => \\\\new SubRing {\\n  | contains_zro => {?hidden}\\n  | contains_+ => {?hidden}\\n  | contains_* => {?hidden}\\n  | contains_negative => {?hidden}\\n  | contains_ide => {?hidden}\\n}', '\\\\func integralClosure-left \\\\hlevels  {R E1 : CRing} (f : RingHom R E1) : RingHom R (IRing {integralClosure-subring {R} {E1} f}) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, integral_image f x)\\n} => corestrict {integralClosure-subring {R} {E1} f} {R} f (integral_image f)', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\lemma polyMap-comp \\\\hlevels  {A B C : AddPointed} (f : AddPointedHom A B) (g : AddPointedHom B C) {p : Poly A} :\\n  polyMap g (polyMap f p) = polyMap (g \u2218 f) p ', '\\\\lemma polyEval_polyMap \\\\hlevels  {f : RingHom} {p : Poly f.Dom} {a : E {f.Dom}} :\\n  polyEval {f.Cod} (polyMap f p) (f.func a) = f.func (polyEval {f.Dom} p a) ', '\\\\func polyEval \\\\hlevels  {R3 : Ring} (_ : Poly R3) (_ : R.E) : R.E \\n  | {R}, pzero, a => R.zro\\n  | {R}, padd p e, a => polyEval {R} p a R.* a R.+ e\\n  | {R}, peq i, a => (R.zro-right {R.zro R.* a} *> R.zro_*-left {a}) @ i', '| Cod : BaseSet', '\\\\func isMonic \\\\hlevels  {R : Ring} (p : Poly R) : \\\\Prop => TruncP (\\\\Sigma (n : Nat) (degree<= {R} p n) (polyCoef {R} p n = R.ide))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '\\\\func integralClosure-right \\\\hlevels  {R E1 : CRing} (f : RingHom R E1) : RingHom (IRing {integralClosure-subring {R} {E1} f}) S {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} => embed {integralClosure-subring {R} {E1} f}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func IRing \\\\hlevels  {this : SubRing} : Ring (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro {\\\\new this {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new this {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S} x.1, contains_negative {\\\\new this {}} {x.1} x.2)\\n  | ide => (ide {S}, contains_ide)\\n  | natCoef => natCoefImpl {ISemiring}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| E : \\\\Set', '\\\\func isIntegral \\\\hlevels  (f : RingHom) (x : E {f.Cod}) : \\\\Prop \\n  => TruncP (\\\\Sigma (p : Poly f.Dom) (isMonic {f.Dom} p) (polyEval {f.Cod} (polyMap f p) x = zro {f.Cod}))', '\\\\func polyMap \\\\hlevels  (f3 : AddPointedHom) (_ : Poly f.Dom) : Poly f.Cod \\n  | f, pzero => pzero {f.Cod}\\n  | f, padd p e => padd {f.Cod} (polyMap f p) (f.func e)\\n  | f, peq i => transportInv\\n    {E {f.Cod}} (\\\\lam (x : E {f.Cod}) => padd {f.Cod} (pzero {f.Cod}) x = pzero {f.Cod}) {f.func (zro {f.Dom})} {zro {f.Cod}}\\n      f.func-zro (path (peq {f.Cod})) @ i', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>polyEval {IRing {integralClosure-subring {R} {E1} f}} (polyMap (integralClosure-left {R} {E1} f) t.1) a = zro", "completion": "ext (inv (polyEval_polyMap {integralClosure-right f}) *> pmap (\\lam p0 => polyEval p0 _) (later $ polyMap-comp _ _) *> t.3)"}
{"prompt": "['a : NF', 'b : NF', 'l : Array NF n', 'this : Data']<<<break>>>['| len : Nat', '| env : Array (E {R})', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 6 + E E : E', '| R : Semiring', \"\\\\lemma interpretNF_++ \\\\hlevels  {this : Data} {l1 l2 : NF} : interpretNF' (l1 ++ l2) = interpretNF' l1 + interpretNF' l2 \", '| C : Semiring', '| E : \\\\Set', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', \"\\\\func interpretNF' \\\\hlevels  {this3 : Data} (_ : NF) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => mulCoef x.2 x.1\\n  | {this}, x :: l => mulCoef x.2 x.1 + interpretNF' l\", '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys']<<<break>>>interpretNF'\n  (b ++ Big {List (\\Sigma (List (Fin (len {env}))) (E {C}))} {List (\\Sigma (List (Fin (len {env}))) (E {C}))} (++) a l) = interpretNF' b + interpretNF'\n  (Big {List (\\Sigma (List (Fin (len {env}))) (E {C}))} {List (\\Sigma (List (Fin (len {env}))) (E {C}))} (++) a l)", "completion": "interpretNF_++ {this}"}
{"prompt": "['c : Limit {Precat.op {J}} {Precat.op {I.D}} (Functor.op {Comp {J} {I.C} {I.D} (\\\\new I {}) F})', 'J : Precat', 'I : ReflectiveSubPrecat', 'F : Functor J I.C']<<<break>>>['| A : \\\\Type', '| reflectorMap (X : Ob {D}) : Hom {D} X (F (reflector X))', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j', '| D : Precat', '| isFaithful {X Y : Ob {C}} {f g : Hom {C} X Y} (Func {X} {Y} f = Func {X} {Y} g) : f = g', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| ret B : A', '| reflector (Ob {D}) : Ob {C}', '| J : Precat', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this1 : FullyFaithfulFunctor} : FullyFaithfulFunctor (Precat.op {C}) (Precat.op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C}} => Func {Y} {X}\\n} => \\\\new FullyFaithfulFunctor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n}', '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\func isInj {this : Equiv} {a a' : A} (p : f a = f a') : a = a' \\n  => inv {A} {ret (f a)} {a} (ret_f a) *> pmap {B} {A} ret {f a} {f a'} p *> ret_f a'\", '\\\\func f_ret {this : Equiv} (y : B) : f (ret y) = y \\n  => pmap {B} {B} (\\\\lam (y : B) => f (ret y)) {y} {f (sec y)} (inv {B} {f (sec y)} {y} (f_sec y)) *> pmap {A} {B} f {ret (f (sec y))} {sec y} (ret_f (sec y)) *> f_sec y', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma inverse-right \\\\plevels obj >= hom \\\\hlevels  {this : FullyFaithfulFunctor} {X Y : Ob {C}} {f : Hom {D} (F X) (F Y)} : Func {X} {Y} (inverse {X} {Y} f) = f ', '\\\\field isReflective {X : Ob {D}} {Y : Ob {C}} : Equiv {Hom {C} (reflector X) Y} {Hom {D} X (F Y)} (\\\\lam (p0 : A {\\\\this}) => Func {reflector X} {Y} p0 \u2218 reflectorMap X)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '\\\\func inverse \\\\plevels obj >= hom \\\\hlevels  {this : FullyFaithfulFunctor} {X Y : Ob {C}} (f : Hom {D} (F X) (F Y)) : Hom {C} X Y => ret {isFullyFaithful {X} {Y}} f', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| ret_f (x : A) : ret (f x) = x', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\class ReflectiveSubPrecat \\\\extends FullyFaithfulFunctor, RightAdjointUnit \\\\plevels obj >= hom \\\\hlevels  {\\n  | reflector (Ob {D}) : Ob {Functor.C}\\n  | reflectorMap (X : Ob {D}) : Hom {D} X (F (reflector X))\\n  \\\\field isReflective {X : Ob {D}} {Y : Ob {Functor.C}} : Equiv {Hom {Functor.C} (reflector X) Y} {Hom {D} X (F Y)} (\\\\lam (p0 : A {\\\\this}) => Func {reflector X} {Y} p0 \u2218 reflectorMap X)\\n  | eta => \\\\new NatTrans {D} {D} (Id {D}) (Comp {D} {Functor.C} {D} (\\\\new this9 {}) LAdj) {\\n    | trans => reflectorMap\\n    | natural => {?hidden}\\n  }\\n  | LAdj => \\\\new Functor D Functor.C reflector {\\n    | Func => \\\\lam {X : Ob {Functor.C {\\\\this}}} {Y : Ob {Functor.C {\\\\this}}} (h : Hom {Functor.C {\\\\this}} X Y) =>\\n      ret {isReflective {X} {reflector Y}} (reflectorMap Y \u2218 h)\\n    | Func-id => {?hidden}\\n    | Func-o => {?hidden}\\n  }\\n  | eta-adjoint => isReflective\\n}', '| sec B : A', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '| G : Functor J D', '| C : Precat', '\\\\func map \\\\plevels obj >= hom \\\\hlevels  {C D : Precat} (F1 : Functor C D) {J1 : Precat} {G : Functor J1 C} (c : Cone {J1} {C} G) :\\nCone {J1} {D} (Comp {J1} {C} {D} F1 G) (F.F c.apex) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => F.Func {c.apex} {G.F j} (c.coneMap j)\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| isFullyFaithful {X Y : Ob {C}} : Equiv {Hom {C} X Y} {Hom {D} (F X) (F Y)} (Func {X} {Y})', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", \"\\\\class Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | J : Precat\\n  | D : Precat\\n  | G : Functor J D\\n  | apex : Ob {D}\\n  | coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)\\n  | coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\\n}\", '| limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g', '\\\\class Limit \\\\extends Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\\\new \\\\this {}) z)\\n  | limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex\\n  | limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j\\n  | limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g\\n}', '| apex : Ob {D}', '| D : Precat', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func conePullback \\\\plevels obj >= hom \\\\hlevels  {J1 : Precat} {D1 : Precat} {F1 : Functor J1 D1} (C : Cone {J1} {D1} F1) (z : D.Ob) (f : D.Hom z C.apex) :\\nCone {J1} {D1} F1 z {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => C.coneMap j D.\u2218 f\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| Ob : \\\\hType', '| B : \\\\Type', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>Limit {Precat.op {J1}} {Precat.op {I.C}} (Functor.op {F1}) (I.reflector c.apex) {\n  | coneMap => \\lam (j : Ob {J {\\this}}) => inverse {I1} {F.F j} {I.reflector c.apex} (I.reflectorMap c.apex \u2218 c.coneMap j)\n  | coneCoh => {?hidden}\n  | isLimit => {?hidden}\n  | limMap => \\lam {z : Ob {Cone.D {\\this}}} (c' : Cone {J {\\this}} {Cone.D {\\this}} (G {\\this}) z) => ret {I.isReflective {c.apex} {z}}\n    (c.limMap {I.F z} (map {Precat.op {I.C}} {Precat.op {I.D}} (FullyFaithfulFunctor.op {I1}) {Precat.op {J1}} {Functor.op {F1}} c'))\n  | limBeta => {?hidden}\n  | limUnique => {?hidden}\n}", "completion": "\\new Limit {\n  | J => _\n  | D => _\n  | G => op {F}\n  | apex => reflector {I} (apex {c})\n  | coneMap => \\lam j => inverse {I} (reflectorMap _ \u2218 coneMap {c} j)\n  | coneCoh => \\lam h => isFaithful {I} $ rewrite (Func-o {I}) (repeat {2} (rewrite (inverse-right {I})) (rewrite o-assoc (pmap ((\u2218) _) (coneCoh {c} h))))\n  | limMap => \\lam {z} c' => ret {isReflective {I}} (limMap {c} (map (op {I}) {op {J}} c'))\n  | limBeta => \\lam c' j => isInj {isFullyFaithful {I}} $ Func-o *> pmap ((\u2218) _) (inverse-right {I}) *> inv o-assoc *> pmap (\\lam _x => _x \u2218 _) (f_ret {isReflective {I}} _) *> limBeta {c} (map (op {I}) {op {J}} c') j\n  | limUnique => \\lam {z} {f} {g} p => inv (ret_f {isReflective {I}} f) *> pmap (ret {isReflective {I}}) (limUnique {c}\n    (\\lam j => o-assoc *> (rewrite (inverse-right {I}) in inv (Func-o {I}) *> pmap (Func {I}) (p j) *> Func-o {I}) *> inv o-assoc)) *> ret_f {isReflective {I}} g\n}"}
{"prompt": "['V : Set X.E', 'W : Set X.E', 'A : AddGroup X.E', 'V0 : V A.zro', 'W0 : W A.zro', 'X : TopSpace']<<<break>>>['| zro : E', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>(\u2227) V W A.zro", "completion": "(V0, W0)"}
{"prompt": "['L : PreuniformLocale', 'j : Nucleus {L}', 'o : IsOvert {locale {j}}', 'uU : L.isUniform U', 'U : L.E -> \\\\Prop']<<<break>>>['\\\\func map \\\\hlevels  {this2 : Nucleus} : FrameHom L locale {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (nucleus x, nucleus-join>= {x})\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}', '\\\\func nucleus-star \\\\hlevels  {L1 : Locale} (j : Nucleus {L1}) (U : L.E -> \\\\Prop) : L.E \\n  => SJoin {L1} (\\\\lam (y : L.E) => \\\\Sigma (U y) (IsPositive {locale {j}} (j.nucleus y, j.nucleus-join>= {y})))', '\\\\func wclosed-image \\\\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\\\lam (x : E {L {\\\\this}}) => Meet {Dom}\\n  {\\\\Sigma (j : Nucleus {Dom}) (\\\\Pi {P : \\\\Prop} -> \\\\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\\n  (\\\\lam (j : \\\\Sigma (j : Nucleus {Dom}) (\\\\Pi {P : \\\\Prop} -> \\\\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\\n    nucleus {j.1} x)) => \\\\new Nucleus {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}', '\\\\lemma sdense_overt \\\\hlevels  {f : FrameHom} (_ : isStronglyDense {f}) (_ : IsOvert {f.Cod}) : IsOvert {f.Dom} ', '\\\\lemma top>=star {L : PreuniformLocale} {j : Nucleus {L}} (_ : IsOvert {locale {j}}) {U : L.E -> \\\\Prop} (_ : L.isUniform U) :\\n  open {L} (nucleus-star {L} j U) <= j ', '\\\\lemma wclosure-sdense {j : Nucleus} : isStronglyDense {<=-map {j.L} (wclosed-image {map {j}}) (\\\\new j {}) (wclosure_<= {j})} ', '| nucleus (E {L}) : E {L}', '\\\\lemma wclosure_<= {j : Nucleus} : wclosed-image {map {j}} <= \\\\new j {} ', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '\\\\func open \\\\hlevels  {this2 : Locale} (a : E) : Nucleus ((-->) a) => \\\\new Nucleus {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}', \"\\\\func <=-map {L1 : Locale} (j j' : Nucleus {L1}) (j<=j' : j <= j') : FrameHom (locale {j}) (locale {j'}) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (j'.nucleus x.1, j'.nucleus-join>= {x.1})\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}\"]<<<break>>>\\Pi {x : L.E} ->\n  nucleus {open {L} (nucleus-star {L} (wclosed-image {map {j}}) U)} x L.<= nucleus {wclosed-image {map {j}}} x", "completion": "top>=star (sdense_overt {<=-map (wclosed-image {map {j}}) j wclosure_<=} wclosure-sdense o) uU"}
{"prompt": "['a : E', 'A : LModule R', 'p0 : \\\\Sigma E (\\\\Sigma)', 'm : BilinearMap {R} A B C', 'C : LModule R', 'p1 : \\\\Sigma R.E (\\\\Sigma)', 't_ : \\\\Sigma R.E (\\\\Sigma)', 'R : DRing', 'B : LModule R', 'x_ : \\\\Sigma E (\\\\Sigma)']<<<break>>>['| \\\\infixl 6 + E E : E', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\instance ProductLModule \\\\hlevels  (R1 : Ring) (A B : LModule R1) : LModule R1 (\\\\Sigma A.E B.E) {\\n  | zro => (A.zro, B.zro)\\n  | + => \\\\lam (p : E) (q : E) => (p.1 A.+ q.1, p.2 B.+ q.2)\\n  | negative => \\\\lam (p : E) => (A.negative p.1, B.negative p.2)\\n  | *c => \\\\lam (r : E {R {\\\\this}}) (p : E {\\\\this}) => (r A.*c p.1, r B.*c p.2)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '| Cod : BaseSet', '| linear-right {a : E {A}} : LinearMap {R} B C {\\n  | func => func a\\n}', '| func (E {A}) (E {B}) : E {C}', '| zro : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x', '| linear-left {b : E {B}} : LinearMap {R} A C {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => func p0 b\\n}', '| zro-left {x : E} : zro + x = x', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infixl 7 *c (E {R}) E : E', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| negative-left {x : E} : negative x + x = zro', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| negative E : E', '| +-comm {x y : E} : x + y = y + x', '| *c-ldistr {r : E {R}} {a b : E} : r *c (a + b) = r *c a + r *c b', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>p1.1 C.*c (m.func x.1 a.2 C.+ m.func a.1 x.2 C.+ t C.*c m.func a.1 a.2) = SetHom.func {m.linear-left {(p0.1 + p1.1 *c a).2}} (p0.1.1 A.+ (p1.1 *c a).1) - m.func p0.1.1 p0.1.2", "completion": "rewrite (func-+ {linear-left {m}}) (rewrite (func-+ {linear-right {m}}) (rewrite (func-*c {linear-left {m}})\n  (rewrite (func-*c {linear-right {m}}) (later (rewrite (negative-left, zro-left, *c-ldistr, *c-ldistr) $ +-assoc *> pmap ((+) _)\n    (pmap (\\lam p0 => _ + _ *c p0) (inv (func-*c {linear-right {m}})) *> inv *c-ldistr *> pmap ((*c) _) (inv (func-+ {linear-right {m}})))) *> pmap (\\lam _x => _x + _) +-assoc *> +-assoc *> +-comm))))"}
{"prompt": "['X : CoverSpace', 'p : (\\\\lam (p0 : \\\\Sigma X.E Y.E) => p0.1) ^-1 U \u2286 W', 'U : Set X.E', 'W : Set (\\\\Sigma X.E Y.E)', 'Y : CoverSpace']<<<break>>>['| top : E', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>\\Pi {x : X.E} -> U x -> \\Pi {y : Y.E} -> top y -> W (x, y)", "completion": "\\lam Ux _ => p Ux"}
{"prompt": "['d2 : abs {RealAbGroup} (y - z2) < eps * fromRat (ratio (pos 1) 4)', 'y : Real', 'eps : Real', 'z2 : Real']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\lemma abs>=id \\\\hlevels  {this : LatticeAbGroup} {x : E} : x <= abs x ', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat']<<<break>>>y - z2 < eps * fromRat (ratio (pos 1) 4)", "completion": "abs>=id {RealAbGroup} <\u2218r d2"}
{"prompt": "['R : CRing', 'n : Nat', 'b : R.E', 'm : Nat', 'p : pow {R} e k = a R.* c R.+ b R.* d', 'd : R.E', 'c : R.E', 'e : R.E', 'a : R.E', 'k : Nat']<<<break>>>['| \\\\infixl 6 + E E : E', '| C : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', 'coef C', 'nil', 'inP A', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', ':ide', '| at (j : Fin len) : A j', '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', ':zro', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '| negative E : E', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'var V', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>TruncP (\\Sigma (c : Array (E {R}) (len {pow {R} a n :: pow {R} b m :: nil}))\n  (pow {R} b m = BigSum {R} (\\new Array (E {R}) (len {pow {R} a n :: pow {R} b m :: nil})\n    (\\lam (i : Fin (len {pow {R} a n :: pow {R} b m :: nil})) => c.at i * at {pow {R} a n :: pow {R} b m :: nil} i))))", "completion": "inP (0 :: 1 :: nil, equation)"}
{"prompt": "['Pk : P k', 'l_c_fl_q : \\\\Sigma (l : Array (E {K})) (c : E {K}) (isAlgebraGenerated {rfd.RootField} {K} f l) (polyMap f (degree1PolyDivision\\n  {RootField {nextField {k} {p} Pk p/=0 (\\\\lam (pi : Inv {PolyEuclideanRingData k} p) => (\\\\case polyInv {k} {p} pi \\\\with {\\n    | inP (r, q, i) =>\\n      \\\\case transport {Poly k} (\\\\lam (x : Poly k) => degree {k} x = suc n) {p} {padd {k} (pzero {k}) r} q d \\\\with {}\\n  }))}} (polyMap rfd.rootFieldHom p) rfd.root).1 = c *c BigProd {PolyEuclideanRingData K} (map {E {K}} {Poly K} (\\\\lam (a : E {K}) => padd {K} ide (negative {K} a)) l))', 'this : SplittingFieldData', 'n : Nat', 'rfd : RootFieldData P k p', 'K_PK_f_Ks : \\\\Sigma (K : DiscreteField) (P K) (f : RingHom rfd.RootField K) (IsSplittingField {rfd.RootField} {K} (degree1PolyDivision\\n  {RootField {nextField {k} {p} Pk p/=0 (\\\\lam (pi : Inv {PolyEuclideanRingData k} p) => (\\\\case polyInv {k} {p} pi \\\\with {\\n    | inP (r, q, i) =>\\n      \\\\case transport {Poly k} (\\\\lam (x : Poly k) => degree {k} x = suc n) {p} {padd {k} (pzero {k}) r} q d \\\\with {}\\n  }))}} (polyMap rfd.rootFieldHom p) rfd.root).1 f)', 'k : DiscreteField', 'p/=0 : p = zro -> Empty', 'd : degree {k} p = suc n', 'p : Poly k']<<<break>>>['| root : E {RootField}', '\\\\func degree \\\\hlevels  {R1 : Ring.Dec} (_ : Poly R1) : Nat \\n  | {R}, pzero => 0\\n  | {R}, padd p e => \\\\case decideEq p zro \\\\with {\\n    | yes p => 0\\n    | no n => suc (degree {R} p)\\n  }\\n  | {R}, peq i => idp {Nat} {0} @ i', 'suc Nat', '| RootField-gen (x : E {RootField}) : TruncP (\\\\Sigma (q : Poly k) (polyMapEval {k} {RootField} rootFieldHom q root = x))', '\\\\lemma isAlgebraGenerated-comp \\\\hlevels  {R E1 S : CRing} {f : RingHom R E1} {g : RingHom E1 S} {a : E.E} {l : Array S.E}\\n  (_ : \\\\Pi (x : E.E) -> TruncP (\\\\Sigma (p : Poly R) (polyMapEval {R} {E1} f p a = x)))\\n  (_ : isAlgebraGenerated {E1} {S} g l) : isAlgebraGenerated {R} {S} (g \u2218 f) (g.func a :: l) ', 'padd (Poly R) R.E', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '| rootFieldHom : RingHom k RootField', 'pzero', '\\\\lemma polyInv \\\\hlevels  {R : StrictDomain} {p : Poly R} (_ : Inv {PolyRing R} p) :\\n  TruncP (\\\\Sigma (r : R.E) (p = padd {R} (pzero {R}) r) (Inv {R} r)) ', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| E : \\\\Set', '\\\\func \\\\infixl 8 compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {R S T : Ring} (g : RingHom S T) (f : RingHom R S) : RingHom R T {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', \"\\\\instance PolyEuclideanRingData (R : DiscreteField) : EuclideanRingData (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (PolyRing.*)\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n  | # => (#)\\n  | decideEq => PolyDecRing.decideEq {R}\\n  | euclideanMap => degree {R}\\n  | divMod => \\\\lam (p : E {\\\\this}) (q : E {\\\\this}) => (\\\\case DecSet.decideEq (degree {R} q) 0 \\\\with {\\n    | yes p1 => \\\\case DecSet.decideEq q zro \\\\with {\\n      | yes p1 => (zro, p)\\n      | no n => (R.finv (leadCoef {R} q) *c p, zro)\\n    }\\n    | no n => divMod_fuel {R} p q (suc' (degree {R} p))\\n  })\\n  | negative => negative {R}\\n} => \\\\new EuclideanRingData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n  | negative-left => {?hidden}\\n}\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| nextField {K : DiscreteField} {p : Poly K} (P K) (p /= zro) (Not (Inv {PolyEuclideanRingData K} p)) : RootFieldData P K p', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '| RootField : DiscreteField', '\\\\type isAlgebraGenerated \\\\hlevels  {R E1 : CRing} (f : RingHom R E1) (l : Array E.E) : \\\\Prop => \\\\Pi (x : E.E) ->\\n  TruncP (\\\\Sigma (p : E) (x = func {mPolyEval {Fin l.len} {E1} l.at} (mPoly-map {Fin l.len} {R} {E1} f p)))', '| func (E {Dom}) : E {Cod}']<<<break>>>isAlgebraGenerated {k} {K} (f \u2218 rfd.rootFieldHom) (func {f} rfd.root :: l)", "completion": "isAlgebraGenerated-comp (RootField-gen {rfd}) fl"}
{"prompt": "['b : E', 'this : BooleanAlgebra', 'a : E']<<<break>>>['| meet-univ {x y z : E} (z <= x) (z <= y) : z <= x \u2227 y', '| <=-refl {x : E} : x <= x', '| top : E', '| top-univ {x : E} : x <= top', '| \\\\infix 4 <= E E : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| compl E : E']<<<break>>>compl (a \u2227 b) <= compl (a \u2227 b) \u2227 top", "completion": "meet-univ {this} (<=-refl {this}) (top-univ {this})"}
{"prompt": "['f : UniformEmbedding L M', 'Wx : W x', 'x : E {Dom {\\\\this}}', 'cW : \\\\Pi {x : E {f.Dom}} -> W x -> V (f.func x)', 'V : E {g.Dom} -> \\\\Prop']<<<break>>>['| func (E {Dom}) : E {Cod}']<<<break>>>V (f.func x)", "completion": "cW Wx"}
{"prompt": "['d : Nat', 'null : Nat']<<<break>>>['suc Nat', '\\\\lemma id<suc \\\\plevels  \\\\hlevels  {n : Nat} : n < suc n ', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', \"\\\\func gcd-isGCD \\\\hlevels  {this1 : EuclideanSemiringData} (a b : E) :\\nGCD a b (gcd a b) (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val1 {\\\\this}) (reduce a b).1 {\\n  | inv-right => {?hidden}\\n})\\n  (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val2 {\\\\this}) (reduce a b).2 {\\n    | inv-right => {?hidden}\\n  }) (gcd-isGCD-fueled (suc' (euclideanMap b)) {a} {b}) => \\\\new GCD\", \"\\\\func reduce \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : \\\\Sigma E E => reduce-fueled (suc' (euclideanMap b)) a b\", '| euclideanMap E : Nat', '| val1 : E {M}', '| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', '\\\\class GCD \\\\hlevels  {\\n  | M : CMonoid\\n  | val1 : E {M}\\n  | val2 : E {M}\\n  | res : E {M}\\n  | res|val1 : LDiv {M} res val1\\n  | res|val2 : LDiv {M} res val2\\n  | res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res\\n}', '| val2 : E {M}', '| E : \\\\Set', \"\\\\lemma suc'=suc \\\\plevels  \\\\hlevels  (n : Nat) : suc' n = suc n \", '| M : CMonoid', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '| res : E {M}', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| \\\\infix 4 < E E : \\\\Prop', '\\\\lemma reduce*fueled-left \\\\hlevels  {this : EuclideanSemiringData} (s : Nat) (a b : E) (_ : euclideanMap b < s) :\\n  (reduce-fueled s a b).1 * gcd-fueled s a b = a ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func gcd-isGCD-fueled \\\\hlevels  {this1 : EuclideanSemiringData} (s1 : Nat) {a1 b1 g1 : E} (_ : LDiv g1 a1) (_ : LDiv g1 b1) :\\n  LDiv g1 (gcd-fueled s1 a1 b1) \\n  | {this}, 0, {a}, {b}, {g}, g|a, g|b => g|a\\n  | {this}, suc s, {a}, {b}, {g}, g|a, g|b => \\\\case decideEq b zro \\\\with {\\n    | yes p => g|a\\n    | no b/=0 => gcd-isGCD-fueled s {b} {(divMod a b).2} {g} g|b\\n      (summandDiv {g|b.inv * (divMod a b).1} {(divMod a b).2} {g|a.inv} {g} (ldiv/=0 {g} {b} b/=0 g|b)\\n        (pmap {E} {E} (\\\\lam (_x : E) => _x + (divMod a b).2) {g * (g|b.inv * (divMod a b).1)} {g * g|b.inv * (divMod a b).1}\\n          (Paths.inv {E} {g * g|b.inv * (divMod a b).1} {g * (g|b.inv * (divMod a b).1)} (*-assoc {g} {g|b.inv} {(divMod a b).1})) *> pmap {E} {E} (\\\\lam (p0 : E) => p0 * (divMod a b).1 + (divMod a b).2) {g * g|b.inv} {b} g|b.inv-right *> isDivMod a b *> Paths.inv {E} {g * g|a.inv} {a} g|a.inv-right))\\n  }', \"\\\\func suc' \\\\plevels  \\\\hlevels  (_ : Nat) : Nat \\n  | 0 => 1\\n  | suc n => suc (suc n)\"]<<<break>>>GCD {NatEuclidean} (suc n) d (gcd {NatEuclidean} (suc n) d)\n  (\\new LDiv {M {\\this}} (res {\\this}) (val1 {\\this}) (reduce {NatEuclidean} (suc n) d).1 {\n    | inv-right => {?hidden}\n  })\n  (\\new LDiv {M {\\this}} (res {\\this}) (val2 {\\this}) (reduce {NatEuclidean} (suc n) d).2 {\n    | inv-right => {?hidden}\n  }) (gcd-isGCD-fueled {NatEuclidean} (suc' (euclideanMap d)) {suc n} {d})", "completion": "gcd-isGCD n d"}
{"prompt": "['M : Monoid', 'this : Monoid (arg.1 @ i) {\\n  | ide => h2 @ i\\n  | * => h3 @ i\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n}', 'h3 : Path (\\\\lam (i : I) => arg.1 @ i -> arg.1 @ i -> arg.1 @ i) (M.*) (N.*)', 'N : Monoid', 'arg : \\\\Sigma (p1 : M.E = N.E) (transport {\\\\Set} (\\\\lam (x : \\\\Set) => x) {M.E} {N.E} p1 M.ide = N.ide)\\n  (\\\\Pi (e : M.E) -> \\\\Pi (e1 : M.E) ->\\n    transport {\\\\Set} (\\\\lam (x1 : \\\\Set) => x1) {M.E} {N.E} p1 (e M.* e1) = transport {\\\\Set} (\\\\lam (x1 : \\\\Set) => x1) {M.E} {N.E} p1 e N.* transport {\\\\Set} (\\\\lam (x1 : \\\\Set) => x1) {M.E} {N.E} p1 e1)', 'i : I']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '| *-assoc {x y z : E} : x * y * z = x * (y * z)']<<<break>>>\\Pi {x : E {\\this}} -> \\Pi {y z : arg.1 @ i} -> (@) h3 i ((@) h3 i x y) z = (@) h3 i x ((@) h3 i y z)", "completion": "\\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (*-assoc {M}) (*-assoc {N})) i {x}"}
{"prompt": "['A : Dec', 'xs : List A.E']<<<break>>>['\\\\data Sorted \\\\hlevels  {A : Preorder} (List A.E) \\\\with\\n  | {A}, nil => sorted-nil\\n  | {A}, x :: xs => sorted-cons (x A.<= headDef {A.E} x xs) (Sorted {A} xs)', '\\\\lemma sort-sorted \\\\hlevels  {A : Dec} (xs : List A.E) : Sorted {A} (sort {A} xs) ', '\\\\func sort \\\\hlevels  {A2 : Dec} (_ : List A.E) : List A.E \\n  | {A}, nil => nil {A.E}\\n  | {A}, a :: xs => insert {A} a (sort {A} xs)']<<<break>>>Sorted {A} (sort {A} xs)", "completion": "sort-sorted xs"}
{"prompt": "['l1 : Localization R S1', 'l2 : Localization R S2', 'x : E {l1.R}', \"p2 : \\\\Pi (x : R.E) -> S1.contains x -> Inv {l2.R'} (func {l2.inL} x)\"]<<<break>>>[\"| inL : RingHom R R'\", \"\\\\func lift \\\\hlevels  {this : Localization} {R'' : CRing} (f : RingHom R R'') (l : \\\\Pi (x : E {R}) -> contains {S} x -> Inv {R''} (f.func x)) :\\n  RingHom R' R'' => (center {local-univ {R''} f l}).1\", \"| R' : CRing\", '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', \"\\\\lemma lift-prop-func \\\\hlevels  {this : Localization} {R'' : CRing} (f : RingHom R R'') (l : \\\\Pi (x : E {R}) -> contains {S} x -> Inv {R''} (f.func x))\\n  (x : E {R}) : func {lift {R''} f l} (func {inL} x) = f.func x \"]<<<break>>>func {lift {l1} {l2.R'} l2.inL p2} (func {l1.inL} x) = func {l2.inL} x", "completion": "lift-prop-func {l1} (inL {l2}) p2 x"}
{"prompt": "['x : E', 'y : E', 'x<y : x < y', 'x>0 : zro < x', 'this : OrderedField', 'y>0 : zro < y']<<<break>>>['| zro : E', '\\\\lemma pinv_pos-inv \\\\hlevels  {this : OrderedField} {x : E} (x>0 : zro < x) : pinv (pinv x {?hidden}) {?hidden} = x ', '\\\\lemma pinv>0 \\\\hlevels  {this : OrderedField} {x : E} (x>0 : zro < x) : zro < pinv x {?hidden} ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '\\\\func pinv \\\\hlevels  {this : OrderedField} (x : E) (\\\\property x>0 : zro < x) : E => inv {pos#0 {x} x>0}', \"\\\\func transport2 {A B : \\\\Type} (C : A -> B -> \\\\Type) {a a' : A} {b b' : B} (_ : a = a') (_ : b = b') (_ : C a b) : C a' b' \\n  | {A}, {B}, C, {a}, {a'}, {b}, {b'}, idp, idp, c => c\", '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>pinv (pinv x {?hidden}) {?hidden} < pinv (pinv y {?hidden}) {?hidden}", "completion": "transport2 ((<) {this}) (inv $ pinv_pos-inv {this} x>0) (inv $ pinv_pos-inv {this} y>0) x<y"}
{"prompt": "['a : Rat', 'l : Real', 'c : Series X.E', 'bp : \\\\Pi (n : Nat) -> X.norm (c (suc n)) <= X.norm (c n) * b n', 'X : ExPseudoNormedRing', 'la<1 : l * fromRat a < ide', 'b : Series Real', 'a>=0 : zro <= a', 'bl : IsLimit {RealNormed} {NatBSemilattice} b l']<<<break>>>['\\\\lemma rat_real_<= \\\\plevels  \\\\hlevels  {a b : Rat} : a <= b <-> fromRat a <= fromRat b ', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma norm>=0 \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : zro <= X.norm x ', '| \\\\infix 4 <= E E : \\\\Prop', '| \\\\infixl 7 * E E : E', '\\\\instance NatBSemilattice \\\\hlevels  : BottomJoinSemilattice Nat {\\n  | <= => (<=)\\n  | join => join {NatSemiring}\\n  | bottom => 0\\n} => \\\\new BottomJoinSemilattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | bottom-univ => {?hidden}\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma pow>=0 \\\\hlevels  {this : PosetSemiring} {a : E} {k : Nat} (_ : zro <= a) : zro <= pow a k ', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| E : \\\\Set', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\lemma *_join \\\\plevels  \\\\hlevels  {x y : ExUpperReal} : x * y = join x zro * join y zro ', '| join-right {x y : E} : y <= x \u2228 y', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', '\\\\lemma *_>=0 \\\\plevels  \\\\hlevels  {x y : ExUpperReal} : zro <= x * y ', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\lemma <=_* \\\\plevels  \\\\hlevels  {x x' y y' : ExUpperReal} (_ : x <= x') (_ : y <= y') : x * y <= x' * y' \", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', 'join \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal => \\\\new ExUpperReal (\\\\lam (a : Rat) => \\\\Sigma (x.U a) (y.U a)) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\instance RealValuedRing : CompleteValuedCRing Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (+)\\n  | negative => negative\\n  | norm => abs {RealAbGroup}\\n  | * => (RealField.*)\\n  | ide => fromRat ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n} => \\\\new CompleteValuedCRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n  | *-comm => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\lemma <=-upper \\\\plevels  \\\\hlevels  {x y : Real} : x Preorder.<= y <-> x ExUpperReal.<= y ', '\\\\lemma join_*-right \\\\hlevels  {this : LinearlyOrderedSemiring} {a b c : E} (_ : zro <= c) : (a \u2228 b) * c = a * c \u2228 b * c ', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro_*-left {x : E} : zro * x = zro', 'suc Nat', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '\\\\lemma join-upper \\\\plevels  \\\\hlevels  {x y : Real} : RealAbGroup.join x y = ExUpperReal.join x y ', '\\\\lemma cont-limit \\\\hlevels  {I : DirectedSet} {X Y : TopSpace} {f : I.E -> X.E} {l : X.E} (_ : IsLimit {X} {I} f l) (g : ContMap X Y) :\\n  IsLimit {Y} {I} (\\\\lam (n : I.E) => g.func (f n)) (g.func l) ', '| join-left {x y : E} : x <= x \u2228 y', '| *-comm {x y : E} : x * y = y * x', '\\\\func tuple \\\\hlevels  {X Y Z : CoverSpace} (f : CoverMap Z X) (g : CoverMap Z Y) : CoverMap Z (X \u2a2f Y) {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (f.func z, g.func z)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\lemma upper-ratio-test {S : Series ExUpperReal} (_ : \\\\Pi (n : Nat) -> zro <= S n) (_ : TruncP (\\\\Sigma (B : Rat) (U {S 0} B))) (b : Series Real)\\n  (_ : \\\\Pi (n : Nat) -> S (suc n) <= S n * b n) {l : Real} (_ : l < ide) (_ : IsLimit {RealNormed} {NatBSemilattice} b l) :\\n  IsConvUpperSeries S ', \"\\\\func transport2 {A B : \\\\Type} (C : A -> B -> \\\\Type) {a a' : A} {b b' : B} (_ : a = a') (_ : b = b') (_ : C a b) : C a' b' \\n  | {A}, {B}, C, {a}, {a'}, {b}, {b'}, idp, idp, c => c\", \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func const \\\\hlevels  {Y X : CoverSpace} (x : X.E) : CoverMap Y X {\\n  | func => \\\\lam (_ : E {Dom {const {Y} {X} x}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma *-upper \\\\hlevels  {x y : Real} (_ : zro <= x) (_ : zro <= y) : x RealField.* y = x ExUpperReal.* y ', '| ide : E', '\\\\lemma *-cover \\\\hlevels  : CoverMap (ProductCoverSpace RealNormed RealNormed) RealNormed {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 * s.2\\n} ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma ide-right \\\\plevels  \\\\hlevels  {x : ExUpperReal} (_ : zro <= x) : x * fromRat ide = x ', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| norm E : ExUpperReal', '| norm-bounded (x : E) : IsBounded {norm x}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : CoverSpace} (g : CoverMap Y Z) (f : CoverMap X Y) : CoverMap X Z {\\n  | func => \\\\lam (x : E {Dom {g \u2218 f}}) => g.func (f.func x)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\func midSum \\\\hlevels  {A3 : AddMonoid} (_ : Series A.E) (_ _ : Nat) : A.E \\n  | {A}, S, 0, m => partialSum {A} S m\\n  | {A}, S, suc n, 0 => A.zro\\n  | {A}, S, suc n, suc m => midSum {A} (\\\\lam (j : Nat) => S (suc j)) n m', '\\\\func id \\\\hlevels  {X : CoverSpace} : CoverMap X X {\\n  | func => \\\\lam (x : E {Dom {id {X}}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\lemma *-rat \\\\plevels  \\\\hlevels  {x y : Rat} (_ : zro <= x) (_ : zro <= y) : fromRat x ExUpperReal.* fromRat y = fromRat (x RatField.* y) ', '\\\\infixl 7 * \\\\hlevels  (x y : Real) : Real => func {*-cover-def} (x, y)', '| U Rat : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\instance RealAbGroup \\\\hlevels  : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | meet => RealAbGroup.meet\\n  | join => RealAbGroup.join\\n} => \\\\new LinearlyOrderedAbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative-left => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>\\Pi {eps : Rat} -> zro < eps -> TruncP (\\Sigma (N : Nat) (\\Pi {n1 : Nat} ->\n  N <= n1 -> U {midSum {ExUpperRealAbMonoid} (\\lam (n1 : Nat) => X.norm (c n1) * fromRat (pow {RatField} a n1)) N n1} eps))", "completion": "upper-ratio-test (\\lam n => *_>=0) (rewrite (ide-right norm>=0) (norm-bounded (c 0))) (\\lam n => b n * a)\n  (\\lam n => <=_* (bp n) <=-refl <=\u2218 transport2 (<=) (inv *-assoc) (inv *-assoc)\n    (<=_* <=-refl $ transport2 (<=) (*-comm *> *-assoc *> pmap ((*) _) (*-comm *> *-rat (pow>=0 {RatField} a>=0) a>=0)) (inv *_join) $ <=_* join-left $ transport ((<=) _)\n      (inv (*-upper join-right (rat_real_<=.1 a>=0)) *> join_*-right {RealField} (rat_real_<=.1 a>=0) *> pmap ((\u2228) {RealAbGroup} _) (zro_*-left {RealField}) *> join-upper) $ <=_* (<=-upper.1 join-left) <=-refl))\n  la<1 (cont-limit bl $ *-cover \u2218 tuple id (const (fromRat a)))"}
{"prompt": "['n : Nat', 'R : CRing']<<<break>>>['\\\\instance MonoidAlgebra \\\\hlevels  (M : CMonoid) (R1 : CRing) : CAlgebra R1 (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | negative => negative {M.E} {R1}\\n  | *c => \\\\lam (x : E {R}) => (Semigroup.*) (func {monoidRingHom {M} {R1}} x)\\n  | * => (MonoidSemiring.*)\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | coefMap => coefMap-impl\\n} => homAlgebra {R1} {\\\\new CRing (MonoidSet M.E R1) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (MonoidSemiring.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => negative {M.E} {R1}\\n  | negative-left => {?hidden}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl {MonoidSemiring M R1}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}} (monoidRingHom {M} {R1})', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '\\\\instance PolyAlgebra \\\\hlevels  (R1 : CRing) : CAlgebra R1 (Poly R1) {\\n  | zro => pzero {R1}\\n  | + => (+)\\n  | negative => negative {R1}\\n  | *c => (*c)\\n  | * => (*)\\n  | ide => padd {R1} (pzero {R1}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R1} (pzero {R1}) (R.natCoef n)\\n  | coefMap => coefMap-impl\\n} => \\\\new CAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func monoidRingHom \\\\hlevels  {M : Monoid} {R : Ring} : RingHom R (MonoidRing M R) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => inMS~ {M.E} {R} ((a, M.ide) :: nil)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| Cod : BaseSet', '| R : Ring', '\\\\func coefMap-impl \\\\hlevels  {this : AAlgebra} (x : E {R}) : E => x *c ide', \"\\\\func + {M3 : \\\\Set} {R3 : AddMonoid} (_ _ : MonoidSet M3 R3) : MonoidSet M3 R3 \\n  | {M}, {R}, in~ l, in~ l' => in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l')\\n  | {M}, {R}, in~ l, ~-equiv l1 l2 r i =>\\n  monoidSet-ext {M} {R} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l1)} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l2)}\\n    (~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l ++ l1} {l1 ++ l}\\n      (~-perm {M} {R} {l ++ l1} {l1 ++ l} (eperm-++-comm {\\\\Sigma R.E M} {l} {l1})) *> ~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l1 ++ l} {l2 ++ l} (~_++-left {M} {R} {l1} {l2} {l} r) *> ~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l2 ++ l} {l ++ l2}\\n      (~-perm {M} {R} {l2 ++ l} {l ++ l2} (eperm-++-comm {\\\\Sigma R.E M} {l2} {l}))) @ i\\n  | {M}, {R}, ~-equiv l1 l2 r i, in~ l' =>\\n  monoidSet-ext {M} {R} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l1 ++ l')} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l2 ++ l')}\\n    (~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l1 ++ l'} {l2 ++ l'} (~_++-left {M} {R} {l1} {l2} {l'} r)) @ i\", '\\\\func homLModule \\\\hlevels  (f : RingHom) : LModule f.Dom (E {f.Cod}) {\\n  | zro => zro {f.Cod}\\n  | + => (+) {f.Cod}\\n  | negative => negative {f.Cod}\\n  | *c => \\\\lam (x : E {R {\\\\this}}) => (*) (f.func x)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '\\\\instance MonoidSemiring \\\\hlevels  (M : Monoid) (R : Semiring) : Semiring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl\\n} => \\\\new Semiring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '| \\\\infixl 7 * E E : E', '\\\\func natCoefImpl \\\\hlevels  {this2 : Semiring} (_ : Nat) : E \\n  | {this}, 0 => zro\\n  | {this}, suc n => natCoefImpl n + ide', '\\\\type MonoidSet \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : \\\\Set => Quotient {Array (\\\\Sigma R.E M)} (~)', '\\\\class CAlgebra \\\\extends AAlgebra, PseudoCAlgebra \\\\hlevels ', \"\\\\func negative {M2 : \\\\Set} {R2 : AddGroup} (_ : MonoidSet M2 R2) : MonoidSet M2 R2 \\n  | {M}, {R}, in~ l => in~ {Array (\\\\Sigma R.E M)} {(~)} (map {\\\\Sigma R.E M} {\\\\Sigma R.E M} (func {M} {R}) l)\\n  | {M}, {R}, ~-equiv l l' r i =>\\n  monoidSet-ext {M} {R} {in~ {Array (\\\\Sigma R.E M)} {(~)} (map {\\\\Sigma R.E M} {\\\\Sigma R.E M} (func {M} {R}) l)}\\n    {in~ {Array (\\\\Sigma R.E M)} {(~)} (map {\\\\Sigma R.E M} {\\\\Sigma R.E M} (func {M} {R}) l')}\\n    (toEquality {Array (\\\\Sigma R.E M)} {Quotient {Array (\\\\Sigma R.E M)} (~)} (inMS~ {M} {R}) {(~)}\\n      (~-pequiv {Array (\\\\Sigma R.E M)} {(~)}) {map {\\\\Sigma R.E M} {\\\\Sigma R.E M} (func {M} {R}) l}\\n      {map {\\\\Sigma R.E M} {\\\\Sigma R.E M} (func {M} {R}) l'}\\n      (~_negative {M} {R} {l} {l'} (cin {Array (\\\\Sigma R.E M)} {(~)} {l} {l'} r))) @ i\", \"\\\\func * {M3 : Monoid} {R3 : Semiring} (_ _ : MonoidSet M.E R3) : MonoidSet M.E R3 \\n  | {M}, {R}, in~ l, in~ l' =>\\n    in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l')\\n  | {M}, {R}, in~ l, ~-equiv l1 l2 r i => monoidSet-ext {M.E} {R}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l1)}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l2)}\\n    (toEquality {Array (\\\\Sigma R.E M.E)} {Quotient {Array (\\\\Sigma R.E M.E)} (~)} (inMS~ {M.E} {R}) {(~)}\\n      (~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)}) {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l1}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l2} (*-coh-right {M} {R} {l} {l1} {l2} r)) @ i\\n  | {M}, {R}, ~-equiv l1 l2 r i, in~ l => monoidSet-ext {M.E} {R}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l1 l)}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l2 l)}\\n    (~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)} {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l1 l}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (\\\\lam (b : \\\\Sigma R.E M.E) (a : \\\\Sigma R.E M.E) => func {M} {R} a b) l\\n        l1}\\n      (~-perm {M.E} {R} {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l1 l}\\n        {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (\\\\lam (b : \\\\Sigma R.E M.E) (a : \\\\Sigma R.E M.E) => func {M} {R} a b) l\\n          l1} (pairs-flip {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {func {M} {R}} {l1} {l})) *> toEquality {Array (\\\\Sigma R.E M.E)} {Quotient {Array (\\\\Sigma R.E M.E)} (~)} (inMS~ {M.E} {R}) {(~)}\\n      (~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)})\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l1}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l2}\\n      (*-coh-right {Monoid.op {M}} {Semiring.op {R}} {l} {l1} {l2} r) *> ~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l2}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l2 l}\\n      (~-perm {M.E} {R} {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l2}\\n        {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l2 l}\\n        (pairs-flip {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {func {Monoid.op {M}} {Semiring.op {R}}} {l} {l2}))) @ i\", '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', 'in~ A']<<<break>>>CAlgebra (PolyAlgebra R1) (MonoidSet (E {PermSetMonoid (Fin n)}) (PolyAlgebra R1)) {\n  | zro => in~ {Array (\\Sigma (E {PolyAlgebra R1}) (E {PermSetMonoid (Fin n)}))} {(~)} nil\n  | + => (+)\n  | negative => negative {E {PermSetMonoid (Fin n)}} {PolyAlgebra R1}\n  | *c => \\lam (x : E {R}) => (Semigroup.*) (func {monoidRingHom {PermSetMonoid (Fin n)} {PolyAlgebra R1}} x)\n  | * => (MonoidSemiring.*)\n  | ide => in~ {Array (\\Sigma (E {PolyAlgebra R1}) (E {PermSetMonoid (Fin n)}))} {(~)}\n    ((ide {PolyAlgebra R1}, ide {PermSetMonoid (Fin n)}) :: nil)\n  | natCoef => natCoefImpl {MonoidSemiring (PermSetMonoid (Fin n)) (PolyAlgebra R1)}\n  | coefMap => coefMap-impl\n}", "completion": "MonoidAlgebra _ _"}
{"prompt": "['t : \\\\Sigma (j : Fin l.len) (at {keep {A} {P} D l} i = l.at j)', 'a : A', 'p : \\\\Pi {i j : Fin (suc l.len)} -> at {a :: l} i = at {a :: l} j -> i = j', 'P : A -> \\\\Prop', 'D : \\\\Pi (a : A) -> Dec (P a)', 'i : Fin (len {keep {A} {P} D l})', 'l : Array A n', 'q : (\\\\case yes {P a} p \\\\with {\\n  | yes p => a :: keep {A} {P} D l\\n  | no n => keep {A} {P} D l\\n}) !! suc i = (\\\\case yes {P a} p \\\\with {\\n| yes p => a :: keep {A} {P} D l\\n| no n => keep {A} {P} D l\\n}) !! 0', 'A : \\\\Type', 'n : Nat']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func keep {A2 : \\\\Type} {P1 : A2 -> \\\\Prop} (_ : \\\\Pi (a : A2) -> Dec (P1 a)) (_ : Array A2) : Array A2 \\n  | {A}, {P}, D, nil => nil\\n  | {A}, {P}, D, :: {n} a l => \\\\case D a \\\\with {\\n    | yes p => a :: keep {A} {P} D l\\n    | no n => keep {A} {P} D l\\n  }', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>suc t.1 = 0", "completion": "p {suc t.1} {0} (inv t.2 *> q)"}
{"prompt": "['this : RealBanachSpace', 'a : E']<<<break>>>['\\\\func const \\\\hlevels  {Y X : CoverSpace} (x : X.E) : CoverMap Y X {\\n  | func => \\\\lam (_ : E {Dom {const {Y} {X} x}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\func id \\\\hlevels  {X : CoverSpace} : CoverMap X X {\\n  | func => \\\\lam (x : E {Dom {id {X}}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '\\\\func tuple \\\\hlevels  {X Y Z : CoverSpace} (f : CoverMap Z X) (g : CoverMap Z Y) : CoverMap Z (X \u2a2f Y) {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (f.func z, g.func z)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\class CoverMap \\\\extends PrecoverMap, StronglyCauchyMap \\\\hlevels  {\\n  | func-weak-cauchy => \\\\lam (F1 : WeaklyCauchyFilter Dom) =>\\n  \\\\new WeaklyCauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n    | filter-mono => {?hidden}\\n    | filter-top => {?hidden}\\n    | filter-meet => {?hidden}\\n    | isWeaklyProper => {?hidden}\\n    | isCauchyFilter => {?hidden}\\n  }\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>CoverMap RealNormed (RealNormed \u2a2f this1) {\n  | func => \\lam (z : E {Dom {\\this}}) => (func {id {RealNormed}} z, func {const {RealNormed} a} z)\n}", "completion": "tuple id (const a)"}
{"prompt": "['a : E', 'p : \\\\Pi (j : Fin (suc l.len)) -> x <= at {a :: l} j', 'l : Array E n', 'x : E', 'this : TopMeetSemilattice', 'n : Nat']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', '| at (j : Fin len) : A j', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set']<<<break>>>x <= at {a :: l} 0", "completion": "p 0"}
{"prompt": "['J : \\\\Set', 'x : C.Ob', 'C : SiteWithBasis', 'Z : Ob', 'F : Functor (op {C}) SetCat', 'g : J -> Ob', 'this : QEquiv {Z -> sheafOnSiteWithBasis.MatchingFamily {C1} {{?error}} x1 {J} g1}\\n  {vsheafOnSiteWithBasis.MatchingFamily {C1} {SetCat} {F} x1 {J} g1 Z}\\n  (\\\\lam (g2 : A {\\\\this}) => \\\\new vsheafOnSiteWithBasis.MatchingFamily {C1} {SetCat} {F} x1 {J} g1 Z {\\n    | family => \\\\lam (j : vsheafOnSiteWithBasis.MatchingFamily.J {\\\\this}) (z : z {\\\\this}) =>\\n      sheafOnSiteWithBasis.MatchingFamily.family {g2 z} j\\n    | isMatching => {?hidden}\\n  }) {\\n  | ret => \\\\lam (mf : B {\\\\this}) (z : Z) => \\\\new sheafOnSiteWithBasis.MatchingFamily {C1} {{?error}} x1 {J} g1 {\\n    | family => \\\\lam (j : sheafOnSiteWithBasis.MatchingFamily.J {\\\\this}) => mf.family j z\\n    | isMatching => {?hidden}\\n  }\\n  | ret_f => idpe {Z -> sheafOnSiteWithBasis.MatchingFamily {C1} {{?error}} x1 {J} g1}\\n  | f_sec => idpe {vsheafOnSiteWithBasis.MatchingFamily {C1} {SetCat} {F} x1 {J} g1 Z}\\n}']<<<break>>>[\"\\\\class MatchingFamily \\\\hlevels  {\\n  | C : SiteWithBasis\\n  | D : Cat\\n  | F : Functor (op {C}) D\\n  | x : Ob {C}\\n  | J : \\\\Set\\n  | g J : Ob\\n  | z : Ob {D}\\n  | family (j : J) : Hom {D} z (Functor.F {vsheafOnSiteWithBasis.MatchingFamily.F} (g j).1)\\n  | isMatching (j j' : J) : Func {vsheafOnSiteWithBasis.MatchingFamily.F} {(g j).1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n    (pbProj1 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) \u2218 family j = Func {vsheafOnSiteWithBasis.MatchingFamily.F} {(g j').1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n    (pbProj2 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) \u2218 family j'\\n}\", '| A : \\\\Type', '| Hom Ob Ob : \\\\Set', '| pullback {x y z : Ob} (f : Hom x z) (g : Hom y z) : Pullback {x} {y} {z} f g', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| family (j : J) : Functor.F {sheafOnSiteWithBasis.MatchingFamily.F} (g j).1', '| F (Ob {C}) : Ob {D}', '| apex : Ob {D}', \"| isMatching (j j' : J) : Func {sheafOnSiteWithBasis.MatchingFamily.F} {(g j).1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n  (pbProj1 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) (family j) = Func {sheafOnSiteWithBasis.MatchingFamily.F} {(g j').1} {apex {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}}\\n  (pbProj2 {pullback {C} {(g j).1} {(g j').1} {x} (g j).2 (g j').2}) (family j')\", '| F : Functor (op {C}) D', '| J : \\\\Set', '| z : Ob {D}', '| C : SiteWithBasis', '| g J : Ob', '| x : Ob {C}', '| D : Cat']<<<break>>>\\Pi (g2 : A {\\this}) -> MatchingFamily {C1} {SetCat} {F} x1 {J1} g1 Z {\n  | family => \\lam (j : J {\\this}) (z : z {\\this}) => family {g2 z} j\n  | isMatching => {?hidden}\n}", "completion": "\\lam g => \\new MatchingFamily {\n  | family => \\lam j z => family {g z} j\n  | isMatching => \\lam j j' => ext (\\lam z => isMatching j j')\n}"}
{"prompt": "['q : Rat', 'xa : OBall (eps * ratio (pos 1) 4) x a', 'x : E', '|x|<q : U {norm x} q', 'this : StoneC*Algebra', 'a : E', 'eps : E']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', '| dist E E : ExUpperReal', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '| dist-symm {x y : E} : dist x y = dist y x', 'pos Nat', '\\\\lemma <_<= \\\\plevels  \\\\hlevels  {x : ExUpperReal} {q : Rat} (_ : x.U q) : x <= fromRat q ', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>norm x + dist a x <= fromRat q + fromRat (eps * ratio (pos 1) 4)", "completion": "<=_+ {ExUpperRealAbMonoid} (<_<= |x|<q) (rewrite (dist-symm {this}) $ <_<= xa)"}
{"prompt": "['f : \\\\Pi {U : Set S.E} -> C U -> TruncP (\\\\Sigma (V1 : Set (StronglyRegularCauchyFilter S))\\n  (\\\\Sigma (e : E) ((\u2227) (single {StronglyRegularCauchyFilter S} F) V1 e) -> V1 \u2286 V) (mkSet {S} U \u2286 V1))', 'F : StronglyRegularCauchyFilter S', 'V : Set (StronglyRegularCauchyFilter S)', 'CU : C U', 'S : StronglyRegularCoverSpace', 'U : Set S.E']<<<break>>>['\\\\func mkSet \\\\hlevels  {X : StronglyRegularCoverSpace} (U : Set X.E) : Set (StronglyRegularCauchyFilter X) \\n  => \\\\lam (F1 : StronglyRegularCauchyFilter X) => F.F U', '\\\\func coverSpace \\\\hlevels  {X1 : StronglyRegularCoverSpace} : StronglyRegularCoverSpace (StronglyRegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => isCCauchy {X1}\\n} => \\\\new StronglyRegularCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isStronglyRegular => {?hidden}\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\class StronglyRegularCauchyFilter \\\\extends WeaklyCauchyFilter \\\\hlevels  {\\n  | isStronglyRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V s<=< U) (F V))\\n}']<<<break>>>TruncP (\\Sigma (V1 : Set (StronglyRegularCauchyFilter S))\n  (\\Sigma (e : E) ((\u2227) (single {StronglyRegularCauchyFilter S} F) V1 e) -> V1 \u2286 V) (mkSet {S} U \u2286 V1))", "completion": "f CU"}
{"prompt": "['x : X.E', 'W : Set (\\\\Sigma X.E Y.E)', 'X : CoverSpace', 'y : Y.E', 'Y : CoverSpace']<<<break>>>['\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\lemma cauchy-subset \\\\hlevels  {X : PrecoverSpace} {C D : Set (Set X.E)} (_ : X.isCauchy C) (_ : \\\\Pi {U : Set X.E} -> C U -> D U) : X.isCauchy D ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\lemma prodCover \\\\hlevels  {X Y : CoverSpace} {C : Set (Set X.E)} (_ : X.isCauchy C) {D : Set (Set Y.E)} (_ : Y.isCauchy D) :\\nisCauchy {X \u2a2f Y} (\\\\lam (W : Set (E {X \u2a2f Y})) =>\\n  TruncP (\\\\Sigma (U : Set X.E) (C U) (V : Set Y.E) (D V) (W = (\\\\lam (s : \\\\Sigma X.E Y.E) => \\\\Sigma (U s.1) (V s.2))))) ']<<<break>>>TruncP (\\Sigma (U : Set X.E) (V : Set Y.E) (single {X.E} x <=< U) (single {Y.E} y <=< V)\n  (\\Pi {x : X.E} -> U x -> \\Pi {y : Y.E} -> V y -> W (x, y))) -> single {\\Sigma X.E Y.E} (x, y) <=< W", "completion": "\\lam p0 => (\\case \\elim p0 \\with {\n  | inP (U, V, x<=<U, y<=<V, h) => cauchy-subset\n    {X \u2a2f Y} (prodCover (unfolds in x<=<U) (unfolds in y<=<V)) (\\lam {p0} p1 => (\\case \\elim p0, \\elim p1 \\with {\n      | _, inP (U', Ug, V', Vg, idp) =>\n        later (\\lam s {z} t => h (Ug (s.1.1, (pmap (\\lam p0 => p0.1) s.2.1, s.2.2.1)) t.1) (Vg (s.1.2, (pmap (\\lam p0 => p0.2) s.2.1, s.2.2.2)) t.2))\n    }))\n})"}
{"prompt": "['M : UniformLocale', 'S : Opens (CompletionPres M)', 'f : UniformHom M L', 'L : UniformLocale', 'q : \\\\Sigma (j : \\\\Sigma (x : M.E) (S.1 x)) (x : L.E) ((func {presentation {L} {M} f} j.1).1 x)']<<<break>>>['\\\\lemma <=u_<= \\\\hlevels  {L : PreuniformLocale} {a b : L.E} (_ : a <=u b) : a L.<= b ', '\\\\func presentation {L : UniformLocale} : FramePresHom (CompletionPres L) (F L) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new FramePresHom {\\n  | func-conj => {?hidden}\\n  | func-basicCover => {?hidden}\\n  | func-image => {?hidden}\\n}', '| func-<= {x y : E {Dom}} (x <= y) : func x <= func y', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\func \\\\infix 4 <=u \\\\hlevels  {L : PreuniformLocale} (a b : L.E) : \\\\Prop => TruncP (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U) (star {L} a U L.<= b))']<<<break>>>L.Join {\\Sigma (b : M.E) (b <=u q.1.1)} (\\lam (j : \\Sigma (b : M.E) (b <=u q.1.1)) => func {presentation {L}} (f.func j.1)) L.<= L.Join {\\Sigma (x : M.E) (S.1 x)} (\\lam (j : \\Sigma (x : M.E) (S.1 x)) => f.func (func {presentation {M}} j.1))", "completion": "Join-univ (\\lam r => func-<= {f} (<=u_<= r.2) <=\u2218 Join-cond q.1)"}
{"prompt": "['x : X.E', 'X : TopAbGroup', 'y : X.E']<<<break>>>['+-cover \\\\hlevels  {X : TopAbGroup} : CoverMap (UniformCompletion X \u2a2f UniformCompletion X) (Completion X) \\n=> subtract-cover {X} \u2218 prod {UniformCompletion X} {UniformCompletion X} {UniformCompletion X} {Completion X} (id {UniformCompletion X})\\n  (negative-cover {X})', '| \\\\infixl 6 + E E : E', '\\\\func id \\\\hlevels  {X : CoverSpace} : CoverMap X X {\\n  | func => \\\\lam (x : E {Dom {id {X}}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', \"\\\\func prod \\\\hlevels  {X Y X' Y' : CoverSpace} (f : CoverMap X Y) (g : CoverMap X' Y') : CoverMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} z, func {g \u2218 proj2 {X} {X'}} z)\\n} => tuple {Y} {Y'} {X \u2a2f X'} (f \u2218 proj1 {X} {X'}) (g \u2218 proj2 {X} {X'})\", '\\\\lemma negative-uniform \\\\hlevels  {X : TopAbGroup} : TopAbGroupMap X X {\\n  | func => X.negative\\n} ', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\lemma +-char \\\\hlevels  {X : TopAbGroup} {x y : X.E} : func {+-cover {X}} (pointCF {X} x, pointCF {X} y) = pointCF {X} (x X.+ y) ', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '\\\\instance UniformCompletion \\\\hlevels  (X1 : UniformSpace) : CompleteUniformSpace (RegularCauchyFilter X1) {\\n  | isOpen => isOpen {coverSpace {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set (E {\\\\this}))) => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C)\\n    (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (D V) (mkSet {X1} U \u2286 V))))\\n} => \\\\new CompleteUniformSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cover => {?hidden}\\n  | uniform-top => {?hidden}\\n  | uniform-refine => {?hidden}\\n  | uniform-inter => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | uniform-star => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set']<<<break>>>func {+-cover {X}} (pointCF {X} (func {prod {X} {X} {X} {X} (id {X}) (negative-uniform {X})} (x, y)).1,\n  pointCF {X} (func {prod {X} {X} {X} {X} (id {X}) (negative-uniform {X})} (x, y)).2) = pointCF {X}\n  ((func {prod {X} {X} {X} {X} (id {X}) (negative-uniform {X})} (x, y)).1 X.+ (func {prod {X} {X} {X} {X} (id {X}) (negative-uniform {X})} (x, y)).2)", "completion": "+-char {X}"}
{"prompt": "['g : \\\\Pi {n : I.E} -> N I.<= n -> a (f n)', 'X : RegularPreuniformSpace', 'N<=L : N I.<= L', 'h : \\\\Pi {n : I.E} -> M I.<= n -> b (f n)', 'I : DirectedSet', 'b : E {A {\\\\this}}', 'N : I.E', 'f : I.E -> X.E', 'M : I.E', 'L : I.E', 'a : E {A {\\\\this}}', 'M<=L : M I.<= L']<<<break>>>['| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>\\Pi {n : I.E} -> L I.<= n -> (\u2227) a b (f n)", "completion": "\\lam L<=n => (g $ N<=L <=\u2218 L<=n, h $ M<=L <=\u2218 L<=n)"}
{"prompt": "['t : SType {R} (positiveSubset R)', 's : SType {R} (positiveSubset R)', 'p : join {R} (in~ {SType {R} (positiveSubset R)}\\n  {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} s)\\n  (in~ {SType {R} (positiveSubset R)}\\n    {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} t) < in~ {SType {R} (positiveSubset R)}\\n  {\\\\lam (a : SType {R} (positiveSubset R)) (b : SType {R} (positiveSubset R)) => a.1 R.* b.2 = b.1 R.* a.2} t', 'R : OrderedCRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '| isPos E : \\\\Prop', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| rdistr {x y z : E} : (x + y) * z = x * z + y * z', '| E : \\\\Set', '| negative E : E', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| *-assoc {x y z : E} : x * y * z = x * (y * z)']<<<break>>>R.isPos ((t.1 R.* s.2 R.+ R.negative (s.1 R.* t.2 R.\u2228 t.1 R.* s.2)) R.* t.2)", "completion": "rewrite (inv rdistr) (rewrite (inv *-assoc) (unfolds p))"}
{"prompt": "['x : Real', 'null : x - z1 < eps * fromRat (ratio (pos 1) 4)', 'eps : Real', 'z1 : Real', 'y : Real', 'null : z1 = z2', 'z2 : Real', 'null : z2 - y < eps * fromRat (ratio (pos 1) 4)']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', 'LessOrEquals', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatAlgebraData {RealField} (eps :: x :: zro :: zro :: zro :: zro :: z1 :: z2 :: y :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 9} 1 :+ :negative {E} {Fin 9} (var {E} {Fin 9} 8)) < interpret {\\new LinearRatAlgebraData {RealField} (eps :: x :: zro :: zro :: zro :: zro :: z1 :: z2 :: y :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 9} 0 :* coef {E} {Fin 9} (rat (pos 1) 2 {?hidden} {?hidden}))", "completion": "solve<Problem {\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => eps :: x :: zro :: zro :: zro :: zro :: z1 :: z2 :: y :: nil\n}}\n  ((var 1 :+ :negative (var 6), Less, var 0 :* coef (rat (pos 1) 4 {?hidden} {?hidden})) :: (var 7 :+ :negative (var 8), Less, var 0 :* coef (rat (pos 1) 4 {?hidden} {?hidden})) :: (var 6, LessOrEquals, var 7) :: nil)\n  (var 1 :+ :negative (var 8)) (var 0 :* coef (rat (pos 1) 2 {?hidden} {?hidden}))\n  (4 :: 4 :: 4 :: 4 :: nil, 0, idp, idp {Bool} {true}) (_x :: _x :: =_<= p :: nil)"}
{"prompt": "[\"xy<eps/4_x'y'<eps/4 : Prod {X.E} {X.E} (\\\\lam (y : X.E) => U {X.dist x y} (eps * ratio (pos 1) 4))\\n  (\\\\lam (y : X.E) => U {X.dist x' y} (eps * ratio (pos 1) 4)) p0\", 'eps : Rat', 'X : ExPseudoMetricSpace', 'p0 : \\\\Sigma X.E X.E', 'x : X.E', \"x' : X.E\"]<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', '\\\\func ratio \\\\plevels  \\\\hlevels  (_ : Int) (_ : Nat) : Rat \\n  | nom, 0 => fromInt (pos 0)\\n  | nom, suc d => makeRat nom (suc d) (\\\\lam (p0 : suc d = 0) => (\\\\case p0 \\\\with {}))', '| dist E E : ExUpperReal', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| \\\\infixl 7 * E E : E', '\\\\lemma +-rat \\\\plevels  \\\\hlevels  {x y : Rat} : fromRat x ExUpperReal.+ fromRat y = fromRat (x RatField.+ y) ', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma <-rat \\\\plevels  \\\\hlevels  {x : ExUpperReal} {y : Rat} : x < fromRat y <-> x.U y ', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| dist-symm {x y : E} : dist x y = dist y x', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\lemma <_+ \\\\plevels  \\\\hlevels  {x y x' y' : ExUpperReal} (_ : x < x') (_ : y < y') : x + y < x' + y' \", '| +-comm {x y : E} : x + y = y + x', '| dist-triang {x y z : E} : dist x z <= dist x y + dist y z', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>X.dist x p0.1 AddMonoid.+ X.dist p0.1 x' <= X.dist p0.1 p0.2 AddMonoid.+ fromRat (eps * ratio (pos 1) 4 RatField.+ eps * ratio (pos 1) 4)", "completion": "transport (\\lam _x => _x <= _) +-comm (<=_+ (dist-triang {X}) <=-refl <=\u2218 transportInv (\\lam _x => _x <= _) +-assoc\n  (<=_+ <=-refl $ transport ((<=) _) +-rat $ <=-less $ <_+ (transport (\\lam _x => _x < _) dist-symm $ <-rat.2 x'y'<eps/4) (<-rat.2 xy<eps/4)))"}
{"prompt": "['W : E {Cod {\\\\this}} -> \\\\Prop', \"U' : Set X.E\", 'Z : TopSpace', 'f : ContMap (X \u2a2f Y) Z', \"h : \\\\Pi {x : X.E} -> U' x -> \\\\Pi {y : Y.E} -> V' y -> W' (f.func (x, y))\", 'Y : TopSpace', 'X : TopSpace', \"g : \\\\Pi {y' : Z.E} -> W' y' -> W (defined {Z.E} y')\", \"V' : Set Y.E\"]<<<break>>>['| value isDefined : E', '\\\\lemma defined-ext \\\\hlevels  {X : \\\\Set} {u : Partial X} {x : X} (d : u.isDefined) (_ : u.value d = x) : u = defined {X} x ', '\\\\func plift2 \\\\hlevels  {X Y Z : \\\\Set} (f : X -> Y -> Z) (p : Partial X) (q : Partial Y) : Partial Z {\\n  | isDefined => \\\\Sigma p.isDefined q.isDefined\\n  | value => \\\\lam (d : isDefined {\\\\this}) => f (p.value d.1) (q.value d.2)\\n} => \\\\new Partial', '\\\\class Partial \\\\hlevels  {\\n  | E : \\\\Set\\n  | isDefined : \\\\Prop\\n  | value isDefined : E\\n}', '\\\\func defined \\\\hlevels  {X : \\\\Set} (x : X) : Partial X {\\n  | isDefined => \\\\Sigma\\n  | value => \\\\lam (_ : isDefined {\\\\this}) => x\\n} => \\\\new Partial', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| isDefined : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', \"\\\\instance PartialTopSpace \\\\hlevels  (Y : TopSpace) : TopSpace (Partial Y.E) {\\n  | isOpen => \\\\lam (U : Set (E {\\\\this})) => \\\\Pi {y : Partial Y.E} ->\\n    U y -> (U = top) || (\\\\Sigma (U' : Set Y.E) (Y.isOpen U') (p : y.isDefined) (U' (y.value p)) (\\\\Pi {y' : Y.E} -> U' y' -> U (defined {Y.E} y')))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}\"]<<<break>>>\\Pi {x : E} -> \\Sigma (d : x.isDefined) (U' (x.value d)) -> \\Pi {y : E} ->\n  \\Sigma (d : y.isDefined) (V' (y.value d)) -> W (plift2 {X.E} {Y.E} {Z.E} (\\lam (x : X.E) (y : Y.E) => f.func (x, y)) x y)", "completion": "\\lam {x} d1 {y} d2 => transportInv W (defined-ext {_} {plift2 (\\lam x y => f (x, y)) x y} (d1.1, d2.1) idp) $ g $ h d1.2 d2.2"}
{"prompt": "['this : TotalOrder', 'z : E', 'y<=z : y <= z', 'y : E', 'x : E']<<<break>>>['| <=-refl {x : E} : x <= x', '| join-univ {x y z : E} (x <= z) (y <= z) : x \u2228 y <= z', '| \\\\infix 4 <= E E : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '| join-right {x y : E} : y <= x \u2228 y', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>x \u2227 (y \u2228 z) <= x \u2227 y \u2228 x \u2227 z", "completion": "meet-monotone {this} (<=-refl {this}) (join-univ {this} y<=z (<=-refl {this})) <=\u2218 {this} join-right {this}"}
{"prompt": "['this : SiteWithBasis', 'J : \\\\Set', 'x : Ob', 'y : Ob', 'h : Hom x y', 'g : J -> Ob', 'c : isBasicCover y {J} g']<<<break>>>['| isBasicCover (x : Ob) {J : \\\\Set} (J -> Ob) : \\\\Prop', '\\\\func pullbackFunctor \\\\plevels obj >= hom \\\\hlevels  {C1 : PrecatWithPullbacks} {x1 y1 : C.Ob} (f : C.Hom x1 y1) : Functor (SlicePrecat {C1} y1) (SlicePrecat {C1} x1)\\n  (\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) {\\n  | Func => \\\\lam {a : ObOver {C1} y1} {b : ObOver {C1} y1} (g : Hom a b) => (\\n    \\\\let p => C.pullback {x1} {a.1} {y1} f a.2\\n    \\\\in (pbMap {C.pullback {x1} {b.1} {y1} f b.2}\\n          {((\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) a).1} p.pbProj1\\n          (g.1 C.\u2218 p.pbProj2)\\n          (p.pbCoh *> pmap {C.Hom a.1 y1} {C.Hom p.apex y1} (\\\\lam (_x : C.Hom a.1 y1) => _x C.\u2218 p.pbProj2) {a.2} {b.2 C.\u2218 g.1}\\n            (inv {C.Hom a.1 y1} {b.2 C.\u2218 g.1} {a.2} g.2) *> C.o-assoc {((\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) a).1} {a.1} {b.1} {y1}\\n            {b.2} {g.1} {p.pbProj2}),\\n          pbBeta1 {C.pullback {x1} {b.1} {y1} f b.2}\\n            {((\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) a).1} {p.pbProj1}\\n            {g.1 C.\u2218 p.pbProj2}\\n            {p.pbCoh *> pmap {C.Hom a.1 y1} {C.Hom p.apex y1} (\\\\lam (_x : C.Hom a.1 y1) => _x C.\u2218 p.pbProj2) {a.2} {b.2 C.\u2218 g.1}\\n              (inv {C.Hom a.1 y1} {b.2 C.\u2218 g.1} {a.2} g.2) *> C.o-assoc {((\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) a).1} {a.1} {b.1} {y1}\\n              {b.2} {g.1} {p.pbProj2}}))\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}', '| basicCover-stable {x y : Ob} (f : Hom x y) {J : \\\\Set} {g : J -> Ob} (isBasicCover y {J} g) : isBasicCover x {J} (\\\\lam (j : J) => F (g j))']<<<break>>>isBasicCover x {J} (\\lam (j : J) => F (g j))", "completion": "basicCover-stable {this} h c"}
{"prompt": "['this : ExPseudoNormedAbGroup', 'y : E', 'p0 : \\\\Sigma E E', 'eps : Rat', \"xx'<eps/2_yy'<eps/2 : Prod {E} {E} (\\\\lam (y : E) => U {dist x y} (half eps)) (\\\\lam (y1 : E) => U {dist y y1} (half eps)) p0\"]<<<break>>>['| norm E : ExUpperReal', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| U Rat : \\\\Prop', '| dist E E : ExUpperReal', '\\\\func half \\\\plevels  \\\\hlevels  (a : Rat) : Rat => a * ratio (pos 1) 2', '| norm-dist {x y : E} : dist x y = norm (x - y)']<<<break>>>U {norm (y - p0.2)} (half eps)", "completion": "rewrite (norm-dist {this}) yy'<eps/2"}
{"prompt": "[\"V'' : Set X.E\", \"U' : E {A {\\\\this}}\", 'U : E {A {\\\\this}}', 'X : PrecoverSpace']<<<break>>>['\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func Compl \\\\hlevels  {X : \\\\hType} (U : Set X) : Set X => \\\\lam (x : X) => Not (U x)']<<<break>>>Compl {X.E} U \u2227 V'' \u2286 Compl {X.E} (U \u2227 U')", "completion": "\\lam p0 p1 => (\n  \\let | (nUx, _) => p0\n       | (Ux, _) => p1\n  \\in nUx Ux)"}
{"prompt": "['x : E {\\\\this}', 'this : RealPreBanachAlgebra E {\\n  | isOpen => isOpen\\n  | isCauchy => isCauchy\\n  | cauchy-open => {?hidden}\\n  | isUniform => isUniform\\n  | uniform-cauchy => {?hidden}\\n  | dist => ExPseudoNormedAbGroup.dist\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => negative\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm => OrderedC*Algebra.toBanach.norm\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | norm-double => {?hidden}\\n  | * => (Semigroup.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | norm_*_<= => {?hidden}\\n  | ide => ide\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoef\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_ide_<= => {?hidden}\\n}']<<<break>>>['\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"| U-closed {q q' : Rat} (U q) (q < q') : U q'\", '| U Rat : \\\\Prop', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| negative E : E', '| norm E : ExUpperReal', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>\\Pi {q q' : Rat} -> U {norm {\\this} (negative {\\this} x)} q -> q < q' -> U {norm {\\this} (negative {\\this} x)} q'", "completion": "U-closed {norm (negative x)}"}
{"prompt": "['x : E {\\\\this}', 'p0 : x.isDefined', 'this : AddMonoid (Partial X.E) {\\n  | zro => defined {X.E} X.zro\\n  | + => plift2 {X.E} {X.E} {X.E} (X.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n}']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| isDefined : \\\\Prop']<<<break>>>isDefined {zro {\\this} + x}", "completion": "((), p0)"}
{"prompt": "['X : UniformSpace', 'f : \\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set E) (E1 V) (mkSet {X} U \u2286 V))', 'C : Set (Set X.E)', 'E : Set (Set (E {Cod {\\\\this}}))', 'Cu : X.isUniform C']<<<break>>>['| <=<-right {U V W : E {A}} (U <= V) (R V W) : R U W', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func mkSet \\\\hlevels  {X : CoverSpace} (U : Set X.E) : Set (RegularCauchyFilter X) => \\\\lam (F1 : RegularCauchyFilter X) => F.F U', '| uniform-refine {C D : Set (Set E)} (isUniform C) (Refines {E} C D) : isUniform D', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '\\\\lemma <=<-regular \\\\hlevels  {this : UniformSpace} {C : Set (Set E)} (_ : isUniform C) :\\n  isUniform (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U))) ', 'inP A', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\instance UniformCompletion \\\\hlevels  (X1 : UniformSpace) : CompleteUniformSpace (RegularCauchyFilter X1) {\\n  | isOpen => isOpen {coverSpace {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set (E {\\\\this}))) => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C)\\n    (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (D V) (mkSet {X1} U \u2286 V))))\\n} => \\\\new CompleteUniformSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cover => {?hidden}\\n  | uniform-top => {?hidden}\\n  | uniform-refine => {?hidden}\\n  | uniform-inter => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | uniform-star => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '\\\\lemma single_<= \\\\hlevels  {X : \\\\Set} {a : X} {U : Set X} (_ : U a) : single {X} a \u2286 U ']<<<break>>>X.isUniform (\\lam (U : Set X.E) => TruncP (\\Sigma (V : Set (RegularCauchyFilter X)) (E1 V) (U = pointCF {X} ^-1 V)))", "completion": "uniform-refine (<=<-regular {X} Cu) (\\lam p0 => (\\case p0 \\with {\n  | inP (U', CU', U<=<U') => \\case f CU' \\with {\n    | inP (V, DV, p) => inP (pointCF ^-1 V, inP (V, DV, idp), \\lam Ux => p $ <=<-right (single_<= Ux) U<=<U')\n  }\n}))"}
{"prompt": "['d1 : LDiv x y', 'solver : SubstSolverModel E {\\n  | Term => MonoidSolverModel.Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => \\\\lam {n : Nat} (t : SolverModel.Term {\\\\this} n) => normalize-aux {n} t (nil {Fin n})\\n  | interpret => interpret\\n  | interpretNF => \\\\lam {n : Nat} => interpretNF {Fin n}\\n  | nfVar => \\\\lam {n : Nat} (v : Fin n) => v :: nil {Fin n}\\n  | >>= => \\\\lam {m : Nat} {n : Nat} => (>>=)\\n}', 'this : UnitlessMonoid', 'env : Array E 3', 'd1=ide : val {lmake {d1.inv} d2.inv (cancel_*-left y {d2.inv * d1.inv} {ide} (\\n  \\\\let | solver => MonoidSolverModel this\\n       | env => y :: d2.inv :: d1.inv :: x :: nil\\n  \\\\in terms-equality {solver} env (var {env.len} 0 :* (var {env.len} 1 :* var {env.len} 2)) (var {env.len} 0 :* :ide {4})\\n        (apply-axiom {solver} env (var {env.len} 0 :* var {env.len} 1) (var {env.len} 3) d2.inv-right (0 :: 3 :: nil {Fin 5}) *> terms-equality-conv {solver} env (var {env.len} 3 :* var {env.len} 2) (var {env.len} 0) d1.inv-right)))} = ide']<<<break>>>['| M : \\\\Set', '| interpret {n : Nat} (Fin n -> M) (Term n) : M', ':ide', 'suc Nat', '| interpretNF {n : Nat} (Fin n -> M) (NF n) : M', 'nil', '| \\\\infixl 2 >>= {m n : Nat} (NF m) (Fin m -> NF n) : NF n', '| inv-right : val * inv = elem', '\\\\infixl 7 :* (_ _ : Term n)', '| nfVar {n : Nat} (Fin n) : NF n', '| at (j : Fin len) : A j', '\\\\lemma terms-equality \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s)) :\\n  interpret {env.len} env.at t = interpret {env.len} env.at s ', '| normalize {n : Nat} (Term n) : NF n', '| E : \\\\Set', 'var (Fin n)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func fcase {A : \\\\Type} {n : Nat} (_ : A) (_ : Fin n -> A) (_ : Fin (suc n)) : A \\n  | {A}, {n}, a, f, zero => a\\n  | {A}, {n}, a, f, suc j => f j', '| ide : E', '| inv : E {M}', '| NF Nat : \\\\Set', '\\\\lemma terms-equality-conv \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpret {env.len} env.at t = interpret {env.len} env.at s) :\\n  interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s) ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma apply-axiom \\\\hlevels  {this : SubstSolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpret {env.len} env.at t = interpret {env.len} env.at s) (pattern : NF (suc env.len)) :\\n  interpretNF {env.len} env.at (pattern >>= fcase {NF env.len} {env.len} (normalize {env.len} t) (nfVar {env.len})) = interpretNF {env.len} env.at (pattern >>= fcase {NF env.len} {env.len} (normalize {env.len} s) (nfVar {env.len})) ', '\\\\infixr 5 :: A (List A)']<<<break>>>solver.interpret {env.len} env.at (var {env.len} 0) = solver.interpret {env.len} env.at (var {env.len} 1)", "completion": "terms-equality {solver} env (var 0) (var 1)\n  (apply-axiom {solver} env :ide (var 2) (Paths.inv {E} {d1.inv} {ide} d1=ide) (1 :: 0 :: nil) *> terms-equality-conv {solver} env (var 0 :* var 2) (var 1) d1.inv-right)"}
{"prompt": "['DV : D V', 'D : Set (Set (E {\\\\this}))', 'L : Locale', 'V : Set (E {\\\\this})']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)']<<<break>>>(\\lam (s : \\Sigma (s : Set (CompleteFilter L)) (D s)) => points_* {L} s.1) (V, DV) <= Join {L} {\\Sigma (s : Set (CompleteFilter L)) (D s)}\n  (\\lam (s : \\Sigma (s : Set (CompleteFilter L)) (D s)) => points_* {L} s.1)", "completion": "Join-cond (later (V, DV))"}
{"prompt": "['r : GroupTerm V', 'fstLeafToRemoveInd : Nat', 'l : GroupTerm V', 'nf-pf : isInNF (l :* r)', 'this : NatData']<<<break>>>[\"\\\\func rp-preserves-nf \\\\hlevels  {this2 : NatData} (t1 : GroupTerm V) (_ : isInNF t1) (fstLeafToRemoveInd2 : Nat) :\\n  isInNF (remove-pair t1 fstLeafToRemoveInd2).1 \\n  | {this}, l :* r, nf-pf, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | greater _x => \\\\case (remove-pair r (fstLeafToRemoveInd -' count-leaves l)).2 \\\\with {\\n      | true => nf-pf.1\\n      | false => (nf-pf.1, rp-preserves-nf r nf-pf.2 (fstLeafToRemoveInd -' count-leaves l))\\n    }\\n    | less _x => \\\\case (remove-pair l fstLeafToRemoveInd).2 \\\\with {\\n      | true => nf-pf.2\\n      | false => (rp-preserves-nf l nf-pf.1 fstLeafToRemoveInd, nf-pf.2)\\n    }\\n    | equals p => \\\\case (remove-pair l fstLeafToRemoveInd).2, (remove-pair r 0).2 \\\\with {\\n      | true, true => ()\\n      | true, false => rp-preserves-nf r nf-pf.2 0\\n      | false, true => rp-preserves-nf l nf-pf.1 fstLeafToRemoveInd\\n      | false, false => (rp-preserves-nf l nf-pf.1 fstLeafToRemoveInd, rp-preserves-nf r nf-pf.2 0)\\n    }\\n  }\\n  | {this}, var v, nf-pf, fstLeafToRemoveInd => ()\\n  | {this}, :ide, nf-pf, fstLeafToRemoveInd => ()\\n  | {this}, :inv t, nf-pf, fstLeafToRemoveInd => \\\\case t, nf-pf \\\\with {\\n    | var v, nf-pf => ()\\n  }\", '\\\\func count-leaves \\\\hlevels  {this1 : NatData} (_ : GroupTerm V) : Nat \\n  | {this}, l :* r => count-leaves l + count-leaves r\\n  | {this}, :inv (var x) => 1\\n  | {this}, :inv g => 0\\n  | {this}, var x => 1\\n  | {this}, t => 0', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", \"\\\\func remove-pair \\\\hlevels  {this5 : NatData} (_ : GroupTerm V) (_ : Nat) : \\\\Sigma (GroupTerm V) Bool \\n  | {this}, l :* r, fstLeafToRemoveInd => \\\\case trichotomy fstLeafToRemoveInd (count-leaves l) \\\\with {\\n    | less _x => \\n      \\\\let res-l => remove-pair l fstLeafToRemoveInd\\n      \\\\in \\\\case res-l.2 \\\\with {\\n            | true => (r, false)\\n            | false => (res-l.1 :* r, false)\\n          }\\n    | equals p => \\n      \\\\let | res-l => remove-pair l fstLeafToRemoveInd\\n           | res-r => remove-pair r 0\\n      \\\\in \\\\case res-l.2, res-r.2 \\\\with {\\n            | true, true => (:ide {Nat}, true)\\n            | true, false => res-r\\n            | false, true => res-l\\n            | false, false => (res-l.1 :* res-r.1, false)\\n          }\\n    | greater _x => \\n      \\\\let res-r => remove-pair r (fstLeafToRemoveInd -' count-leaves l)\\n      \\\\in \\\\case res-r.2 \\\\with {\\n            | true => (l, false)\\n            | false => (l :* res-r.1, false)\\n          }\\n  }\\n  | {this}, :inv (var x), fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :inv g, fstLeafToRemoveInd => (:inv {V} g, false)\\n  | {this}, var x, fstLeafToRemoveInd => (:ide {Nat}, true)\\n  | {this}, :ide, fstLeafToRemoveInd => (:ide {Nat}, false)\", '\\\\func isInNF \\\\hlevels  {this2 : NatData} (_ : GroupTerm V) : \\\\Prop \\n  | {this}, l :* r => \\\\Sigma (isInNF l) (isInNF r)\\n  | {this}, var v => \\\\Sigma\\n  | {this}, :ide => \\\\Sigma\\n  | {this}, :inv t => \\\\case t \\\\with {\\n    | var v => \\\\Sigma\\n    | :ide => Empty\\n    | :inv g => Empty\\n    | t :* s => Empty\\n  }']<<<break>>>isInNF (remove-pair r (fstLeafToRemoveInd -' count-leaves l)).1", "completion": "rp-preserves-nf r nf-pf.2 (fstLeafToRemoveInd -' count-leaves {this} l)"}
{"prompt": "['this : Coreflection']<<<break>>>[\"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\class Precat \\\\plevels obj >= hom \\\\hlevels  {\\n  | Ob : \\\\hType\\n  | Hom Ob Ob : \\\\Set\\n  | id (X : Ob) : Hom X X\\n  | \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z\\n  | id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f\\n  | id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f\\n  | o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)\\n}', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', '| D : Precat', '| L : Functor D C', '| C : Precat', '\\\\func Const \\\\plevels obj >= hom \\\\hlevels  {C1 D : Precat} (d : D.Ob) : Functor C1 D (\\\\lam (_ : Ob {C {\\\\this}}) => d) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (_ : Hom {C {\\\\this}} X Y) => D.id d\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func comma-precat \\\\plevels obj >= hom \\\\hlevels  {C1 D1 : Precat} (L : Functor D1 C1) (b : C.Ob) : Precat (\\\\Sigma (x : D.Ob) (y : Ob) (C.Hom (L.F x) (F y))) {\\n  | Hom => \\\\lam (p0 : Ob {\\\\this}) (p1 : Ob {\\\\this}) =>\\n    \\\\Sigma (f : D.Hom p0.1 p1.1) (g : Hom p0.2 p1.2) (p1.3 C.\u2218 L.Func {p0.1} {p1.1} f = Func {p0.2} {p1.2} g C.\u2218 p0.3)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (D.id p0.1, id p0.2,\\n    pmap {C.Hom (L.F p0.1) (L.F p0.1)} {C.Hom (L.F p0.1) (F p0.2)} ((C.\u2218) {L.F p0.1} {L.F p0.1} {F p0.2} p0.3)\\n      {L.Func {p0.1} {p0.1} (id {L.C} p0.1)} {id {L.D} (L.F p0.1)} (L.Func-id {p0.1}) *> C.id-right {L.F p0.1} {F p0.2} {p0.3} *> inv {C.Hom (L.F p0.1) (F p0.2)} {Func {p0.2} {p0.2} (id p0.2) C.\u2218 p0.3} {p0.3}\\n      (pmap {C.Hom (F p0.2) (F p0.2)} {C.Hom (L.F p0.1) (F p0.2)} (\\\\lam (_x : C.Hom (F p0.2) (F p0.2)) => _x C.\u2218 p0.3)\\n        {Func {p0.2} {p0.2} (id {C} p0.2)} {id {D} (F p0.2)} (Func-id {p0.2}) *> C.id-left {L.F p0.1} {F p0.2} {p0.3}))\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) => (p0.1 D.\u2218 p1.1, p0.2 \u2218 p1.2,\\n    pmap {C.Hom (L.F X.1) (L.F Z.1)} {C.Hom (L.F X.1) (F Z.2)} ((C.\u2218) {L.F X.1} {L.F Z.1} {F Z.2} Z.3)\\n      {L.Func {X.1} {Z.1} (p0.1 \u2218 p1.1)} {L.Func {Y.1} {Z.1} p0.1 \u2218 L.Func {X.1} {Y.1} p1.1}\\n      (L.Func-o {X.1} {Y.1} {Z.1} {p0.1} {p1.1}) *> inv {C.Hom (L.F X.1) (F Z.2)} {Z.3 C.\u2218 L.Func {Y.1} {Z.1} p0.1 C.\u2218 L.Func {X.1} {Y.1} p1.1}\\n      {Z.3 C.\u2218 (L.Func {Y.1} {Z.1} p0.1 C.\u2218 L.Func {X.1} {Y.1} p1.1)}\\n      (C.o-assoc {L.F X.1} {L.F Y.1} {L.F Z.1} {F Z.2} {Z.3} {L.Func {Y.1} {Z.1} p0.1} {L.Func {X.1} {Y.1} p1.1}) *> pmap {C.Hom (L.F Y.1) (F Z.2)} {C.Hom (L.F X.1) (F Z.2)}\\n      (\\\\lam (_x : C.Hom (L.F Y.1) (F Z.2)) => _x C.\u2218 L.Func {X.1} {Y.1} p1.1) {Z.3 C.\u2218 L.Func {Y.1} {Z.1} p0.1}\\n      {Func {Y.2} {Z.2} p0.2 C.\u2218 Y.3} p0.3 *> C.o-assoc {L.F X.1} {L.F Y.1} {F Y.2} {F Z.2} {Func {Y.2} {Z.2} p0.2} {Y.3} {L.Func {X.1} {Y.1} p1.1} *> pmap {C.Hom (L.F X.1) (F Y.2)} {C.Hom (L.F X.1) (F Z.2)} ((C.\u2218) {L.F X.1} {F Y.2} {F Z.2} (Func {Y.2} {Z.2} p0.2))\\n      {Y.3 C.\u2218 L.Func {X.1} {Y.1} p1.1} {Func {X.2} {Y.2} p1.2 C.\u2218 X.3} p1.3 *> inv {C.Hom (L.F X.1) (F Z.2)} {Func {Y.2} {Z.2} p0.2 C.\u2218 Func {X.2} {Y.2} p1.2 C.\u2218 X.3}\\n      {Func {Y.2} {Z.2} p0.2 C.\u2218 (Func {X.2} {Y.2} p1.2 C.\u2218 X.3)}\\n      (C.o-assoc {L.F X.1} {F X.2} {F Y.2} {F Z.2} {Func {Y.2} {Z.2} p0.2} {Func {X.2} {Y.2} p1.2} {X.3}) *> pmap {C.Hom (F X.2) (F Z.2)} {C.Hom (L.F X.1) (F Z.2)} (\\\\lam (_x : C.Hom (F X.2) (F Z.2)) => _x C.\u2218 X.3)\\n      {Func {Y.2} {Z.2} p0.2 \u2218 Func {X.2} {Y.2} p1.2} {Func {X.2} {Z.2} (p0.2 \u2218 p1.2)}\\n      (inv {C.Hom (F X.2) (F Z.2)} {Func {X.2} {Z.2} (p0.2 \u2218 p1.2)} {Func {Y.2} {Z.2} p0.2 \u2218 Func {X.2} {Y.2} p1.2}\\n        (Func-o {X.2} {Y.2} {Z.2} {p0.2} {p1.2})))\\n} => commaPrecat {D1} {TrivialCat} {C1} L (Const {TrivialCat} {C1} b)', '| Hom Ob Ob : \\\\Set', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| B : Ob {C}', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| id (X : Ob) : Hom X X', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| D : Precat', '| C : Precat', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)', '\\\\func TrivialCat \\\\plevels  \\\\hlevels  : Cat (\\\\Sigma) {\\n  | Hom => Paths {\\\\new Graph (\\\\Sigma) (\\\\lam (_ : V {\\\\this}) (_ : V {\\\\this}) => Empty)}\\n  | id => \\\\lam (x : Ob {\\\\this}) =>\\n    empty {\\\\new Graph (\\\\Sigma) (\\\\lam (_ : V {\\\\this}) (_ : V {\\\\this}) => Empty)} {x} {x} (idp {\\\\Sigma} {x})\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (q : Hom {\\\\this} Y Z) (p : Hom {\\\\this} X Y) =>\\n    concat {\\\\new Graph (\\\\Sigma) (\\\\lam (_ : V {\\\\this}) (_ : V {\\\\this}) => Empty)} {X} {Y} {Z} p q\\n} => FreeCat {\\\\new Graph (\\\\Sigma) (\\\\lam (_ : V {\\\\this}) (_ : V {\\\\this}) => Empty)}']<<<break>>>Precat (\\Sigma (x : Ob {Coreflection.D}) (y : Ob) (Hom {Coreflection.C} (F {L} x) (F y))) {\n  | Hom => \\lam (p0 : Ob {\\this}) (p1 : Ob {\\this}) =>\n    \\Sigma (f : Hom {Coreflection.D} p0.1 p1.1) (g : Hom p0.2 p1.2) (p1.3 \u2218 Func {L} {p0.1} {p1.1} f = Func {p0.2} {p1.2} g \u2218 p0.3)\n  | id => \\lam (p0 : Ob {\\this}) => (id {Coreflection.D} p0.1, id p0.2,\n    pmap {Hom {Coreflection.C} (F {L} p0.1) (F {L} p0.1)} {Hom {Coreflection.C} (F {L} p0.1) (F p0.2)}\n      ((\u2218) {Coreflection.C} {F {L} p0.1} {F {L} p0.1} {F p0.2} p0.3) {Func {L} {p0.1} {p0.1} (id {Functor.C {L}} p0.1)}\n      {id {Functor.D {L}} (F {L} p0.1)} (Func-id {L} {p0.1}) *> id-right {Coreflection.C} {F {L} p0.1} {F p0.2} {p0.3} *> inv {Hom {Coreflection.C} (F {L} p0.1) (F p0.2)} {Func {p0.2} {p0.2} (id p0.2) \u2218 p0.3} {p0.3}\n      (pmap {Hom {Coreflection.C} (F p0.2) (F p0.2)} {Hom {Coreflection.C} (F {L} p0.1) (F p0.2)}\n        (\\lam (_x : Hom {Coreflection.C} (F p0.2) (F p0.2)) => _x \u2218 p0.3) {Func {p0.2} {p0.2} (id {Functor.C} p0.2)}\n        {id {Functor.D} (F p0.2)} (Func-id {p0.2}) *> id-left {Coreflection.C} {F {L} p0.1} {F p0.2} {p0.3}))\n  | o => \\lam {X Y Z : Ob {\\this}} (p0 : Hom {\\this} Y Z) (p1 : Hom {\\this} X Y) =>\n  (p0.1 \u2218 p1.1, p0.2 \u2218 p1.2, pmap {Hom {Coreflection.C} (F {L} X.1) (F {L} Z.1)} {Hom {Coreflection.C} (F {L} X.1) (F Z.2)}\n    ((\u2218) {Coreflection.C} {F {L} X.1} {F {L} Z.1} {F Z.2} Z.3) {Func {L} {X.1} {Z.1} (p0.1 \u2218 p1.1)}\n    {Func {L} {Y.1} {Z.1} p0.1 \u2218 Func {L} {X.1} {Y.1} p1.1} (Func-o {L} {X.1} {Y.1} {Z.1} {p0.1} {p1.1}) *> inv {Hom {Coreflection.C} (F {L} X.1) (F Z.2)} {Z.3 \u2218 Func {L} {Y.1} {Z.1} p0.1 \u2218 Func {L} {X.1} {Y.1} p1.1}\n    {Z.3 \u2218 (Func {L} {Y.1} {Z.1} p0.1 \u2218 Func {L} {X.1} {Y.1} p1.1)}\n    (o-assoc {Coreflection.C} {F {L} X.1} {F {L} Y.1} {F {L} Z.1} {F Z.2} {Z.3} {Func {L} {Y.1} {Z.1} p0.1}\n      {Func {L} {X.1} {Y.1} p1.1}) *> pmap {Hom {Coreflection.C} (F {L} Y.1) (F Z.2)} {Hom {Coreflection.C} (F {L} X.1) (F Z.2)}\n    (\\lam (_x : Hom {Coreflection.C} (F {L} Y.1) (F Z.2)) => _x \u2218 Func {L} {X.1} {Y.1} p1.1)\n    {Z.3 \u2218 Func {L} {Y.1} {Z.1} p0.1} {Func {Y.2} {Z.2} p0.2 \u2218 Y.3} p0.3 *> o-assoc {Coreflection.C} {F {L} X.1} {F {L} Y.1} {F Y.2} {F Z.2} {Func {Y.2} {Z.2} p0.2} {Y.3} {Func {L} {X.1} {Y.1} p1.1} *> pmap {Hom {Coreflection.C} (F {L} X.1) (F Y.2)} {Hom {Coreflection.C} (F {L} X.1) (F Z.2)}\n    ((\u2218) {Coreflection.C} {F {L} X.1} {F Y.2} {F Z.2} (Func {Y.2} {Z.2} p0.2)) {Y.3 \u2218 Func {L} {X.1} {Y.1} p1.1}\n    {Func {X.2} {Y.2} p1.2 \u2218 X.3} p1.3 *> inv {Hom {Coreflection.C} (F {L} X.1) (F Z.2)} {Func {Y.2} {Z.2} p0.2 \u2218 Func {X.2} {Y.2} p1.2 \u2218 X.3}\n    {Func {Y.2} {Z.2} p0.2 \u2218 (Func {X.2} {Y.2} p1.2 \u2218 X.3)}\n    (o-assoc {Coreflection.C} {F {L} X.1} {F X.2} {F Y.2} {F Z.2} {Func {Y.2} {Z.2} p0.2} {Func {X.2} {Y.2} p1.2} {X.3}) *> pmap {Hom {Coreflection.C} (F X.2) (F Z.2)} {Hom {Coreflection.C} (F {L} X.1) (F Z.2)}\n    (\\lam (_x : Hom {Coreflection.C} (F X.2) (F Z.2)) => _x \u2218 X.3) {Func {Y.2} {Z.2} p0.2 \u2218 Func {X.2} {Y.2} p1.2}\n    {Func {X.2} {Z.2} (p0.2 \u2218 p1.2)}\n    (inv {Hom {Coreflection.C} (F X.2) (F Z.2)} {Func {X.2} {Z.2} (p0.2 \u2218 p1.2)} {Func {Y.2} {Z.2} p0.2 \u2218 Func {X.2} {Y.2} p1.2}\n      (Func-o {X.2} {Y.2} {Z.2} {p0.2} {p1.2})))\n}", "completion": "comma-precat (L {this}) (B {this})"}
{"prompt": "['A : SimpleARS', 'lconf : isLocallyConfluent A', 'term : isTerminating A']<<<break>>>['\\\\data transitive-closure \\\\hlevels  {A : \\\\Set} (Rel A) (_ _ : A) : \\\\Prop \\n  | tc-direct (R a b)\\n  | tc-connect (c : A) (R a c) (transitive-closure {A} R c b)', '\\\\lemma Acc=>AccTrans \\\\hlevels  {A : \\\\Set} {R : Rel A} (a : A) (_ : Acc {A} R a) : Acc {A} (transitive-closure {A} R) a ', '| A : \\\\Set', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func well-founded-induction-transitive {A1 : \\\\Set} {R1 : Rel A1} (C1 : A1 -> \\\\Type)\\n  (_ : \\\\Pi (a : A1) -> (\\\\Pi (b : A1) -> transitive-closure {A1} R1 a b -> C1 b) -> C1 a) (a1 : A1)\\n  (_ : Acc-Trans {A1} R1 a1) : C1 a1 \\n  | {A}, {R}, C, induction, a, acc successors => induction a (\\\\lam (b : A) (a~>b : transitive-closure {A} R a b) =>\\n    well-founded-induction {A} {transitive-closure {A} R} C induction b (successors b a~>b))', '\\\\data Join \\\\hlevels  {A1 : ARS} (_ _ : A.A) : \\\\Prop \\n  | join (c : A.A) (a ~>_* c) (b ~>_* c)', 'tc-direct (R a b)', '\\\\lemma ~>*-concat \\\\hlevels  {A1 : ARS} {a b c : A.A} (_ : a ~>_* b) (_ : b ~>_* c) : a ~>_* c ', '\\\\lemma append-left \\\\hlevels  {A1 : ARS} {a b c : A.A} (_ : c ~>_* a) (_ : Join {A1} a b) : Join {A1} c b ', '| \\\\infix 4 ~> : Rel A', \"\\\\func trc-direct' \\\\hlevels  {A : \\\\Set} {R : Rel A} {a : A} : transitive-refl-closure {A} R a a => trc-direct {A} {R} {a} {a} (idp {A} {a})\", '\\\\func \\\\infix 4 ~>_* \\\\hlevels  {A1 : ARS} : Rel A.A => transitive-refl-closure {A.A} (A.~>)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data transitive-refl-closure \\\\hlevels  {A : \\\\Set} (Rel A) (_ _ : A) : \\\\Prop \\n  | trc-direct (a = b)\\n  | trc-connect (c : A) (R a c) (transitive-refl-closure {A} R c b)', 'join (c : A.A) (a ~>_* c) (b ~>_* c)']<<<break>>>\\Pi {a : A.A} -> \\Pi {b c : A.A} -> a ~>_* b -> a ~>_* c -> Join {A1} b c", "completion": "\\lam {a} => well-founded-induction-transitive (\\lam a => \\Pi {b c : A} (p1 : a ~>_* b) (p2 : a ~>_* c) -> Join b c)\n  (\\lam x step {b'} {c'} x~>*b' x~>*c' => (\\case x~>*b', x~>*c' \\with {\n    | trc-direct x=b', _ => join c' (rewriteI x=b' x~>*c') trc-direct'\n    | _, trc-direct x=c' => join b' trc-direct' (rewriteI x=c' x~>*b')\n    | trc-connect e x~>e e~>*b', trc-connect d x~>d d~>*c' => \\case lconf x~>e x~>d \\with {\n      | join u e~>*u d~>*u => \n        \\let join-b'-u => step e (tc-direct x~>e) {b'} {u} e~>*b' e~>*u\n        \\in \\case \\elim join-b'-u \\with {\n              | join v b'~>*v u~>*v => \n                \\let join-v-c' => step d (tc-direct x~>d) {v} {c'} (~>*-concat d~>*u u~>*v) d~>*c'\n                \\in append-left b'~>*v join-v-c'\n            }\n    }\n  })) a (Acc=>AccTrans a (term a))"}
{"prompt": "['Y : UniformSpace', 'C : Set (Set X.E)', 'Cu : X.isUniform C', 'X : UniformSpace']<<<break>>>['\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\func Refines \\\\hlevels  {X : \\\\hType} (C D : Set (Set X)) : \\\\Prop => \\\\Pi {U : Set X} -> C U -> TruncP (\\\\Sigma (V : Set X) (D V) (U \u2286 V))', '| Cod : BaseSet', '| func-uniform {E1 : Set (Set (E {Cod}))} (isUniform {Cod} E1) : isUniform {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (E1 V) (U = func ^-1 V)))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func Prod \\\\hlevels  {X Y : \\\\hType} (U : Set X) (V : Set Y) : Set (\\\\Sigma X Y) => \\\\lam (s : \\\\Sigma X Y) => \\\\Sigma (U s.1) (V s.2)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func proj1 \\\\hlevels  {X Y : UniformSpace} : UniformMap (X \u2a2f Y) X {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1\\n} => \\\\new UniformMap {\\n  | func-cont => {?hidden}\\n  | func-uniform => {?hidden}\\n}', '| E : \\\\Set', '| isUniform (Set (Set E)) : \\\\Prop', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>TruncP (\\Sigma (C1 : Set (Set X.E)) (X.isUniform C1) (D : Set (Set Y.E)) (Y.isUniform D) (Refines {\\Sigma X.E Y.E}\n  (\\lam (W : Set (\\Sigma X.E Y.E)) => TruncP (\\Sigma (U : Set X.E) (C1 U) (V : Set Y.E) (D V) (W = Prod {X.E} {Y.E} U V)))\n  (\\lam (U : Set (E {Dom {proj1 {X} {Y}}})) =>\n    TruncP (\\Sigma (V : Set (E {Cod {proj1 {X} {Y}}})) (C V) (U = func {proj1 {X} {Y}} ^-1 V)))))", "completion": "func-uniform {proj1} Cu"}
{"prompt": "[]<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| R : Semiring', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| vars : Array (E {M})', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\field mData : MonoidData {R} vars', '| E : \\\\Set', '\\\\class LinearRatAlgebraData \\\\extends RatAlgebraData, LinearData \\\\hlevels ', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>LinearRatAlgebraData {RealField} nil {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new LinearRatAlgebraData {\n  | R => RealField\n  | vars => nil\n}"}
{"prompt": "['n : Nat']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\class LinearSemiringData \\\\extends LinearData, SemiringData \\\\hlevels ', '| E : \\\\Set']<<<break>>>LinearSemiringData {NatSemiring} (n :: nil)", "completion": "\\new LinearSemiringData {\n  | R => NatSemiring\n  | vars => n :: nil\n}"}
{"prompt": "['q : Rat', 'y : E', 'x : E', 'this : RieszSpace']<<<break>>>['\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '\\\\lemma join_*n \\\\hlevels  {this : AbsAbGroup} {n : Nat} {x y : E} : n *n (x \u2228 y) = n *n x \u2228 n *n y ', '\\\\func ratNom \\\\plevels  \\\\hlevels  (_ : Rat) : Int \\n  | rat n denom denom/=0 reduced => n', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a']<<<break>>>iabs (ratNom q) *n (x \u2228 y) = iabs (ratNom q) *n x \u2228 iabs (ratNom q) *n y", "completion": "join_*n {this}"}
{"prompt": "['L : Locale', 'y : E {Dom {\\\\this}}', 'f : PrecoverMap (LocalePrecoverSpace L) (LocalePrecoverSpace M)', 'M : Locale', 'b_b<=<x : \\\\Sigma (b : M.E) (b <=< x)', 'p : x <= y', 'x : E {Dom {\\\\this}}']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {this : Locale} (x y : E) : \\\\Prop => top <= neg x \u2228 y', '\\\\instance LocaleRatherBelow \\\\hlevels  {L : Locale} : RatherBelow {L} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| <=<-left {U V W : E {A}} (R U V) (V <= W) : R U W', '| Join {J : \\\\Set} (J -> E) : E', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func points^* \\\\hlevels  {L : Locale} (a : L.E) : Set (CompleteFilter L) => \\\\lam (x : CompleteFilter L) => x.F a', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)']<<<break>>>(\\lam (s : \\Sigma (b : M.E) (b <=< y)) => points_* {L} (f.func ^-1 points^* {M} s.1))\n  (b, <=<-left {LocaleRatherBelow {M}} {b} {x} {y} b<=<x p) <= Join {L} {\\Sigma (b : M.E) (b <=< y)} (\\lam (s : \\Sigma (b : M.E) (b <=< y)) => points_* {L} (f.func ^-1 points^* {M} s.1))", "completion": "Join-cond (later (b, <=<-left b<=<x p))"}
{"prompt": "['Lr : IsRegularLocale {L}', 'L : Locale']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '| cauchy-top : isCauchy (single {E -> \\\\Prop} top)', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| <=<-left {U V W : E {A}} (R U V) (V <= W) : R U W', '| isCauchy (Set (Set E)) : \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D', '| open-top : isOpen top', '\\\\class StronglyRegularCoverSpace \\\\extends CoverSpace \\\\hlevels  {\\n  | isStronglyRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V s<=< U)))\\n  | isRegular => \\\\lam {C : Set (Set E)} (Cc : isCauchy C) => cauchy-subset {\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V s<=< U))}\\n    {\\\\lam (U : Set E) => TruncP (\\\\Sigma (U1 : Set E) (C U1) (U <=< U1))} (isStronglyRegular {C} Cc)\\n    (\\\\lam {U : Set E} (p0 : TruncP (\\\\Sigma (U1 : Set E) (C U1) (U s<=< U1))) => (\\\\case p0 \\\\with {\\n      | inP (V, CV, Us<=<V) => inP {\\\\Sigma (U1 : Set E) (C U1) (U <=< U1)} (V, CV, s<=<_<=< {U} {V} Us<=<V)\\n    }))\\n}', '\\\\func SJoin \\\\hlevels  {this : CompleteLattice} (U : E -> \\\\Prop) : E => Join {\\\\Sigma (b : E) (U b)} (\\\\lam (t : Total {E} U) => t.1)', '\\\\type \\\\infix 4 <=< \\\\hlevels  {this : Locale} (x y : E) : \\\\Prop => top <= neg x \u2228 y', '\\\\func Total {B : \\\\Type} (F : B -> \\\\Type) : \\\\Type => \\\\Sigma (b : B) (F b)', '| top : E', '| cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))', '| E : \\\\Set', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma points-unit \\\\hlevels  {L : Locale} {a : L.E} : a L.<= points_* {L} (points^* {L} a) ', '| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)', '| cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))', '\\\\lemma points-counit \\\\hlevels  {L : Locale} {U : Set (CompleteFilter L)} : points^* {L} (points_* {L} U) \u2286 U ', '| cauchy-open {S : Set E} : isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))', '\\\\func LocalePrecoverSpace \\\\hlevels  (L : Locale) : PrecoverSpace (CompleteFilter L) {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    L.top L.<= L.Join {\\\\Sigma (s : Set (CompleteFilter L)) (C s)} (\\\\lam (s : \\\\Sigma (s : Set (E {\\\\this})) (C s)) => points_* {L} s.1)\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '\\\\lemma points_<=< \\\\hlevels  {L : Locale} {a b : L.E} (_ : a <=< b) : points^* {L} a s<=< points^* {L} b ', '| Join {J : \\\\Set} (J -> E) : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '\\\\func points^* \\\\hlevels  {L : Locale} (a : L.E) : Set (CompleteFilter L) => \\\\lam (x : CompleteFilter L) => x.F a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\instance StronglyRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (s<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '| open-Union {S : Set (Set E)} (\\\\Pi {U : Set E} -> S U -> isOpen U) : isOpen (Union {E} S)', '\\\\type \\\\infix 4 s<=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => (W = Compl {X.E} V) || (W = U))', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)', '\\\\func isOpen \\\\hlevels  {this : PrecoverSpace} (S : Set E) : \\\\Prop => \\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S)']<<<break>>>StronglyRegularCoverSpace (CompleteFilter L) {\n  | isOpen => isOpen {LocalePrecoverSpace L}\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | isCauchy => \\lam (C : Set (Set E)) =>\n    L.top L.<= L.Join {\\Sigma (s : Set (CompleteFilter L)) (C s)} (\\lam (s : \\Sigma (s : Set E) (C s)) => points_* {L} s.1)\n  | cauchy-cover => {?hidden}\n  | cauchy-top => {?hidden}\n  | cauchy-refine => {?hidden}\n  | cauchy-glue => {?hidden}\n  | cauchy-open => {?hidden}\n  | isStronglyRegular => {?hidden}\n}", "completion": "\\new StronglyRegularCoverSpace {\n  | PrecoverSpace => LocalePrecoverSpace L\n  | isStronglyRegular => \\lam p0 => p0 <=\u2218 Join-univ (\\lam p0 => (\n    \\let (U, CU) => p0\n    \\in Lr _ <=\u2218 Join-univ (\\lam p0 => (\n          \\let (a, a<=<_*U) => p0\n          \\in points-unit <=\u2218 Join-cond (later (points^* a, inP (U, CU, <=<-left (points_<=< a<=<_*U) points-counit)))))))\n}"}
{"prompt": "['x : R.E', 'p : contains x', 'l : Localization R S']<<<break>>>[\"| inL : RingHom R R'\", \"| local (x : E {R}) (contains {S} x) : Inv {R'} (func {inL} x)\", \"| R' : CRing\", '| func (E {Dom}) : E {Cod}', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ']<<<break>>>Inv {l.R'} (func {l.inL} x)", "completion": "local {l} x p"}
{"prompt": "['X : RealBanachAlgebra', 'c*-sum : \\\\Pi {a b : X.E} -> X.norm (a X.* a) <= X.norm (a X.* a X.+ b X.* b)', 'b : X.E', 'pb : b X.* b = X.ide - x', 'a : X.E', 'pa : a X.* a = x', 'x : X.E']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '| norm_ide_<= : norm ide <= fromRat ide', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func interpret {G3 : Group} {n2 : Nat} (_ : Fin n2 -> G.E) (_ : Term n2) : G.E \\n  | {G}, {n}, env, var x => env x\\n  | {G}, {n}, env, :ide => G.ide\\n  | {G}, {n}, env, :inverse t => G.inverse (interpret {G} {n} env t)\\n  | {G}, {n}, env, t :* s => interpret {G} {n} env t G.* interpret {G} {n} env s', ':inverse (Term n)', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\lemma apply-axioms \\\\hlevels  {A : AbGroup} {n : Nat} (env : Array A.E n)\\n  (l : Array (\\\\Sigma Int (t s : Term env.len) (interpret {toCGroup A} {n} env.at t = interpret {toCGroup A} {n} env.at s)))\\n  (right : Array Int env.len) :\\ninterpretNF {toCGroup A} {n} env.at (mkArray {Int} {n} (\\\\lam (j : Fin n) => BigSum {IntRing}\\n  (\\\\new Array Int l.len (\\\\lam (i : Fin l.len) => (l.at i).1 * (at {normalize {n} (l.at i).2} j - at {normalize {n} (l.at i).3} j))) + right.at j)) = interpretNF {toCGroup A} {n} env.at right ', '| at (j : Fin len) : A j', '| E : \\\\Set', 'var (Fin n)', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\infixl 7 :* (_ _ : Term n)', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', '| norm E : ExUpperReal', '\\\\lemma terms-equality \\\\hlevels  {A : AbGroup} (env : Array A.E) (t s : Term env.len)\\n  (_ : interpretNF {toCGroup A} {env.len} env.at (normalize {env.len} (t :* :inverse {env.len} s)) = A.zro) :\\n  interpret {toCGroup A} {env.len} env.at t = interpret {toCGroup A} {env.len} env.at s ', 'pos Nat', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\data Term \\\\plevels  \\\\hlevels  Nat \\n  | var (Fin n)\\n  | :ide\\n  | :inverse (Term n)\\n  | \\\\infixl 7 :* (_ _ : Term n)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance ExUpperRealLattice \\\\hlevels  : CompleteLattice ExUpperReal {\\n  | <= => (ExUpperReal.<=)\\n  | meet => meet\\n  | join => join\\n  | top => top-impl\\n  | Join => ExUpperRealLattice.Join\\n  | Meet => ExUpperRealLattice.Meet\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }']<<<break>>>X.norm (X.ide - x) <= ide", "completion": "rewriteI pb (c*-sum {_} {a} <=\u2218 transportInv (\\lam p0 => norm {X} p0 <= _) (abGroup {(pa, pb)}) (norm_ide_<= {X}))"}
{"prompt": "['B : BooleanRing', 'a : PFunc {V} {B}', \"d2<l' : SFRefines {V} {B} d2 (reduce {V} {B} l')\", \"l' : PFunc {V} {B}\", 'a<d2 : SFRefines {V} {B} a d2', 'd2 : PFunc {V} {B}', 'V : PosetQModule']<<<break>>>[\"\\\\type SFRefines \\\\hlevels  {V : PosetQModule} {B : BooleanRing} (l l' : PFunc {V} {B}) : \\\\Prop => \\\\Sigma (\\\\Pi (j : Fin l'.len) ->\\n  ((l' !! j).1 = V.zro) || (l' !! j).2 B.<= BigJoin {B} (map {\\\\Sigma V.E B.E} {B.E} (\\\\lam (p0 : \\\\Sigma V.E B.E) => p0.2) l))\\n  (\\\\Pi (j : Fin l.len) -> TruncP (\\\\Sigma (j1 : Fin l'.len) ((l !! j).1 = (l' !! j1).1) ((l !! j).2 B.<= (l' !! j1).2)))\", '\\\\lemma SFRefines-trans \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l1 l2 l3 : PFunc {V} {B}} (_ : IsReduced {V} {B} l3) (_ : SFRefines {V} {B} l1 l2)\\n  (_ : SFRefines {V} {B} l2 l3) : SFRefines {V} {B} l1 l3 ', '\\\\func reduce \\\\hlevels  {V2 : PosetQModule} {B2 : BooleanRing} (_ : PFunc {V2} {B2}) : PFunc {V2} {B2} \\n  | {V}, {B}, nil => nil\\n  | {V}, {B}, :: {n} x l => add {V} {B} x.1 x.2 (reduce {V} {B} l)', '\\\\lemma reduce_IsReduced \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l : PFunc {V} {B}} : IsReduced {V} {B} (reduce {V} {B} l) ']<<<break>>>SFRefines {V} {B} a (reduce {V} {B} l')", "completion": "SFRefines-trans {V} {B} (reduce_IsReduced {V} {B}) a<d2 d2<l'"}
{"prompt": "['l : Array K.E', 'n : Nat']<<<break>>>['| len : Nat', '\\\\field trichotomy (x y : E) : Tri x y', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\data Tri \\\\hlevels  {A : StrictPoset} (_ _ : A.E) \\n  | less (a A.< a')\\n  | equals (a = a')\\n  | greater (a A.> a')\"]<<<break>>>Tri {NatSemiring} l.len n", "completion": "trichotomy (len {l}) n"}
{"prompt": "['a<x : x.L a', 'a : Rat', 'x : LowerReal', 'b : Rat']<<<break>>>['| L Rat : \\\\Prop', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\lemma L_<= \\\\plevels  \\\\hlevels  {this : ExtendedLowerReal} {q r : Rat} (_ : L q) (_ : r <= q) : L r ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>x.L (a \u2227 b)", "completion": "L_<= {x} a<x meet-left"}
{"prompt": "['l : Array (\\\\Sigma V.E B.E) n', 'V : PosetQModule', 'B : BooleanRing']<<<break>>>[\"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '\\\\lemma reduce_~ \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l : PFunc {V} {B}} : reduce {V} {B} l ~ l ', '\\\\func reduce \\\\hlevels  {V2 : PosetQModule} {B2 : BooleanRing} (_ : PFunc {V2} {B2}) : PFunc {V2} {B2} \\n  | {V}, {B}, nil => nil\\n  | {V}, {B}, :: {n} x l => add {V} {B} x.1 x.2 (reduce {V} {B} l)']<<<break>>>reduce {V} {B} l ~ l", "completion": "reduce_~ {V} {B}"}
{"prompt": "['n : Nat', 'g : PosetHom (FinOrder (suc n)) (FinOrder (suc n))', 'fg-comp : f.func o g.func = id {Fin (suc n)}', 'f : PosetHom (FinOrder (suc n)) (FinOrder (suc n))']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| func (E {Dom}) : E {Cod}', '\\\\func id {A : \\\\Type} : \\\\Pi (x : A) -> A => \\\\lam (x : A) => x', '\\\\func \\\\infixr 8 o {A B C : \\\\Type} (g : B -> C) (f : A -> B) : \\\\Pi (x : A) -> C => \\\\lam (x : A) => g (f x)']<<<break>>>\\Pi {a : Fin (suc n)} -> \\Pi {b : Fin (suc n)} -> g.func a = g.func b -> a = b", "completion": "\\lam {a} {b} leq => (\n  \\have A0 => pmap f leq\n  \\in (at) (rewrite (pmap (\\lam f => f a) fg-comp, pmap (\\lam k => k b) fg-comp) A0) A0 A0)"}
{"prompt": "['A : Matrix R.E (suc n) (suc n)', 'R : CRing', 'B : Matrix R.E m m', 'm : Nat', 'n : Nat']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', 'suc Nat', '\\\\func determinant {R : CRing} {n : Nat} (M : Matrix R.E n n) : R.E => FinSum {R} {SymFin n}\\n  (\\\\lam (e : Sym n) => sign {R} {n} e R.* BigProd {R} (\\\\new Array R.E n (\\\\lam (j : Fin n) => at {at {M} (f {e} j)} j)))', '| at (j : Fin len) : A j', '| ide : E', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| negative E : E', '\\\\func minor {R : \\\\Type} {n m : Nat} (M : Matrix R (suc n) (suc m)) (i0 : Fin (suc n)) (j0 : Fin (suc m)) : Matrix R n m \\n  => map {Array R (suc m)} {Array R m} (\\\\lam (p0 : Array R (suc m)) => skip {R} {m} p0 j0) (skip {Array R (suc m)} {n} M i0)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>Array R.E (suc n) (\\lam (i : Fin (suc n)) =>\n  at {at {A} i} 0 * pow {R} (negative {R} (ide {R})) i * determinant {R} {n} (minor {R.E} {n} {n} A i 0) * determinant {R} {m} B)", "completion": "\\lam i => A i 0 * pow {R} -1 i * determinant (minor A i 0) * determinant B"}
{"prompt": "['this : TotalOrder', 'y : E', 'x : E']<<<break>>>['| \\\\infix 4 <= E E : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| join-right {x y : E} : y <= x \u2228 y']<<<break>>>y <= x \u2228 y", "completion": "join-right {this}"}
{"prompt": "['eps : Rat', 'c : Series ExUpperReal', 'B1 : E', 'cc : IsConvUpperSeries c', 'B : Rat', 'eps>0 : zro < eps']<<<break>>>['\\\\lemma finv>0 {this : DiscreteOrderedField} {x : E} (_ : zro < x) : zro < finv x ', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma <_*_positive_positive \\\\hlevels  {this : OrderedSemiring} {x y : E} (_ : zro < x) (_ : zro < y) : zro < x * y ', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func midSum \\\\hlevels  {A3 : AddMonoid} (_ : Series A.E) (_ _ : Nat) : A.E \\n  | {A}, S, 0, m => partialSum {A} S m\\n  | {A}, S, suc n, 0 => A.zro\\n  | {A}, S, suc n, suc m => midSum {A} (\\\\lam (j : Nat) => S (suc j)) n m', '| finv E : E', '| zro<ide : zro < ide', '\\\\func join (_ _ : Rat) : Rat \\n  | rat n1 d1 denom/=0 reduced, rat n2 d2 denom/=0 reduced => \\\\case dec<_<= {IntRing} (n1 * pos d2) (n2 * pos d1) \\\\with {\\n    | inl x<y => rat n2 d2 {?hidden} {?hidden}\\n    | inr y<=x => rat n1 d1 {?hidden} {?hidden}\\n  }', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| U Rat : \\\\Prop', '| join-right {x y : E} : y <= x \u2228 y']<<<break>>>TruncP (\\Sigma (N : Nat) (\\Pi {n : Nat} -> N <= n -> U {midSum {ExUpperRealAbMonoid} c N n} (finv B1 * eps)))", "completion": "cc {finv B1 * eps} (<_*_positive_positive {RatField} (finv>0 {RatField} $ zro<ide {RatField} <\u2218l join-right) eps>0)"}
{"prompt": "['Q : Dec', 's : point {Q} x < (b, a.2)', 'x : Q.E', 'a : Interval Q', 'b_p_q : \\\\Sigma (b : E) (z.2 < b) (\\\\Pi {x : E} -> point {op {Q}} x < (a.2, b) ->\\n  TruncP (\\\\Sigma (j : Fin (len {mkArray {Interval (op {Q})} {l.len} (\\\\lam (i : Fin l.len) => ((l.at i).2, (l.at i).1))}))\\n    (point {op {Q}} x < at {mkArray {Interval (op {Q})} {l.len} (\\\\lam (i : Fin l.len) => ((l.at i).2, (l.at i).1))} j)))']<<<break>>>['\\\\type \\\\infix 4 < \\\\hlevels  {Q : BiorderedSet} (x y : Interval Q) : \\\\Prop => \\\\Sigma (y.1 Q.< x.1) (x.2 Q.< y.2)', '\\\\func op \\\\hlevels  {this2 : Dec} : Dec E {\\n  | < => \\\\lam (x : E) (y : E) => y < x\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => decideEq\\n  | trichotomy => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy x y \\\\with {\\n    | less y<x => greater {x} {y} y<x\\n    | equals x=y => equals {x} {y} x=y\\n    | greater x<y => less {x} {y} x<y\\n  })\\n} => \\\\new Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| E : \\\\Set', '\\\\func point \\\\hlevels  {Q : Poset} (x : Q.E) : Interval Q => (x, x)', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>point {op {Q}} x < (a.2, b)", "completion": "(s.2, s.1)"}
{"prompt": "['b : E', 'this : BezoutRing', 'c : E', 'a : E', 's_t_d1_d2 : \\\\Sigma (s t : E) (LDiv (s * a + t * b) a) (LDiv (s * a + t * b) b)', 'z : E', 'g : GCD a b z']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '| res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '| inv : E {M}', '\\\\lemma product-left \\\\hlevels  {M : Monoid} (x : M.E) {y z : M.E} (y|z : LDiv {M} y z) : LDiv {M} (x M.* y) (x M.* z) y|z.inv ']<<<break>>>LDiv (c * (s * a + t * b)) (c * z) (inv {g.res-univ (s * a + t * b) d1 d2})", "completion": "product-left c (res-univ {g} _ d1 d2)"}
{"prompt": "['B : \\\\Type', 'A : \\\\Type', 'this : Pullback (\\\\new Square (\\\\Sigma A1 B1) A1 B1 (\\\\Sigma) (\\\\lam (p : U {\\\\this}) => p.2) (\\\\lam (_ : V {\\\\this}) => ()) (\\\\lam (p : U {\\\\this}) => p.1)\\n  (\\\\lam (_ : X {\\\\this}) => ()) (\\\\lam (_ : U {\\\\this}) => idp {\\\\Sigma} {()})) {\\n  | pullback-univ => {?hidden}\\n}', 'Z : \\\\Type']<<<break>>>['| A : \\\\Type', '| U : \\\\Type', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', \"\\\\func pull (s : Square) {U' : \\\\Type} (f : U' -> s.U) :\\nSquare U' s.V s.X s.Y (\\\\lam (u' : U {\\\\this}) => s.ux (f u')) s.vy (\\\\lam (u' : U {\\\\this}) => s.uv (f u')) s.xy\\n  (\\\\lam (z : U {\\\\this}) => s.sqcomm (f z)) => \\\\new Square\", '| ux U : X', '| square : Square', '| uv U : V', '| ret B : A', '| V : \\\\Type', '| X : \\\\Type', '| sec B : A', '| B : \\\\Type', '| Y : \\\\Type', '| vy V : Y', '\\\\class Square {\\n  | U : \\\\Type\\n  | V : \\\\Type\\n  | X : \\\\Type\\n  | Y : \\\\Type\\n  | ux U : X\\n  | vy V : Y\\n  | uv U : V\\n  | xy X : Y\\n  | sqcomm (u : U) : vy (uv u) = xy (ux u)\\n}', '| xy X : Y']<<<break>>>QEquiv {Z -> U {square {\\this}}} {Square Z (V {square {\\this}}) (X {square {\\this}}) (Y {square {\\this}}) {\n  | vy => vy {square {\\this}}\n  | xy => xy {square {\\this}}\n}} (pull (square {\\this}) {Z}) {\n  | ret => \\lam (s : B {\\this}) (z : Z) => (s.uv z, s.ux z)\n  | ret_f => \\lam (a : A {\\this}) => idp {Z -> \\Sigma A1 B1} {ret {\\this}\n    (pull (\\new Square (\\Sigma A1 B1) A1 B1 (\\Sigma) (\\lam (p : \\Sigma A1 B1) => p.2) (\\lam (_ : A1) => ()) (\\lam (p : \\Sigma A1 B1) => p.1)\n      (\\lam (_ : B1) => ()) (\\lam (_ : \\Sigma A1 B1) => idp {\\Sigma} {()})) {Z} a)}\n  | f_sec => \\lam (b : B {\\this}) =>\n  idp {Square Z A1 B1 (\\Sigma) (\\lam (u' : Z) => (sec {\\this} b u').2) (\\lam (_ : A1) => ()) (\\lam (u' : Z) => (sec {\\this} b u').1)\n    (\\lam (_ : B1) => ()) (\\lam (_ : Z) => idp {\\Sigma} {()})}\n    {pull (\\new Square (\\Sigma A1 B1) A1 B1 (\\Sigma) (\\lam (p : \\Sigma A1 B1) => p.2) (\\lam (_ : A1) => ()) (\\lam (p : \\Sigma A1 B1) => p.1)\n      (\\lam (_ : B1) => ()) (\\lam (_ : \\Sigma A1 B1) => idp {\\Sigma} {()})) {Z} (sec {\\this} b)}\n}", "completion": "\\new QEquiv {\n  | ret => \\lam (s : Square) z => (uv {s} z, ux {s} z)\n  | ret_f => \\lam _ => idp\n  | f_sec => \\lam _ => idp\n}"}
{"prompt": "['C : Set (Set E)', 'x : E', 'y : E', 'this : PreuniformSpace', 'Cu : isUniform C', 'sf : \\\\Pi {C : Set (Set E)} -> isCauchy C -> TruncP (\\\\Sigma (U : Set E) (C U) (\\\\Sigma (U x) (U y)))']<<<break>>>['\\\\lemma makeCauchy \\\\hlevels  {this : PreuniformSpace} {C : Set (Set E)} (_ : isUniform C) : isCauchy C ', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U : Set E) (C U) (\\Sigma (U x) (U y)))", "completion": "sf (makeCauchy {this} Cu)"}
