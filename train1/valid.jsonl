{"prompt": "['eps : Rat', 'eps>0 : zro < eps']<<<break>>>['true', '\\\\lemma reduce2/=0 \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : Not ((reduce {NatEuclidean} a b).2 = 0) ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '| len : Nat', '\\\\lemma solve<Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 < interpret t2 ', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, LessOrEquals, t1) :: p', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'coef C', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', ':zro', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '| \\\\infix 4 < E E : \\\\Prop', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'var V', '\\\\lemma gcd_reduced \\\\plevels  \\\\hlevels  (a b : Nat) (_ : Not (b = 0)) : gcd {NatEuclidean} (reduce {NatEuclidean} a b).1 (reduce {NatEuclidean} a b).2 = 1 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatData (eps :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 1} 0 :* coef {E} {Fin 1} (rat (pos 1) 2 {?hidden} {?hidden})) < interpret {\\new LinearRatData (eps :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 1} 0)", "completion": "solve<Problem {\\new LinearRatData {\n  | R => RatField\n  | vars => eps :: nil\n}} ((:zro, Less, var 0) :: nil) (var 0 :* coef (rat (pos 1) 2 {?hidden} {?hidden})) (var 0)\n  (2 :: 1 :: nil, 0, idp, idp {Bool} {true}) (eps>0 :: nil)"}
{"prompt": "['d : Nat', \"l' : Array S'.E d' (\\\\lam (j : Fin d') => (polyCoef {S1} p j, mPolyImage-element {R} {S1} f (\\\\new Array S.E d' (polyCoef {S1} p)) j))\", \"d' : Nat\", \"d'=d+1 : d' = suc d\", \"SR : SubRing (Cod {mPolyEval {Fin d'} {S1} (polyCoef {S1} p) \u2218 mPoly-mapHom {Fin d'} {R} {S1} f}) (\\\\lam (y : E {S {\\\\this}}) =>\\n  TruncP (\\\\Sigma (x : E {Dom {mPolyEval {Fin d'} {S1} (polyCoef {S1} p) \u2218 mPoly-mapHom {Fin d'} {R} {S1} f}})\\n    (func {mPolyEval {Fin d'} {S1} (polyCoef {S1} p) \u2218 mPoly-mapHom {Fin d'} {R} {S1} f} x = y)))\", 'S : CRing']<<<break>>>['\\\\lemma polyCoef_fromArray \\\\hlevels  {R : AddPointed} {l : Array R.E} {j : Fin l.len} : polyCoef {R} (fromArray {R} l) j = l.at j ', '\\\\func toFin \\\\plevels  \\\\hlevels  (k1 : Nat) {n1 : Nat} (\\\\property _ : k1 < n1) : Fin n1 \\n  | 0, {suc n}, p => 0\\n  | suc k, {suc n}, p => suc (toFin k {n} {?hidden})', '\\\\func cStruct \\\\hlevels  {R : CRing} (S1 : SubRing R) : CRing (\\\\Sigma (x : E {S.S}) (S.contains x)) {\\n  | zro => (zro {S.S}, contains_zro {\\\\new S1 {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new S1 {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S.S} x.1, contains_negative {\\\\new S1 {}} {x.1} x.2)\\n  | ide => (ide {S.S}, S.contains_ide)\\n  | natCoef => natCoefImpl {ISemiring {S1}}\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', 'suc Nat', '\\\\lemma id<suc \\\\plevels  \\\\hlevels  {n : Nat} : n < suc n ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func fromArray \\\\hlevels  {R2 : AddPointed} (_ : Array R.E) : Poly R2 \\n  | {R}, nil => pzero {R}\\n  | {R}, :: {n} a l => padd {R} (fromArray {R} l) a', '\\\\func polyCoef \\\\hlevels  {R4 : AddPointed} (_ : Poly R4) (_ : Nat) : R.E \\n  | {R}, pzero, n => R.zro\\n  | {R}, padd p e, 0 => e\\n  | {R}, padd p e, suc n => polyCoef {R} p n\\n  | {R}, peq i, 0 => idp {R.E} {R.zro} @ i\\n  | {R}, peq i, suc n => idp {R.E} {R.zro} @ i', '| at (j : Fin len) : A j', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '| E : \\\\Set']<<<break>>>polyCoef {cStruct {S} SR} (fromArray {cStruct {S} SR} l') (toFin d {d'} {?hidden}) = l'.at (toFin d {d'} {?hidden})", "completion": "polyCoef_fromArray {_} {l'} {toFin d $ rewrite d'=d+1 id<suc}"}
{"prompt": "['R : CRing']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| ~-reflexive {x : A} : x ~ x', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '| zro : E', '\\\\instance M~-equiv \\\\hlevels  {R : Ring} {n m : Nat} : Equivalence (Matrix R.E n m) {\\n  | ~ => (M~)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '\\\\type IsDiagonal \\\\hlevels  {R : AddPointed} {n m : Nat} (A : Matrix R.E n m) : \\\\Prop \\n  => \\\\Pi {i : Fin n} -> \\\\Pi {j : Fin m} -> i /= j -> at {at {A} i} j = R.zro', '\\\\type \\\\infix 4 M~ \\\\hlevels  {R : Ring} {n m : Nat} (A B : Matrix R.E n m) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Inv {MatrixRing R n}) (D : Inv {MatrixRing R m}) (B = C.val product A product D.val))']<<<break>>>1 <= 1 -> 1 <= 2 -> \\Pi (A : Matrix R.E 1 1) -> TruncP (\\Sigma (B : Matrix R.E 1 1) (IsDiagonal {R} {1} {1} B) (A M~ B))", "completion": "\\lam _ _ A => inP (A, \\lam {p0} {p1} p => (\\case \\elim p0, \\elim p1, \\elim p \\with {\n  | 0, 0, p => absurd (p idp)\n}), ~-reflexive)"}
{"prompt": "['c : \\\\Pi (x : R.E) -> U x -> I.contains x', 'R : CRing', 'U : R.E -> \\\\Prop', 'I : Ideal R']<<<break>>>['| E : \\\\Set', '| contains (E {S}) : \\\\Prop']<<<break>>>\\Pi (j : \\Sigma (x : R.E) (U x)) -> I.contains j.1", "completion": "\\lam j => c j.1 j.2"}
{"prompt": "['C : Set (Set (\\\\Sigma I.E X.E))', 'n : I.E', 'I : DirectedSet', 'X : CoverSpace']<<<break>>>['\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {U : Set X.E} ->\nTruncP (\\Sigma (U1 : Set (\\Sigma I.E X.E)) (C U1) ((\\lam (p0 : \\Sigma I.E X.E) => p0.2) ^-1 U \u2286 U1)) ->\n  (\\lam (U : Set X.E) => TruncP (\\Sigma (V : Set (\\Sigma I.E X.E)) (C V) (\\Pi {x : X.E} -> U x -> V (n, x)))) U", "completion": "\\lam p0 => (\\case \\elim p0 \\with {\n  | inP (V, CV, p) => inP $ later (V, CV, \\lam p0 => p p0)\n})"}
{"prompt": "['this : RealBanachSpace', 'q : Rat', 'a : E']<<<break>>>['\\\\func const \\\\hlevels  {Y X : CoverSpace} (x : X.E) : CoverMap Y X {\\n  | func => \\\\lam (_ : E {Dom {const {Y} {X} x}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\func id \\\\hlevels  {X : CoverSpace} : CoverMap X X {\\n  | func => \\\\lam (x : E {Dom {id {X}}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\lemma *r_*q \\\\hlevels  {this : RealBanachSpace} {q : Rat} {a : E} : fromRat q *r a = q *q a ', '\\\\func tuple \\\\hlevels  {X Y Z : CoverSpace} (f : CoverMap Z X) (g : CoverMap Z Y) : CoverMap Z (X \u2a2f Y) {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (f.func z, g.func z)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| func (E {Dom}) : E {Cod}', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| E : \\\\Set', '\\\\infixl 7 *r \\\\hlevels  {this : RealBanachSpace} (r : Real) (a : E) : E => func {lift} (r, a)', '\\\\instance RealNormed \\\\hlevels  : CompleteNormedAbGroup Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n} => \\\\new CompleteNormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | isStronglyComplete => {?hidden}\\n}']<<<break>>>fromRat q *r (func {tuple {RealNormed} {RealNormed} (id {RealNormed}) (const {RealNormed} a)} (fromRat q)).2 = q *q (func {tuple {RealNormed} {RealNormed} (id {RealNormed}) (const {RealNormed} a)} (fromRat q)).2", "completion": "*r_*q {this}"}
{"prompt": "['x : E', 'this : AbGroup']<<<break>>>['| \\\\infixl 6 + E E : E', '| negative E : E', '| E : \\\\Set', '| +-comm {x y : E} : x + y = y + x']<<<break>>>x + negative x = negative x + x", "completion": "+-comm {this}"}
{"prompt": "['f : RingHom K S', 'l : Array S.E', 'p/=0 : p /= zro', \"l' : Array S.E l.len (\\\\lam (j : Fin l.len) => l.at j - pow {S} a (d j))\", 'S : CRing', 'p : E', 'K : DiscreteField']<<<break>>>['\\\\func cStruct \\\\hlevels  {R : CRing} (S1 : SubRing R) : CRing (\\\\Sigma (x : E {S.S}) (S.contains x)) {\\n  | zro => (zro {S.S}, contains_zro {\\\\new S1 {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new S1 {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S.S} x.1, contains_negative {\\\\new S1 {}} {x.1} x.2)\\n  | ide => (ide {S.S}, S.contains_ide)\\n  | natCoef => natCoefImpl {ISemiring {S1}}\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', 'suc Nat', '\\\\func degree<= \\\\hlevels  {R3 : AddPointed} (_ : Poly R3) (_ : Nat) : \\\\Prop \\n  | {R}, pzero, n => \\\\Sigma\\n  | {R}, padd p a, 0 => p = pzero {R}\\n  | {R}, padd p a, suc n => degree<= {R} p n\\n  | {R}, peq i, 0 =>\\n    propExt {pzero {R} = pzero {R}} {\\\\Sigma} (\\\\lam (_ : pzero {R} = pzero {R}) => ()) (\\\\lam (_ : \\\\Sigma) => idp {Poly R} {pzero {R}}) @ i\\n  | {R}, peq i, suc n => idp {\\\\Prop} {\\\\Sigma} @ i', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\func mPolyImage {R E1 : CRing} (f : RingHom R E1) (l : Array E.E) :\\nSubRing (Cod {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f}) (\\\\lam (y : E {S {\\\\this}}) =>\\n  TruncP (\\\\Sigma (x : E {Dom {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f}})\\n    (func {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f} x = y))) \\n  => ringHomImage (mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f)', '\\\\func change-vars \\\\hlevels  {R : CRing} {n : Nat} (p : E) (d : Nat) (l : Array R.E n) : Poly R \\n=> mPolyMapEval {Fin n} {R} {PolyAlgebra R} (polyHom {R}) p\\n  (\\\\lam (j : Fin n) => padd {R} (pzero {R}) (l.at j) + pow {PolyRing R} (padd {R} ide R.zro) (pow {NatSemiring} d j))', '\\\\func mPolyImage-element \\\\hlevels  {R E1 : CRing} (f : RingHom R E1) (l : Array E.E) (j : Fin l.len) : contains (l.at j) \\n=> inP {\\\\Sigma (x : E {Dom {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f}})\\n  (func {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f} x = l.at j)}\\n  (mVar {Fin l.len} {R} j, transportInv {E.E} (\\\\lam (x : E {f.Cod}) =>\\n    x E.* func {permSet-univ {Fin l.len} {E1} ((!!) l)} (func {id {PermSetMonoid (Fin l.len)}} (inPS {Fin l.len} (j :: nil))) E.+ E.zro = l !! j)\\n    {f.func R.ide} {E.ide} f.func-ide\\n    (transport {E.E} (\\\\lam (x0 : E.E) => x0 = l !! j) {l !! at {j :: nil} 0} {E.ide E.* (l !! at {j :: nil} 0 E.* E.ide) E.+ E.zro}\\n      (inv {E.E} {E.ide E.* (l !! at {j :: nil} 0 E.* E.ide) E.+ E.zro} {l !! at {j :: nil} 0}\\n        (path ((@) (E.zro-right {E.ide E.* (l !! at {j :: nil} 0 E.* E.ide)})) *> path ((@) (E.ide-left {l !! at {j :: nil} 0 E.* E.ide})) *> path ((@) (E.ide-right {l !! at {j :: nil} 0}))))\\n      (idp {E.E} {l !! at {j :: nil} 0})))', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func mdegree \\\\hlevels  {J : DecSet} {R : Dec} (p : E) : Nat => decMdegree {J} {R} (ret {monoidSetDec-equiv {PermSetDec J} {R} {\\\\new R {}}} p)', '| at (j : Fin len) : A j', '\\\\func mPoly-map \\\\hlevels  {J : \\\\Set} {R S : CRing} (f : AddMonoidHom R S) (p : E) : E \\n  => monoidSet-map {PermSet J} {PermSet J} (\\\\lam (x : PermSet J) => x) f p', '\\\\func mPolyImageHom \\\\hlevels  {R E1 : CRing} (f : RingHom R E1) (l : Array E.E) : RingHom R (cStruct {E1} (mPolyImage {R} {E1} f l)) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, mPolyImage-ext {R} {E1} f l x)\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '| func-zro : func (zro {Dom}) = zro {Cod}', '| E : \\\\Set', '| contains (E {S}) : \\\\Prop', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma MPoly_poly-field {K : DiscreteField} {E1 : CRing} (f : RingHom K E1) {n : Nat} {p : E} (_ : p /= zro) (a : Array E.E n) :\\nTruncP (\\\\Sigma (m : Nat) (degree<= {E1} (change-vars {E1} {n} (mPoly-map {Fin n} {K} {E1} f p) (suc (mdegree {FinFin n} {K} p)) a) m)\\n  (Inv {E1} (polyCoef {E1} (change-vars {E1} {n} (mPoly-map {Fin n} {K} {E1} f p) (suc (mdegree {FinFin n} {K} p)) a) m))) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '\\\\lemma mPolyImage-ext \\\\hlevels  {R E1 : CRing} (f : RingHom R E1) (l : Array E.E) (b : R.E) : contains (f.func b) ', '\\\\func polyCoef \\\\hlevels  {R4 : AddPointed} (_ : Poly R4) (_ : Nat) : R.E \\n  | {R}, pzero, n => R.zro\\n  | {R}, padd p e, 0 => e\\n  | {R}, padd p e, suc n => polyCoef {R} p n\\n  | {R}, peq i, 0 => idp {R.E} {R.zro} @ i\\n  | {R}, peq i, suc n => idp {R.E} {R.zro} @ i', '| func (E {Dom}) : E {Cod}', '| S : BaseSet']<<<break>>>TruncP (\\Sigma (m : Nat)\n  (degree<= {cStruct {S1} (mPolyImage {K} {S1} f l')} (change-vars {cStruct {S1} (mPolyImage {K} {S1} f l')} {suc l.len}\n    (mPoly-map {Fin (suc l.len)} {K} {cStruct {S1} (mPolyImage {K} {S1} f l')} (mPolyImageHom {K} {S1} f l') p)\n    (suc (mdegree {FinFin (suc l.len)} {K} p))\n    ((S.zro, transport {S.E} contains {f.func K.zro} {S.zro} f.func-zro (mPolyImage-ext {K} {S1} f l' K.zro)) :: \\new Array E l.len (\\lam (j : Fin l.len) => (l'.at j, mPolyImage-element {K} {S1} f l' j))))\n    m)\n  (Inv {cStruct {S1} (mPolyImage {K} {S1} f l')}\n    (polyCoef {cStruct {S1} (mPolyImage {K} {S1} f l')} (change-vars {cStruct {S1} (mPolyImage {K} {S1} f l')} {suc l.len}\n      (mPoly-map {Fin (suc l.len)} {K} {cStruct {S1} (mPolyImage {K} {S1} f l')} (mPolyImageHom {K} {S1} f l') p)\n      (suc (mdegree {FinFin (suc l.len)} {K} p))\n      ((S.zro, transport {S.E} contains {f.func K.zro} {S.zro} f.func-zro (mPolyImage-ext {K} {S1} f l' K.zro)) :: \\new Array E l.len (\\lam (j : Fin l.len) => (l'.at j, mPolyImage-element {K} {S1} f l' j))))\n      m)))", "completion": "MPoly_poly-field (mPolyImageHom f l') p/=0\n  ((zro, transport (mPolyImage f l') (func-zro {f}) (mPolyImage-ext f l' zro)) :: (\\lam j => (l' j, mPolyImage-element f l' j)))"}
{"prompt": "['M : Monoid', 'env : V -> M.E', 'l : List V', 'v : V', 's : List V', 'V : \\\\Set']<<<break>>>['\\\\lemma interpretNF_++ \\\\hlevels  {M : Monoid} {V : \\\\Set} {env : V -> M.E} {t s : List V} :\\n  interpretNF {M} {V} env (t ++ s) = interpretNF {M} {V} env t M.* interpretNF {M} {V} env s ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\lemma interpretNF_:: \\\\hlevels  {M : Monoid} {V : \\\\Set} {env : V -> M.E} {x : V} {l : List V} :\\n  interpretNF {M} {V} env (x :: l) = env x M.* interpretNF {M} {V} env l ', '| \\\\infixl 7 * E E : E', '\\\\func interpretNF \\\\hlevels  {M2 : Monoid} {V1 : \\\\Set} (_ : V1 -> M.E) (_ : List V1) : M.E \\n  | {M}, {V}, env, nil => M.ide\\n  | {M}, {V}, env, x :: nil => env x\\n  | {M}, {V}, env, x :: l => env x M.* interpretNF {M} {V} env l', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', '\\\\infixr 5 :: A (List A)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>interpretNF {M} {V} env (v :: l ++ s) = interpretNF {M} {V} env (v :: l) M.* interpretNF {M} {V} env s", "completion": "rewrite (interpretNF_:: {M}) (rewrite (interpretNF_:: {M}) (pmap ((*) _) (interpretNF_++ {M}) *> inv *-assoc))"}
{"prompt": "['X : TopAbGroup', 'I : DirectedSet', 'f : I.E -> X.E']<<<break>>>['| zro : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| <=-refl {x : E} : x <= x', '| at (j : Fin len) : A j', '| isOpen (Set E) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '\\\\func IsConvergent \\\\hlevels  {I : DirectedSet} {X : CoverSpace} (f : I.E -> X.E) : \\\\Prop => CoverMap (DirectedCoverSpace I) X {\\n  | func => f\\n}', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>at {IsConvergent {I} {X} f :: (\\Pi {U : Set X.E} ->\n  X.isOpen U -> U X.zro -> TruncP (\\Sigma (N : I.E) (\\Pi {n m : I.E} -> N I.<= n -> n I.<= m -> U (f m - f n)))) :: (\\Pi {U : Set X.E} -> X.isOpen U -> U X.zro -> TruncP (\\Sigma (N : I.E) (\\Pi {n : I.E} -> N I.<= n -> U (f n - f N)))) :: nil}\n  1 -> \\Pi {U : Set X.E} -> X.isOpen U -> U X.zro -> TruncP (\\Sigma (N : I.E) (\\Pi {n : I.E} -> N I.<= n -> U (f n - f N)))", "completion": "\\lam fc Uo U0 => (\\case fc Uo U0 \\with {\n  | inP (N, g) => inP (N, \\lam p => g <=-refl p)\n})"}
{"prompt": "['c : Cover {framePres {X}} b {J} f', 'U : Set X.E', 'p : U = conj W b', 'f : J -> E', 'b : E', 'X : StronglyRegularCoverSpace', 'W : E', 'J : \\\\Set', \"U' : Set X.E\", \"U'<=<U : U' s<=< U\"]<<<break>>>['| conj E E : E', '| <=<-left {U V W : E {A}} (R U V) (V <= W) : R U W', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\instance StronglyRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (s<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '| A : TopMeetSemilattice', \"\\\\lemma cover-char \\\\hlevels  {X : StronglyRegularCoverSpace} {U : Set X.E} {J : \\\\Set} {g : J -> Set X.E} (_ : Cover {framePres {X}} U {J} g)\\n  {U' : Set X.E} (_ : U' s<=< U) : X.isCauchy (\\\\lam (V : Set X.E) => (V = Compl {X.E} U') || (\\\\Sigma (j : J) (g j = V))) \", '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func framePres \\\\hlevels  {X : PrecoverSpace} : FramePres (Set X.E) {\\n  | conj => (\u2227)\\n  | BasicCover => \\\\lam {J : \\\\Set} (U : E {\\\\this}) (f : J -> E {\\\\this}) =>\\n    (\\\\Sigma (U = top) (C : Set (Set X.E)) (X.isCauchy C) (\\\\Pi {V : Set X.E} -> C V -> TruncP (\\\\Sigma (j : J) (f j = V)))) || (\\\\Pi {V : Set X.E} -> V s<=< U -> TruncP (\\\\Sigma (j : J) (f j = V))) || (U = bottom)\\n} => \\\\new FramePres', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| meet-right {x y : E} : x \u2227 y <= y', '\\\\func Compl \\\\hlevels  {X : \\\\hType} (U : Set X) : Set X => \\\\lam (x : X) => Not (U x)']<<<break>>>X.isCauchy (\\lam (V : Set X.E) => (V = Compl {X.E} U') || (\\Sigma (j : J) (f j = V)))", "completion": "cover-char c (<=<-left U'<=<U $ later $ rewrite p meet-right)"}
{"prompt": "['a : E.E', 'Sa : S.contains a', 'S : SubRing E', 'i : Fin n']<<<break>>>['| S : BaseSet', '\\\\lemma contains_pow \\\\hlevels  {this : SubMonoid} {x : E {S}} (_ : contains x) {n : Nat} : contains (pow {S} x n) ', '| contains (E {S}) : \\\\Prop', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>S.contains (pow {S.S} a i)", "completion": "contains_pow {S} Sa"}
{"prompt": "[\"f : SiteWithBasisPrehom C C'\"]<<<break>>>['| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| Hom Ob Ob : \\\\Set', '\\\\class Functor \\\\plevels obj >= hom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F (Ob {C}) : Ob {D}\\n  | Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)\\n  | Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)\\n  | Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f\\n}', '| D : Precat', '| C : Precat', '| Ob : \\\\hType', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}']<<<break>>>Functor (op {f.C}) (op {f.D}) f.F {\n  | Func => \\lam {X Y : Ob {C {\\this}}} => f.Func {Y} {X}\n}", "completion": "op {f}"}
{"prompt": "['R : CRing', 'S : CRing', 'f : RingHom R S']<<<break>>>['\\\\func + {I4 : Ideal} (_ _ : Type I4) : Type I4 \\n  | {I}, in~ a, in~ b => in~ {E {I.S}} {\\\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b)} (a + b)\\n  | {I1}, in~ a, ~-equiv b c r i =>\\n  fequiv {I1} {a + b} {a + c} (transport {E {I.S}} I.contains {b + negative {I.S} c} {a + b + negative {I.S} (a + c)}\\n    (inv {E {I.S}} {a + b + negative {I.S} (a + c)} {b + negative {I.S} c}\\n      (((path (\\\\lam (i : I) => a + b + negative_+ {I.S} {a} {c} @ i) *> (\\n        \\\\let d => \\\\new CGroupData {toCGroup I.S} (\\\\lam (a1 : V {\\\\this}) => at {a :: b :: c :: nil} (fromNat {2} a1))\\n        \\\\in simplify-correct {d} (var {d.V} 0 :* var {d.V} 1 :* (:inv {d.V} (var {d.V} 2) :* :inv {d.V} (var {d.V} 0))))) *> path (\\\\lam (i : I) => zro {I.S} + b + (negative {I.S} c + negative_zro {I.S} @ i))) *> path (\\\\lam (i : I) => zro-left {I.S} {b} @ i + (negative {I.S} c + zro {I.S})) *> path (\\\\lam (i : I) => b + zro-right {I.S} {negative {I.S} c} @ i)))\\n    r) @ i\\n  | {I1}, ~-equiv b c r i, in~ a =>\\n  fequiv {I1} {b + a} {c + a} (transport {E {I.S}} I.contains {b + negative {I.S} c} {b + a + negative {I.S} (c + a)}\\n    (inv {E {I.S}} {b + a + negative {I.S} (c + a)} {b + negative {I.S} c}\\n      ((((path (\\\\lam (i : I) => b + a + negative_+ {I.S} {c} {a} @ i) *> (\\n        \\\\let d => \\\\new CGroupData {toCGroup I.S} (\\\\lam (a1 : V {\\\\this}) => at {b :: a :: c :: nil} (fromNat {2} a1))\\n        \\\\in simplify-correct {d} (var {d.V} 0 :* var {d.V} 1 :* (:inv {d.V} (var {d.V} 1) :* :inv {d.V} (var {d.V} 2))))) *> path (\\\\lam (i : I) => zro-right {I.S} {b} @ i + (negative {I.S} (zro {I.S}) + negative {I.S} c))) *> path (\\\\lam (i : I) => b + (negative_zro {I.S} @ i + negative {I.S} c))) *> path (\\\\lam (i : I) => b + zro-left {I.S} {negative {I.S} c} @ i)))\\n    r) @ i', '\\\\class CRing \\\\extends Ring, PseudoCRing, CSemiring \\\\hlevels ', '\\\\func negative {I3 : Ideal} (_ : Type I3) : Type I3 \\n  | {I}, in~ a => inF {I} (negative {I.S} a)\\n  | {I1}, ~-equiv a b r i => fequiv {I1} {negative {I.S} a} {negative {I.S} b}\\n    (transport {E {I.S}} I.contains {negative {I.S} (ide {I.S}) * (a - b)} {negative {I.S} a - negative {I.S} b}\\n      (terms-equality {I.S} (a :: b :: nil)\\n        (:negative {Int} {2} (:ide {Int} {2}) :* (var {Int} {2} 0 :+ :negative {Int} {2} (var {Int} {2} 1)))\\n        (:negative {Int} {2} (var {Int} {2} 0) :+ :negative {Int} {2} (:negative {Int} {2} (var {Int} {2} 1)))\\n        (idp {E {I.S}} {ringInterpretNF {I.S} (a :: b :: nil) (normalize {2} {IntRing}\\n          (:negative {Int} {2} (:ide {Int} {2}) :* (var {Int} {2} 0 :+ :negative {Int} {2} (var {Int} {2} 1)) :+ :negative {Int} {2} (:negative {Int} {2} (var {Int} {2} 0) :+ :negative {Int} {2} (:negative {Int} {2} (var {Int} {2} 1)))))}))\\n      (I.ideal-left {negative {I.S} (ide {I.S})} {a - b} r)) @ i', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func inF \\\\hlevels  {I : Ideal} (a : E {I.S}) : Type I => in~ {E {I.S}} {\\\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b)} a', '| zro : E', '\\\\func * {I4 : Ideal} (_ _ : Type I4) : Type I4 \\n  | {I}, in~ a, in~ b => inF {I} (a * b)\\n  | {I1}, in~ a, ~-equiv b c r i => fequiv {I1} {a * b} {a * c}\\n    (transport {E {I.S}} I.contains {a * (b - c)} {a * b - a * c} (ldistr_- {I.S} {a} {b} {c}) (I.ideal-left {a} {b - c} r)) @ i\\n  | {I1}, ~-equiv b c r i, in~ a => fequiv {I1} {b * a} {c * a}\\n    (transport {E {I.S}} I.contains {(b - c) * a} {b * a - c * a} (rdistr_- {I.S} {b} {c} {a}) (I.ideal-right {a} {b - c} r)) @ i', '| natCoef Nat : E', '\\\\instance FactorRing \\\\hlevels  (I1 : Ideal) : CRing (Type I1) {\\n  | zro => inF {I1} (zro {I.S})\\n  | + => (FactorRing.+)\\n  | * => (FactorRing.*)\\n  | negative => FactorRing.negative {I1}\\n  | ide => inF {I1} (ide {I.S})\\n  | natCoef => \\\\lam (n : Nat) => inF {I1} (natCoef {I.S} n)\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\type Type \\\\hlevels  (I : Ideal) : \\\\Set => Quotient {E {I.S}} (\\\\lam (a : E {I.S}) (b : E {I.S}) => I.contains (a - b))', '\\\\func KernelC \\\\hlevels  {R : CRing} {S1 : Ring} (f : RingHom R S1) : Ideal R (\\\\lam (x : E {S}) => f.func x = zro {f.Cod}) => \\\\new Ideal {\\n  | contains_zro => {?hidden}\\n  | contains_+ => {?hidden}\\n  | ideal-left => {?hidden}\\n}', '| S : BaseSet']<<<break>>>CRing (Type (KernelC {R} {S1} f)) {\n  | zro => inF {KernelC {R} {S1} f} (zro {S})\n  | + => (+)\n  | * => (*)\n  | negative => negative {KernelC {R} {S1} f}\n  | ide => inF {KernelC {R} {S1} f} (ide {S})\n  | natCoef => \\lam (n : Nat) => inF {KernelC {R} {S1} f} (natCoef {S} n)\n}", "completion": "FactorRing (KernelC f)"}
{"prompt": "['Q : Dec', 'l : Array E', \"x' : E\"]<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '\\\\type Interval \\\\hlevels  (Q : Poset) : \\\\Set => \\\\Sigma Q.E Q.E', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', 'cover-inj (j : J) (g j = x)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\instance RealPres \\\\hlevels  (Q : Dec) : FramePres (Interval Q) {\\n  | conj => (\u2227)\\n  | BasicCover => Indexing {\\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))} {Interval Q}\\n    (\\\\lam (p0 : \\\\Sigma (x : Bool) (if {\\\\Set} x (\\\\Sigma (p r q s : Q.E) (p Q.< r) (r Q.< q) (q Q.< s)) (\\\\Sigma Q.E Q.E))) =>\\n    (\\\\case p0 \\\\with {\\n      | (true, (p, r, q, s, _x, _x, _x)) => (Fin 2, (p, s), \\\\lam (p0 : Fin 2) => (\\\\case p0 \\\\with {\\n        | zero => (p, q)\\n        | suc zero => (r, s)\\n      }))\\n      | (false, (p, q)) => (\\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q), (p, q),\\n        \\\\lam (t : \\\\Sigma (r s : Q.E) (p Q.< r) (r Q.< s) (s Q.< q)) => (t.1, t.2))\\n    }))\\n} => \\\\new FramePres']<<<break>>>Cover {RealPres Q} x' {Fin (len {(x' :: nil) ++ l})} (at {(x' :: nil) ++ l})", "completion": "cover-inj 0 idp"}
{"prompt": "['p2 : Hom {J {\\\\this}} p0 p1', 'this : Limit {Precat.op {Precategory-of-elements {C1} P}} {Precat.op {PresheafCat C1}}\\n  (Functor.op {Comp {Precategory-of-elements {C1} P} {C1} {PresheafCat C1} (functor {C1}) (projection {C1} {P})}) P {\\n  | coneMap => \\\\lam (p0 : Ob {J {\\\\this}}) =>\\n  \\\\new NatTrans {Precat.op {C1}} {SetCat} (VPresheaf.F {Functor.F {Cone.G {\\\\this}} p0}) (VPresheaf.F {apex {\\\\this}}) {\\n    | trans => \\\\lam (o : Ob {C {\\\\this}}) (h : Functor.F {NatTrans.F {\\\\this}} o) => Func {P.F} {p0.1} {o} h p0.2\\n    | natural => {?hidden}\\n  }\\n  | coneCoh => {?hidden}\\n  | isLimit => {?hidden}\\n  | limMap => \\\\lam {G : Ob {Cone.D {\\\\this}}} (cone : Cone {J {\\\\this}} {Cone.D {\\\\this}} (Cone.G {\\\\this}) G) =>\\n  \\\\new NatTrans {Precat.op {C1}} {SetCat} (VPresheaf.F {apex {\\\\this}}) G.F {\\n    | trans => \\\\lam (X : Ob {C {\\\\this}}) (p : Functor.F {NatTrans.F {\\\\this}} X) => f {yoneda-lemma {C1} X G} (cone.coneMap (X, p))\\n    | natural => {?hidden}\\n  }\\n  | limBeta => {?hidden}\\n  | limUnique => {?hidden}\\n}', 'h1 : (\\\\lam (X : C.Ob) => (\\\\lam (h : Functor.F {VPresheaf.F {Functor.F p0}} X) => Func {P.F} {p0.1} {X} h p0.2) \u2218 trans {Func {p0} {p1} p2} X) = (\\\\lam (X : C.Ob) (h : C.Hom X p1.1) => Func {P.F} {p1.1} {X} h p1.2)', 'C : Precat', 'P : Ob', 'p1 : Ob {J {\\\\this}}', 'X : Ob {C {\\\\this}}', 'p0 : Ob {J {\\\\this}}', 'i : I']<<<break>>>['| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X', '| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}', '| D : Precat', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| G : Functor J D', '| Ob : \\\\hType', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}']<<<break>>>\\Pi {Y : C.Ob} ->\n  \\Pi (f : Hom X Y) -> (@) h1 i Y \u2218 (\\lam (g : C.Hom X p1.1) => g C.\u2218 f) = Func {P.F} {X} {Y} f \u2218 (@) h1 i X", "completion": "(@) (prop-dpi (\\lam i => ext_coe) (natural {Func {p0} {p1} p2 \u2218 \\new NatTrans {op {C}} {SetCat} (F {F p0}) P.F {\n  | trans => \\lam (o : Ob) (h : F {F {F p0}} o) => Func {P.F} {p0.1} {o} h p0.2\n  | natural => {?hidden}\n}})\n  (natural {\\new NatTrans {op {C}} {SetCat} (F {F p1}) P.F {\n    | trans => \\lam (o : Ob) (h : F {F {F p1}} o) => Func {P.F} {p1.1} {o} h p1.2\n    | natural => {?hidden}\n  }})) i {X}"}
{"prompt": "['C : Site', 'null : A {\\\\this}', 'p : B {\\\\this}', 'D : Cat', 'null : A {\\\\this}', 'i : I']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\class VSheaf \\\\extends VPresheaf \\\\hlevels  {\\n  | isSheaf {x : Ob {C}} {s : Sieve {C} x} (isCover {C} x s) : Limit {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {D}\\n    (Comp {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n      (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C}} {D} VPresheaf.F\\n      (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F} apex) {\\n    | coneMap => \\\\lam (j : Ob {J}) => Func {VPresheaf.F} {apex} {Functor.F j} (coneMap j)\\n    | coneCoh => {?hidden}\\n  }\\n}', '\\\\type ObOver \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : \\\\hType => \\\\Sigma (y : C.Ob) (C.Hom y x)', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func subPrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} {X : \\\\hType} (f : X -> C.Ob) : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => C.Hom (f x) (f y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => C.id (f x)\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} => (C.\u2218)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| J : Precat', '\\\\instance SlicePrecat \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (x : C.Ob) : Precat (ObOver {C} x) {\\n  | Hom => \\\\lam (p0 : Ob {\\\\this}) (p1 : Ob {\\\\this}) => \\\\Sigma (h : C.Hom p0.1 p1.1) (p1.2 C.\u2218 h = p0.2)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (C.id p0.1, C.id-right {p0.1} {x} {p0.2})\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) => (p0.1 C.\u2218 p1.1,\\n    inv {C.Hom X.1 x} {Z.2 C.\u2218 p0.1 C.\u2218 p1.1} {Z.2 C.\u2218 (p0.1 C.\u2218 p1.1)} (C.o-assoc {X.1} {Y.1} {Z.1} {x} {Z.2} {p0.1} {p1.1}) *> pmap {C.Hom Y.1 x} {C.Hom X.1 x} (\\\\lam (_x : C.Hom Y.1 x) => _x C.\u2218 p1.1) {Z.2 C.\u2218 p0.1} {Y.2} p0.2 *> p1.2)\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func map \\\\plevels obj >= hom \\\\hlevels  {C D : Precat} (F1 : Functor C D) {J1 : Precat} {G : Functor J1 C} (c : Cone {J1} {C} G) :\\nCone {J1} {D} (Comp {J1} {C} {D} F1 G) (F.F c.apex) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => F.Func {c.apex} {G.F j} (c.coneMap j)\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '| S {y : Ob {C}} (Hom {C} y x) : \\\\Prop', '| F : Functor (op {C}) D', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '| isSheaf {x : Ob {C}} {s : Sieve {C} x} (isCover {C} x s) : Limit {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {D}\\n  (Comp {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {C}} {D} VPresheaf.F\\n    (Functor.op {diagram {s}})) (Functor.F {VPresheaf.F} apex) {\\n  | coneMap => \\\\lam (j : Ob {J}) => Func {VPresheaf.F} {apex} {Functor.F j} (coneMap j)\\n  | coneCoh => {?hidden}\\n}', '| C : Precat', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", '| F (Ob {C}) : Ob {D}', '\\\\class Sieve \\\\extends Presieve \\\\plevels obj >= hom \\\\hlevels  {\\n  | isSieve {z y : Ob {C}} (g : Hom {C} z y) {f : Hom {C} y x} (S {y} f) : S {z} (f \u2218 g)\\n}', '\\\\class Limit \\\\extends Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | isLimit (z : Ob {D}) : Equiv {Hom {D} z apex} {Cone {J} {D} G z} (conePullback {J} {D} {G} (\\\\new \\\\this {}) z)\\n  | limMap {z : Ob {D}} (Cone {J} {D} G z) : Hom {D} z apex\\n  | limBeta {z : Ob {D}} (c : Cone {J} {D} G z) (j : Ob {J}) : coneMap j \u2218 limMap {z} c = c.coneMap j\\n  | limUnique {z : Ob {D}} {f g : Hom {D} z apex} (\\\\Pi (j : Ob {J}) -> coneMap j \u2218 f = coneMap j \u2218 g) : f = g\\n}', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| Ob : \\\\hType', '| isCover (x : Ob) (Sieve x) : \\\\Prop', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func cone \\\\plevels obj >= hom \\\\hlevels  {this2 : Presieve} :\\nCone {Precat.op {subPrecat {SlicePrecat {C} x} {\\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)} (\\\\lam (p : \\\\Sigma (y : ObOver {C} x) (S {y.1} y.2)) => p.1)}}\\n  {Precat.op {C}} (Functor.op {diagram}) x {\\n  | coneMap => \\\\lam (p0 : Ob {J {\\\\this}}) => p0.1.2\\n} => \\\\new Cone {\\n  | coneCoh => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\func diagram \\\\plevels obj >= hom \\\\hlevels  {this1 : Presieve} : Functor (subPrecat {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)) => p.1)) Presieve.C\\n  (\\\\lam (X : Ob {Functor.C {\\\\this}}) => F (F X)) {\\n  | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) => Func {F X} {F Y} (Func {X} {Y} f)\\n} => Comp {subPrecat {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)) => p.1)} {SlicePrecat {Presieve.C} x} {Presieve.C}\\n  (forget {Presieve.C} x) (embedding {SlicePrecat {Presieve.C} x} {\\\\Sigma (y : ObOver {Presieve.C} x) (S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : Ob) (S {y.1} y.2)) => p.1))']<<<break>>>VSheaf D C1 (VPresheaf.F {p @ i}) {\n  | isSheaf => {?hidden}\n}", "completion": "\\new VSheaf {\n  | F => F {p @ i}\n  | isSheaf => \\lam {x} => (@) (prop-dpi (\\lam i => ext_coe) (isSheaf {a}) (isSheaf {a})) i {x}\n}"}
{"prompt": "['l : E', 'l<x : l < x', 'u : E', 'x<u : x < u', 'x : Rat', 'this : FramePresHom (RealPres RatField) (F (discrete Rat)) {\\n  | func => \\\\lam (p : E {Dom {\\\\this}}) (x : Rat) => \\\\Sigma (p.1 < x) (x < p.2)\\n  | func-conj => {?hidden}\\n  | func-basicCover => {?hidden}\\n  | func-image => {?hidden}\\n}']<<<break>>>[\"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>func {\\this} (l, u) x", "completion": "(l<x, x<u)"}
{"prompt": "['R : Ring', 'a : Array A.E n', 'f : Array A.E (suc n) -> B.E', 'B : LModule R', 'fl : isMultiLinear {R} {suc n} {A} {B} f', 'A : LModule R']<<<break>>>['\\\\class LinearMap \\\\extends AddGroupHom \\\\hlevels  {\\n  | R : Ring\\n  | func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x\\n}', '\\\\func insert {A3 : \\\\Type} (_ : A3) (l2 : Array A3) (_ : Fin (suc l.len)) : Array A3 (suc l.len) \\n  | {A}, a, nil, j => a :: nil\\n  | {A}, a, :: {n} b l, zero => a :: b :: l\\n  | {A}, a, :: {n} b l, suc j => b :: insert {A} a l j', '| E : \\\\Set', '| Dom : BaseSet']<<<break>>>LinearMap {R} A B {\n  | func => \\lam (x : E {Dom {\\this}}) => f (insert {A.E} x a 0)\n}", "completion": "fl a 0"}
{"prompt": "['s : \\\\Sigma R.E J.E', 'J : DecSet', 'j : J.E']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>Dec (j = s.2)", "completion": "decideEq j s.2"}
{"prompt": "['M : RingedLocale', 'f# : NatTrans {op {M.L}} {CRingCat} (F {M.R}) (F {direct_image_locale {L.L} {M.L} f L.R})', 'g# : NatTrans {op {M.L}} {CRingCat} (F {M.R}) (F {direct_image_locale {L.L} {M.L} f L.R})', 'L : RingedLocale', 'f : FrameHom M.L L.L', 'q : \\\\Pi (a : E {M.L}) -> \\\\Pi (x : E {Functor.F {VPresheaf.F {M.R}} a}) ->\\n  func {Func {VPresheaf.F {L.R}} {f.func a} {f.func a} (fromHomEq {f.Cod} {f.Dom} {f} {f} (idp {FrameHom M.L L.L} {f}) a)}\\n    (func {g#.trans a} x) = func {f#.trans a} x']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func fromHomEq \\\\hlevels  {L M : Locale} {f g : FrameHom M L} (p : f = g) (a : M.E) : f.func a L.<= g.func a \\n  => transport {FrameHom M L} (\\\\lam (h : FrameHom M L) => f.func a L.<= h.func a) {f} {g} p (L.<=-refl {f.func a})', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\class FrameHom \\\\extends SetHom \\\\hlevels  {\\n  | func-<= {x y : E {Dom}} (x <= y) : func x <= func y\\n  | func-top : func (top {Dom}) = top {Cod}\\n  | func-top>= : top {Cod} <= func (top {Dom})\\n  | func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y\\n  | func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)\\n  | func-Join {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\\\lam (j : J) => func (f j))\\n  | func-Join>= {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\\\lam (j : J) => func (f j))\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| L : Locale', '| \\\\infixl 7 * E E : E', '\\\\instance CRingCat : Cat CRing {\\n  | Hom => Hom\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => subCat {RingCat} {CRing} (\\\\new Embedding {CRing} {Ob} (\\\\lam (R : A {\\\\this}) => R) {\\n  | isEmb => \\\\lam (R S : A {\\\\this}) =>\\n  \\\\new Retraction {R = S} {f {\\\\this} R = f {\\\\this} S} (pmap {A {\\\\this}} {B {\\\\this}} (f {\\\\this}) {R} {S}) {\\n    | sec => \\\\lam (p : B {\\\\this}) => path (\\\\lam (i : I) => \\\\new CRing (E {p @ i}) {\\n      | zro => zro {p @ i}\\n      | + => (+) {p @ i}\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*) {p @ i}\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | negative => negative {p @ i}\\n      | negative-left => {?hidden}\\n      | ide => ide {p @ i}\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef {p @ i}\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n    })\\n    | f_sec => idpe {R = S}\\n  }\\n})', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\class NatTrans \\\\plevels obj >= hom >= iobj >= ihom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F : Functor C D\\n  | G : Functor C D\\n  | trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)\\n  | natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X\\n}', '| C : Precat', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)', '\\\\func functor \\\\hlevels  {this2 : FrameHom} : Functor Dom Cod func {\\n  | Func => func-<=\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '\\\\class RingedLocaleHom {\\n  | Dom : RingedLocale\\n  | Cod : RingedLocale\\n  | f : FrameHom (L {Cod}) (L {Dom})\\n  | f# : NatTrans {op {L {Cod}}} {CRingCat} (F {R {Cod}}) (F {direct_image_locale {L {Dom}} {L {Cod}} f (R {Dom})})\\n}', '| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X', '| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| R : VSheaf CRingCat L', '| func-ide : func (ide {Dom}) = ide {Cod}', '\\\\class RingHom \\\\extends SemiringHom, AddGroupHom \\\\hlevels ', '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id (X : Ob) : Hom X X', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| Ob : \\\\hType', '| func (E {Dom}) : E {Cod}', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| Func-id {X : Ob {C}} : Func {X} {X} (id {C} X) = id {D} (F X)', '| Dom : BaseSet', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>\\Pi (i : I) -> RingedLocaleHom L1 M f (\n  \\have arg => \\lam (a : E {M.L}) => path (\\lam (i : I) => (\n          \\have arg => \\lam (x : E {Functor.F {VPresheaf.F {M.R}} a}) => inv {E {Functor.F {VPresheaf.F {L.R}} (f.func a)}}\n                  {func {Func {VPresheaf.F {L.R}} {f.func a} {f.func a} (fromHomEq {L.L} {M.L} {f} {f} (idp {FrameHom M.L L.L} {f}) a)}\n                    (func {g#.trans a} x)} {func {f#.trans a} x} (q a x) *> pmap {RingHom (Functor.F {VPresheaf.F {L.R}} (f.func a)) (Functor.F {VPresheaf.F {L.R}} (f.func a))}\n                  {E {Functor.F {VPresheaf.F {L.R}} (f.func a)}}\n                  (\\lam (h : RingHom (Functor.F {VPresheaf.F {L.R}} (f.func a)) (Functor.F {VPresheaf.F {L.R}} (f.func a))) =>\n                    h.func (func {g#.trans a} x)) {Func {VPresheaf.F {L.R}} {f.func a} {f.func a} (id (f.func a))}\n                  {id (Functor.F {VPresheaf.F {L.R}} (f.func a))} (Func-id {VPresheaf.F {L.R}} {f.func a})\n          \\in \n                \\let h1 => path (\\lam (i : I) (e : E {Functor.F {VPresheaf.F {M.R}} a}) => arg e @ i)\n                \\in \\new RingHom (Functor.F {VPresheaf.F {M.R}} a) (Functor.F {VPresheaf.F {L.R}} (f.func a)) {\n                      | func => \\lam (e : E {Dom {\\this}}) => arg e @ i\n                      | func-+ => {?hidden}\n                      | func-ide => {?hidden}\n                      | func-* => {?hidden}\n                    }))\n  \\in \n        \\let h1 => path (\\lam (i : I) (X : E {M.L}) => arg X @ i)\n        \\in \\new NatTrans {Precat.op {M.L}} {CRingCat} (VPresheaf.F {M.R})\n              (Comp {Precat.op {M.L}} {Precat.op {L.L}} {CRingCat} (VPresheaf.F {L.R}) (Functor.op {functor {f}})) {\n              | trans => \\lam (X : Ob {C {\\this}}) => arg X @ i\n              | natural => {?hidden}\n            })", "completion": "\\lam i => \\new RingedLocaleHom {\n  | Dom => L\n  | Cod => M\n  | f => f\n  | f# => (exts (\\lam a => exts (\\lam x => inv (q a x) *> pmap (\\lam (h : RingHom (R {L} (f a)) (R {L} (f a))) => h (g# a x)) (Func-id {F {R {L}}} {f a}))) : f# = g#) @ i\n}"}
{"prompt": "['y : R.E', 'f : RingHom R S', 'S : CRing']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| zro-right {x : E} : x + zro = x', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set']<<<break>>>f.func y S.+ S.zro = f.func y", "completion": "zro-right {_} {f.func y}"}
{"prompt": "['this : OrderedC*AlgebraHom']<<<break>>>['\\\\lemma half<id \\\\plevels  \\\\hlevels  {a : Rat} (_ : fromInt (pos 0) < a) : half a < a ', '\\\\instance RatValuedRing \\\\hlevels  : PseudoValuedRing Rat {\\n  | isOpen => isOpen {RatNormed}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RatNormed}\\n  | dist => dist {RatNormed}\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (+)\\n  | negative => negative\\n  | norm => \\\\lam (a : E) => Real.fromRat (abs {RatField} a)\\n  | * => (RatField.*)\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n} => \\\\new PseudoValuedRing {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_* => {?hidden}\\n  | norm_ide => {?hidden}\\n}', '\\\\lemma <=_*q-left \\\\hlevels  {this : PosetQModule} {q r : Rat} (_ : q <= r) {a : E} (_ : zro <= a) : q *q a <= r *q a ', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| Cod : BaseSet', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\lemma OBall-open \\\\hlevels  {X : ExPseudoMetricSpace} {eps : Rat} {x : X.E} : X.isOpen (OBall {X} eps x) ', '\\\\lemma OBall-center \\\\hlevels  {X : ExPseudoMetricSpace} {eps : Rat} (_ : zro < eps) {x : X.E} : OBall {X} eps x x ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func IsDense \\\\hlevels  {this : OrderedC*AlgebraHom} : \\\\Prop => \\\\Pi {eps : Rat} ->\\n  zro < eps -> \\\\Pi (y : E {Cod}) -> TruncP (\\\\Sigma (x : E {Dom}) (func x - y <= eps *q ide {Cod}) (y - func x <= eps *q ide {Cod}))', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma zro<=ide \\\\hlevels  {this : OrderedC*Algebra} : zro <= ide ', '| isOpen (Set E) : \\\\Prop', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\lemma half>0 \\\\plevels  \\\\hlevels  {a : Rat} (_ : fromInt (pos 0) < a) : fromInt (pos 0) < half a ', '| E : \\\\Set', '\\\\func half \\\\plevels  \\\\hlevels  (a : Rat) : Rat => a * ratio (pos 1) 2', '| negative E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma dist_open \\\\hlevels  {X : ExPseudoMetricSpace} {U : Set X.E} :\\n  X.isOpen U <-> (\\\\Pi {x : X.E} -> U x -> TruncP (\\\\Sigma (eps : Rat) (zro < eps) (OBall {X} eps x \u2286 U))) ', '\\\\lemma negative_- \\\\hlevels  {this : AddGroup} {x y : E} : negative (x - y) = y - x ', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', '\\\\lemma toNormed \\\\hlevels  {this : OrderedC*AlgebraHom} : NormedAbGroupMap (toBanach {Dom}) (toBanach {Cod}) {\\n  | func => func\\n} ', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '\\\\func IsDense \\\\hlevels  {this : ContMap} : \\\\Prop => IsDenseSet {Cod} (\\\\lam (y : E {Cod}) => TruncP (\\\\Sigma (x : E {Dom}) (func x = y)))', '| func (E {Dom}) : E {Cod}', '\\\\func OBall \\\\hlevels  {X : ExPseudoMetricSpace} (eps : Rat) (x : X.E) : Set X.E => \\\\lam (y : X.E) => U {X.dist x y} eps', '\\\\func toBanach \\\\hlevels  {this107 : OrderedC*Algebra} : RealPreBanachAlgebra E {\\n  | isOpen => isOpen\\n  | isCauchy => isCauchy\\n  | isUniform => isUniform\\n  | dist => ExPseudoNormedAbGroup.dist\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | negative => negative\\n  | norm => OrderedC*Algebra.toBanach.norm\\n  | * => (Semigroup.*)\\n  | ide => ide\\n  | natCoef => natCoef\\n} => \\\\new RealPreBanachAlgebra {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | norm-double => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | norm_*_<= => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | norm_ide_<= => {?hidden}\\n}', '| Dom : BaseSet']<<<break>>>OrderedC*AlgebraHom.IsDense <-> ContMap.IsDense {toNormed}", "completion": "(\\lam d {y} Uo Uy => (\\case (dist_open {toBanach}).1 Uo Uy \\with {\n  | inP (eps, eps>0, Up) => \\case d (half>0 eps>0) y \\with {\n    | inP (x, xl, xr) =>\n      inP (func {this} x, inP (x, idp), Up $ inP (half eps, half<id eps>0, half>0 eps>0, xr, rewrite negative_- xl))\n  }\n}),\n  \\lam d {eps} eps>0 y => (\\case d {y} {OBall {toBanach} eps y} (OBall-open {toBanach}) (OBall-center {toBanach} eps>0) \\with {\n    | inP (_, inP (x, idp), inP (delta, delta<eps, _, y-x<=delta, x-y<=delta)) =>\n    inP (x, (rewrite negative_- in x-y<=delta) <=\u2218 <=_*q-left (<=-less {RatField} delta<eps) zro<=ide,\n      y-x<=delta <=\u2218 <=_*q-left (<=-less {RatField} delta<eps) zro<=ide)\n  }))"}
{"prompt": "['n : Nat']<<<break>>>['| zro : E', '\\\\lemma rfunc-inc \\\\plevels  \\\\hlevels  {n : Nat} : rfunc n <= rfunc (suc n) ', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', 'suc Nat', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'rfunc \\\\hlevels  (_ : Nat) : Rat \\n  | 0 => zro\\n  | suc n => ratio (pos 1) 2 * (ide + rfunc n * rfunc n)', '\\\\lemma to>=0 \\\\hlevels  {this : PosetAddGroup} {x y : E} (_ : x <= y) : zro <= y - x ', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>zro <= rfunc (suc n) - rfunc n", "completion": "to>=0 {RatField} rfunc-inc"}
{"prompt": "['e : Iso {C}', 'g : D.Hom z (F.F e.dom)', 'D : Precat', 'F : Functor C D', 'C : Cat', 'z : D.Ob']<<<break>>>['\\\\func isotoid \\\\plevels obj >= hom \\\\hlevels  {this : Cat} {a b : Ob} (e : Iso {a} {b}) : a = b => ret {univalence {a} {b}} e', '| Hom Ob Ob : \\\\Set', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| dom : Ob {C}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\lemma transport_Hom-right \\\\plevels obj >= hom \\\\hlevels  {C D : Precat} {x y : C.Ob} (p : x = y) {z : D.Ob} (F1 : Functor C D) {g : D.Hom z (F.F x)} :\\n  transport {D.Ob} (D.Hom z) {F.F x} {F.F y} (pmap {C.Ob} {D.Ob} F.F {x} {y} p) g = F.Func {x} {y} (transport {C.Ob} (C.Hom x) {x} {y} p (C.id x)) D.\u2218 g ', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| cod : Ob {C}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id (X : Ob) : Hom X X', '\\\\class Iso \\\\extends SplitMono \\\\plevels obj >= hom \\\\hlevels  {\\n  | f_hinv : f \u2218 hinv = id {C} cod\\n}', '| Ob : \\\\hType']<<<break>>>transport {D.Ob} (D.Hom z) {F.F e.dom} {F.F e.cod}\n  (pmap {C.Ob} {D.Ob} F.F {e.dom} {e.cod} (isotoid {C} {e.dom} {e.cod} (\\new e {}))) g = F.Func {e.dom} {e.cod} (transport {C.Ob} (C.Hom e.dom) {e.dom} {e.cod} (isotoid {C} {e.dom} {e.cod} (\\new e {})) (C.id e.dom)) D.\u2218 g", "completion": "transport_Hom-right (isotoid {C} e) F"}
{"prompt": "['X : CoverSpace']<<<break>>>['| cauchy-top : isCauchy (single {E -> \\\\Prop} top)', 'suc Nat', \"\\\\lemma cycle' \\\\plevels  \\\\hlevels  {n : Nat} {l : Array \\\\Prop (suc n)} (_ : DArray {suc n} (\\\\lam (i : Fin (suc n)) => l.at i -> l.at (suc i mod suc n))) : TFAE l \", '| isCauchy (Set (Set E)) : \\\\Prop', 'inP A', '| cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D', '| Cod : BaseSet', '| func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '| open-top : isOpen top', '\\\\type TFAE \\\\plevels  \\\\hlevels  (l : Array \\\\Prop) : \\\\Prop => \\\\Pi (i j : Fin l.len) -> l.at i -> l.at j', '| isSeparatedCoverSpace {x y : E} (\\\\Pi {C : Set (Set E)} -> isCauchy C -> TruncP (\\\\Sigma (U : Set E) (C U) (\\\\Sigma (U x) (U y)))) : x = y', '| isOpen (Set E) : \\\\Prop', '| at (j : Fin len) : A j', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\instance Completion \\\\hlevels  (X : CoverSpace) : CompleteCoverSpace (RegularCauchyFilter X) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X}}\\n  | isCauchy => isCCauchy {X}\\n} => \\\\new CompleteCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '| cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))', '| E : \\\\Set', '\\\\class PrecoverSpace \\\\extends TopSpace \\\\hlevels  {\\n  | isCauchy (Set (Set E)) : \\\\Prop\\n  | cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))\\n  | cauchy-top : isCauchy (single {E -> \\\\Prop} top)\\n  | cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D\\n  | cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))\\n  | cauchy-open {S : Set E} : TopSpace.isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))\\n}', '\\\\lemma isDenseEmbedding \\\\hlevels  {S : CoverSpace} : IsDenseEmbedding {completion {S}} ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\class SeparatedCoverSpace \\\\extends CoverSpace, HausdorffTopSpace \\\\hlevels  {\\n  | isSeparatedCoverSpace {x y : E} (\\\\Pi {C : Set (Set E)} -> isCauchy C -> TruncP (\\\\Sigma (U : Set E) (C U) (\\\\Sigma (U x) (U y)))) : x = y\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)', '| cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))', '\\\\func completion \\\\hlevels  {S : CoverSpace} : CoverMap S (coverSpace {S}) {\\n  | func => pointCF {S}\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| cauchy-open {S : Set E} : isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))', '\\\\class PrecoverMap \\\\extends ContMap \\\\hlevels  {\\n  | func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func IsEmbedding \\\\hlevels  {this : PrecoverMap} : \\\\Prop => \\\\Pi {C : Set (Set (E {Dom}))} -> isCauchy {Dom} C ->\\n  isCauchy {Cod} (\\\\lam (V : Set (E {Cod})) => TruncP (\\\\Sigma (U : Set (E {Dom})) (C U) (func ^-1 V \u2286 U)))', '\\\\lemma separated-char \\\\hlevels  {S : CoverSpace} {x y : S.E} :\\n  TFAE ((F {pointCF {S} x} \u2286 F {pointCF {S} y}) :: (pointCF {S} x CF~ pointCF {S} y) :: (pointCF {S} x = pointCF {S} y) :: (\\\\Pi {U : Set S.E} -> single {S.E} x <=< U <-> single {S.E} y <=< U) :: (\\\\Pi {U : Set S.E} -> single {S.E} x <=< U -> U y) :: (\\\\Pi {U V : Set S.E} -> single {S.E} x <=< U -> single {S.E} y <=< V -> TruncP (\\\\Sigma (e : S.E) ((\u2227) U V e))) :: (\\\\Pi {U V : Set S.E} -> S.isOpen U -> S.isOpen V -> U x -> V y -> TruncP (\\\\Sigma (e : S.E) ((\u2227) U V e))) :: (\\\\Pi {C : Set (Set S.E)} -> S.isCauchy C -> TruncP (\\\\Sigma (U : Set S.E) (C U) (\\\\Sigma (U x) (U y)))) :: nil) ', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func IsInj \\\\hlevels  {A B : \\\\Set} (f : A -> B) : \\\\Prop => \\\\Pi {a a' : A} -> f a = f a' -> a = a'\", '| isRegular {C : Set (Set E)} (isCauchy C) : isCauchy (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V <=< U)))', '| open-Union {S : Set (Set E)} (\\\\Pi {U : Set E} -> S U -> isOpen U) : isOpen (Union {E} S)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infixl 8 mod \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n mod m', '| func (E {Dom}) : E {Cod}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '| Dom : BaseSet']<<<break>>>TFAE (SeparatedCoverSpace X.E {\n  | isOpen => X.isOpen\n  | open-top => {?hidden}\n  | open-inter => {?hidden}\n  | open-Union => {?hidden}\n  | isCauchy => X.isCauchy\n  | cauchy-cover => {?hidden}\n  | cauchy-top => {?hidden}\n  | cauchy-refine => {?hidden}\n  | cauchy-glue => {?hidden}\n  | cauchy-open => {?hidden}\n  | isRegular => {?hidden}\n} :: (\\Pi {Y : PrecoverSpace} -> \\Pi {f : PrecoverMap X Y} -> IsEmbedding {f} -> IsInj {X.E} {Y.E} f.func) :: IsInj {X.E} {E {Cod {completion {X}}}} (func {completion {X}}) :: TruncP (\\Sigma (Y : SeparatedCoverSpace) (f : PrecoverMap X Y) (IsInj {X.E} {Y.E} f.func)) :: nil)", "completion": "cycle' (later (\\lam Xs {_} {f} fe {x} {x'} fx=fx' =>\n  isSeparatedCoverSpace {Xs} $ separated-char 4 7 (\\lam x<=<U => (\\case cauchy-cover (fe x<=<U) (f x) \\with {\n    | inP (V, inP (W, h, p), Vfx) => h (x, (idp, p Vfx)) (p $ rewrite fx=fx' in Vfx)\n  })), \\lam c => c isDenseEmbedding.2, \\lam ci => inP (Completion X, completion, ci), \\lam p0 => (\\case \\elim p0 \\with {\n    | inP (Y, f, fi) => \\new SeparatedCoverSpace {\n      | isSeparatedCoverSpace => \\lam c => fi $ isSeparatedCoverSpace (\\lam Cc => (\\case c (func-cover Cc) \\with {\n        | inP (U, inP (V, CV, p), (Ux, Uy)) => inP (V, CV, (rewrite p in Ux, rewrite p in Uy))\n      }))\n    }\n  })))"}
{"prompt": "[\"p : V = mkSet {X} V'\", 'F : RegularCauchyFilter X', 'V : Set (RegularCauchyFilter X)', 'X : UniformSpace', 'VF : V F', \"V' : Set X.E\"]<<<break>>>[\"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\func mkSet \\\\hlevels  {X : CoverSpace} (U : Set X.E) : Set (RegularCauchyFilter X) => \\\\lam (F1 : RegularCauchyFilter X) => F.F U']<<<break>>>mkSet {X} V' F", "completion": "rewrite p VF"}
{"prompt": "['this : CoverSpace X {\\n  | isOpen => \\\\lam (U : Set E) => TruncP (\\\\Sigma (V : Set Y.E) (Y.isOpen V) (U = f ^-1 V))\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | isCauchy => isCauchy\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n}', 'Y : CoverSpace', 'X : \\\\Set', 'f : X -> Y.E']<<<break>>>['\\\\func PrecoverTransfer \\\\hlevels  {X : \\\\Set} {Y : PrecoverSpace} (f : X -> Y.E) : PrecoverSpace X {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => \\\\lam (C : Set (Set (E {\\\\this}))) =>\\n    Y.isCauchy (\\\\lam (V : Set Y.E) => TruncP (\\\\Sigma (U : Set (E {\\\\this})) (C U) (f ^-1 V \u2286 U)))\\n} => \\\\new PrecoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n}', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {C : Set (Set (E {\\this}))} -> isCauchy C -> \\Pi (x : E) -> TruncP (\\Sigma (U : Set E) (C U) (U x))", "completion": "\\lam {C} => cauchy-cover {PrecoverTransfer f}"}
{"prompt": "['e : Equiv {(\\\\case inl {\\\\Sigma (n : Nat) (a b : R.E) (R.isHomogen a (suc n)) (R.isHomogen b (suc n))} {Nat} s \\\\with {\\n  | inl (n, a, b, ah, bh) =>\\n    (Bool, (a R.+ b, n, R.homogen-+ {suc n} {a} {b} ah bh), \\\\lam (p0 : Bool) => if {Carrier R} p0 (a, n, ah) (b, n, bh))\\n  | inr n => (Empty, (R.zro, n, R.homogen-zro {suc n}), absurd {\\\\Sigma (a : R.E) (n : Nat) (R.isHomogen a (suc n))})\\n}).1} {J}', 'u : Nat', 'ac : contains (pow {S} a.1 u)', 'l0 : Nat', 'a : Ob', 'f : J -> E', 'R : GradedCRing', 'l1 : Nat']<<<break>>>['true', '| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', 'false', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\lemma closure2-lem \\\\hlevels  {R : CRing} {a : R.E} (f : Bool -> R.E) : contains a <-> TruncP (\\\\Sigma (c d : R.E) (a = f true R.* c R.+ f false R.* d)) ', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>TruncP (\\Sigma (c d : R.E)\n  (pow {R} a.1 u = if {R.E} true (pow {R} (a.1 R.* (f1 (e.f true)).1) l0) (pow {R} (a.1 R.* (f1 (e.f false)).1) l1) R.* c R.+ if {R.E} false (pow {R} (a.1 R.* (f1 (e.f true)).1) l0) (pow {R} (a.1 R.* (f1 (e.f false)).1) l1) R.* d))", "completion": "(closure2-lem (\\lam p0 => if p0 _ _)).1 ac"}
{"prompt": "['M : Matrix R.E n n', 'n : Nat', 'R : CRing']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 6 + E E : E', '\\\\func BigProd \\\\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l', '\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', 'padd (Poly R) R.E', '\\\\type Sym \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => Equiv {Fin n} {Fin n}', '| \\\\infixl 7 * E E : E', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func sign \\\\hlevels  {R : Ring} {n : Nat} (e : Sym n) : R.E => pow {R} (R.negative R.ide) (inversions {n} e)', '| at (j : Fin len) : A j', '\\\\lemma func-FinSum {A B : AbMonoid} (f : AddMonoidHom A B) {J : FinSet} {a : J.E -> A.E} :\\n  f.func (FinSum {A} {J} a) = FinSum {B} {J} (\\\\lam (j : J.E) => f.func (a j)) ', '| E : \\\\Set', '| negative E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\instance PolyAlgebra \\\\hlevels  (R1 : CRing) : CAlgebra R1 (Poly R1) {\\n  | zro => pzero {R1}\\n  | + => (+)\\n  | negative => negative {R1}\\n  | *c => (*c)\\n  | * => (*)\\n  | ide => padd {R1} (pzero {R1}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R1} (pzero {R1}) (R.natCoef n)\\n  | coefMap => coefMap-impl\\n} => \\\\new CAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| ide : E', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', 'FinSum {this : AbMonoid} {A : FinSet} (x : A.E -> E) : E => (aux {A} {x}).1', '| zro : E', '\\\\instance SymFin (n : Nat) : FinSet (Sym n) {\\n  | finCard => fac n\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case finEq {\\\\this} \\\\with {\\n    | inP e => \\\\case decideEq (e.ret x) (e.ret y) \\\\with {\\n      | yes q => yes {x = y} (isInj {symQEquiv {Fin (finCard {\\\\this})} {E {\\\\this}} (fromEquiv e)} {x} {y} q)\\n      | no q => no {x = y} (\\\\lam (p : x = y) => q (pmap {E {\\\\this}} {Fin (finCard {\\\\this})} e.ret {x} {y} p))\\n    }\\n  })\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '| func (E {Dom}) : E {Cod}', '\\\\func polyCoefHom \\\\hlevels  {R : Ring} {n : Nat} : AddGroupHom (PolyRing R) R {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => polyCoef {R} p0 n\\n} => \\\\new AddGroupHom {\\n  | func-+ => {?hidden}\\n}', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>func {polyCoefHom {R} {n}}\n  (FinSum {PolyRing R} {SymFin n} (\\lam (e : Sym n) => sign {PolyAlgebra R} {n} e * BigProd {PolyAlgebra R}\n    (\\new Array (Poly R) n (\\lam (j : Fin n) => padd {R} ide R.zro * padd {R} zro (\\case decideEq (f {e} j) j \\with {\n      | yes p => R.ide\n      | no n => R.zro\n    }) + negative (padd {R} zro (at {at {M} (f {e} j)} j)))))) = FinSum {R} {SymFin n} (\\lam (j : E {SymFin n}) =>\n  func {polyCoefHom {R} {n}} ((\\lam (e : Sym n) => sign {PolyAlgebra R} {n} e * BigProd {PolyAlgebra R}\n    (\\new Array (Poly R) n (\\lam (j : Fin n) => padd {R} ide R.zro * padd {R} zro (\\case decideEq (f {e} j) j \\with {\n      | yes p => R.ide\n      | no n => R.zro\n    }) + negative (padd {R} zro (at {at {M} (f {e} j)} j))))) j))", "completion": "func-FinSum polyCoefHom"}
{"prompt": "['a2_u : IsCoprime {R} a2 u', 'u : R.E', 'a2 : R.E', 'R : Dec']<<<break>>>['| val1 : E {M}', '| ide-left {x : E} : ide * x = x', '\\\\func =>gcd \\\\hlevels  {M1 : CMonoid} {x y : M.E} (c : IsCoprime {M1} x y) :\\nGCD {M1} x y M.ide (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val1 {\\\\this}) x {\\n  | inv-right => {?hidden}\\n})\\n  (\\\\new LDiv {M {\\\\this}} (res {\\\\this}) (val2 {\\\\this}) y {\\n    | inv-right => {?hidden}\\n  })\\n  (\\\\lam (g : E {M {\\\\this}}) (g|x : LDiv {M {\\\\this}} g (val1 {\\\\this})) (g|y : LDiv {M {\\\\this}} g (val2 {\\\\this})) => (\\n    \\\\have i => c g g|x g|y\\n    \\\\in \\\\new LDiv {M {\\\\this}} g (res {\\\\this}) i.inv {\\n          | inv-right => {?hidden}\\n        })) => \\\\new GCD', '| res : E {M}', '\\\\class GCD \\\\hlevels  {\\n  | M : CMonoid\\n  | val1 : E {M}\\n  | val2 : E {M}\\n  | res : E {M}\\n  | res|val1 : LDiv {M} res val1\\n  | res|val2 : LDiv {M} res val2\\n  | res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res\\n}', '| ide : E', '| val2 : E {M}', '| E : \\\\Set', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '| inv : E {M}', '| inv-right : val * inv = elem', '| M : CMonoid']<<<break>>>GCD {R} a2 u R.ide (\\new LDiv {M {\\this}} (res {\\this}) (val1 {\\this}) a2 {\n  | inv-right => {?hidden}\n})\n  (\\new LDiv {M {\\this}} (res {\\this}) (val2 {\\this}) u {\n    | inv-right => {?hidden}\n  })\n  (\\lam (g : E {M {\\this}}) (g|x : LDiv {M {\\this}} g (val1 {\\this})) (g|y : LDiv {M {\\this}} g (val2 {\\this})) => (\n    \\have i => a2_u g g|x g|y\n    \\in \\new LDiv {M {\\this}} g (res {\\this}) i.inv {\n          | inv-right => {?hidden}\n        }))", "completion": "=>gcd a2_u"}
{"prompt": "['h1 : (\\\\lam (e : X.E) => func {adjointMap {X} {Y} f} (embed {X} e)) = f.func', 'this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F {\\n  | Func => FrameUnitalSubcat.Func\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n  | reflector => PresentedFrame\\n  | reflectorMap => FrameReflectiveSubcat.reflectorMap\\n  | isReflective => \\\\lam {X : Ob {D {\\\\this}}} {Y : Ob {C {\\\\this}}} =>\\n  \\\\new QEquiv {Hom {C {\\\\this}} (reflector {\\\\this} X) Y} {Hom {D {\\\\this}} X (Functor.F {\\\\this} Y)}\\n    (\\\\lam (p0 : A {\\\\this}) => Functor.Func {\\\\this} {reflector {\\\\this} X} {Y} p0 \u2218 ReflectiveSubPrecat.reflectorMap {\\\\this} X) {\\n    | ret => adjointMap {X} {Y}\\n    | ret_f => \\\\lam (f1 : A {\\\\this}) => path (\\\\lam (i : I) => (\\n      \\\\have arg => \\\\lam (U : Opens X) => (\\n              \\\\let | g => \\\\lam (q : \\\\Sigma (x : X.E) (U.1 x)) => func {FrameReflectiveSubcat.reflectorMap X} q.1\\n                   | t => path (\\\\lam (i : I) => (\\n                     \\\\have arg => \\\\lam (x : X.E) => propExt {U.1 x}\\n                             {Cover {X} x {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                               (\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2)}\\n                             (\\\\lam (u : U.1 x) =>\\n                             cover-inj {X} {x} {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                               {\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2}\\n                               ((x, u), x, cover-inj {X} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x} () (idp {X.E} {x})) (idp {X.E} {x}))\\n                             (closure<= {X} {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                               {\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2}\\n                               {U}\\n                               (\\\\lam (t : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) =>\\n                               cover-trans {X} {t.2} {\\\\Sigma (x : X.E) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : X.E) (U.1 x)) => t.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => t.1.1} t.3 (\\\\lam (_ : \\\\Sigma) =>\\n                                 cover-inj {X} {t.1.1} {\\\\Sigma (x : X.E) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : X.E) (U.1 x)) => t.1} t.1 (idp {X.E} {t.1.1})))\\n                               {x})\\n                     \\\\in \\n                           \\\\let h1 => path (\\\\lam (i : I) (e : X.E) => arg e @ i)\\n                           \\\\in (\\\\lam (e : X.E) => arg e @ i,\\n                                 prop-dpi (\\\\lam (i : I) => \\\\Pi (x : X.E) -> SCover {X} x (h1 @ i) -> (@) h1 i x) U.2 (Join {\\\\Sigma (x : X.E) (U.1 x)} g).2 @ i)))\\n              \\\\in transportInv {Opens X} (\\\\lam (x : Opens X) =>\\n                    func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} x = f.func x)\\n                    {U} {Join {\\\\Sigma (x : X.E) (U.1 x)} g} t\\n                    (func-Join {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)}\\n                      {\\\\Sigma (x : X.E) (U.1 x)} {g} *> inv {Y.E} {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j))}\\n                      {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                        func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} (g j))}\\n                      (pmap {\\\\Sigma (x : X.E) (U.1 x) -> Y.E} {Y.E} (Y.Join {\\\\Sigma (x : X.E) (U.1 x)})\\n                        {\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j)} {\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                          func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} (g j)}\\n                        (path (\\\\lam (i : I) (_x : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                          (pmap {Opens X} {Y.E} f.func {func {FrameReflectiveSubcat.reflectorMap X} _x.1}\\n                            {Join {\\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)}\\n                              (\\\\lam (q : \\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)) => embed {X} q.1)}\\n                            (element_join {X} {func {FrameReflectiveSubcat.reflectorMap X} _x.1}) *> f.func-Join {\\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)}\\n                            {\\\\lam (j : \\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)) =>\\n                            (\\\\lam (p0 : X.E) => Cover {X} p0 {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1),\\n                              \\\\lam (x : X.E) (c : SCover {X} x (\\\\lam (p0 : X.E) => Cover {X} p0 {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) =>\\n                                cover-trans {X} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))} {\\\\lam (t : \\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) => t.1} c (\\\\lam (p0 : \\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) => p0.2))}) @ i))) *> inv {Y.E} {f.func (Join {\\\\Sigma (x : X.E) (U.1 x)} g)}\\n                      {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j))}\\n                      (f.func-Join {\\\\Sigma (x : X.E) (U.1 x)} {g})))\\n      \\\\in \\n            \\\\let h1 => path (\\\\lam (i : I) (e : Opens X) => arg e @ i)\\n            \\\\in \\\\new FrameHom (reflector {\\\\this} X) Y {\\n                  | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                  | func-<= => {?hidden}\\n                  | func-top => {?hidden}\\n                  | func-top>= => {?hidden}\\n                  | func-meet => {?hidden}\\n                  | func-meet>= => {?hidden}\\n                  | func-Join => {?hidden}\\n                  | func-Join>= => {?hidden}\\n                }))\\n    | f_sec => \\\\lam (f1 : B {\\\\this}) => path (\\\\lam (i : I) => (\\n      \\\\have arg => adjointMap_embed {X} {Y} f1\\n      \\\\in \\n            \\\\let h1 => path (\\\\lam (i : I) (e : X.E) => arg e @ i)\\n            \\\\in \\\\new FramePresHom X (Functor.F {\\\\this} Y) {\\n                  | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                  | func-conj => {?hidden}\\n                  | func-basicCover => {?hidden}\\n                  | func-image => {?hidden}\\n                }))\\n  }\\n}', 'X : Ob {D {\\\\this}}', 'Y : Ob {C {\\\\this}}', 'this : QEquiv {Hom {C {\\\\this}} (reflector {\\\\this} X) Y} {Hom {D {\\\\this}} X (Functor.F {\\\\this} Y)}\\n  (\\\\lam (p0 : A {\\\\this}) => Functor.Func {\\\\this} {reflector {\\\\this} X} {Y} p0 \u2218 ReflectiveSubPrecat.reflectorMap {\\\\this} X) {\\n  | ret => adjointMap {X} {Y}\\n  | ret_f => \\\\lam (f1 : A {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => \\\\lam (U : Opens X) => (\\n            \\\\let | g => \\\\lam (q : \\\\Sigma (x : X.E) (U.1 x)) => func {FrameReflectiveSubcat.reflectorMap X} q.1\\n                 | t => path (\\\\lam (i : I) => (\\n                   \\\\have arg => \\\\lam (x : X.E) => propExt {U.1 x}\\n                           {Cover {X} x {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                             (\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2)}\\n                           (\\\\lam (u : U.1 x) =>\\n                           cover-inj {X} {x} {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                             {\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2}\\n                             ((x, u), x, cover-inj {X} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x} () (idp {X.E} {x})) (idp {X.E} {x}))\\n                           (closure<= {X} {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                             {\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2}\\n                             {U}\\n                             (\\\\lam (t : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) =>\\n                             cover-trans {X} {t.2} {\\\\Sigma (x : X.E) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : X.E) (U.1 x)) => t.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => t.1.1} t.3 (\\\\lam (_ : \\\\Sigma) =>\\n                               cover-inj {X} {t.1.1} {\\\\Sigma (x : X.E) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : X.E) (U.1 x)) => t.1} t.1 (idp {X.E} {t.1.1})))\\n                             {x})\\n                   \\\\in \\n                         \\\\let h1 => path (\\\\lam (i : I) (e : X.E) => arg e @ i)\\n                         \\\\in (\\\\lam (e : X.E) => arg e @ i,\\n                               prop-dpi (\\\\lam (i : I) => \\\\Pi (x : X.E) -> SCover {X} x (h1 @ i) -> (@) h1 i x) U.2 (Join {\\\\Sigma (x : X.E) (U.1 x)} g).2 @ i)))\\n            \\\\in transportInv {Opens X} (\\\\lam (x : Opens X) =>\\n                  func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} x = f.func x)\\n                  {U} {Join {\\\\Sigma (x : X.E) (U.1 x)} g} t\\n                  (func-Join {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)}\\n                    {\\\\Sigma (x : X.E) (U.1 x)} {g} *> inv {Y.E} {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j))}\\n                    {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                      func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} (g j))}\\n                    (pmap {\\\\Sigma (x : X.E) (U.1 x) -> Y.E} {Y.E} (Y.Join {\\\\Sigma (x : X.E) (U.1 x)})\\n                      {\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j)} {\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                        func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} (g j)}\\n                      (path (\\\\lam (i : I) (_x : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                        (pmap {Opens X} {Y.E} f.func {func {FrameReflectiveSubcat.reflectorMap X} _x.1}\\n                          {Join {\\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)}\\n                            (\\\\lam (q : \\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)) => embed {X} q.1)}\\n                          (element_join {X} {func {FrameReflectiveSubcat.reflectorMap X} _x.1}) *> f.func-Join {\\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)}\\n                          {\\\\lam (j : \\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)) =>\\n                          (\\\\lam (p0 : X.E) => Cover {X} p0 {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1),\\n                            \\\\lam (x : X.E) (c : SCover {X} x (\\\\lam (p0 : X.E) => Cover {X} p0 {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) =>\\n                              cover-trans {X} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))} {\\\\lam (t : \\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) => t.1} c (\\\\lam (p0 : \\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) => p0.2))}) @ i))) *> inv {Y.E} {f.func (Join {\\\\Sigma (x : X.E) (U.1 x)} g)}\\n                    {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j))}\\n                    (f.func-Join {\\\\Sigma (x : X.E) (U.1 x)} {g})))\\n    \\\\in \\n          \\\\let h1 => path (\\\\lam (i : I) (e : Opens X) => arg e @ i)\\n          \\\\in \\\\new FrameHom (reflector {\\\\this} X) Y {\\n                | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                | func-<= => {?hidden}\\n                | func-top => {?hidden}\\n                | func-top>= => {?hidden}\\n                | func-meet => {?hidden}\\n                | func-meet>= => {?hidden}\\n                | func-Join => {?hidden}\\n                | func-Join>= => {?hidden}\\n              }))\\n  | f_sec => \\\\lam (f1 : B {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => adjointMap_embed {X} {Y} f1\\n    \\\\in \\n          \\\\let h1 => path (\\\\lam (i : I) (e : X.E) => arg e @ i)\\n          \\\\in \\\\new FramePresHom X (Functor.F {\\\\this} Y) {\\n                | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                | func-conj => {?hidden}\\n                | func-basicCover => {?hidden}\\n                | func-image => {?hidden}\\n              }))\\n}', 'f : B {\\\\this}']<<<break>>>['\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', '| func-image {y : E {Cod}} : Cover {Cod} y {E {Dom}} func', '| f A : B', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| sec B : A', '| E : \\\\Set', '| F (Ob {C}) : Ob {D}']<<<break>>>Path (\\lam (i : I) => \\Pi {y : E {F {\\this} Y}} -> Cover {F {\\this} Y} y {X.E} (h1 @ i))\n  (func-image {f {\\this} (sec {\\this} f1)}) f.func-image", "completion": "prop-dpi (\\lam i => ext_coe) (func-image {Func {PresentedFrame X} {Y} (adjointMap {X} {Y} f) \u2218 reflectorMap X}) (func-image {f})"}
{"prompt": "[\"d : CRingData {R} (t' :: B !! 0 !! 0 :: s' :: u' :: B !! 1 !! 1 :: v' :: at {A} 0 !! 0 :: u :: at {A} 1 !! 0 :: v :: s :: t :: nil) {\\n  | interpretNF_negate => {?hidden}\\n}\", 't : R.E', 'B : Matrix R.E 2 2', \"t' : R.E\", 'R : CRing', \"s' : R.E\", 'p : at {at {A} 0} 0 R.* u = at {at {A} 1} 0 R.* v', \"v' : R.E\", 'v : R.E', 'u : R.E', \"p' : at {at {B} 0} 0 R.* u' = at {at {B} 1} 1 R.* v'\", \"q' : s' R.* u' R.+ t' R.* v' = R.ide\", \"u' : R.E\", 'A : Matrix R.E 2 2', 's : R.E', 'q : s R.* u R.+ t R.* v = R.ide']<<<break>>>['| \\\\infixl 6 + E E : E', '| C : Semiring', 'coef C', 'nil', '\\\\func map {A1 B2 : \\\\Type} (_ : A1 -> B2) (_ : List A1) : List B2 \\n  | {A}, {B}, f, nil => nil {B}\\n  | {A}, {B}, f, a :: l => f a :: map {A} {B} f l', '| \\\\infixl 7 * E E : E', '| at (j : Fin len) : A j', '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', '| E : \\\\Set', '| negative E : E', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idealElem \\\\hlevels  {R2 : CRing} (_ : List (\\\\Sigma R.E R.E)) : R.E \\n  | {R}, nil => R.zro\\n  | {R}, (c, gen) :: xs => c R.* gen R.+ idealElem {R} xs', '| ide : E', '\\\\infixl 7 :* (_ _ : RingTerm C V)', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', 'pos Nat', '| zro : E', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\field mData : MonoidData {R} vars', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'var V', '\\\\infixr 5 :: A (List A)']<<<break>>>idealElem {R}\n  (map {\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\Sigma R.E R.E} (\\lam (x : \\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\n    ((interpret {d} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 0)),\n      at {at {A} 0} 0 R.* u R.+ R.negative (at {at {A} 1} 0 R.* v),\n      toZero {R} {at {at {A} 0} 0 R.* u} {at {at {A} 1} 0 R.* v} p) :: (interpret {d} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 0)), s R.* u R.+ t R.* v R.+ R.negative R.ide,\n        toZero {R} {s R.* u R.+ t R.* v} {R.ide} q) :: (interpret {d}\n          (:negative {E {d.C}} {Fin (len {vars {d.mData}})} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 1)) :* var {E {d.C}} {Fin (len {vars {d.mData}})} 0 :* var {E {d.C}} {Fin (len {vars {d.mData}})} 2),\n          at {at {B} 0} 0 R.* u' R.+ R.negative (at {at {B} 1} 1 R.* v'),\n          toZero {R} {at {at {B} 0} 0 R.* u'} {at {at {B} 1} 1 R.* v'} p') :: (interpret {d} (coef {E {d.C}} {Fin (len {vars {d.mData}})} (pos 0)), s' R.* u' R.+ t' R.* v' R.+ R.negative R.ide,\n            toZero {R} {s' R.* u' R.+ t' R.* v'} {R.ide} q') :: nil {\\Sigma R.E (gen : R.E) (gen = R.zro)})) = R.zro", "completion": "gensZeroToIdealZero ((interpret {d} (coef 0), A !! 0 !! 0 R.* u + negative (A !! 1 !! 0 R.* v),\n  toZero {R} {A !! 0 !! 0 R.* u} {A !! 1 !! 0 R.* v} p) :: (interpret {d} (coef 0), s R.* u R.+ t R.* v + negative R.ide, toZero {R} {s R.* u R.+ t R.* v} {R.ide} q) :: (interpret {d} (:negative (coef 1) :* var 0 :* var 2), B !! 0 !! 0 R.* u' + negative (B !! 1 !! 1 R.* v'),\n    toZero {R} {B !! 0 !! 0 R.* u'} {B !! 1 !! 1 R.* v'} p') :: (interpret {d} (coef 0), s' R.* u' R.+ t' R.* v' + negative R.ide, toZero {R} {s' R.* u' R.+ t' R.* v'} {R.ide} q') :: nil)"}
{"prompt": "['context-a : List env.Sort', 'env : FSignature', 'context-add : List env.Sort', 'sublist : SubList {env.Sort} context-a context-b', 'ms : MetaContext env.Sort', 'context-b : List env.Sort', 'fin : Index {env.Sort} context-add']<<<break>>>['\\\\func append-context-right \\\\hlevels  {env3 : FSignature} {old-context2 new-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Substitution {env3} old-context2 new-context3 mc3) {additional-context3 : List env.Sort}\\n  (index2 : Index {env.Sort} (old-context2 ++ additional-context3)) :\\n  Term env3 (new-context3 ++ additional-context3) ((old-context2 ++ additional-context3) !! index2) mc3 \\n  | {env}, {nil}, {new-context}, {mc}, subst, {additional-context}, index =>\\n  weakening {env} {(nil {env.Sort} ++ additional-context) !! index} {additional-context} {new-context ++ additional-context} {mc}\\n    (var {env} {additional-context} {(nil {env.Sort} ++ additional-context) !! index} {mc} index\\n      (idp {env.Sort} {(nil {env.Sort} ++ additional-context) !! index}))\\n    (id+left {env.Sort} {additional-context} {new-context})\\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, zero =>\\n  weakening {env} {((a :: old-context) ++ additional-context) !! 0} {new-context} {new-context ++ additional-context} {mc} (subst 0)\\n    (id+right {env.Sort} {new-context} {additional-context})\\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, suc index => append-context-right\\n    {env} {old-context} {new-context} {mc} (\\\\lam (i : Index {env.Sort} old-context) => subst (suc i)) {additional-context}\\n      index', '\\\\func substitution \\\\hlevels  {env : FSignature} {narrow-context wide-context : List env.Sort}\\n  (sublist : SubList {env.Sort} narrow-context wide-context) {ms : MetaContext env.Sort} :\\n  Substitution {env} narrow-context wide-context ms \\n=> \\\\lam (i : Index {env.Sort} narrow-context) => weakening {env} {narrow-context !! i} {narrow-context} {wide-context} {ms}\\n  (var {env} {narrow-context} {narrow-context !! i} {ms} i (idp {env.Sort} {narrow-context !! i})) sublist', '\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', '| Sort : \\\\Set', \"\\\\func weakening \\\\hlevels  {env3 : FSignature} {s'3 : env.Sort} {narrow-context3 wide-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Term env3 narrow-context3 s'3 mc3) (_ : SubList {env.Sort} narrow-context3 wide-context3) :\\n  Term env3 wide-context3 s'3 mc3 \\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, var index p, sublist =>\\n  var {env} {wide-context} {s'} {mc} (shift-index {env.Sort} {narrow-context} {wide-context} sublist index)\\n    (proof {env.Sort} {narrow-context} {wide-context} {s'} sublist index p)\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, metavar m arguments, sublist =>\\n  metavar {env} {wide-context} {s'} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s'} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s'} m)) => Term env wide-context (mc.m-domain {s'} m !! index) mc)\\n    (\\\\lam (i1 : Fin (MetaContext.arity {mc} {s'} m)) =>\\n      weakening {env} {mc.m-domain {s'} m !! i1} {narrow-context} {wide-context} {mc} (arguments.at i1) sublist))\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, func f arguments, sublist =>\\n  func {env} {wide-context} {s'} {mc} f (\\\\new DArray {FSignature.arity {env} {s'} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s'} f)) => Term env (wide-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i1 : Fin (FSignature.arity {env} {s'} f)) =>\\n    weakening {env} {f !!sort i1} {narrow-context ++ f !!domain i1} {wide-context ++ f !!domain i1} {mc} (arguments.at i1)\\n      (extend-right-both {env.Sort} {narrow-context} {wide-context} sublist {f !!domain i1})))\", 'var (index : Index {env.Sort} context) (termSort = context !! index)', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\func expand-fin-right {A1 : \\\\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \\n  | {A}, {nil}, {b}, i => i\\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma on-end \\\\hlevels  {env : FSignature} {old-context new-context : List env.Sort} {mc : MetaContext env.Sort}\\n  {additional-context : List env.Sort} (subst : Substitution {env} old-context new-context mc)\\n  (index : Index {env.Sort} additional-context) :\\nappend-context-right {env} {old-context} {new-context} {mc} subst {additional-context}\\n  (expand-fin-right {env.Sort} {old-context} {additional-context} index) = weakening {env} {(old-context ++ additional-context) !! expand-fin-right {env.Sort} {old-context} {additional-context} index}\\n  {additional-context} {new-context ++ additional-context} {mc} (var {env} {additional-context}\\n    {(old-context ++ additional-context) !! expand-fin-right {env.Sort} {old-context} {additional-context} index} {mc} index\\n    (correct {env.Sort} {old-context} {additional-context} index)) (id+left {env.Sort} {additional-context} {new-context}) ', '\\\\func id+left {A : \\\\Type} {i l : List A} : SubList {A} i (l ++ i) => extend-left-single {A} {i} {i} (identity {A} {i}) {l}', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func correct {A2 : \\\\Type} {a b2 : List A2} (i2 : Index {A2} b2) : (a ++ b2) !! expand-fin-right {A2} {a} {b2} i2 = b2 !! i2 \\n  | {A}, {nil}, {b}, i => idp {A} {(nil {A} ++ b) !! expand-fin-right {A} {nil {A}} {b} i}\\n  | {A}, {a :: a1}, {b}, i => correct {A} {a1} {b} i']<<<break>>>append-context-right\n{env} {context-a} {context-b} {ms} (substitution {env} {context-a} {context-b} sublist {ms}) {context-add}\n  (expand-fin-right {env.Sort} {context-a} {context-add} fin) = weakening {env} {(context-a ++ context-add) !! expand-fin-right {env.Sort} {context-a} {context-add} fin} {context-add}\n  {context-b ++ context-add} {ms}\n  (var {env} {context-add} {(context-a ++ context-add) !! expand-fin-right {env.Sort} {context-a} {context-add} fin} {ms} fin\n    (correct {env.Sort} {context-a} {context-add} fin)) (id+left {env.Sort} {context-add} {context-b})", "completion": "on-end _ _"}
{"prompt": "['R : SmithDomain', 'A : Matrix R.E n m', 'p : k < n', 'm : Nat', 'n : Nat', 'k : Nat', 'q : k < m']<<<break>>>['| \\\\infix 4 > E E : \\\\Prop', '\\\\func DivPreoder \\\\hlevels  (M : CMonoid) : Preorder M.E {\\n  | <= => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => TruncP (LDiv {M} y x)\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', '\\\\field trichotomy (x y : E) : Tri x y', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '| <_meet-univ {x y z : E} (x < y) (x < z) : x < y \u2227 z', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '\\\\func fin-inc_<= \\\\plevels  \\\\hlevels  {n m : Nat} (p : n <= m) (i : Fin n) : Fin m => toFin i {m} {?hidden}', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set', '| \\\\infix 4 ~ A A : \\\\Prop', '\\\\func EquivRel \\\\hlevels  {this2 : Preorder} : Equivalence E {\\n  | ~ => \\\\lam (x : A {\\\\this}) (y : A {\\\\this}) => \\\\Sigma (x <= y) (y <= x)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", 'in~ A', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func toFin \\\\plevels  \\\\hlevels  (k1 : Nat) {n1 : Nat} (\\\\property _ : k1 < n1) : Fin n1 \\n  | 0, {suc n}, p => 0\\n  | suc k, {suc n}, p => suc (toFin k {n} {?hidden})', '\\\\lemma toFin=id \\\\plevels  \\\\hlevels  {k n : Nat} {p : k < n} : toFin k {n} {?hidden} = k ', \"\\\\data Tri \\\\hlevels  {A : StrictPoset} (_ _ : A.E) \\n  | less (a A.< a')\\n  | equals (a = a')\\n  | greater (a A.> a')\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '\\\\lemma fin_nat-inj \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : x = y) : x = y ', '| \\\\infix 4 < E E : \\\\Prop', '| zro : E', '| meet-left {x y : E} : x \u2227 y <= x', '\\\\func inD \\\\hlevels  {M : CMonoid} (x : M.E) : DivQuotient M => in~ {E} {(~)} x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma divQuotient_un0 \\\\hlevels  {this : CSemiring} {a : E} (_ : in~ {E} {(~)} a = in~ {E} {(~)} zro) : a = zro ', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>(\\lam (x : Quotient {R.E} (~)) => x = in~ {R.E} {(~)} R.zro <-> A !! toFin k {n} {?hidden} !! toFin k {m} {?hidden} = R.zro)\n(inD {R} (at {at {A} (fin-inc_<= {\\case trichotomy n m \\with {\n  | less _x => n\n  | equals p => n\n  | greater _x => m\n}} {n} (meet-left {n} {m}) (toFin k {\\case trichotomy n m \\with {\n  | less _x => n\n  | equals p => n\n  | greater _x => m\n}} {?hidden}))}\n  (fin-inc_<= {\\case trichotomy n m \\with {\n    | less _x => n\n    | equals p => n\n    | greater _x => m\n  }} {m} (meet-right {n} {m}) (toFin k {\\case trichotomy n m \\with {\n    | less _x => n\n    | equals p => n\n    | greater _x => m\n  }} {?hidden}))))", "completion": "(\\lam c => pmap2 (\\lam i => A i) (later $ fin_nat-inj $ toFin=id *> inv toFin=id *> inv toFin=id)\n  (later $ fin_nat-inj $ toFin=id *> inv toFin=id *> inv toFin=id) *> divQuotient_un0 {R} c,\n  \\lam c => pmap in~ (pmap2 (\\lam i => A i) (later $ fin_nat-inj $ toFin=id *> toFin=id *> inv toFin=id)\n    (later $ fin_nat-inj $ toFin=id *> toFin=id *> inv toFin=id) *> c))"}
{"prompt": "['A : LModule R', 'B : LModule R', 'c : R.E', 'R : CRing', 'f : LinearMap {R} A B']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\class LinearMap \\\\extends AddGroupHom \\\\hlevels  {\\n  | R : Ring\\n  | func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x\\n}', '| Cod : BaseSet', '| R : Ring', '| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infixl 7 *c (E {R}) E : E', '| func-+ {x y : E {Dom}} : func (x + y) = func x + func y', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '| *c-ldistr {r : E {R}} {a b : E} : r *c (a + b) = r *c a + r *c b', \"| *c-assoc {r r' : E {R}} {a : E} : r * r' *c a = r *c (r' *c a)\"]<<<break>>>LinearMap {R1} A B {\n  | func => \\lam (a : E {Dom {\\this}}) => c B.*c f.func a\n  | func-+ => {?hidden}\n  | func-*c => {?hidden}\n}", "completion": "\\new LinearMap {\n  | R => _\n  | Dom => A\n  | Cod => B\n  | func => \\lam a => c *c {B} f a\n  | func-+ => rewrite (func-+ {f}, *c-ldistr {B}) idp\n  | func-*c => rewrite (func-*c {f}, inv (*c-assoc {B}), inv (*c-assoc {B}), *-comm {R}) idp\n}"}
{"prompt": "['X : RealPreBanachAlgebra']<<<break>>>['\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : PrecoverSpace} (g : PrecoverMap Y Z) (f : PrecoverMap X Y) : PrecoverMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new PrecoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\instance TopAbGroupCompletion \\\\hlevels  (X1 : TopAbGroup) : CompleteTopAbGroup (RegularCauchyFilter X1) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X1}}\\n  | zro => pointCF {X1} X.zro\\n  | + => +-func {X1}\\n  | negative => func {negative-cover {X1}}\\n  | isCauchy => isCCauchy {X1}\\n  | isUniform => \\\\lam (D : Set (Set E)) =>\\n    TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (\\\\Pi {U : Set X.E} -> C U -> TruncP (\\\\Sigma (V : Set E) (D V) (mkSet {X1} U \u2286 V))))\\n} => \\\\new CompleteTopAbGroup {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | +-cont => {?hidden}\\n  | negative-cont => {?hidden}\\n  | neighborhood-uniform => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\lemma proj2 \\\\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) Y {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.2\\n} ', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : CoverSpace} (g : CoverMap Y Z) (f : CoverMap X Y) : CoverMap X Z {\\n  | func => \\\\lam (x : E {Dom {g \u2218 f}}) => g.func (f.func x)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\func id \\\\hlevels  {X : CoverSpace} : CoverMap X X {\\n  | func => \\\\lam (x : E {Dom {id {X}}}) => x\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\func *-cover \\\\hlevels  {X : RealPreBanachAlgebra} : CoverMap (coverSpace {X} \u2a2f coverSpace {X}) (Completion X) \\n  => lift2 {X} (*-locally-uniform {X})', \"\\\\func prod \\\\hlevels  {X Y X' Y' : CoverSpace} (f : CoverMap X Y) (g : CoverMap X' Y') : CoverMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} z, func {g \u2218 proj2 {X} {X'}} z)\\n} => tuple {Y} {Y'} {X \u2a2f X'} (f \u2218 proj1 {X} {X'}) (g \u2218 proj2 {X} {X'})\", '\\\\instance Completion \\\\hlevels  (X : CoverSpace) : CompleteCoverSpace (RegularCauchyFilter X) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X}}\\n  | isCauchy => isCCauchy {X}\\n} => \\\\new CompleteCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\func tuple \\\\hlevels  {X Y Z : CoverSpace} (f : CoverMap Z X) (g : CoverMap Z Y) : CoverMap Z (X \u2a2f Y) {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (f.func z, g.func z)\\n} => \\\\new CoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\class CoverMap \\\\extends PrecoverMap, StronglyCauchyMap \\\\hlevels  {\\n  | func-weak-cauchy => \\\\lam (F1 : WeaklyCauchyFilter Dom) =>\\n  \\\\new WeaklyCauchyFilter Cod (\\\\lam (V : E {A {SetFilter-map {E {Dom}} {E {Cod}} func F1}}) => F.F (func ^-1 V)) {\\n    | filter-mono => {?hidden}\\n    | filter-top => {?hidden}\\n    | filter-meet => {?hidden}\\n    | isWeaklyProper => {?hidden}\\n    | isCauchyFilter => {?hidden}\\n  }\\n}', '\\\\lemma proj1 \\\\hlevels  {X Y : CoverSpace} : CoverMap (X \u2a2f Y) X {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} ', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>CoverMap (TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X) (Completion X) {\n  | func => \\lam (x : E {Dom {*-cover {X} PrecoverMap.\u2218 tuple {TopAbGroupCompletion X} {Completion X} {TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X}\n    (proj1 {TopAbGroupCompletion X} {TopAbGroupCompletion X} CoverMap.\u2218 proj1 {TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X} {TopAbGroupCompletion X})\n    (*-cover {X} CoverMap.\u2218 prod {TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X} {TopAbGroupCompletion X} {TopAbGroupCompletion X}\n      {TopAbGroupCompletion X} (proj2 {TopAbGroupCompletion X} {TopAbGroupCompletion X}) (id {TopAbGroupCompletion X}))}}) =>\n  func {*-cover {X}}\n    (func {tuple {TopAbGroupCompletion X} {Completion X} {TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X}\n      (proj1 {TopAbGroupCompletion X} {TopAbGroupCompletion X} CoverMap.\u2218 proj1 {TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X} {TopAbGroupCompletion X})\n      (*-cover {X} CoverMap.\u2218 prod {TopAbGroupCompletion X \u2a2f TopAbGroupCompletion X} {TopAbGroupCompletion X} {TopAbGroupCompletion X}\n        {TopAbGroupCompletion X} (proj2 {TopAbGroupCompletion X} {TopAbGroupCompletion X}) (id {TopAbGroupCompletion X}))} x)\n}", "completion": "*-cover \u2218 tuple (proj1 \u2218 proj1) (*-cover \u2218 prod proj2 id)"}
{"prompt": "['Y : RegularPreuniformSpace', 'X : RegularPreuniformSpace', 'D : Set (Set X.E)', 'V : Set X.E', 'U : Set X.E', 'DU : D U', 'V<=*U : V <=* U']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', 'inP A', '| E : \\\\Set', '\\\\func \\\\infix 4 <=* \\\\hlevels  {X : PreuniformSpace} (V U : Set X.E) : \\\\Prop \\n  => TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (star {X.E} V C \u2286 U))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (V' : Set X.E) ((\\lam (s : \\Sigma X.E Y.E) => s.1) ^-1 V = (\\lam (s : \\Sigma X.E Y.E) => s.1) ^-1 V') (U : Set X.E) (D U)\n  (V' <=* U))", "completion": "inP (V, idp, U, DU, V<=*U)"}
{"prompt": "['f : LinearMap {R} A B']<<<break>>>['\\\\class AddGroupHom \\\\extends AddMonoidHom \\\\hlevels  {\\n  | func-zro => cancel-left {Cod} (func (zro {Dom})) {func (zro {Dom})} {zro {Cod}}\\n    (inv {E {Cod}} {func (zro {Dom} + zro {Dom})} {func (zro {Dom}) + func (zro {Dom})} (func-+ {zro {Dom}} {zro {Dom}}) *> pmap {E {Dom}} {E {Cod}} func {zro {Dom} + zro {Dom}} {zro {Dom}} (zro-right {Dom} {zro {Dom}}) *> inv {E {Cod}} {func (zro {Dom}) + zro {Cod}} {func (zro {Dom})} (zro-right {Cod} {func (zro {Dom})}))\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', 'inP A', '\\\\instance ImageAddGroup \\\\hlevels  (f : AddGroupHom) : AddGroup (Image {E {f.Dom}} {E {f.Cod}} f.func) {\\n  | zro => (zro {f.Cod}, inP {\\\\Sigma (a : E {f.Dom}) (f.func a = zro {f.Cod})} (zro {f.Dom}, f.func-zro))\\n  | + => \\\\lam (a : E) (b : E) => (a.1 + b.1, \\\\case a.2, b.2 \\\\with {\\n    | inP t, inP s => inP {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1 + b.1)} (t.1 + s.1,\\n      f.func-+ {t.1} {s.1} *> pmap2 {E {f.Cod}} {E {f.Cod}} {E {f.Cod}} ((+) {f.Cod}) {f.func t.1} {a.1} t.2 {f.func s.1} {b.1} s.2)\\n  })\\n  | negative => \\\\lam (a : E {\\\\this}) => (negative {f.Cod} a.1,\\n    map {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)} {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = negative {f.Cod} a.1)} a.2\\n      (\\\\lam (s : \\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)) =>\\n        (negative {f.Dom} s.1, func-negative {f} {s.1} *> pmap {E {f.Cod}} {E {f.Cod}} (negative {f.Cod}) {f.func s.1} {a.1} s.2)))\\n} => \\\\new AddGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | negative-right => {?hidden}\\n}', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '\\\\func ImageAddGroupLeftHom \\\\hlevels  (f : AddGroupHom) : AddGroupHom f.Dom (ImageAddGroup f) {\\n  | func => \\\\lam (a : E {Dom {ImageAddPointedLeftHom f}}) =>\\n    (f.func a, inP {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\\n} => \\\\new AddGroupHom {\\n  | func-+ => {?hidden}\\n}', '| Dom : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func ImageAddPointedLeftHom \\\\hlevels  (f : AddPointedHom) : AddPointedHom f.Dom (ImageAddPointed f) {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) => (f.func a, inP {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\\n} => \\\\new AddPointedHom {\\n  | func-zro => {?hidden}\\n}']<<<break>>>AddGroupHom f.Dom (ImageAddGroup f) {\n  | func => \\lam (a : E {Dom {ImageAddPointedLeftHom f}}) =>\n    (f.func a, inP {\\Sigma (a1 : E {f.Dom}) (f.func a1 = f.func a)} (a, idp {E {f.Cod}} {f.func a}))\n}", "completion": "ImageAddGroupLeftHom f"}
{"prompt": "['n : Nat', 'a : Fin (suc n)']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| A : \\\\Type', 'suc Nat', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func fac \\\\plevels  \\\\hlevels  (_ : Nat) : Nat \\n  | 0 => 1\\n  | suc n => suc n * fac n', '| f_sec (y : B) : f (sec y) = y', \"\\\\func sigma-right {A1 : \\\\Type} {B1 B' : A1 -> \\\\Type} (q : \\\\Pi (a : A1) -> Equiv {B1 a} {B' a}) :\\nEquiv {\\\\Sigma (a : A1) (B1 a)} {\\\\Sigma (a : A1) (B' a)} (\\\\lam (p : A {\\\\this}) => (p.1, f {q p.1} p.2)) {\\n  | ret => \\\\lam (p' : B {\\\\this}) => (p'.1, ret {q p'.1} p'.2)\\n  | ret_f => \\\\lam (p : A {\\\\this}) => path (\\\\lam (i : I) => (p.1, ret_f {q p.1} p.2 @ i))\\n  | sec => \\\\lam (p' : B {\\\\this}) => (p'.1, sec {q p'.1} p'.2)\\n  | f_sec => \\\\lam (p' : B {\\\\this}) => path (\\\\lam (i : I) => (p'.1, f_sec {q p'.1} p'.2 @ i))\\n} => \\\\new Equiv\", \"\\\\func symmetric-rec {n : Nat} : QEquiv {Sym (suc n)} {\\\\Sigma (Fin (suc n)) (Sym n)} (\\\\lam (e : A {\\\\this}) => (f {e} 0, reduce {n} e)) {\\n  | ret => \\\\lam (s : B {\\\\this}) => isEquiv {FinFin (suc n)} (\\\\lam (p0 : E) => (\\\\case p0 \\\\with {\\n    | zero => s.1\\n    | suc j => sface {n} s.1 (f {s.2} j)\\n  }))\\n    (\\\\lam {j : E} {j' : E} => (\\\\case j, j' \\\\with {\\n      | zero, zero => \\\\lam (_ : (\\\\case 0 \\\\with {\\n        | zero => s.1\\n        | suc j => sface {n} s.1 (f {s.2} j)\\n      }) = (\\\\case 0 \\\\with {\\n      | zero => s.1\\n      | suc j => sface {n} s.1 (f {s.2} j)\\n      })) => idp {Fin (suc n)} {0}\\n      | zero, suc j' => \\\\lam (p : (\\\\case 0 \\\\with {\\n        | zero => s.1\\n        | suc j => sface {n} s.1 (f {s.2} j)\\n      }) = (\\\\case suc j' \\\\with {\\n      | zero => s.1\\n      | suc j => sface {n} s.1 (f {s.2} j)\\n      })) => absurd {0 = suc j'} (sface-skip {n} {s.1} {f {s.2} j'} (inv {Fin (suc n)} {s.1} {sface {n} s.1 (f {s.2} j')} p))\\n      | suc j, zero => \\\\lam (p : (\\\\case suc j \\\\with {\\n        | zero => s.1\\n        | suc j => sface {n} s.1 (f {s.2} j)\\n      }) = (\\\\case 0 \\\\with {\\n      | zero => s.1\\n      | suc j => sface {n} s.1 (f {s.2} j)\\n      })) => absurd {suc j = 0} (sface-skip {n} {s.1} {f {s.2} j} p)\\n      | suc j, suc j' => \\\\lam (p : (\\\\case suc j \\\\with {\\n        | zero => s.1\\n        | suc j => sface {n} s.1 (f {s.2} j)\\n      }) = (\\\\case suc j' \\\\with {\\n      | zero => s.1\\n      | suc j => sface {n} s.1 (f {s.2} j)\\n      })) => pmap {Fin n} {Fin (suc n)} (fsuc {n}) {j} {j'} (isInj {s.2} {j} {j'} (sface-inj {n} {s.1} {f {s.2} j} {f {s.2} j'} p))\\n    }))\\n  | ret_f => \\\\lam (e : A {\\\\this}) => equals {suc n} {ret {\\\\this} (f {e} 0, reduce {n} e)} {e} (\\\\lam (p0 : Fin (suc n)) => (\\\\case p0 \\\\with {\\n    | zero => idp {Fin (suc n)} {f {e} 0}\\n    | suc j => sface_skip {n} {f {e} 0} {f {e} (suc j)} {\\\\lam (p : f {e} 0 = f {e} (suc j)) => (\\\\case isInj {e} {0} {suc j} p \\\\with {})}\\n  }))\\n  | f_sec => \\\\lam (s : B {\\\\this}) =>\\n  pmap {Sym n} {\\\\Sigma (Fin (suc n)) (Sym n)} (\\\\lam (p0 : Sym n) => (s.1, p0)) {reduce {n} (sec {\\\\this} s)} {s.2}\\n    (equals {n} {reduce {n} (sec {\\\\this} s)} {s.2} (\\\\lam (j : Fin n) => skip_sface {n} {s.1} {f {s.2} j} {\\\\lam (p : (\\\\case 0 \\\\with {\\n      | zero => s.1\\n      | suc j => sface {n} s.1 (f {s.2} j)\\n    }) = (\\\\case suc j \\\\with {\\n    | zero => s.1\\n    | suc j => sface {n} s.1 (f {s.2} j)\\n    })) => (\\\\case isInj {sec {\\\\this} s} {0} {suc j} p \\\\with {})}))\\n} => \\\\new QEquiv\", '\\\\type Sym \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => Equiv {Fin n} {Fin n}', '| \\\\infixl 7 * E E : E', '| ret_f (x : A) : ret (f x) = x', '| ret B : A', '| f A : B', '\\\\func \\\\infixr 3 transEquiv {A1 B1 C : \\\\Type} (e1 : Equiv {A1} {B1}) (e2 : Equiv {B1} {C}) : Equiv {A1} {C} (\\\\lam (x : A {\\\\this}) => e2.f (e1.f x)) {\\n  | ret => \\\\lam (y : B {\\\\this}) => e1.ret (e2.ret y)\\n  | ret_f => \\\\lam (x : A {\\\\this}) => pmap {B1} {A1} e1.ret {e2.ret (e2.f (e1.f x))} {e1.f x} (e2.ret_f (e1.f x)) *> e1.ret_f x\\n  | sec => \\\\lam (y : B {\\\\this}) => e1.sec (e2.sec y)\\n  | f_sec => \\\\lam (y : B {\\\\this}) => pmap {B1} {C} e2.f {e1.f (e1.sec (e2.sec y))} {e2.sec y} (e1.f_sec (e2.sec y)) *> e2.f_sec y\\n} => \\\\new Equiv', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| natCoef Nat : E', '| sec B : A', '\\\\func fin_equiv \\\\plevels  \\\\hlevels  {n1 : Nat} : Equiv {Fin (fac n1)} {Sym n1} \\n  | {0} => \\\\new QEquiv {Fin (fac 0)} {Sym 0} (\\\\lam (_ : A {\\\\this}) => idEquiv {Fin 0}) {\\n    | ret => \\\\lam (_ : B {\\\\this}) => 0\\n    | ret_f => \\\\lam (p0 : A {\\\\this}) => (\\\\case p0 \\\\with {\\n      | zero => idp {Fin (fac 0)} {0}\\n    })\\n    | f_sec => \\\\lam (e : B {\\\\this}) => equals {0} {idEquiv {Fin 0}} {e} (\\\\lam (p0 : Fin 0) => (\\\\case p0 \\\\with {}))\\n  }\\n  | {suc n} => transEquiv {Fin (natCoef (suc n) * fac n)} {\\\\Sigma (Fin (suc n)) (Fin (fac n))} {Sym (suc n)} (prod_equiv {suc n} {fac n})\\n    (transEquiv {\\\\Sigma (Fin (suc n)) (Fin (fac n))} {\\\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\\n      (sigma-right {Fin (suc n)} {\\\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\\\lam (_ : Fin (suc n)) => Sym n}\\n        (\\\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n})))', '| B : \\\\Type', '\\\\func symQEquiv {A B : \\\\Type} (e : QEquiv {A} {B}) : QEquiv {B} {A} e.ret {\\n  | ret => e.f\\n  | ret_f => e.f_sec\\n  | f_sec => e.ret_f\\n} => \\\\new QEquiv', '\\\\class Equiv \\\\extends Section, Retraction', '\\\\func prod_equiv \\\\plevels  \\\\hlevels  {n m : Nat} : Equiv {Fin (natCoef n * m)} {\\\\Sigma (Fin n) (Fin m)} \\n=> transport {Nat} (\\\\lam (x : Nat) => Equiv {Fin x} {\\\\Sigma (Fin n) (Fin m)}) {BigSum {NatSemiring} (replicate {E} n m)}\\n  {natCoef n * m} (BigSum_replicate {NatSemiring} {m} {n}) (aux {n} {\\\\lam (_ : Fin n) => m})', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>Equiv {Fin (natCoef (suc n) * fac n)} {Sym (suc n)}\n  (\\lam (x : A {\\this}) => f {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n    (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n      (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n    (f {prod_equiv {suc n} {fac n}} x)) {\n  | ret => \\lam (y : B {\\this}) => ret {prod_equiv {suc n} {fac n}}\n    (ret {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n      (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n        (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n      y)\n  | ret_f => \\lam (x : A {\\this}) =>\n  pmap {\\Sigma (Fin (suc n)) (Fin (fac n))} {Fin (natCoef (suc n) * fac n)} (ret {prod_equiv {suc n} {fac n}})\n    {ret {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n      (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n        (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n      (f {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n        (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n          (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n        (f {prod_equiv {suc n} {fac n}} x))} {f {prod_equiv {suc n} {fac n}} x}\n    (ret_f {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n      (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n        (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n      (f {prod_equiv {suc n} {fac n}} x)) *> ret_f {prod_equiv {suc n} {fac n}} x\n  | sec => \\lam (y : B {\\this}) => sec {prod_equiv {suc n} {fac n}}\n    (sec {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n      (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n        (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n      y)\n  | f_sec => \\lam (y : B {\\this}) => pmap {\\Sigma (Fin (suc n)) (Fin (fac n))} {Sym (suc n)}\n    (f {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n      (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n        (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))})\n    {f {prod_equiv {suc n} {fac n}} (sec {prod_equiv {suc n} {fac n}}\n      (sec {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n        (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n          (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n        y))}\n    {sec {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n      (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n        (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n      y}\n    (f_sec {prod_equiv {suc n} {fac n}}\n      (sec {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n        (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n          (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n        y)) *> f_sec {transEquiv {\\Sigma (Fin (suc n)) (Fin (fac n))} {\\Sigma (Fin (suc n)) (Sym n)} {Sym (suc n)}\n    (sigma-right {Fin (suc n)} {\\lam (_ : Fin (suc n)) => Fin (fac n)} {\\lam (_ : Fin (suc n)) => Sym n}\n      (\\lam (_ : Fin (suc n)) => fin_equiv {n})) (symQEquiv {Sym (suc n)} {\\Sigma (Fin (suc n)) (Sym n)} (symmetric-rec {n}))}\n    y\n}", "completion": "transEquiv prod_equiv (transEquiv (sigma-right (\\lam _ => fin_equiv)) (symQEquiv symmetric-rec))"}
{"prompt": "[\"V' : E {A {\\\\this}}\", 'U : E {A {\\\\this}}', \"U' : E {A {\\\\this}}\", 'V : E {A {\\\\this}}', 'L : Locale']<<<break>>>['\\\\func neg \\\\hlevels  {this : Locale} (x : E) : E => x --> bottom', '| meet-left {x y : E} : x \u2227 y <= x', '\\\\lemma neg-inverse \\\\hlevels  {this : Locale} {x y : E} (_ : x <= y) : neg y <= neg x ', '| \\\\infix 4 <= E E : \\\\Prop', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| join-left {x y : E} : x <= x \u2228 y']<<<break>>>neg {L} U L.\u2227 V' L.<= neg {L} (U L.\u2227 U') L.\u2228 V L.\u2227 V'", "completion": "meet-left <=\u2218 neg-inverse {L} meet-left <=\u2218 join-left"}
{"prompt": "['a : Rat']<<<break>>>['| L Rat : \\\\Prop', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExtendedLowerReal (\\\\lam (_x : Rat) => _x < x) => \\\\new ExtendedLowerReal {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n}', '\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExtendedLowerReal) : \\\\Prop => \\\\Pi {a : Rat} -> x.L a -> y.L a', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : LowerReal (\\\\lam (_x : Rat) => _x < x) => \\\\new LowerReal {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n}']<<<break>>>LowerReal.fromRat a <= ExtendedLowerReal.fromRat a", "completion": "\\lam p => p"}
{"prompt": "['V : AddGroup', 'B : BottomDistributiveLattice']<<<break>>>['\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\instance ~_Equivalence \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} : Equivalence (Array (\\\\Sigma V.E B.E)) {\\n  | ~ => (~)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', \"\\\\data \\\\infix 4 ~ {V : AddMonoid} {B : BottomDistributiveLattice} (_ _ : Array (\\\\Sigma V.E B.E)) : \\\\Prop \\n  | ~-perm (EPerm {\\\\Sigma V.E B.E} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-trans {m : Array (\\\\Sigma V.E B.E)} (l ~ m) (m ~ l')\\n  | ~-zro-left {b : B.E} (l = (V.zro, b) :: l')\\n  | ~-zro-right {v : V.E} (l = (v, B.bottom) :: l')\\n  | ~-+-left {l'' : Array (\\\\Sigma V.E B.E)} {u v : V.E} {b : B.E} (l = (u, b) :: (v, b) :: l'') (l' = (u V.+ v, b) :: l'')\\n  | ~-+-right {l'' : Array (\\\\Sigma V.E B.E)} {v : V.E} {a b : B.E} (l = (v, a B.\u2228 b) :: (v, a B.\u2227 b) :: l'') (l' = (v, a) :: (v, b) :: l'')\", '| E : \\\\Set', '\\\\class Equivalence \\\\extends Transitive \\\\hlevels  {\\n  | ~-reflexive {x : A} : x ~ x\\n  | ~-symmetric {x y : A} (x ~ y) : y ~ x\\n}']<<<break>>>Equivalence (Array (\\Sigma (E {V}) (E {B}))) {\n  | ~ => (~)\n}", "completion": "~_Equivalence {_} {_}"}
{"prompt": "['this : LinearlyOrderedAbGroup Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | negative => RealAbGroup.negative\\n  | negative-left => {?hidden}\\n  | isPos => \\\\lam (x : E {\\\\this}) => x.L zro\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | meet => RealAbGroup.meet\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join => RealAbGroup.join\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n}']<<<break>>>['| zro : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"| U-closed {q q' : Rat} (U q) (q < q') : U q'\", '| U Rat : \\\\Prop', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>\\Pi {q q' : Rat} -> U {zro {\\this}} q -> q < q' -> U {zro {\\this}} q'", "completion": "U-closed {fromRat zro}"}
{"prompt": "['u : Array R.E 3', 'f : \\\\Pi (j : Fin 3) -> at {at {at {A} 0} 0 :: at {at {A} 0} 1 :: at {at {A} 1} 1 :: nil} j = u.at j R.* d', 'R : CRing', 'A : Matrix R.E 2 2', 'd : R.E']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 7 * E E : E', '| at (j : Fin len) : A j', '| E : \\\\Set']<<<break>>>at {at {at {A} 0} 0 :: at {at {A} 0} 1 :: at {at {A} 1} 1 :: nil} 2 = u.at 2 R.* d", "completion": "f 2"}
{"prompt": "['y : X.E', 'i : I', 'X : ExPseudoNormedAbGroup', 'h1 : (<=<) (single {X.E} x) = (<=<) (single {X.E} y)', 'arg : \\\\Pi (U : X.E -> \\\\Prop) -> single {X.E} x <=< U = single {X.E} y <=< U', 'x : X.E']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| top : E', '| filter-top : F (top {A})', '\\\\func pointCF \\\\hlevels  {S1 : CoverSpace} (x : S.E) : RegularCauchyFilter S1 ((<=<) (single {S.E} x)) => \\\\new RegularCauchyFilter {\\n  | filter-mono => {?hidden}\\n  | filter-top => {?hidden}\\n  | filter-meet => {?hidden}\\n  | isCauchyFilter => {?hidden}\\n  | isProper => {?hidden}\\n  | isRegularFilter => {?hidden}\\n}', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>arg top @ i", "completion": "prop-dpi (\\lam i => ext_coe) (filter-top {pointCF {X} x}) (filter-top {pointCF {X} y}) @ i"}
{"prompt": "['n/=0 : n /= 0', 'A : StoneC*PseudoAlgebra', 'n : Nat', 'x : E {\\\\this}']<<<break>>>['| isDivisible (a : E) {n : Nat} (n /= 0) : TruncP (\\\\Sigma (b : E) (n *n b = a))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func \\\\infixl 7 *n \\\\hlevels  {this2 : AddMonoid} (_ : Nat) (_ : E) : E \\n  | {this}, 0, a => zro\\n  | {this}, suc n, a => n *n a + a']<<<break>>>TruncP (\\Sigma (b : A.E) (n *n b = x.2))", "completion": "isDivisible {A} x.2 n/=0"}
{"prompt": "['J : \\\\Set', 'z : P.E', \"this : SiteWithBasis P.E {\\n  | Hom => Cover1 {P}\\n  | id => <=-refl\\n  | o => \\\\lam {X Y Z : Ob} (f : Hom Y Z) (g : Hom X Y) => g <=\u2218 f\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | pullback => \\\\lam {x1 y1 z1 : P.E} (f1 : Cover1 {P} x1 z1) (g1 : Cover1 {P} y1 z1) => \\\\new Pullback {x1} {y1} {z1} f1 g1 (P.conj x1 y1) {\\n    | pbProj1 => cover-proj1 {P} {apex {\\\\this}} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x {\\\\this}} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {x1})\\n    | pbProj2 => cover-proj2 {P} {P.conj x1 y1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => y1} {x1} {y1} (idp {P.E} {P.conj x1 y1}) () (idp {P.E} {y1})\\n    | pbCoh => {?hidden}\\n    | pbMap => \\\\lam {w : Ob {D {\\\\this}}} (p1 : Hom {D {\\\\this}} w (x {\\\\this})) (p2 : Hom {D {\\\\this}} w (y {\\\\this}))\\n      (_ : f {\\\\this} \u2218 p1 = g {\\\\this} \u2218 p2) => cover-prod {P} {w} {x1} {y1} p1 p2\\n    | pbBeta1 => {?hidden}\\n    | pbBeta2 => {?hidden}\\n    | pbEta => {?hidden}\\n  }\\n  | isBasicCover => \\\\lam (x : Ob {\\\\this}) {J : \\\\Set} (g : J -> Ob) =>\\n  TruncP (\\\\Sigma (y : P.E) (Cover1 {P} x y) (g' : J -> P.E) (P.BasicCover {J} y g')\\n    (\\\\Pi (j : J) -> \\\\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (g j).1)))\\n  | basicCover-stable => {?hidden}\\n}\", 'y : Ob {\\\\this}', \"c : P.BasicCover {J} z g'\", 'x : Ob {\\\\this}', \"g' : J -> P.E\", 'g : J -> Ob', 'y<=z : Cover1 {P} y z', \"d : \\\\Pi (j : J) -> \\\\Sigma (Cover1 {P} (g j).1 (g' j)) (Cover1 {P} (P.conj y (g' j)) (g j).1)\", 'x<=y : Hom {\\\\this} x y', 'P : FramePres']<<<break>>>['| conj E E : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', 'inP A', '\\\\func Cover1 \\\\hlevels  {P : FramePres} (x y : P.E) : \\\\Prop => Cover {P} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => y)', '\\\\func pullbackFunctor \\\\plevels obj >= hom \\\\hlevels  {C1 : PrecatWithPullbacks} {x1 y1 : C.Ob} (f : C.Hom x1 y1) : Functor (SlicePrecat {C1} y1) (SlicePrecat {C1} x1)\\n  (\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) {\\n  | Func => \\\\lam {a : ObOver {C1} y1} {b : ObOver {C1} y1} (g : Hom a b) => (\\n    \\\\let p => C.pullback {x1} {a.1} {y1} f a.2\\n    \\\\in (pbMap {C.pullback {x1} {b.1} {y1} f b.2}\\n          {((\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) a).1} p.pbProj1\\n          (g.1 C.\u2218 p.pbProj2)\\n          (p.pbCoh *> pmap {C.Hom a.1 y1} {C.Hom p.apex y1} (\\\\lam (_x : C.Hom a.1 y1) => _x C.\u2218 p.pbProj2) {a.2} {b.2 C.\u2218 g.1}\\n            (inv {C.Hom a.1 y1} {b.2 C.\u2218 g.1} {a.2} g.2) *> C.o-assoc {((\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) a).1} {a.1} {b.1} {y1}\\n            {b.2} {g.1} {p.pbProj2}),\\n          pbBeta1 {C.pullback {x1} {b.1} {y1} f b.2}\\n            {((\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) a).1} {p.pbProj1}\\n            {g.1 C.\u2218 p.pbProj2}\\n            {p.pbCoh *> pmap {C.Hom a.1 y1} {C.Hom p.apex y1} (\\\\lam (_x : C.Hom a.1 y1) => _x C.\u2218 p.pbProj2) {a.2} {b.2 C.\u2218 g.1}\\n              (inv {C.Hom a.1 y1} {b.2 C.\u2218 g.1} {a.2} g.2) *> C.o-assoc {((\\\\lam (t : Ob) => (apex {C.pullback {x1} {t.1} {y1} f t.2}, map {C1} {x1} {y1} {f} {t.1} t.2)) a).1} {a.1} {b.1} {y1}\\n              {b.2} {g.1} {p.pbProj2}}))\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', '| BasicCover {J : \\\\Set} E (J -> E) : \\\\Prop', '\\\\lemma cover-prod \\\\hlevels  {P : FramePres} {x y z : P.E} (_ : Cover1 {P} x y) (_ : Cover1 {P} x z) : Cover1 {P} x (P.conj y z) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\lemma cover-proj2 \\\\hlevels  {P : FramePres} {x : P.E} {J : \\\\Set} {g : J -> P.E} {a b : P.E} (_ : x = P.conj a b) (j : J) (_ : g j = b) :\\n  Cover {P} x {J} g ', 'cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)', '| E : \\\\Set']<<<break>>>TruncP (\\Sigma (y1 : P.E) (Cover1 {P} x y1) (g' : J -> P.E) (P.BasicCover {J} y1 g')\n  (\\Pi (j : J) -> \\Sigma (Cover1 {P} (F (g j)).1 (g' j)) (Cover1 {P} (P.conj x (g' j)) (F (g j)).1)))", "completion": "inP (z, cover-trans x<=y (\\lam _ => y<=z), g', c,\n  \\lam j => (cover-trans (cover-proj2 idp () idp) (\\lam _ => (d j).1), cover-prod (cover-proj1 idp () idp)\n    (cover-trans (cover-prod (cover-trans (cover-proj1 idp () idp) (\\lam _ => x<=y)) (cover-proj2 idp () idp)) (\\lam _ => (d j).2))))"}
{"prompt": "['this : Dec']<<<break>>>['\\\\lemma gcd \\\\hlevels  {M : GCDDomain} {D : DecSet M.E} (_ : \\\\Pi {x : M.E} -> x /= M.zro -> M.#0 x) (a b : M.E) : TruncP (GCD {M} a b) ', '\\\\class GCD \\\\hlevels  {\\n  | M : CMonoid\\n  | val1 : E {M}\\n  | val2 : E {M}\\n  | res : E {M}\\n  | res|val1 : LDiv {M} res val1\\n  | res|val2 : LDiv {M} res val2\\n  | res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res\\n}', '| E : \\\\Set', '\\\\class Dec \\\\extends GCDDomain, GCDMonoid, Dec, IntegrallyClosedDomain \\\\hlevels  {\\n  | gcd-ldistr => \\\\lam (c : E) {x : E} {y : E} {z : E} (g : GCD x y z) => (\\\\scase decideEq c zro \\\\with {\\n    | yes c=0 => transportInv {E} (\\\\lam (x1 : E) => TruncP (GCD (x1 * x) (x1 * y) (x1 * z))) {c} {zro} c=0\\n      (transport {E} (\\\\lam (x2 : E) => TruncP (GCD (zro * x) (zro * y) x2)) {zro} {zro * z}\\n        (Paths.inv {E} {zro * z} {zro} (path ((@) (zro_*-left {z}))))\\n        (transport {E} (\\\\lam (x1 : E) => TruncP (GCD (zro * x) x1 zro)) {zro} {zro * y}\\n          (Paths.inv {E} {zro * y} {zro} (path ((@) (zro_*-left {y}))))\\n          (transport {E} (\\\\lam (x0 : E) => TruncP (GCD x0 zro zro)) {zro} {zro * x}\\n            (Paths.inv {E} {zro * x} {zro} (path ((@) (zro_*-left {x}))))\\n            (inP {GCD zro zro zro} (\\\\new GCD zro zro zro (id-div {zro}) (id-div {zro})\\n              (\\\\lam (g : E {M {\\\\this}}) (g|0 : LDiv {M {\\\\this}} g (val1 {\\\\this})) (_ : LDiv {M {\\\\this}} g (val2 {\\\\this})) => g|0))))))\\n    | no c/=0 => map {GCD (c * x) (c * y)} {GCD (c * x) (c * y) (c * z)} (gcd {\\\\new this38 {}} nonZeroApart (c * x) (c * y))\\n      (gcd-ldistr_cancel {c} {x} {y} {z} (\\\\lam {a : E} {b : E} => nonZero-cancel-left {c} {a} {b} c/=0) g)\\n  })\\n  | isIntegrallyClosedDomain => \\\\lam (x : E {Cod {locMap {subMonoid}}}) (xi : isIntegral (locMap {subMonoid}) x) =>\\n  (\\\\scase coprime-repr-aux {\\\\new this13 {}} x, xi \\\\with {\\n    | inP c, inP d =>\\n    \\\\scase loc_poly {subMonoid} (\\\\lam {a : E} (s : contains a) {x y : E} => nonZero-cancel-right {x} {y} {a} (apartNonZero {a} s)) d.1 d.2\\n      {c.1} {c.2} {c.3}\\n      (transport {Quotient {SType subMonoid} (\\\\lam (a : SType subMonoid) (b : SType subMonoid) => a.1 * b.2 = b.1 * a.2)}\\n        (\\\\lam (x : Quotient {SType subMonoid} (\\\\lam (a : SType subMonoid) (b : SType subMonoid) => a.1 * b.2 = b.1 * a.2)) =>\\n          polyEval {Cod {locMap {subMonoid}}} (polyMap (locMap {subMonoid}) d.1) x = zro {Cod {locMap {subMonoid}}}) {x}\\n        {inl~ {\\\\new this13 {}} {subMonoid} (c.1, c.2, c.3)} c.5 d.3) \\\\with {\\n      | inP e => transportInv {Quotient {SType subMonoid} (\\\\lam (a : SType subMonoid) (b : SType subMonoid) => a.1 * b.2 = b.1 * a.2)}\\n        (\\\\lam (x : Quotient {SType subMonoid} (\\\\lam (a : SType subMonoid) (b : SType subMonoid) => a.1 * b.2 = b.1 * a.2)) =>\\n          TruncP (\\\\Sigma (b : E {Dom {locMap {subMonoid}}}) (func {locMap {subMonoid}} b = x))) {x}\\n        {inl~ {\\\\new this13 {}} {subMonoid} (c.1, c.2, c.3)} c.5 (\\\\case decide#0 c.1 \\\\with {\\n          | inl q => inP {\\\\Sigma (b : E {Dom {locMap {subMonoid}}}) (func {locMap {subMonoid}} b = inl~ {\\\\new this13 {}} {subMonoid} (c.1, c.2, c.3))}\\n            (zro, equals1 {subMonoid} {(zro, ide, contains_ide)} {(c.1, c.2, c.3)}\\n              (transport {E} ((=) (zro * c.2)) {c.1} {c.1 * ide} (Paths.inv {E} {c.1 * ide} {c.1} (path ((@) (ide-right {c.1}))))\\n                (transport {E} (\\\\lam (x0 : E) => x0 = c.1) {zro} {zro * c.2} (Paths.inv {E} {zro * c.2} {zro} (path ((@) (zro_*-left {c.2}))))\\n                  (Paths.inv {E} {c.1} {zro} q))))\\n          | inr c1#0 => inP {\\\\Sigma (b : E {Dom {locMap {subMonoid}}}) (func {locMap {subMonoid}} b = inl~ {\\\\new this13 {}} {subMonoid} (c.1, c.2, c.3))}\\n            ((Monoid.DivBase.inv\\n            {gcd_pow_div {nonZeroGCDMonoid} {(c.2, c.3)} {(c.1, c1#0)} {e.1} (transport {\\\\Sigma (x : E) (AddGroup.With#.#0 x)}\\n              (\\\\lam (elem : \\\\Sigma (x : E) (AddGroup.With#.#0 x)) => LDiv {nonZeroMonoid} (c.2, c.3) elem)\\n              {(pow c.1 e.1, pow_#0 {c.1} {e.1} c1#0)} {pow {nonZeroGCDMonoid} (c.1, c1#0) e.1} (path (\\\\lam (i : I) => (\\n                \\\\have arg => Paths.inv {E} {(pow {nonZeroGCDMonoid} (c.1, c1#0) e.1).1} {pow c.1 e.1} (func-pow {embedMonoid {subMonoid}} {(c.1, c1#0)} {e.1})\\n                \\\\in (arg @ i,\\n                      prop-dpi (\\\\lam (i : I) => AddGroup.With#.#0 (arg @ i)) (pow_#0 {c.1} {e.1} c1#0) (pow {nonZeroGCDMonoid} (c.1, c1#0) e.1).2 @ i))))\\n              (ldiv_nonZero {(c.2, c.3)} {(pow c.1 e.1, pow_#0 {c.1} {e.1} c1#0)} e.2))\\n              (<=gcd {nonZeroGCDMonoid} {(c.2, c.3)} {(c.1, c1#0)}\\n                (\\\\new GCD {nonZeroGCDMonoid} (c.2, c.3) (c.1, c1#0) ide (ide-div {nonZeroGCDMonoid} {(c.2, c.3)})\\n                  (ide-div {nonZeroGCDMonoid} {(c.1, c1#0)})\\n                  (\\\\lam (g : E {M {\\\\this}}) (g|c2 : LDiv {M {\\\\this}} g (val1 {\\\\this})) (g|c1 : LDiv {M {\\\\this}} g (val2 {\\\\this})) =>\\n                    ldiv_nonZero {g} {ide} (res-univ {c.4} g.1 (nonZero_ldiv {g} {(c.1, c1#0)} g|c1) (nonZero_ldiv {g} {(c.2, c.3)} g|c2)))))}).1,\\n              Paths.inv {Quotient {SType subMonoid} (\\\\lam (a : SType subMonoid) (b : SType subMonoid) => a.1 * b.2 = b.1 * a.2)}\\n                {inl~ {\\\\new this13 {}} {subMonoid} (c.1, c.2, c.3)} {func {locMap {subMonoid}} (Monoid.DivBase.inv\\n                  {gcd_pow_div {nonZeroGCDMonoid} {(c.2, c.3)} {(c.1, c1#0)} {e.1} (transport {\\\\Sigma (x : E) (AddGroup.With#.#0 x)}\\n                    (\\\\lam (elem : \\\\Sigma (x : E) (AddGroup.With#.#0 x)) => LDiv {nonZeroMonoid} (c.2, c.3) elem)\\n                    {(pow c.1 e.1, pow_#0 {c.1} {e.1} c1#0)} {pow {nonZeroGCDMonoid} (c.1, c1#0) e.1} (path (\\\\lam (i : I) => (\\n                      \\\\have arg => Paths.inv {E} {(pow {nonZeroGCDMonoid} (c.1, c1#0) e.1).1} {pow c.1 e.1} (func-pow {embedMonoid {subMonoid}} {(c.1, c1#0)} {e.1})\\n                      \\\\in (arg @ i,\\n                            prop-dpi (\\\\lam (i : I) => AddGroup.With#.#0 (arg @ i)) (pow_#0 {c.1} {e.1} c1#0) (pow {nonZeroGCDMonoid} (c.1, c1#0) e.1).2 @ i))))\\n                    (ldiv_nonZero {(c.2, c.3)} {(pow c.1 e.1, pow_#0 {c.1} {e.1} c1#0)} e.2))\\n                    (<=gcd {nonZeroGCDMonoid} {(c.2, c.3)} {(c.1, c1#0)}\\n                      (\\\\new GCD {nonZeroGCDMonoid} (c.2, c.3) (c.1, c1#0) ide (ide-div {nonZeroGCDMonoid} {(c.2, c.3)})\\n                        (ide-div {nonZeroGCDMonoid} {(c.1, c1#0)})\\n                        (\\\\lam (g : E {M {\\\\this}}) (g|c2 : LDiv {M {\\\\this}} g (val1 {\\\\this})) (g|c1 : LDiv {M {\\\\this}} g (val2 {\\\\this})) =>\\n                          ldiv_nonZero {g} {ide} (res-univ {c.4} g.1 (nonZero_ldiv {g} {(c.1, c1#0)} g|c1) (nonZero_ldiv {g} {(c.2, c.3)} g|c2)))))}).1}\\n                (div_loc {subMonoid} {c.1} {c.2} {c.3} (nonZero_ldiv {(c.2, c.3)} {(c.1, c1#0)}\\n                  (gcd_pow_div {nonZeroGCDMonoid} {(c.2, c.3)} {(c.1, c1#0)} {e.1} (transport {\\\\Sigma (x : E) (AddGroup.With#.#0 x)}\\n                    (\\\\lam (elem : \\\\Sigma (x : E) (AddGroup.With#.#0 x)) => LDiv {nonZeroMonoid} (c.2, c.3) elem)\\n                    {(pow c.1 e.1, pow_#0 {c.1} {e.1} c1#0)} {pow {nonZeroGCDMonoid} (c.1, c1#0) e.1} (path (\\\\lam (i : I) => (\\n                      \\\\have arg => Paths.inv {E} {(pow {nonZeroGCDMonoid} (c.1, c1#0) e.1).1} {pow c.1 e.1} (func-pow {embedMonoid {subMonoid}} {(c.1, c1#0)} {e.1})\\n                      \\\\in (arg @ i,\\n                            prop-dpi (\\\\lam (i : I) => AddGroup.With#.#0 (arg @ i)) (pow_#0 {c.1} {e.1} c1#0) (pow {nonZeroGCDMonoid} (c.1, c1#0) e.1).2 @ i))))\\n                    (ldiv_nonZero {(c.2, c.3)} {(pow c.1 e.1, pow_#0 {c.1} {e.1} c1#0)} e.2))\\n                    (<=gcd {nonZeroGCDMonoid} {(c.2, c.3)} {(c.1, c1#0)}\\n                      (\\\\new GCD {nonZeroGCDMonoid} (c.2, c.3) (c.1, c1#0) ide (ide-div {nonZeroGCDMonoid} {(c.2, c.3)})\\n                        (ide-div {nonZeroGCDMonoid} {(c.1, c1#0)})\\n                        (\\\\lam (g : E {M {\\\\this}}) (g|c2 : LDiv {M {\\\\this}} g (val1 {\\\\this})) (g|c1 : LDiv {M {\\\\this}} g (val2 {\\\\this})) =>\\n                          ldiv_nonZero {g} {ide} (res-univ {c.4} g.1 (nonZero_ldiv {g} {(c.1, c1#0)} g|c1) (nonZero_ldiv {g} {(c.2, c.3)} g|c2)))))))))\\n        })\\n    }\\n  })\\n  | isGCD => gcd {\\\\new this35 {}} nonZeroApart\\n}', '| nonZeroApart {x : E} (x /= zro) : #0 x', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi (a b : E) -> TruncP (GCD a b)", "completion": "gcd (nonZeroApart {this})"}
{"prompt": "[\"j' : Ob {J {\\\\this}}\", 'this : Limit {J1} G1 (limit-obj {J1} G1) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => \\\\new FrameHom (apex {\\\\this}) (F {G {\\\\this}} j) {\\n    | func => \\\\lam (P : E {Dom {\\\\this}}) => P.1 j\\n    | func-<= => {?hidden}\\n    | func-top => {?hidden}\\n    | func-top>= => {?hidden}\\n    | func-meet => {?hidden}\\n    | func-meet>= => {?hidden}\\n    | func-Join => {?hidden}\\n    | func-Join>= => {?hidden}\\n  }\\n  | coneCoh => {?hidden}\\n  | isLimit => {?hidden}\\n  | limMap => limMap-impl\\n  | limBeta => {?hidden}\\n  | limUnique => {?hidden}\\n}', \"h1 : (\\\\lam (e : \\\\Sigma (P : \\\\Pi (j : J.Ob) -> E {G.F j}) (\\\\Pi {j j' : J.Ob} -> \\\\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) =>\\n  func {G.Func {j} {j'} h} (e.1 j)) = (\\\\lam (e : \\\\Sigma (P : \\\\Pi (j : J.Ob) -> E {G.F j}) (\\\\Pi {j j' : J.Ob} -> \\\\Pi (h : J.Hom j j') -> func {G.Func {j} {j'} h} (P j) = P j')) => e.1 j')\", 'j : Ob {J {\\\\this}}', \"h : Hom {J {\\\\this}} j j'\"]<<<break>>>['| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| G : Functor J D', '| Join {J : \\\\Set} (J -> E) : E', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| func-Join>= {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\\\lam (j : J) => func (f j))', '| D : Precat']<<<break>>>Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> E {apex {\\this}}} ->\n  (@) h1 i (Join {apex {\\this}} {J} f) <= Join {F {G {\\this}} j'} {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {Func {G {\\this}} {j} {j'} h \u2218 coneMap {\\this} j}) (func-Join>= {coneMap {\\this} j'})", "completion": "prop-dpi (\\lam i => ext_coe)\n  (func-Join>= {o {limit-obj {J} G} {G.F j} {G.F j'} (G.Func {j} {j'} h) (\\new FrameHom (limit-obj {J} G) (G.F j) {\n    | func => \\lam (P : E) => P.1 j\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  })})\n  (func-Join>= {\\new FrameHom (limit-obj {J} G) (G.F j') {\n    | func => \\lam (P : E) => P.1 j'\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }})"}
{"prompt": "['a : \\\\Sigma (j : D.Ob) (F j)', 'D : BottomJoinSemilattice']<<<break>>>['| bottom : E', '| \\\\infix 4 <= E E : \\\\Prop', '| bottom-univ {x : E} : bottom <= x']<<<break>>>D.bottom D.<= a.1", "completion": "bottom-univ {D}"}
{"prompt": "['Y : Ob {\\\\this}', 'h1 : (\\\\lam (X1 : C.Ob) => D.id (Y.F X1) D.\u2218 f.trans X1) = f.trans', 'X : Ob {C {\\\\this}}', 'i : I', 'C : Precat', 'this : Precat (Functor C1 D1) {\\n  | Hom => NatTrans {C1} {D1}\\n  | id => \\\\lam (F : Ob {\\\\this}) => \\\\new NatTrans {C1} {D1} F F {\\n    | trans => \\\\lam (X : Ob {C {\\\\this}}) => D.id (F.F X)\\n    | natural => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (b : Hom {\\\\this} Y Z) (a : Hom {\\\\this} X Y) => \\\\new NatTrans {C1} {D1} X Z {\\n    | trans => \\\\lam (X1 : Ob {C {\\\\this}}) => b.trans X1 D.\u2218 a.trans X1\\n    | natural => {?hidden}\\n  }\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', 'D : Precat', 'f : Hom {\\\\this} X Y', 'X : Ob {\\\\this}']<<<break>>>['| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X', '| Hom Ob Ob : \\\\Set', '| id (X : Ob) : Hom X X', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| Ob : \\\\hType', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}']<<<break>>>\\Pi {Y1 : C.Ob} -> \\Pi (f : C.Hom X1 Y1) -> (@) h1 i Y1 D.\u2218 X.Func {X1} {Y1} f = Y.Func {X1} {Y1} f D.\u2218 (@) h1 i X1", "completion": "(@) (prop-dpi (\\lam i => ext_coe) (natural {\\new NatTrans {C} {D1} X Y {\n  | trans => \\lam (X1 : C.Ob) => D.id (Y.F X1) D.\u2218 f.trans X1\n  | natural => {?hidden}\n}}) (natural {f})) i {X}"}
{"prompt": "['Y : TopSpace', 's : E {\\\\this}', 'this : TopSpace (\\\\Sigma X.E Y.E) {\\n  | isOpen => \\\\lam (W : Set (E {\\\\this})) =>\\n  \\\\Pi {s : E {\\\\this}} -> W s -> TruncP (\\\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\\n    (\\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)))\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}', 'X : TopSpace']<<<break>>>['| isOpen (Set E) : \\\\Prop', '| top : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| open-top : isOpen top', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\n  (\\Pi {x : X.E} -> U x -> \\Pi {y : Y.E} -> V y -> top (x, y)))", "completion": "inP (top, open-top, (), top, open-top, (), \\lam _ _ => ())"}
{"prompt": "[\"g' : Fin l.len -> Array P.E\", 'g : J -> P.E', \"S : \\\\Pi (x : E) -> \\\\Sigma (l : Array J) (Cover {P} (at {g' x.1} x.2) {Fin l.len} (\\\\lam (i : Fin l.len) => g (l.at i)))\", \"k : Fin (len {Big {Array P.E} {Array P.E} (++) nil (\\\\new Array (Array P.E) l.len g')})\", 'J : \\\\Set', 'P : FramePres', 'l : Array I', \"i_j_p : \\\\Sigma (i : Fin l.len) (j : Fin (len {g' i}))\\n  (at {Big {Array P.E} {Array P.E} (++) nil (\\\\new Array (Array P.E) l.len g')} k = at {g' i} j)\"]<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func unsplit2 {A2 : \\\\Type} {n2 : Nat} (Q2 : Fin n2 -> Nat) (S2 : \\\\Sigma (i : Fin n2) (Fin (Q2 i)) -> Array A2) (i1 : Fin n2)\\n  (j2 : Fin (Q2 i1)) (k2 : Fin (len {S2 (i1, j2)})) :\\nIndex {A2} (at {S2 (i1, j2)} k2) (Big {Array A2} {Array A2} (++) nil (\\\\new Array (Array A2) n2\\n  (\\\\lam (i : Fin n2) => Big {Array A2} {Array A2} (++) nil (mkArray {Array A2} {Q2 i} (\\\\lam (j : Fin (Q2 i)) => S2 (i, j)))))) \\n  | {A}, {suc n}, Q, S, zero, j, k =>\\n  index-left {A} {at {S (0, j)} k} {Big {Array A} {Array A} (++) nil (\\\\new Array (Array A) (Q 0) (\\\\lam (j : Fin (Q 0)) => S (0, j)))}\\n    {Big {Array A} {Array A} (++) nil (\\\\new Array (Array A) n\\n      (\\\\lam (j : Fin n) => Big {Array A} {Array A} (++) nil (mkArray {Array A} {Q (suc j)} (\\\\lam (j1 : Fin (Q (suc j))) => S (suc j, j1)))))}\\n    (unsplit {A} {Q 0} (\\\\lam (j : Fin (Q 0)) => S (0, j)) j k)\\n  | {A}, {suc n}, Q, S, suc i, j, k =>\\n  index-right {A} {at {S (suc i, j)} k} {Big {Array A} {Array A} (++) nil (mkArray {Array A} {Q 0} (\\\\lam (j : Fin (Q 0)) => S (0, j)))}\\n    {Big {Array A} {Array A} (++) nil (\\\\new Array (Array A) n (\\\\lam (i : Fin n) =>\\n      Big {Array A} {Array A} (++) nil (mkArray {Array A} {Q (suc i)} (\\\\lam (j : Fin (Q (suc i))) => S (suc i, j)))))}\\n    (unsplit2 {A} {n} (\\\\lam (i : Fin n) => Q (suc i)) (\\\\lam (p : \\\\Sigma (i : Fin n) (Fin (Q (suc i)))) => S (suc p.1, p.2)) i j k)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', 'cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '\\\\data Cover \\\\hlevels  {P : FramePres} P.E {J : \\\\Set} (J -> P.E) : \\\\Prop \\n  | cover-basic (P.BasicCover {J} x g)\\n  | cover-inj (j : J) (g j = x)\\n  | cover-trans {I : \\\\Set} {f : I -> P.E} (Cover {P} x {I} f) (\\\\Pi (i : I) -> Cover {P} (f i) {J} g)\\n  | cover-proj1 {a b : P.E} (x = P.conj a b) (j : J) (g j = a)\\n  | cover-idemp (j : J) (g j = P.conj x x)\\n  | cover-comm {a b : P.E} (x = P.conj a b) (j : J) (g j = P.conj b a)\\n  | cover-ldistr {a b : P.E} (x = P.conj a b) {f : J -> P.E} (Cover {P} b {J} f) (\\\\Pi (j : J) -> g j = P.conj a (f j))', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", 'cover-inj (j : J) (g j = x)', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray']<<<break>>>Cover {P} (at {Big {Array P.E} {Array P.E} (++) nil (\\new Array (Array P.E) l.len g')} k)\n  {Fin (len {Big {Array J} {Array J} (++) nil (\\new Array (Array J) l.len (\\lam (i : Fin l.len) =>\n    Big {Array J} {Array J} (++) nil (\\new Array (Array J) (len {g' i}) (\\lam (j : Fin (len {g' i})) => (S (i, j)).1))))})}\n  (\\lam (i : Fin (len {Big {Array J} {Array J} (++) nil (\\new Array (Array J) l.len (\\lam (i : Fin l.len) =>\n    Big {Array J} {Array J} (++) nil (\\new Array (Array J) (len {g' i}) (\\lam (j : Fin (len {g' i})) => (S (i, j)).1))))})) =>\n  g (Big {Array J} {Array J} (++) nil (\\new Array (Array J) l.len (\\lam (i : Fin l.len) =>\n    Big {Array J} {Array J} (++) nil (\\new Array (Array J) (len {g' i}) (\\lam (j : Fin (len {g' i})) => (S (i, j)).1)))) !! i))", "completion": "rewrite p (cover-trans (S (i, j)).2 (\\lam m => (\n  \\have p => unsplit2 (\\lam i => len {g' i}) (\\lam p => (S p).1) i j m\n  \\in cover-inj p.1 (pmap g p.2))))"}
{"prompt": "['l : PFunc {V} {B}', 'env : Array B.E 3', 'k2 : Fin (len {map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (s.1, diff {B} s.2 b)) l})', 'V : PosetQModule', 'lr : IsReduced {V} {B} l', 'k1 : Fin (len {map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (s.1, diff {B} s.2 b)) l})', 'B : BooleanRing', 'p : index-right {\\\\Sigma V.E B.E} {map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (V.zro V.+ s.1, b B.* s.2)) l}\\n  {map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (s.1, diff {B} s.2 b)) l} k1 /= index-right {\\\\Sigma V.E B.E} {map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (V.zro V.+ s.1, b B.* s.2)) l}\\n  {map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (s.1, diff {B} s.2 b)) l} k2', 'b : B.E']<<<break>>>['true', '| \\\\infixl 6 + E E : E', '\\\\func split \\\\hlevels  {V : PosetQModule} {B : BooleanRing} (b : B.E) (l : PFunc {V} {B}) : Array (\\\\Sigma V.E B.E) \\n  => map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (V.zro V.+ s.1, b B.* s.2)) l ++ map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (s.1, diff {B} s.2 b)) l', \"\\\\func multiply \\\\plevels  \\\\hlevels  {n2 : Nat} (_ _ : NF n2) : NF n2 \\n  | {n}, l1, nil => nil {Array Bool n}\\n  | {n}, l1, l2 => multiply' {n} l1 l2 (nil {Array Bool n})\", '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', 'nil', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', \"\\\\func interpretNF \\\\hlevels  {B : BooleanRing} {n : Nat} (env : Fin n -> B.E) (l : NF n) : B.E \\n  => interpretNF' {B} {n} (\\\\new Array B.E n env) (collapse {n} (sort {LexicographicalArray {n} BoolOpPoset} l))\", '\\\\func Big {A1 B1 : \\\\Type} (_ : A1 -> B1 -> B1) (_ : B1) (_ : Array A1) : B1 \\n  | {A}, {B}, op, b, nil => b\\n  | {A}, {B}, op, b, :: {n} a l => op a (Big {A} {B} op b l)', '\\\\infixl 7 :* (_ _ : Term n)', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| \\\\infixl 7 * E E : E', 'false', '\\\\func diff \\\\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y', '| at (j : Fin len) : A j', \"\\\\func interpretNF' \\\\hlevels  {B3 : BooleanRing} {n2 : Nat} (_ : Array B.E n2) (_ : NF n2) : B.E \\n  | {B}, {n}, env, nil => B.zro\\n  | {B}, {n}, env, x :: nil => interpretMonomial {B} {n} env x\\n  | {B}, {n}, env, x :: l => interpretMonomial {B} {n} env x B.+ interpretNF' {B} {n} env l\", '| E : \\\\Set', 'var (Fin n)', '\\\\data Term \\\\plevels  \\\\hlevels  Nat \\n  | var (Fin n)\\n  | :zro\\n  | :negative (Term n)\\n  | \\\\infixl 6 :+ (_ _ : Term n)\\n  | \\\\infixl 7 :* (_ _ : Term n)', '\\\\func interpret \\\\hlevels  {B4 : BooleanRing} (env4 : Array B.E) (_ : Term env.len) : B.E \\n  | {B}, env, var j => env.at j\\n  | {B}, env, :zro => B.zro\\n  | {B}, env, :negative t => B.negative (interpret {B} env t)\\n  | {B}, env, t :+ s => interpret {B} env t B.+ interpret {B} env s\\n  | {B}, env, t :* s => interpret {B} env t B.* interpret {B} env s', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', ':zro', '\\\\func index-right {A1 : \\\\Type} {l1 m1 : Array A1} (_ : Fin m.len) : Fin (len {l1 ++ m1}) \\n  | {A}, {nil}, {m}, i => i\\n  | {A}, {:: {n} a l}, {m}, i => suc (index-right {A} {l} {m} i)', \"\\\\lemma apply-axioms \\\\hlevels  {B : BooleanRing} {n : Nat} (env : Array B.E n)\\n  (l : Array (\\\\Sigma (NF n) (t s : Term n) (interpret {B} env t = interpret {B} env s))) (add : NF n) :\\ninterpretNF {B} {n} env.at (Big {List (Array Bool n)} {List (Array Bool n)} (++) add\\n  (map {\\\\Sigma (NF n) (t s : Term n) (interpret {B} env t = interpret {B} env s)} {List (Array Bool n)}\\n    (\\\\lam (s : \\\\Sigma (NF n) (t s : Term n) (interpret {B} env t = interpret {B} env s)) =>\\n      multiply {n} s.1 (normalize {n} (s.2 :+ s.3))) l)) = interpretNF' {B} {n} env add \", '| zro : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func normalize {n5 : Nat} (_ : Term n5) : NF n5 \\n  | {n}, var j => singleAt {Bool} {n} j true false :: nil {Array Bool n}\\n  | {n}, :zro => nil {Array Bool n}\\n  | {n}, :negative t => normalize {n} t\\n  | {n}, t :+ s => normalize {n} t ++ normalize {n} s\\n  | {n}, t :* s => multiply {n} (normalize {n} t) (normalize {n} s)', '\\\\infixl 6 :+ (_ _ : Term n)', '\\\\func NF \\\\plevels  \\\\hlevels  (n : Nat) : \\\\Set0 => List (Array Bool n)', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpretNF {B} {3} env.at (Big {List (Array Bool 3)} {List (Array Bool 3)} (++) (nil {Array Bool 3})\n  (map {\\Sigma (NF 3) (t s : Term 3) (interpret {B} env t = interpret {B} env s)} {List (Array Bool 3)}\n    (\\lam (s : \\Sigma (NF 3) (t s : Term 3) (interpret {B} env t = interpret {B} env s)) =>\n      multiply {3} s.1 (normalize {3} (s.2 :+ s.3)))\n    (((false :: true :: false :: nil) :: (false :: false :: false :: nil) :: nil {Array Bool 3}, var {3} 0 :* var {3} 2,\n      :zro {3}, lr {k1} {k2} (\\lam (q1 : k1 = k2) => p (path (\\lam (_ : I) => index-right {\\Sigma V.E B.E}\n        {map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (_ : \\Sigma V.E B.E) => (V.zro V.+ \\this.1, b B.* \\this.2)) l}\n        {map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (_ : \\Sigma V.E B.E) => (\\this.1, diff {B} \\this.2 b)) l} (q1 @ \\this))))) :: nil))) = interpretNF' {B} {3} env (nil {Array Bool 3})", "completion": "apply-axioms env (((false :: true :: false :: nil) :: (false :: false :: false :: nil) :: nil, var 0 :* var 2, :zro,\n  lr {k1} {k2} (\\lam (q : k1 = k2) =>\n    p (path (\\lam (i : I) => index-right {\\Sigma V.E B.E} {map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (V.zro V.+ s.1, b B.* s.2)) l}\n      {map {\\Sigma V.E B.E} {\\Sigma V.E B.E} (\\lam (s : \\Sigma V.E B.E) => (s.1, diff {B} s.2 b)) l} (q @ i))))) :: nil) nil"}
{"prompt": "['X : PrecoverSpace']<<<break>>>['| isCauchy (Set (Set E)) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\instance PrecoverLattice \\\\hlevels  (X : \\\\Set) : CompleteLattice (PrecoverSpace X) {\\n  | <= => \\\\lam (A : E {\\\\this}) (B : E {\\\\this}) => \\\\Pi {C : Set (Set X)} -> A.isCauchy C -> B.isCauchy C\\n  | meet => meet-impl\\n  | join => join-impl\\n  | top => DiscreteCover X\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n  ClosurePrecoverSpace {X} (\\\\lam (C : Set (Set X)) => TruncP (\\\\Sigma (j : J) (isCauchy {f j} C)))\\n    (\\\\lam {C : Set (Set X)} (e : TruncP (\\\\Sigma (j : J) (isCauchy {f j} C))) (x : X) => (\\\\case e \\\\with {\\n      | inP (j, Cc) => cauchy-cover {f j} {C} Cc x\\n    }))\\n  | Meet => Meet-impl\\n} => \\\\new CompleteLattice {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Meet-cond => {?hidden}\\n  | Meet-univ => {?hidden}\\n}', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '\\\\class PrecoverSpace \\\\extends TopSpace \\\\hlevels  {\\n  | isCauchy (Set (Set E)) : \\\\Prop\\n  | cauchy-cover {C : Set (Set E)} (isCauchy C) (x : E) : TruncP (\\\\Sigma (U : Set E) (C U) (U x))\\n  | cauchy-top : isCauchy (single {E -> \\\\Prop} top)\\n  | cauchy-refine {C D : Set (Set E)} (isCauchy C) (Refines {E} C D) : isCauchy D\\n  | cauchy-glue {C : Set (Set E)} (isCauchy C) {D : Set E -> Set (Set E)} (\\\\Pi {U : Set E} -> C U -> isCauchy (D U)) : isCauchy (\\\\lam (U : Set E) => TruncP (\\\\Sigma (V W : Set E) (C V) (D V W) (U = V \u2227 W)))\\n  | cauchy-open {S : Set E} : TopSpace.isOpen S <-> (\\\\Pi {x : E} -> S x -> isCauchy (\\\\lam (U : Set E) => U x -> U \u2286 S))\\n}']<<<break>>>\\Pi {x : E} -> x <= \\new X {} -> \\Pi {C : Set (Set X.E)} -> x.isCauchy C -> X.isCauchy C", "completion": "\\lam p => p"}
{"prompt": "['eps : Rat']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\lemma natUnit \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n * m = 1) : m = 1 ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '| zro-right {x : E} : x + zro = x', '\\\\lemma reduce*gcd-right \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : (reduce a b).2 * gcd a b = b ', 'pos Nat', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| zro_*-left {x : E} : zro * x = zro', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>rat (pos 1) 1 {?hidden} {?hidden} + zro * eps <= rat (pos 1) 1 {?hidden} {?hidden}", "completion": "=_<= $ pmap ((+) _) zro_*-left *> zro-right"}
{"prompt": "['this : SubRing']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\class SubRing \\\\extends SubPseudoRing, SubSemiring \\\\hlevels ', '\\\\func IAddMonoid \\\\hlevels  {this2 : SubAddMonoid} : AddMonoid (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro)\\n  | + => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\\n} => \\\\new AddMonoid {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n}', '| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)', '\\\\func ISemiring \\\\hlevels  {this2 : SubSemiring} : Semiring (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro {\\\\new this2 {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new this2 {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n  | ide => (ide {S}, contains_ide)\\n  | natCoef => natCoefImpl\\n} => \\\\new Semiring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| contains_ide : contains (ide {S})', '| ide : E', '| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| contains_zro : contains (zro {S})', '\\\\class SubPseudoSemiring \\\\extends SubAddMonoid, SubSemigroup \\\\hlevels ', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func IAddGroup \\\\hlevels  {this2 : SubAddGroup} : AddGroup (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro)\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E {\\\\this}) => (negative {S} x.1, contains_negative {x.1} x.2)\\n} => \\\\new AddGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | negative-right => {?hidden}\\n}', '\\\\func natCoefImpl \\\\hlevels  {this2 : Semiring} (_ : Nat) : E \\n  | {this}, 0 => zro\\n  | {this}, suc n => natCoefImpl n + ide', '\\\\func ISemigroup \\\\hlevels  {this2 : SubSemigroup} : Semigroup (\\\\Sigma (x : E {S}) (contains x)) {\\n  | * => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n} => \\\\new Semigroup {\\n  | *-assoc => {?hidden}\\n}', '| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)', '\\\\class Ring \\\\extends PseudoRing, Semiring \\\\hlevels ', '\\\\func IRing \\\\hlevels  {this : SubRing} : Ring (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro {\\\\new this {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new this {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S} x.1, contains_negative {\\\\new this {}} {x.1} x.2)\\n  | ide => (ide {S}, contains_ide)\\n  | natCoef => natCoefImpl {ISemiring}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| E : \\\\Set', '| negative E : E', '| S : BaseSet', '| contains (E {S}) : \\\\Prop']<<<break>>>Ring (\\Sigma (x : E {S}) (contains x)) {\n  | zro => (zro {S}, contains_zro {\\new this {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new this {}} {x.1} {y.1} x.2 y.2)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S} x.1, contains_negative {\\new this {}} {x.1} x.2)\n  | ide => (ide {S}, contains_ide)\n  | natCoef => natCoefImpl {ISemiring}\n}", "completion": "IRing {this}"}
{"prompt": "[\"x' : Nat\", \"t' : (suc n' * ratDenom (fromInt (neg (suc x')))) div d < (suc x' * ratDenom (rat (neg (suc n')) d {?hidden} {?hidden})) div d\", \"reduced : gcd {NatEuclidean} (iabs (neg (suc n'))) d = 1\", \"n' : Nat\", 'd : Nat', 'd/=0 : d /= 0']<<<break>>>['\\\\lemma <_suc_<= \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < suc m) : n <= m ', 'suc Nat', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", 'neg Nat  {\\n  | 0 => pos 0\\n}', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\func \\\\infixl 8 div \\\\plevels  \\\\hlevels  (n m : Nat) : Nat => n div m', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', '\\\\func divMod \\\\plevels  \\\\hlevels  (_ _ : Nat) : \\\\Sigma Nat Nat ', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'suc<suc (n < m)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\func ratDenom \\\\plevels  \\\\hlevels  (_ : Rat) : Nat \\n  | rat nom d denom/=0 reduced => d', '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>suc ((suc n' * ratDenom (fromInt (neg (suc x')))) div d) <= (suc x' * d) div d", "completion": "<_suc_<= (suc<suc t')"}
{"prompt": "['this : PermutationRepresReducible', 'zeromod : IsZeroMod {R} S']<<<break>>>['| zro : E', '| S : LinRepres R G', '\\\\func invSubRepr \\\\hlevels  {this2 : PermutationRepresReducible} :\\nSubLRepres {PermutationRepresReducible.R} {PermutationRepresReducible.G} Repr R_m-triv {\\n  | in => \\\\new InterwiningMap {SubLRepres.G {\\\\this}} {SubLRepres.R {\\\\this}} (S {\\\\this}) (SubLRepres.E {\\\\this}) {\\n    | func => \\\\lam (r : BaseSet.E {PermutationRepresReducible.R}) (_ : BaseSet.E {X}) => r\\n    | func-+ => {?hidden}\\n    | func-*c => {?hidden}\\n    | func-** => {?hidden}\\n  }\\n} => \\\\new SubLRepres {\\n  | in-mono => {?hidden}\\n}', '| ide : E', '| R : Ring', '| E : \\\\Set']<<<break>>>ide {R} = zro {S}", "completion": "zeromod (ide {R {this}})"}
{"prompt": "['a : Rat', 'b : Rat', 'a>0 : zro < a', 'a<b : a < b']<<<break>>>['\\\\lemma finv_< {this : DiscreteOrderedField} {x y : E} (_ : zro < x) (_ : x < y) : finv y < finv x ', '| finv E : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)']<<<break>>>finv b < finv a", "completion": "finv_< a>0 a<b"}
{"prompt": "[\"this : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (RatField.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => RatField.negative\\n  | negative-left => {?hidden}\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | zeroProduct => {?hidden}\\n  | meet => meet\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join => join\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | *-comm => {?hidden}\\n  | finv => RatField.finv\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n}\", 'x : E {\\\\this}']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| ide-left {x : E} : ide * x = x', '\\\\func AltRat \\\\plevels  \\\\hlevels  : CRing (Type {IntRing} {subset}) {\\n  | zro => in~ {SType {IntRing} subset} {\\\\lam (a : SType {IntRing} subset) (b : SType {IntRing} subset) => a.1 * b.2 = b.1 * a.2}\\n    (zro, ide, contains_ide)\\n  | + => ++ {IntRing} {subset}\\n  | * => ** {IntRing} {subset}\\n  | negative => neg {IntRing} {subset}\\n  | ide => in~ {SType {IntRing} subset} {\\\\lam (a : SType {IntRing} subset) (b : SType {IntRing} subset) => a.1 * b.2 = b.1 * a.2}\\n    (ide, ide, contains_ide)\\n  | natCoef => \\\\lam (n : Nat) => in~ {SType {IntRing} subset} {\\\\lam (a : SType {IntRing} subset) (b : SType {IntRing} subset) => a.1 * b.2 = b.1 * a.2}\\n    (natCoef n, ide, contains_ide)\\n} => LocRing {IntRing} subset', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma *_alt \\\\plevels  \\\\hlevels  {x y : Rat} : rat_alt (x RatField.* y) = rat_alt x Semigroup.* rat_alt y ', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\func subset \\\\plevels  \\\\hlevels  : SubMonoid IntRing isPos => positiveSubset IntRing', 'pos Nat', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '\\\\lemma rat_alt-inj \\\\plevels  \\\\hlevels  {x y : Rat} (_ : rat_alt x = rat_alt y) : x = y ', '| \\\\infixl 7 * E E : E', '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\data Empty \\\\plevels  \\\\hlevels  ', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\func SType \\\\hlevels  {R : CRing} (S : SubMonoid R) : \\\\Set => \\\\Sigma (_ y : R.E) (S.contains y)', '\\\\func rat_alt \\\\plevels  \\\\hlevels  (x : Rat) : E \\n=> in~ {SType {IntRing} subset} {\\\\lam (a : SType {IntRing} subset) (b : SType {IntRing} subset) => a.1 * b.2 = b.1 * a.2}\\n  (ratNom x, pos (ratDenom x), signum_pos {ratDenom x} (ratDenom/=0 {x}))', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}']<<<break>>>ide {\\this} * x = x", "completion": "rat_alt-inj (*_alt *> ide-left {AltRat} {rat_alt x})"}
{"prompt": "['x : E {Dom {\\\\this}}', 'r : E {R {\\\\this}}', 'g : E {G}', 'this : LinRepres']<<<break>>>['| **-*c {g : E {G}} {e : E} {c : E {R}} : g ** (c *c e) = c *c g ** e', '| \\\\infixl 8 ** (E {G}) E : E', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set']<<<break>>>g ** (r *c x) = r *c g ** x", "completion": "**-*c {this}"}
{"prompt": "[\"fr : \\\\Pi {a : A.E} -> \\\\Pi {b b' : B.E} -> f a (b - b') = f a b - f a b'\", 'B : BoundedExPseudoNormedAbGroup', 'A : BoundedExPseudoNormedAbGroup', \"fl : \\\\Pi {a a' : A.E} -> \\\\Pi {b : B.E} -> f (a - a') b = f a b - f a' b\", 'f : A.E -> B.E -> C.E', 'C : ExPseudoNormedAbGroup', 'norm_*_<= : \\\\Pi {x : A.E} -> \\\\Pi {y : B.E} -> C.norm (f x y) <= A.norm x * B.norm y']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', 'true', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', \"\\\\class LocallyUniformMap \\\\extends CoverMap \\\\hlevels  {\\n  | func-locally-uniform {E1 : Set (Set (E {Cod}))} (isUniform {Cod} E1) : TruncP (\\\\Sigma (C : Set (Set (E {Dom}))) (isUniform {Dom} C) (\\\\Pi {U : Set (E {Dom})} ->\\n    C U -> isUniform {Dom} (\\\\lam (V : Set (E {Dom})) => TruncP (\\\\Sigma (W : Set (E {Cod})) (E1 W) (U \u2227 V \u2286 func ^-1 W)))))\\n  | func-cover => \\\\lam {E' : Set (Set (E {Cod}))} (E'c : isCauchy {Cod} E') => closure-univ-cover\\n    {E {Cod}} {isUniform {Cod}} {Dom} {func} (\\\\lam {E1 : Set (Set (E {Cod}))} (Eu : isUniform {Cod} E1) =>\\n      (uniform-cauchy {Dom} {\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (E1 V) (U = func ^-1 V))}).2\\n      (\\\\case func-locally-uniform {E1} Eu \\\\with {\\n        | inP (C, Cu, e) =>\\n        closure-refine {E {Dom}} {isUniform {Dom}} {\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (E1 V) (U = func ^-1 V))} {\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V W : Set (E {Dom})) (C V)\\n          (TruncP (\\\\Sigma (W1 : Set (E {Cod})) (E1 W1) ((\\\\lam (a : E {Dom}) => \\\\Sigma (V a) (W a)) \u2286 func ^-1 W1))) (U = V \u2227 W))} (closure-trans {E {Dom}} {isUniform {Dom}} {\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V W : Set (E {Dom})) (C V)\\n          (TruncP (\\\\Sigma (W1 : Set (E {Cod})) (E1 W1) ((\\\\lam (a : E {Dom}) => \\\\Sigma (V a) (W a)) \u2286 func ^-1 W1))) (U = V \u2227 W))} {C} (closure {E {Dom}} {isUniform {Dom}} {C} Cu) {\\\\lam (U : Set (E {Dom})) (V : Set (E {Dom})) =>\\n          TruncP (\\\\Sigma (W : Set (E {Cod})) (E1 W) ((\\\\lam (a : E {Dom}) => \\\\Sigma (U a) (V a)) \u2286 func ^-1 W))} (\\\\lam {U : Set (E {Dom})} (CU : C U) => closure {E {Dom}} {isUniform {Dom}} {\\\\lam (V : Set (E {Dom})) =>\\n          TruncP (\\\\Sigma (W : Set (E {Cod})) (E1 W) ((\\\\lam (a : E {Dom}) => \\\\Sigma (U a) (V a)) \u2286 func ^-1 W))} (e {U} CU)) (idp {Set (E {Dom}) -> \\\\Prop} {\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V W : Set (E {Dom})) (C V)\\n          (TruncP (\\\\Sigma (W1 : Set (E {Cod})) (E1 W1) ((\\\\lam (a : E {Dom}) => \\\\Sigma (V a) (W a)) \u2286 func ^-1 W1))) (U = V \u2227 W))})) (\\\\lam {Z : Set (E {Dom})} (p0 : TruncP (\\\\Sigma (V W : Set (E {Dom})) (C V)\\n          (TruncP (\\\\Sigma (W1 : Set (E {Cod})) (E1 W1) ((\\\\lam (a : E {Dom}) => \\\\Sigma (V a) (W a)) \u2286 func ^-1 W1))) (Z = V \u2227 W))) =>\\n        (\\\\case p0 \\\\with {\\n          | inP (U, V, CU, inP (W, EW, q), p) =>\\n          inP {\\\\Sigma (V : Set (E {Dom})) (TruncP (\\\\Sigma (V1 : Set (E {Cod})) (E1 V1) (V = func ^-1 V1))) (Z \u2286 V)} (func ^-1 W,\\n            inP {\\\\Sigma (V : Set (E {Cod})) (E1 V) (func ^-1 W = func ^-1 V)} (W, EW, idp {E {Dom} -> \\\\Prop} {func ^-1 W}),\\n            transportInv {E {Dom} -> \\\\Prop} (\\\\lam (x : E {Dom} -> \\\\Prop) => x \u2286 func ^-1 W) {Z} {U \u2227 V} p q)\\n        }))\\n      })) {E'} ((uniform-cauchy {Cod} {E'}).1 E'c)\\n}\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| dist E E : ExUpperReal', '\\\\lemma norm>=0 \\\\hlevels  {X : ExPseudoNormedAbGroup} {x : X.E} : zro <= X.norm x ', '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', 'Less', '| \\\\infixl 7 * E E : E', '\\\\lemma <=_+-positive \\\\hlevels  {this : PosetAddMonoid} {a b : E} (_ : zro <= a) (_ : zro <= b) : zro <= a + b ', '| at (j : Fin len) : A j', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| E : \\\\Set', 'var (Fin n)', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma <_+-left \\\\plevels  \\\\hlevels  {x y : ExUpperReal} (_ : x < y) {z : Rat} : x + fromRat z < y + fromRat z ', '| len : Nat', '\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\lemma <=_* \\\\plevels  \\\\hlevels  {x x' y y' : ExUpperReal} (_ : x <= x') (_ : y <= y') : x * y <= x' * y' \", '\\\\lemma <-rat \\\\plevels  \\\\hlevels  {x : ExUpperReal} {y : Rat} : x < fromRat y <-> x.U y ', '| zro-right {x : E} : x + zro = x', '| vars : Array (E {M})', '\\\\lemma norm_- \\\\hlevels  {X : ExPseudoNormedAbGroup} {x y : X.E} : X.norm (x - y) = X.norm (y - x) ', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '| meet-left {x y : E} : x \u2227 y <= x', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| zro<ide : zro < ide', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\lemma div-lb-rat \\\\plevels  \\\\hlevels  {a : Rat} {b : ExUpperReal} (_ : zro ExUpperRealAbMonoid.< fromRat a) (_ : zro ExUpperRealAbMonoid.< b) :\\n  TruncP (\\\\Sigma (c : Rat) (zro StrictPoset.< c) (fromRat a * fromRat c <= b)) ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro-left {x : E} : zro + x = x', '\\\\func interpretNF \\\\hlevels  {G : CGroup} {n : Nat} (env : Fin n -> G.E) (l : Array Int n) : G.E \\n  => sBigProd {G} (toArray {G} l (\\\\new Array G.E l.len env))', '| <-transitive-right \\\\alias \\\\infixr 9 <\u2218r {a1 a2 a3 : E} (a1 <= a2) (a2 < a3) : a1 < a3', '| meet-right {x y : E} : x \u2227 y <= y', '| C : Semiring', '| R : Semiring', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| <_meet-univ {x y z : E} (x < y) (x < z) : x < y \u2227 z', '\\\\func toCGroup \\\\hlevels  (G : AbGroup) : CGroup G.E {\\n  | ide => G.zro\\n  | * => (G.+)\\n  | inverse => G.negative\\n} => \\\\new CGroup {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | inverse-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '| V : \\\\Set', '| *-comm {x y : E} : x * y = y * x', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func IsBounded \\\\plevels  \\\\hlevels  {this : ExUpperReal} : \\\\Prop => TruncP (\\\\Sigma (r : Rat) (U r))', ':zro', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\lemma rdistr \\\\plevels  \\\\hlevels  {x y z : ExUpperReal} (_ : zro <= x) (_ : zro <= y) : (x + y) * z = x * z + y * z ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '| norm E : ExUpperReal', '| \\\\infix 4 < E E : \\\\Prop', '\\\\lemma terms-equality \\\\hlevels  {A : AbGroup} (env : Array A.E) (t s : Term env.len)\\n  (_ : interpretNF {toCGroup A} {env.len} env.at (normalize {env.len} (t :* :inverse {env.len} s)) = A.zro) :\\n  interpret {toCGroup A} {env.len} env.at t = interpret {toCGroup A} {env.len} env.at s ', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', \"\\\\lemma makeLocallyUniformMap2 \\\\hlevels  {X Y Z : ExPseudoMetricSpace} (f : X.E -> Y.E -> Z.E)\\n  (_ : \\\\Pi {eps : Rat} -> zro < eps -> TruncP (\\\\Sigma (delta : Rat) (zro < delta) (\\\\Pi (x0 : X.E) -> \\\\Pi (y0 : Y.E) ->\\n    TruncP (\\\\Sigma (gamma : Rat) (zro < gamma) (\\\\Pi {x x' : X.E} -> \\\\Pi {y y' : Y.E} -> U {X.dist x0 x} delta ->\\n      U {Y.dist y0 y} delta -> U {X.dist x x'} gamma -> U {Y.dist y y'} gamma -> U {Z.dist (f x y) (f x' y')} eps))))) :\\nLocallyUniformMap (X \u2a2f Y) Z {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => f s.1 s.2\\n} \", 'var V', \"\\\\lemma <_+ \\\\plevels  \\\\hlevels  {x y x' y' : ExUpperReal} (_ : x < x') (_ : y < y') : x + y < x' + y' \", '| U Rat : \\\\Prop', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| \\\\infixl 6 + E E : E', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| norm-dist {x y : E} : dist x y = norm (x - y)', '\\\\lemma simplify-correct \\\\hlevels  {this : CGroupData} (t : GroupTerm V) : interpret t = interpret (simplify t) ', '| \\\\infix 4 <= E E : \\\\Prop', \"\\\\lemma <_*-left' \\\\plevels  \\\\hlevels  {x y : ExUpperReal} (_ : x ExUpperRealAbMonoid.< y) (_ : zro <= x) {z : Rat} (_ : zro StrictPoset.< z) :\\n  x * fromRat z ExUpperRealAbMonoid.< y * fromRat z \", '\\\\lemma U_<= \\\\plevels  \\\\hlevels  {this : ExUpperReal} {q r : Rat} (_ : U q) (_ : q <= r) : U r ', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', ':inv (GroupTerm V)', '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| negative E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func ratNom \\\\plevels  \\\\hlevels  (_ : Rat) : Int \\n  | rat n denom denom/=0 reduced => n', '\\\\class CGroupData \\\\extends NatData \\\\hlevels ', '| <=-refl {x : E} : x <= x', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\lemma negative_zro \\\\hlevels  {this : AddGroup} : negative zro = zro ', '\\\\func signum \\\\plevels  \\\\hlevels  (_ : Int) : Int \\n  | pos 0 => pos 0\\n  | pos (suc n) => pos 1\\n  | neg (suc n) => neg 1', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", '\\\\infixl 6 :* (_ _ : GroupTerm V)', '| Dom : BaseSet', \"\\\\class ExPseudoNormedAbGroup \\\\extends ExPseudoMetricSpace, TopAbGroup \\\\hlevels  {\\n  | norm E : ExUpperReal\\n  | norm_zro : norm zro = zro\\n  | norm_negative {x : E} : norm (negative x) = norm x\\n  | norm_+ {x y : E} : norm (x AddMonoid.+ y) <= norm x ExUpperReal.+ norm y\\n  | norm-dist {x y : E} : ExPseudoMetricSpace.dist x y = norm (x - y)\\n  | open-inter => \\\\lam {U : Set E} {V : Set E} (Uo : TopSpace.isOpen U) (Vo : TopSpace.isOpen V) =>\\n  (cauchy-open {U \u2227 V}).2 (\\\\lam {x : E} (p0 : (\u2227) U V x) => (\\n    \\\\let (Ux, Vx) => p0\\n    \\\\in cauchy-refine {\\\\lam (U1 : Set E) => TruncP (\\\\Sigma (V1 W : Set E) (V1 x -> V1 \u2286 U) (W x -> W \u2286 V) (U1 = V1 \u2227 W))}\\n          {\\\\lam (U1 : Set E) => U1 x -> U1 \u2286 U \u2227 V}\\n          (cauchy-glue {\\\\lam (U1 : Set E) => U1 x -> U1 \u2286 U} ((cauchy-open {U}).1 Uo {x} Ux) {\\\\lam (_ : Set E) (U : Set E) => U x -> U \u2286 V}\\n            (\\\\lam {U1 : Set E} (_ : U1 x -> U1 \u2286 U) => (cauchy-open {V}).1 Vo {x} Vx))\\n          (\\\\lam {U1 : Set E} (p0 : TruncP (\\\\Sigma (V1 W : Set E) (V1 x -> V1 \u2286 U) (W x -> W \u2286 V) (U1 = V1 \u2227 W))) => (\\\\case p0 \\\\with {\\n            | inP (U', V', Uc, Vc, W=U'V') => inP {\\\\Sigma (V1 : Set E) (V1 x -> V1 \u2286 U \u2227 V) (U1 \u2286 V1)}\\n              (U' \u2227 V', \\\\lam (p0 : (\u2227) U' V' x) => \\\\lam {y : E} (p1 : (\u2227) U' V' y) => (\\n                \\\\let | (U'x, V'x) => p0\\n                     | (U'y, V'y) => p1\\n                \\\\in (Uc U'x {y} U'y, Vc V'x {y} V'y)), =_<= {SetLattice E} {U1} {U' \u2227 V'} W=U'V')\\n          }))))\\n  | +-cont => \\\\new UniformMap (ProductUniformSpace this24 this24) this24 {\\n    | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 AddMonoid.+ s.2\\n    | func-cont => {?hidden}\\n    | func-uniform => {?hidden}\\n  }\\n  | open-top => (cauchy-open {\\\\lam (_ : E) => \\\\Sigma}).2 (\\\\lam {x : E} (_ : \\\\Sigma) =>\\n    cauchy-refine {single {E -> \\\\Prop} top} {\\\\lam (U : Set E) => U x -> U \u2286 (\\\\lam (_ : E) => \\\\Sigma)} cauchy-top\\n      (\\\\lam {U : Set E} (_ : single {E -> \\\\Prop} top U) => inP {\\\\Sigma (V : Set E) (V x -> V \u2286 (\\\\lam (_ : E) => \\\\Sigma)) (U \u2286 V)}\\n        (U, \\\\lam (_ : U x) => \\\\lam {x : E} (_ : U x) => (), <=-refl {U})))\\n  | negative-cont => \\\\new UniformMap this25 this25 {\\n    | func => negative\\n    | func-cont => {?hidden}\\n    | func-uniform => {?hidden}\\n  }\\n  | neighborhood-uniform => \\\\lam {C : Set (Set E)} => (\\n    \\\\have lem => \\\\lam {x : E} {y : E} =>\\n          norm-dist {zro} {x - y} *> inv {ExUpperReal} {norm (negative (zro - (x - y)))} {norm (zro - (x - y))} (norm_negative {zro - (x - y)}) *> pmap {E} {ExUpperReal} norm {negative (zro - (x - y))} {x - y}\\n            (transport {E} (\\\\lam (x0 : E) => x0 = x - y) {x AddMonoid.+ negative y}\\n              {negative (zro AddMonoid.+ negative (x AddMonoid.+ negative y))}\\n              (inv {E} {negative (zro AddMonoid.+ negative (x AddMonoid.+ negative y))} {x AddMonoid.+ negative y}\\n                (((((path ((@) (negative_+ {zro} {negative (x AddMonoid.+ negative y)})) *> path (\\\\lam (i : I) => negative (negative_+ {x} {negative y} @ i) AddMonoid.+ negative zro)) *> path (\\\\lam (i : I) => negative_+ {negative (negative y)} {negative x} @ i AddMonoid.+ negative zro)) *> path (\\\\lam (i : I) => negative (negative x) AddMonoid.+ negative (negative (negative y)) AddMonoid.+ negative_zro @ i)) *> path ((@) (zro-right {negative (negative x) AddMonoid.+ negative (negative (negative y))}))) *> path (\\\\lam (i : I) => negative-isInv {x} @ i AddMonoid.+ negative (negative (negative y))) *> path (\\\\lam (i : I) => x AddMonoid.+ negative-isInv {negative y} @ i)))\\n              (idp {E} {x AddMonoid.+ negative y})) *> inv {ExUpperReal} {ExPseudoMetricSpace.dist x y} {norm (x - y)} (norm-dist {x} {y})\\n    \\\\in (\\\\lam (Cu : PreuniformSpace.isUniform C) => (\\\\case (dist-uniform {C}).1 Cu \\\\with {\\n          | inP (eps, eps>0, h) => inP {\\\\Sigma (U : Set E) (TopSpace.isOpen U) (U zro)\\n            (\\\\Pi (x : E) -> TruncP (\\\\Sigma (V : Set E) (C V) (\\\\Pi {y : E} -> U (x - y) -> V y)))}\\n            (OBall eps zro, OBall-open {eps} {zro}, OBall-center {eps} eps>0 {zro}, \\\\lam (x : E) => (\\\\case h x \\\\with {\\n              | inP (U1, CU, g) => inP {\\\\Sigma (V : Set E) (C V) (\\\\Pi {y : E} -> OBall eps zro (x - y) -> V y)}\\n                (U1, CU, \\\\lam {y : E} (d : OBall eps zro (x - y)) => g {y}\\n                  (transport {ExUpperReal} (\\\\lam (p0 : ExUpperReal) => p0.U eps) {ExPseudoMetricSpace.dist zro (x - y)} {ExPseudoMetricSpace.dist x y}\\n                    (lem {x} {y}) d))\\n            }))\\n        }),\\n          \\\\lam (p0 : TruncP (\\\\Sigma (U : Set E) (TopSpace.isOpen U) (U zro)\\n            (\\\\Pi (x : E) -> TruncP (\\\\Sigma (V : Set E) (C V) (\\\\Pi {y : E} -> U (x - y) -> V y))))) => (\\\\case p0 \\\\with {\\n            | inP (U1, Uo, U0, h) => \\\\case (dist_open {U1}).1 Uo {zro} U0 \\\\with {\\n              | inP (eps, eps>0, p) => (dist-uniform {C}).2 (inP {\\\\Sigma (eps : Rat) (zro < eps)\\n                (\\\\Pi (x : E) -> TruncP (\\\\Sigma (U1 : Set E) (C U1) (\\\\Pi {y : E} -> U {ExPseudoMetricSpace.dist x y} eps -> U1 y)))}\\n                (eps, eps>0, \\\\lam (x : E) => (\\\\case h x \\\\with {\\n                  | inP (U2, CU, g) => inP {\\\\Sigma (U1 : Set E) (C U1) (\\\\Pi {y : E} -> U {ExPseudoMetricSpace.dist x y} eps -> U1 y)}\\n                    (U2, CU, \\\\lam {y : E} (d : U {ExPseudoMetricSpace.dist x y} eps) => g {y} (p {x - y} (transportInv\\n                      {ExUpperReal} (\\\\lam (p0 : ExUpperReal) => p0.U eps) {ExPseudoMetricSpace.dist zro (x - y)} {ExPseudoMetricSpace.dist x y}\\n                        (lem {x} {y}) d)))\\n                })))\\n            }\\n          })))\\n  | open-Union => \\\\lam {S : Set (Set E)} (So : \\\\Pi {U : Set E} -> S U -> TopSpace.isOpen U) =>\\n  (cauchy-open {Union {E} S}).2 (\\\\lam {x : E} (p0 : Union {E} S x) => (\\\\case p0 \\\\with {\\n    | inP (U, SU, Ux) => cauchy-refine {\\\\lam (U1 : Set E) => U1 x -> U1 \u2286 U} {\\\\lam (U : Set E) => U x -> U \u2286 Union {E} S}\\n      ((cauchy-open {U}).1 (So {U} SU) {x} Ux)\\n      (\\\\lam {V : Set E} (Vc : V x -> V \u2286 U) => inP {\\\\Sigma (V1 : Set E) (V1 x -> V1 \u2286 Union {E} S) (V \u2286 V1)}\\n        (V, \\\\lam (Vx : V x) => Vc Vx <=\u2218 Union-cond {E} {S} {U} SU, <=-refl {V}))\\n  }))\\n}\", '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', 'inP A', '| norm_+ {x y : E} : norm (x AddMonoid.+ y) <= norm x ExUpperReal.+ norm y', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', ':inverse (Term n)', '\\\\instance RegularPreuniformSpaceHasProduct \\\\hlevels  : HasProduct RegularPreuniformSpace {\\n  | Product => ProductRegularPreuniformSpace\\n} => \\\\new HasProduct', '\\\\func normalize \\\\plevels  \\\\hlevels  {n4 : Nat} (_ : Term n4) : Array Int n4 \\n  | {n}, var v => singleAt {Int} {n} v (pos 1) (pos 0)\\n  | {n}, :ide => replicate {Int} n (pos 0)\\n  | {n}, :inverse t => map {Int} {Int} negative (normalize {n} t)\\n  | {n}, t :* s => mkArray {Int} {n} (\\\\lam (j : Fin n) => at {normalize {n} t} j + at {normalize {n} s} j)', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', '\\\\lemma +-rat \\\\plevels  \\\\hlevels  {x y : Rat} : fromRat x ExUpperReal.+ fromRat y = fromRat (x RatField.+ y) ', ':ide', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '\\\\infixl 7 :* (_ _ : Term n)', '| M : Monoid', '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| norm-bounded (x : E) : IsBounded {norm x}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'var V', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>LocallyUniformMap (A \u2a2f B) C {\n  | func => \\lam (s : E {Dom {\\this}}) => f s.1 s.2\n}", "completion": "makeLocallyUniformMap2 f (\\lam {eps} eps>0 => inP (1, idp, \\lam x0 y0 => (\\case norm-bounded x0, norm-bounded y0 \\with {\n  | inP (x0b, |x0|<x0b), inP (y0b, |y0|<y0b) =>\n  \\case div-lb-rat {x0b + 1 + (y0b + 1 + 1)} {fromRat eps} (inP (1, idp, <=-rat.1 $ linarith (norm>=0 |x0|<x0b, norm>=0 |y0|<y0b)))\n    (<-rat.2 eps>0) \\with {\n    | inP (gamma, gamma>0, gamma-m) =>\n    inP (gamma \u2227 1, <_meet-univ gamma>0 (zro<ide {RatField}), \\lam {x} {x'} {y} {y'} x0x<1 y0y<1 xx'<gamma yy'<gamma =>\n      rewrite norm-dist xx'<gamma at xx'<gamma $ rewrite norm-dist yy'<gamma at yy'<gamma $ rewrite norm-dist x0x<1 at x0x<1 $ rewrite norm-dist y0y<1 at y0y<1 $ rewrite norm-dist $ <-rat.1 $ transport (\\lam p0 => norm p0 < eps) (pmap2 (+) fr fl *> simplify : f x (y - y') + f (x - x') y' = f x y - f x' y') $ norm_+ <\u2218r <=_+ norm_*_<= norm_*_<= <\u2218r transport (\\lam p0 => _ + p0 < _) *-comm\n        (<=_+ (<=_* <=-refl $ <=-less $ <-rat.2 yy'<gamma) (<=_* <=-refl (<=-less $ <-rat.2 xx'<gamma)) <\u2218r transport (\\lam _x => _x < _) (rdistr norm>=0 norm>=0) (<=_* <=-refl (<=-rat.1 meet-left) <\u2218r <_*-left' (\n          \\have lem {X : ExPseudoNormedAbGroup} {x1 x2 : X} (d : U {norm (x1 - x2)} 1) : norm x2 <= norm x1 + 1 =>\n                  transport (\\lam p0 => _ <= _ + p0) norm_- (=_<= (pmap norm abGroup) <=\u2218 norm_+) <=\u2218 <=_+ <=-refl (<=-less $ <-rat.2 d)\n          \\in <=_+ (lem x0x<1) (lem (U_<= yy'<gamma meet-right) <=\u2218 <=_+ (lem y0y<1) <=-refl) <\u2218r transport ((<) _) +-rat\n                (<_+ (transport ((<) _) +-rat $ <_+-left $ <-rat.2 |x0|<x0b) $ transport ((<) _) +-rat $ <_+-left $ transport ((<) _) +-rat $ <_+-left $ <-rat.2 |y0|<y0b))\n          (<=_+-positive {ExUpperRealAbMonoid} norm>=0 norm>=0) gamma>0 <\u2218l gamma-m)))\n  }\n})))"}
{"prompt": "['A : AddGroup X']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| zro-right {x : E} : x + zro = x', '| E : \\\\Set']<<<break>>>\\Pi {x : A.E} -> x A.+ A.zro = x", "completion": "zro-right {A}"}
{"prompt": "['V : Set E', 'this : CoverSpace', 'Vx : V x', 'U : Set E', 'x : E', 'V<=<U : V <=< U']<<<break>>>['| <=<-right {U V W : E {A}} (U <= V) (R V W) : R U W', '| E : \\\\Set', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '\\\\lemma single_<= \\\\hlevels  {X : \\\\Set} {a : X} {U : Set X} (_ : U a) : single {X} a \u2286 U ']<<<break>>>single {E} x <=< U", "completion": "<=<-right (single_<= Vx) V<=<U"}
{"prompt": "['this : Precat X {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Trunc0 (x = y)\\n  | id => \\\\lam (x : Ob {\\\\this}) => in0 {x = x} (idp {X} {x})\\n  | o => o {X}\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', 'X : \\\\Type']<<<break>>>['\\\\data Trunc0 \\\\Type : \\\\Set \\n  | in0 A', 'in0 A', '| Hom Ob Ob : \\\\Set', '\\\\func o {X1 : \\\\Type} {x1 y1 z1 : X1} (_ : Trunc0 (y1 = z1)) (_ : Trunc0 (x1 = y1)) : Trunc0 (x1 = z1) \\n  | {X}, {x}, {y}, {z}, in0 y=z, in0 x=y => in0 {x = z} (x=y *> y=z)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| Ob : \\\\hType', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", \"\\\\func idp_*> {A1 : \\\\Type} {a1 a' : A1} (p : a1 = a') : idp {A1} {a1} *> p = p \\n  | {A}, {a}, {a'}, idp => idp {a = a} {idp {A} {a} *> idp {A} {a}}\"]<<<break>>>\\Pi {o1 : Ob {\\this}} ->\n  \\Pi {o2 : Ob {\\this}} -> \\Pi {p : Hom {\\this} o1 o2} -> o {X} {o1} {o1} {o2} p (in0 {o1 = o1} (idp {X} {o1})) = p", "completion": "\\lam {_} {_} {p} => cases p (\\case  \\with {}) (pmap in0 (idp_*> _))"}
{"prompt": "['f : UniformEmbedding M L', 'L : UniformLocale', 'a : at {L.E :: L.E :: (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U)) :: L.E :: nil} 1', 'c : (\\\\case (1, a) \\\\with {\\n  | (zero, a) => (\\\\Sigma, a, \\\\lam (_ : \\\\Sigma) => L.top)\\n  | (suc zero, a) => (IsPositive {L} a, a, \\\\lam (_ : IsPositive {L} a) => a)\\n  | (suc (suc zero), U) => (\\\\Sigma (x : L.E) (U.1 x), L.top, \\\\lam (p0 : \\\\Sigma (x : L.E) (U.1 x)) => p0.1)\\n  | (suc (suc (suc zero)), a) => (\\\\Sigma (b : L.E) (b <=u a), a, \\\\lam (p0 : \\\\Sigma (b : L.E) (b <=u a)) => p0.1)\\n}).2 L.<= L.Join {P} (\\\\lam (_ : P) => L.top)', 'P : \\\\Prop', 'sd : isStronglyDense {f}', 'M : UniformLocale']<<<break>>>['| isUniform (E -> \\\\Prop) : \\\\Prop', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func pHat \\\\hlevels  {this : Locale} (P : \\\\Prop) : E => Join {P} (\\\\lam (_ : P) => top)', '| Join {J : \\\\Set} (J -> E) : E', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func \\\\infix 4 <=u \\\\hlevels  {L : PreuniformLocale} (a b : L.E) : \\\\Prop => TruncP (\\\\Sigma (U : L.E -> \\\\Prop) (L.isUniform U) (star {L} a U L.<= b))', '\\\\func Total {B : \\\\Type} (F : B -> \\\\Type) : \\\\Type => \\\\Sigma (b : B) (F b)', '| at (j : Fin len) : A j', '| top : E', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func IsPositive \\\\hlevels  {this : Locale} (a : E) : \\\\Prop => \\\\Pi (P : \\\\Prop) -> a <= pHat P -> P', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>M.Join {\\Sigma (b : M.E) (f.func b L.<= (\\case (1, a) \\with {\n  | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => L.top)\n  | (suc zero, a) => (IsPositive {L} a, a, \\lam (_ : IsPositive {L} a) => a)\n  | (suc (suc zero), U) => (\\Sigma (x : L.E) (U.1 x), L.top, \\lam (p0 : \\Sigma (x : L.E) (U.1 x)) => p0.1)\n  | (suc (suc (suc zero)), a) => (\\Sigma (b : L.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : L.E) (b <=u a)) => p0.1)\n}).2)}\n  (\\lam (t : Total {M.E} (\\lam (p0 : M.E) => f.func p0 L.<= (\\case (1, a) \\with {\n    | (zero, a) => (\\Sigma, a, \\lam (_ : \\Sigma) => L.top)\n    | (suc zero, a) => (IsPositive {L} a, a, \\lam (_ : IsPositive {L} a) => a)\n    | (suc (suc zero), U) => (\\Sigma (x : L.E) (U.1 x), L.top, \\lam (p0 : \\Sigma (x : L.E) (U.1 x)) => p0.1)\n    | (suc (suc (suc zero)), a) => (\\Sigma (b : L.E) (b <=u a), a, \\lam (p0 : \\Sigma (b : L.E) (b <=u a)) => p0.1)\n  }).2)) => t.1) M.<= pHat {M} P", "completion": "Join-univ (\\lam p => sd $ p.2 <=\u2218 c)"}
{"prompt": "['R : Ring', 'N : LModule R', 'M : LModule R', 'f : LinearMap {R} M N']<<<break>>>['\\\\instance KerLModule \\\\hlevels  {R1 : Ring} {A B : LModule R1} (f : LinearMap {R1} A B) : LModule R1 (Kernel f) {\\n  | zro => (zro {f.Dom}, f.func-zro)\\n  | + => \\\\lam (a : E) (b : E) => (a.1 + b.1,\\n    f.func-+ {a.1} {b.1} *> pmap2 {E {f.Cod}} {E {f.Cod}} {E {f.Cod}} ((+) {f.Cod}) {f.func a.1} {zro {f.Cod}} a.2 {f.func b.1} {zro {f.Cod}} b.2 *> zro-left {f.Cod} {zro {f.Cod}})\\n  | negative => \\\\lam (a : E) => (negative {f.Dom} a.1,\\n    func-negative {f} {a.1} *> pmap {E {f.Cod}} {E {f.Cod}} (negative {f.Cod}) {f.func a.1} {zro {f.Cod}} a.2 *> negative_zro {f.Cod})\\n  | *c => \\\\lam (r : E {R {\\\\this}}) (a : E {\\\\this}) =>\\n    (r A.*c a.1, f.func-*c {r} {a.1} *> pmap {B.E} {B.E} ((B.*c) r) {f.func a.1} {B.zro} a.2 *> *c_zro-right {B} {r})\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '| Cod : BaseSet', '\\\\func ImageLModuleRightHom \\\\hlevels  {R1 : Ring} {A B : LModule R1} (f : LinearMap {R1} A B) : LinearMap {R1} (ImageLModule {R1} {A} {B} f) B {\\n  | func => \\\\lam (p0 : E {Dom {ImageAddPointedRightHom f}}) => p0.1\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '\\\\func IsSurj {A B : \\\\Type} (f : A -> B) : \\\\Prop => \\\\Pi (y : B) -> TruncP (\\\\Sigma (x : A) (f x = y))', '| R : Ring', '\\\\type Image {A B : \\\\Type} (f : A -> B) : \\\\Type => \\\\Sigma (b : B) (TruncP (\\\\Sigma (a : A) (f a = b)))', '\\\\lemma surj->FullIm \\\\hlevels  {R : Ring} {M N : LModule R} {f : LinearMap {R} M N} (_ : IsSurj {M.E} {N.E} f.func) :\\n  IsSurj {Image {M.E} {N.E} f.func} {N.E} (func {ImageLModuleRightHom {R} {M} {N} f}) ', \"\\\\func IsInj \\\\hlevels  {A B : \\\\Set} (f : A -> B) : \\\\Prop => \\\\Pi {a a' : A} -> f a = f a' -> a = a'\", '\\\\func IsZeroMod \\\\hlevels  {R : Ring} (M : LModule R) : \\\\Prop => \\\\Pi (m : M.E) -> m = M.zro', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\lemma inj->zeroKer \\\\hlevels  {R : Ring} {M N : LModule R} {f : LinearMap {R} M N} (_ : IsInj {M.E} {N.E} f.func) :\\n  IsZeroMod {R} (KerLModule {R} {M} {N} f) ', '| Dom : BaseSet']<<<break>>>\\Sigma (IsInj {M.E} {N.E} f.func) (IsSurj {M.E} {N.E} f.func) -> \\Sigma (IsZeroMod {R} (KerLModule {R} {M} {N} f))\n  (IsSurj {Image {M.E} {N.E} f.func} {N.E} (func {ImageLModuleRightHom {R} {M} {N} f}))", "completion": "\\lam p => (inj->zeroKer p.1, surj->FullIm p.2)"}
{"prompt": "['this : BooleanRing', 'x : E', 'z : E', 'y : E']<<<break>>>['| <=-refl {x : E} : x <= x', '\\\\lemma diff_* \\\\hlevels  {this : BooleanRing} {x y : E} : diff x y * y = zro ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\type \\\\infix 4 <= \\\\hlevels  {R : Semigroup} (x y : R.E) : \\\\Prop => x R.* y = x', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func diff \\\\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y', '| *-comm {x y : E} : x * y = y * x', '\\\\lemma diff-univ \\\\hlevels  {this : BooleanRing} {x y z : E} (_ : x <= y) (_ : x * z = zro) : x <= diff y z ', \"\\\\lemma diff-mono \\\\hlevels  {this : BooleanRing} {x y x' y' : E} (_ : x <= x') (_ : y' <= y) : diff x y <= diff x' y' \", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', \"\\\\lemma join-monotone \\\\hlevels  {this : JoinSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2228 y <= x' \u2228 y' \", '\\\\lemma diff_<= \\\\hlevels  {this : BooleanRing} {x y : E} : diff x y <= x ', '| zro_*-left {x : E} : zro * x = zro', '| meet-right {x y : E} : x \u2227 y <= y', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>diff (diff x z) y \u2228 diff x z \u2227 y <= diff x y \u2228 diff y z", "completion": "join-monotone {this} (diff-mono {this} (diff_<= {this}) (<=-refl {this}))\n  (diff-univ {this} (meet-right {this}) $ *-assoc {this} *> pmap ((*) {this} _) (*-comm {this}) *> inv (*-assoc {this}) *> pmap (\\lam _x => _x * {this} y) (diff_* {this}) *> zro_*-left {this})"}
{"prompt": "['R : CRing', 'l : Array R.E n', 'j : Fin n']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| ide : E', '| E : \\\\Set', '| ide-right {x : E} : x * ide = x']<<<break>>>l !! j R.* R.ide = l !! j", "completion": "ide-right {_} {l !! j}"}
{"prompt": "['y : E', 'x>0 : isPos x', 'this : OrderedField', 'x*y>0 : isPos (x * y)', 'y<0 : isNeg y', 'x : E']<<<break>>>['| \\\\infixl 7 * E E : E', '| \\\\infixl 6 + E E : E', '| isPos E : \\\\Prop', '| negative E : E', '| positive_negative_* {x y : E} (isPos x) (isNeg y) : isNeg (x * y)', '| positive_+ {x y : E} (isPos x) (isPos y) : isPos (x + y)']<<<break>>>isPos (x * y + negative (x * y))", "completion": "positive_+ {this} x*y>0 (positive_negative_* {this} x>0 y<0)"}
{"prompt": "['R : NearSkewField', 'X : TopLModule R', 'f : Total {X.E} S -> Y.E', 'x : Total {X.E} S', 'Y : HausdorffTopLModule R', 'S : Set X.E']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\lemma *c_zro-right \\\\hlevels  {this : LModule} {r : E {R}} : r *c zro = zro ', '\\\\lemma negative_zro \\\\hlevels  {this : AddGroup} : negative zro = zro ', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| zro-right {x : E} : x + zro = x', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '| inv : E {M}', '| open-top : isOpen top', '| negative-right {x : E} : x + negative x = zro', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| val : E {M}', '\\\\func dquot \\\\hlevels  {R : NearSkewField} {X Y : TopLModule R} {S : Set X.E} (f : Total {X.E} S -> Y.E) {x : Total {X.E} S} (h : Inv {R})\\n  (a : X.E) (\\\\property s : S (x.1 X.+ h.val X.*c a)) : Y.E => h.inv Y.*c (f (x.1 X.+ h.val X.*c a, s) - f x)', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| isOpen (Set E) : \\\\Prop', '| top : E', '| zro-left {x : E} : zro + x = x', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| negative E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func Total {X : \\\\Type} (U : Set X) : \\\\Type => \\\\Sigma (x : X) (\\\\property (U x))']<<<break>>>\\Pi {V : Set Y.E} -> Y.isOpen V -> V Y.zro -> TruncP (\\Sigma (W : Set R.E) (R.isOpen W) (W R.zro) (\\Pi {h : R.E} ->\n  W h -> \\Pi (hi : Inv {R} h) -> \\Pi (s : S (x.1 X.+ h X.*c X.zro)) -> V (Y.zro - dquot {R} {X} {Y} {S} f {x} hi X.zro {?hidden})))", "completion": "\\lam Vo V0 => inP (top, open-top, (),\n  \\lam _ _ _ => unfold dquot $ rewrite (zro-left, *c_zro-right {X}, zro-right, negative-right, *c_zro-right {Y}, negative_zro {Y}) V0)"}
{"prompt": "['context-add : List env.Sort', 'env : FSignature', 'i1 : Index {env.Sort} context-add', 'mc : MetaContext env.Sort', 'context-b : List env.Sort', 'context-res : List env.Sort']<<<break>>>['\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', '\\\\func Index {A : \\\\Type} (list : List A) : \\\\Type => Fin (length {A} list)', '| Sort : \\\\Set', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func shift-index \\\\hlevels  {A2 : \\\\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)', '\\\\func identity {A2 : \\\\Type} {list1 : List A2} : SubList {A2} list1 list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})', \"\\\\func push-transport-into-var \\\\hlevels  {env1 : FSignature} {s1 : env.Sort} {context1 context' : List env.Sort} (eq : context1 = context')\\n  {ms1 : MetaContext env.Sort} (index1 : Index {env.Sort} context1) (eq'1 : s1 = context1 !! index1) :\\n\\\\Sigma (eqn : s1 = context' !! transport {List env.Sort} (Index {env.Sort}) {context1} {context'} eq index1)\\n  (transport {List env.Sort} (\\\\lam (p0 : List env.Sort) => Term env1 p0 s1 ms1) {context1} {context'} eq\\n    (var {env1} {context1} {s1} {ms1} index1 eq'1) = var {env1} {context'} {s1} {ms1} (transport {List env.Sort} (Index {env.Sort}) {context1} {context'} eq index1) eqn) \\n  | {env}, {s}, {context}, {context'}, idp, {ms}, index, eq' => (eq', idp {Term env context s ms}\\n    {transport {List env.Sort} (\\\\lam (p0 : List env.Sort) => Term env p0 s ms) {context} {context} (idp {List env.Sort} {context})\\n      (var {env} {context} {s} {ms} index eq')})\", 'var (index : Index {env.Sort} context) (termSort = context !! index)', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\func expand-fin-right {A1 : \\\\Type} {a b1 : List A1} (_ : Index {A1} b1) : Index {A1} (a ++ b1) \\n  | {A}, {nil}, {b}, i => i\\n  | {A}, {a :: a1}, {b}, i => suc (expand-fin-right {A} {a1} {b} i)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func proof \\\\hlevels  {A3 : \\\\Set} {a1 b1 : List A3} {point : A3} (sublist3 : SubList {A3} a1 b1) (ind3 : Index {A3} a1)\\n  (_ : point = a1 !! ind3) : point = b1 !! shift-index {A3} {a1} {b1} sublist3 ind3 \\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, zero, idp => p\\n  | {A}, {x :: xs}, {y :: ys}, {point}, sublist-match p sublist, suc ind, idp =>\\n    proof {A} {xs} {ys} {(x :: xs) !! suc ind} sublist ind (idp {A} {(x :: xs) !! suc ind})\\n  | {A}, {nil}, {y :: ys}, {point}, sublist-skip sublist, ind, idp =>\\n    proof {A} {nil {A}} {ys} {nil {A} !! ind} sublist ind (idp {A} {nil {A} !! ind})\\n  | {A}, {x :: a}, {y :: b}, {point}, sublist-skip sublist, ind, idp =>\\n    proof {A} {x :: a} {b} {(x :: a) !! ind} sublist ind (idp {A} {(x :: a) !! ind})', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func ++-assoc {A2 : \\\\Type} {xs1 ys2 zs2 : List A2} : (xs1 ++ ys2) ++ zs2 = xs1 ++ ys2 ++ zs2 \\n  | {A}, {nil}, {ys}, {zs} => idp {List A} {(nil {A} ++ ys) ++ zs}\\n  | {A}, {x :: xs}, {ys}, {zs} =>\\n    pmap {List A} {List A} ((::) x) {(xs ++ ys) ++ zs} {xs ++ ys ++ zs} (++-assoc {A} {xs} {ys} {zs})', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func extend-left-single {A1 : \\\\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \\n  | {A}, {l}, {r}, sublist, {nil} => sublist\\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})', '\\\\func correct {A2 : \\\\Type} {a b2 : List A2} (i2 : Index {A2} b2) : (a ++ b2) !! expand-fin-right {A2} {a} {b2} i2 = b2 !! i2 \\n  | {A}, {nil}, {b}, i => idp {A} {(nil {A} ++ b) !! expand-fin-right {A} {nil {A}} {b} i}\\n  | {A}, {a :: a1}, {b}, i => correct {A} {a1} {b} i']<<<break>>>transport {List env.Sort} (\\lam (p0 : List env.Sort) =>\n  Term env p0 ((context-b ++ context-add) !! expand-fin-right {env.Sort} {context-b} {context-add} i1) mc)\n  {(context-res ++ context-b) ++ context-add} {context-res ++ context-b ++ context-add}\n  (++-assoc {env.Sort} {context-res} {context-b} {context-add}) (var {env} {(context-res ++ context-b) ++ context-add}\n    {(context-b ++ context-add) !! expand-fin-right {env.Sort} {context-b} {context-add} i1} {mc}\n    (shift-index {env.Sort} {context-add} {(context-res ++ context-b) ++ context-add}\n      (extend-left-single {env.Sort} {context-add} {context-add} (identity {env.Sort} {context-add}) {context-res ++ context-b})\n      i1)\n    (proof {env.Sort} {context-add} {(context-res ++ context-b) ++ context-add}\n      {(context-b ++ context-add) !! expand-fin-right {env.Sort} {context-b} {context-add} i1}\n      (extend-left-single {env.Sort} {context-add} {context-add} (identity {env.Sort} {context-add}) {context-res ++ context-b})\n      i1 (correct {env.Sort} {context-b} {context-add} i1))) = var {env} {context-res ++ context-b ++ context-add}\n  {(context-b ++ context-add) !! expand-fin-right {env.Sort} {context-b} {context-add} i1} {mc}\n  (transport {List env.Sort} (Index {env.Sort}) {(context-res ++ context-b) ++ context-add} {context-res ++ context-b ++ context-add}\n    (++-assoc {env.Sort} {context-res} {context-b} {context-add})\n    (shift-index {env.Sort} {context-add} {(context-res ++ context-b) ++ context-add}\n      (extend-left-single {env.Sort} {context-add} {context-add} (identity {env.Sort} {context-add}) {context-res ++ context-b})\n      i1))\n  (push-transport-into-var {env} {(context-b ++ context-add) !! expand-fin-right {env.Sort} {context-b} {context-add} i1}\n    {(context-res ++ context-b) ++ context-add} {context-res ++ context-b ++ context-add}\n    (++-assoc {env.Sort} {context-res} {context-b} {context-add}) {mc}\n    (shift-index {env.Sort} {context-add} {(context-res ++ context-b) ++ context-add}\n      (extend-left-single {env.Sort} {context-add} {context-add} (identity {env.Sort} {context-add}) {context-res ++ context-b})\n      i1)\n    (proof {env.Sort} {context-add} {(context-res ++ context-b) ++ context-add}\n      {(context-b ++ context-add) !! expand-fin-right {env.Sort} {context-b} {context-add} i1}\n      (extend-left-single {env.Sort} {context-add} {context-add} (identity {env.Sort} {context-add}) {context-res ++ context-b})\n      i1 (correct {env.Sort} {context-b} {context-add} i1))).1", "completion": "(push-transport-into-var _ _ _).2"}
{"prompt": "['a : E', 'this : GCDMonoid']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func BigProd \\\\hlevels  {this : Monoid} (l : Array E) : E => Big {E} {E} (*) ide l', 'inP A', '| E : \\\\Set', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}', '\\\\lemma ide-div \\\\hlevels  {M : Monoid} {x : M.E} : LDiv {M} M.ide x x ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (LDiv (BigProd nil) a)", "completion": "inP ide-div"}
{"prompt": "['x : Real', 'this : Real (\\\\lam (a : Rat) => x.U (RatField.negative a)) (\\\\lam (a : Rat) => x.L (RatField.negative a)) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}']<<<break>>>['\\\\func negative (_ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 xReduced => rat (negative xNom) xDenom {?hidden} {?hidden}', '| L Rat : \\\\Prop', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"| L-closed {q q' : Rat} (L q) (q' < q) : L q'\", '| U Rat : \\\\Prop', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 < E E : \\\\Prop', '\\\\lemma negative_< \\\\hlevels  {this : OrderedAddGroup} {x y : E} (_ : x < y) : negative y < negative x ']<<<break>>>\\Pi {q q' : Rat} -> U {\\this} q -> q < q' -> x.L (negative q')", "completion": "\\lam -q<x q<q' => L-closed {x} -q<x (negative_< {RatField} q<q')"}
{"prompt": "[\"this : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (RatField.*)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => RatField.negative\\n  | negative-left => {?hidden}\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | zeroProduct => {?hidden}\\n  | meet => meet\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join => join\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | *-comm => {?hidden}\\n  | finv => RatField.finv\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n}\", 'x : E {\\\\this}', 'y : E {\\\\this}']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| \\\\infixl 6 + E E : E', 'suc Nat', '| positive_* {x y : E} (isPos x) (isPos y) : isPos (x * y)', \"\\\\func makeRat \\\\plevels  \\\\hlevels  (_ : Int) (denom1 : Nat) (_ : denom1 /= 0) : Rat \\n  | nom, suc 0, denom/=0 => fromInt nom\\n  | nom, denom, denom/=0 => makeRat' nom denom denom/=0\", '\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\func ratNom \\\\plevels  \\\\hlevels  (_ : Rat) : Int \\n  | rat n denom denom/=0 reduced => n', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\instance NatEuclidean \\\\hlevels  : EuclideanSemiringData Nat {\\n  | zro => 0\\n  | + => (+)\\n  | * => (*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | # => (#)\\n  | decideEq => decideEq\\n  | euclideanMap => \\\\lam (n : E {\\\\this}) => n\\n  | divMod => Nat.divMod\\n  | summandDiv => summandDiv\\n} => \\\\new EuclideanSemiringData {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n  | isDivMod => {?hidden}\\n  | isEuclideanMap => {?hidden}\\n}', '\\\\lemma signum_pos \\\\plevels  \\\\hlevels  {n : Nat} (_ : Not (n = 0)) : signum (pos n) = pos 1 ', '\\\\lemma positive_+ {x y : Int} (_ : signum x = pos 1) (_ : signum y = pos 1) : signum (x + y) = pos 1 ', '\\\\lemma signum_nom \\\\plevels  \\\\hlevels  {nom : Int} {denom : Nat} {denom/=0 : Not (denom = 0)} : signum (ratNom (makeRat nom denom denom/=0)) = signum nom ', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func gcd \\\\hlevels  {this : EuclideanSemiringData} (a b : E) : E => gcd-fueled (suc' (euclideanMap b)) a b\", '\\\\func signum \\\\plevels  \\\\hlevels  (_ : Int) : Int \\n  | pos 0 => pos 0\\n  | pos (suc n) => pos 1\\n  | neg (suc n) => neg 1', 'pos Nat', '| isPos E : \\\\Prop', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\lemma productNonZero \\\\plevels  \\\\hlevels  {n m : Nat} (_ : Not (n = 0)) (_ : Not (m = 0)) : Not (n * m = 0) ', 'rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\func * (_ _ : Int) : Int \\n  | pos n, pos m => pos (n * m)\\n  | pos n, neg m => neg (n * m)\\n  | neg (suc n), pos m => neg (suc n * m)\\n  | neg (suc n), neg m => pos (suc n * m)', '\\\\func + (_ _ : Int) : Int \\n  | pos n, pos m => pos (n + m)\\n  | pos n, neg m => n - m\\n  | neg n, pos m => m - n\\n  | neg n, neg m => neg (n + m)', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| positive_+ {x y : E} (isPos x) (isPos y) : isPos (x + y)']<<<break>>>isPos {\\this} x -> isPos {\\this} y -> isPos {\\this} (x + y)", "completion": "\n  \\have h1 => \\lam (xNom : Int) (xDenom : Nat) (xDenom/=0 : xDenom /= 0) (_ : gcd {NatEuclidean} (iabs xNom) xDenom = 1) (yNom : Int)\n          (yDenom : Nat) (yDenom/=0 : yDenom /= 0) (_ : gcd {NatEuclidean} (iabs yNom) yDenom = 1) (x>0 : isPos xNom)\n          (y>0 : isPos yNom) => signum_nom {xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom} {xDenom Nat.* yDenom}\n          {productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0} *> positive_+ {xNom IntRing.* pos yDenom} {yNom IntRing.* pos xDenom}\n          (positive_* {xNom} {pos yDenom} x>0 (signum_pos {yDenom} yDenom/=0))\n          (positive_* {yNom} {pos xDenom} y>0 (signum_pos {xDenom} xDenom/=0))\n  \\in \\case x \\as e : case_return_arg_1_1, y \\as e : case_return_arg_1_2 \\return (\\lam (e : Rat) (e1 : Rat) (r : Rat) => isPos (ratNom e) -> isPos (ratNom e1) -> isPos (ratNom r)) e e case_return_arg_1 \\with {\n        | rat nom (suc (suc n)) denom/=0 reduced, rat nom denom denom/=0 reduced =>\n          h1 nom (suc (suc n)) denom/=0 reduced nom denom denom/=0 reduced\n        | rat nom (suc zero) denom/=0 reduced, rat nom (suc (suc n)) denom/=0 reduced =>\n          h1 nom (suc zero) denom/=0 reduced nom (suc (suc n)) denom/=0 reduced\n        | rat xNom 1 xDenom/=0 reduced, rat yNom 1 yDenom/=0 reduced1 => positive_+\n        | rat nom (suc zero) denom/=0 reduced, rat nom zero denom/=0 reduced =>\n          h1 nom (suc zero) denom/=0 reduced nom zero denom/=0 reduced\n        | rat nom zero denom/=0 reduced, rat nom denom denom/=0 reduced => h1 nom zero denom/=0 reduced nom denom denom/=0 reduced\n      }"}
{"prompt": "['this : Preorder', 'this : Equivalence E {\\n  | ~ => \\\\lam (x : A {\\\\this}) (y : A {\\\\this}) => \\\\Sigma (x <= y) (y <= x)\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}']<<<break>>>['| <=-refl {x : E} : x <= x', '| \\\\infix 4 <= E E : \\\\Prop', '| \\\\infix 4 ~ A A : \\\\Prop', '| A : \\\\Set']<<<break>>>\\Pi {x : A {\\this}} -> x ~ x", "completion": "\\lam {x} => (<=-refl {this}, <=-refl {this})"}
{"prompt": "['this : DiscreteField', 'null : x * finv x = ide', 'x : E']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| finv E : E', '| ide : E', '| E : \\\\Set', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ']<<<break>>>x * finv x - ide = zro", "completion": "toZero {this} {x * finv x} {ide} p"}
{"prompt": "['M : DecSet', \"l' : Array (\\\\Sigma R.E M.E)\", \"e : l ~ l'\", 'R : AbMonoid', 'l : Array (\\\\Sigma R.E M.E)']<<<break>>>['\\\\type MonoidSet \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : \\\\Set => Quotient {Array (\\\\Sigma R.E M)} (~)', '| E : \\\\Set', '\\\\func inMS \\\\hlevels  {M : \\\\Set} {R : AddMonoid} (l : Array (\\\\Sigma R.E M)) : MonoidSet M R => in~ {Array (\\\\Sigma R.E M)} {(~)} l', \"\\\\lemma ~-msequiv \\\\hlevels  {M : \\\\Set} {R : AddMonoid} {l l' : Array (\\\\Sigma R.E M)} (_ : l ~ l') : inMS {M} {R} l = inMS {M} {R} l' \"]<<<break>>>inMS {M.E} {R} l = inMS {M.E} {R} l'", "completion": "~-msequiv e"}
{"prompt": "['C : LModule R']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| R : Ring', '| *c-ldistr {r : E {R}} {a b : E} : r *c (a + b) = r *c a + r *c b']<<<break>>>\\Pi {r : E {C.R}} -> \\Pi {a b : C.E} -> r C.*c (a C.+ b) = r C.*c a C.+ r C.*c b", "completion": "*c-ldistr {C}"}
{"prompt": "['c : E', 'this : CancelGCDMonoid']<<<break>>>['| \\\\infixl 7 * E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '| cancel_*-left (x : E) {y z : E} (x * y = x * z) : y = z']<<<break>>>\\Pi {y z : E} -> c * y = c * z -> y = z", "completion": "cancel_*-left {this} c"}
{"prompt": "[\"this : Locale (Nucleus {L1}) {\\n  | <= => \\\\lam (j : E {\\\\this}) (j' : E {\\\\this}) => \\\\Pi {x : L.E} -> j.nucleus x L.<= j'.nucleus x\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet => NucleusFrame.meet {L1}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top => \\\\new Nucleus {L1} (\\\\lam (_ : E {L {\\\\this}}) => L.top) {\\n    | nucleus-meet => {?hidden}\\n    | nucleus-meet>= => {?hidden}\\n    | nucleus-<= => {?hidden}\\n    | nucleus-unit => {?hidden}\\n    | nucleus-join>= => {?hidden}\\n    | nucleus-join => {?hidden}\\n  }\\n  | top-univ => {?hidden}\\n  | Join => \\\\lam {J : \\\\Set} (g : J -> E {\\\\this}) => \\\\new Nucleus {L1} (\\\\lam (x : E {L {\\\\this}}) =>\\n    L.Meet {\\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j : J) -> \\\\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)}\\n      (\\\\lam (p : \\\\Sigma (n : Nucleus {L1}) (\\\\Pi (j : J) -> \\\\Pi {x : L.E} -> nucleus {g j} x L.<= n.nucleus x)) => nucleus {p.1} x)) {\\n    | nucleus-meet => {?hidden}\\n    | nucleus-meet>= => {?hidden}\\n    | nucleus-<= => {?hidden}\\n    | nucleus-unit => {?hidden}\\n    | nucleus-join>= => {?hidden}\\n    | nucleus-join => {?hidden}\\n  }\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}\", 'L : Locale']<<<break>>>['| <=-refl {x : E} : x <= x', '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set']<<<break>>>\\Pi {x : E {\\this}} -> \\Pi {x1 : L.E} -> x.nucleus x1 <= x.nucleus x1", "completion": "\\lam {x} {x} => <=-refl"}
{"prompt": "['S : Series ExUpperReal', 'h : \\\\Pi {n : Nat} -> M <= n -> U {midSum {ExUpperRealAbMonoid} (\\\\lam (n : Nat) => S (suc n)) M n} eps', 'n : Nat', 'M : Nat', 'p : suc M <= suc n', 'eps : Rat']<<<break>>>['\\\\func midSum \\\\hlevels  {A3 : AddMonoid} (_ : Series A.E) (_ _ : Nat) : A.E \\n  | {A}, S, 0, m => partialSum {A} S m\\n  | {A}, S, suc n, 0 => A.zro\\n  | {A}, S, suc n, suc m => midSum {A} (\\\\lam (j : Nat) => S (suc j)) n m', 'suc Nat', '\\\\lemma conv \\\\plevels  \\\\hlevels  {x y : Nat} (_ : suc x <= suc y) : x <= y ', '| U Rat : \\\\Prop', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}']<<<break>>>U {midSum {ExUpperRealAbMonoid} (\\lam (n : Nat) => S (suc n)) M n} eps", "completion": "h (conv p)"}
{"prompt": "['f : A -> B', 'e2 : Section {B} {C}', 'B : \\\\Type', 'C : \\\\Type', 'p : e2.f o f1 = e3.f', 'e3 : QEquiv {A} {C}', 'A : \\\\Type']<<<break>>>['\\\\func rightFactor {A1 B1 C : \\\\Type} (f1 : A1 -> B1) (e2 : Section {B1} {C}) (e3 : QEquiv {A1} {C} (\\\\lam (a : A {\\\\this}) => e2.f (f1 a))) :\\nQEquiv {A1} {B1} f1 {\\n  | ret => \\\\lam (b : B {\\\\this}) => e3.ret (e2.f b)\\n  | ret_f => e3.ret_f\\n  | f_sec => \\\\lam (b : B {\\\\this}) => (==<) {B1} (f1 (e3.ret (e2.f b))) {e2.ret (e2.f (f1 (e3.ret (e2.f b))))}\\n    (inv {B1} {e2.ret (e2.f (f1 (e3.ret (e2.f b))))} {f1 (e3.ret (e2.f b))} (e2.ret_f (f1 (e3.ret (e2.f b))))) >== (==<) {B1} (e2.ret (e2.f (f1 (e3.ret (e2.f b))))) {e2.ret (e2.f b)}\\n    (pmap {C} {B1} e2.ret {e2.f (f1 (e3.sec (e2.f b)))} {e2.f b} (e3.f_sec (e2.f b))) >== (==<) {B1} (e2.ret (e2.f b)) {b} (e2.ret_f b) >== qed {B1} b\\n} => \\\\new QEquiv', '\\\\class QEquiv \\\\extends Equiv {\\n  | sec => ret\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| f_sec (y : B) : f (sec y) = y', '\\\\func \\\\infixr 8 o {A B C : \\\\Type} (g : B -> C) (f : A -> B) : \\\\Pi (x : A) -> C => \\\\lam (x : A) => g (f x)', '\\\\func \\\\infix 2 qed {A : \\\\Type} (a : A) : a = a => idp {A} {a}', \"\\\\func \\\\infix 2 ==< {A : \\\\Type} (a : A) {a' : A} (p : a = a') : a = a' => p\", '| ret_f (x : A) : ret (f x) = x', '| ret B : A', '| f A : B', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| sec B : A', '| B : \\\\Type', \"\\\\func \\\\infixr 1 >== {A : \\\\Type} {a a' a'' : A} (p : a = a') (q : a' = a'') : a = a'' => p *> q\"]<<<break>>>QEquiv {A} {B1} f1 {\n  | ret => \\lam (b : B {\\this}) =>\n    ret {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})} (e2.f b)\n  | ret_f => ret_f {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})}\n  | f_sec => \\lam (b : B {\\this}) => (==<) {B1}\n    (f1 (ret {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})} (e2.f b)))\n    {e2.ret (e2.f (f1 (ret {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})} (e2.f b))))}\n    (inv {B1}\n      {e2.ret (e2.f (f1 (ret {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})} (e2.f b))))}\n      {f1 (ret {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})} (e2.f b))}\n      (e2.ret_f (f1 (ret {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})} (e2.f b))))) >== (==<) {B1}\n    (e2.ret (e2.f (f1 (ret {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})} (e2.f b)))))\n    {e2.ret (e2.f b)} (pmap {C} {B1} e2.ret\n      {e2.f (f1 (sec {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})} (e2.f b)))}\n      {e2.f b}\n      (f_sec {transportInv {A -> C} (\\lam (p0 : A -> C) => QEquiv {A} {C} p0) {e2.f o f1} {e3.f} p (\\new e3 {})} (e2.f b))) >== (==<) {B1} (e2.ret (e2.f b)) {b} (e2.ret_f b) >== qed {B1} b\n}", "completion": "rightFactor f e2 (transportInv (\\lam p0 => QEquiv p0) p e3)"}
{"prompt": "['imap : \\\\Sigma (y : ObOver {restrict {L} a} x) (s.S {y.1} y.2) -> \\\\Sigma (y : ObOver {L} x.1) (s.S {(y.1, y.2 L.<=\u2218 x.2)} y.2)', 'this : Cone {Precat.op {subPrecat {SlicePrecat {restrict {L} a} x} {\\\\Sigma (y : ObOver {restrict {L} a} x) (s.S {y.1} y.2)}\\n  (\\\\lam (p : \\\\Sigma (y : ObOver {restrict {L} a} x) (s.S {y.1} y.2)) => p.1)}} {S.D}\\n  (Comp {Precat.op {subPrecat {SlicePrecat {restrict {L} a} x} {\\\\Sigma (y : ObOver {restrict {L} a} x) (s.S {y.1} y.2)}\\n    (\\\\lam (p : \\\\Sigma (y : ObOver {restrict {L} a} x) (s.S {y.1} y.2)) => p.1)}} {Precat.op {restrict {L} a}} {S.D}\\n    (Comp {Precat.op {restrict {L} a}} {Precat.op {L}} {S.D} S.F (Functor.op {functor {L} {a}})) (Functor.op {diagram {s}}))\\n  z {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => c.coneMap (imap j)\\n  | coneCoh => {?hidden}\\n}', 'c : A {\\\\this}']<<<break>>>['| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| G : Functor J D', '| J : Precat', '| Ob : \\\\hType', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '| D : Precat']<<<break>>>\\Pi {j : Ob {J {\\this}}} -> \\Pi {j' : Ob {J {\\this}}} ->\n  \\Pi (h : Hom {c.J} (imap j) (imap j')) -> Func {c.G} {imap j} {imap j'} h \u2218 c.coneMap (imap j) = c.coneMap (imap j')", "completion": "\\lam {j} {j'} => coneCoh {c} {imap j} {imap j'}"}
{"prompt": "['Y : TopSpace']<<<break>>>['\\\\class Locale \\\\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\\\hlevels  {\\n  | Join-ldistr>= {J : \\\\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\\\lam (j : J) => e \u2227 f j)\\n  | basicCover-stable => \\\\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\\\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\\n    meet-univ {x} {Join {J} (\\\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\\\lam (j : J) => (g j).1} {x}\\n  | ldistr>= => \\\\lam {x : E} {y : E} {z : E} => (\\n    \\\\have t => path (\\\\lam (i : I) (b : Bool) => (\\\\case b \\\\with {\\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\\n          }) @ i)\\n    \\\\in transportInv\\n        {Bool -> E} (\\\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\\n          {\\\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\\\lam (b : Bool) => x \u2227 if {E} b y z} t\\n          (Join-ldistr>= {Bool} {\\\\lam (p0 : Bool) => if {E} p0 y z} {x}))\\n  | Meet-cond => \\\\lam {J : \\\\Set} (j : J) {f : J -> E} =>\\n  Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n    {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)\\n  | join-left => \\\\lam {x : E} {y : E} => Join-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | join-right => \\\\lam {x : E} {y : E} => Join-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | Meet-univ => \\\\lam {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) =>\\n  Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n    {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  | join-univ => \\\\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\\n  Join-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n    | true => x<=z\\n    | false => y<=z\\n  }))\\n  | join => \\\\lam (x : E) (y : E) => Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)\\n  | Meet => \\\\lam {J : \\\\Set} (g : J -> E) =>\\n    Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)\\n  | isBasicCover => \\\\lam (x : Ob) {J : \\\\Set} (g : J -> Ob) => x <= Join {J} (\\\\lam (j : J) => (g j).1)\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Locale (Set Y.E) {\n  | <= => (\u2286)\n  | meet => \\lam (U : E {\\this}) (V : E {\\this}) (a : Y.E) => \\Sigma (U a) (V a)\n  | top => \\lam (_ : Y.E) => \\Sigma\n  | Join => \\lam {J : \\Set} (f : J -> E {\\this}) (a : Y.E) => TruncP (\\Sigma (j : J) (f j a))\n}", "completion": "SetLattice _"}
{"prompt": "['Y : TopAbGroup', 'V : Set Y.E', 'g : \\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)', 'U : Set X.E', 'X : TopAbGroup', 'W : E {Cod {\\\\this}} -> \\\\Prop']<<<break>>>['| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| negative E : E', '| negative-cont : ContMap \\\\this \\\\this {\\n  | func => negative\\n}']<<<break>>>\\Pi {x : X.E} -> U (func {X.negative-cont} x) ->\n  \\Pi {y : Y.E} -> V (func {Y.negative-cont} y) -> W (func {X.negative-cont} x, Y.negative y)", "completion": "\\lam p0 p1 => g p0 p1"}
{"prompt": "['R : Ring', 'l : Array U.E']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func mkMatrix {R : \\\\Type} {n m : Nat} (f : Fin n -> Fin m -> R) : Matrix R n m \\n  => \\\\new Array (Array R m) n (\\\\lam (i : Fin n) => \\\\new Array R m (f i))', '| \\\\infixl 6 + E E : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\instance MatrixRing \\\\hlevels  (R : Ring) (n : Nat) : Ring (Matrix R.E n n) {\\n  | zro => \\\\new Array (Array R.E n) n (\\\\lam (_ : Fin n) => \\\\new Array R.E n (\\\\lam (_ : Fin n) => R.zro))\\n  | + => \\\\lam (M : E) (N : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => at {at {M} i} j R.+ at {at {N} i} j)\\n  | * => (product)\\n  | negative => \\\\lam (M : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => R.negative (at {at {M} i} j))\\n  | ide => ide {R} {n}\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\instance MatrixAbGroup \\\\hlevels  (A : AbGroup) (n m : Nat) : AbGroup (Matrix A.E n m) {\\n  | zro => mkMatrix {A.E} {n} {m} (\\\\lam (_ : Fin n) (_ : Fin m) => A.zro)\\n  | + => \\\\lam (M : E {\\\\this}) (N : E {\\\\this}) =>\\n    mkMatrix {A.E} {n} {m} (\\\\lam (i : Fin n) (j : Fin m) => at {at {M} i} j A.+ at {at {N} i} j)\\n  | negative => \\\\lam (M : E {\\\\this}) => mkMatrix {A.E} {n} {m} (\\\\lam (i : Fin n) (j : Fin m) => A.negative (at {at {M} i} j))\\n} => \\\\new AbGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n}', '| zro : E', '\\\\func natCoefImpl \\\\hlevels  {this2 : Semiring} (_ : Nat) : E \\n  | {this}, 0 => zro\\n  | {this}, suc n => natCoefImpl n + ide', '\\\\class Ring \\\\extends PseudoRing, Semiring \\\\hlevels ', '\\\\func ide {R : Ring} {n : Nat} : Matrix R.E n n => diagonal {R} (replicate {R.E} n R.ide)', '| at (j : Fin len) : A j', '| E : \\\\Set', '| negative E : E', '\\\\type Matrix (R : \\\\Type) (n m : Nat) : \\\\Type => Array (Array R m) n', '\\\\func \\\\infixl 7 product \\\\hlevels  {R : Ring} {n m k : Nat} (M : Matrix R.E n m) (N : Matrix R.E m k) : Matrix R.E n k => mkMatrix {R.E} {n} {k}\\n  (\\\\lam (i : Fin n) (k : Fin k) => BigSum {R} (\\\\new Array R.E m (\\\\lam (j : Fin m) => at {at {M} i} j R.* at {at {N} j} k)))']<<<break>>>Ring (Matrix (E {R}) l.len l.len) {\n  | zro => \\new Array (Array (E {R}) l.len) l.len (\\lam (_ : Fin l.len) => \\new Array (E {R}) l.len (\\lam (_ : Fin l.len) => zro {R}))\n  | + => \\lam (M : E) (N : E) =>\n    mkMatrix {E {R}} {l.len} {l.len} (\\lam (i : Fin l.len) (j : Fin l.len) => at {at {M} i} j + at {at {N} i} j)\n  | * => (product)\n  | negative => \\lam (M : E) => mkMatrix {E {R}} {l.len} {l.len} (\\lam (i : Fin l.len) (j : Fin l.len) => negative {R} (at {at {M} i} j))\n  | ide => ide {R} {l.len}\n  | natCoef => natCoefImpl\n}", "completion": "MatrixRing _ _"}
{"prompt": "['this : Cat LinearOrder.Dec {\\n  | Hom => PosetHom\\n  | id => \\\\lam (X : Ob {\\\\this}) => \\\\new PosetHom X X {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n    | func-<= => {?hidden}\\n  }\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (f : Hom {\\\\this} Y Z) (g : Hom {\\\\this} X Y) => \\\\new PosetHom X Z {\\n    | func => \\\\lam (x : E {Dom {\\\\this}}) => f.func (g.func x)\\n    | func-<= => {?hidden}\\n  }\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}']<<<break>>>['| Hom Ob Ob : \\\\Set', '| Ob : \\\\hType', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\class PosetHom \\\\extends SetHom \\\\hlevels  {\\n  | func-<= {x y : E {Dom}} (x <= y) : func x <= func y\\n}', '| Dom : BaseSet', '| func-<= {x y : E {Dom}} (x <= y) : func x <= func y']<<<break>>>\\Pi {X Y Z : Ob {\\this}} -> \\Pi (f : Hom {\\this} Y Z) -> \\Pi (g : Hom {\\this} X Y) -> PosetHom X Z {\n  | func => \\lam (x : E {Dom {\\this}}) => f.func (g.func x)\n  | func-<= => {?hidden}\n}", "completion": "\\lam f g => \\new PosetHom {\n  | func => \\lam x => f (g x)\n  | func-<= => \\lam p1 => func-<= {f} (func-<= {g} p1)\n}"}
{"prompt": "['this : FrameHom', 'y : E {L {\\\\this}}', 'x : E {L {\\\\this}}']<<<break>>>['\\\\func pHat \\\\hlevels  {this : Locale} (P : \\\\Prop) : E => Join {P} (\\\\lam (_ : P) => top)', '| nucleus (E {L}) : E {L}', '| \\\\infix 4 <= E E : \\\\Prop', '| Cod : BaseSet', \"\\\\lemma meet-monotone \\\\hlevels  {this : MeetSemilattice} {x y x' y' : E} (_ : x <= x') (_ : y <= y') : x \u2227 y <= x' \u2227 y' \", '| Meet-cond {J : \\\\Set} (j : J) {f : J -> E} : Meet {J} f <= f j', '| nucleus-meet>= {x y : E {L}} : nucleus x \u2227 nucleus y <= nucleus (x \u2227 y)', '| Meet-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> e <= f j) : e <= Meet {J} f', '\\\\class Nucleus \\\\hlevels  {\\n  | L : Locale\\n  | nucleus (E {L}) : E {L}\\n  | nucleus-meet {x y : E {L}} : nucleus (x \u2227 y) = nucleus x \u2227 nucleus y\\n  | nucleus-meet>= {x y : E {L}} : nucleus x \u2227 nucleus y <= nucleus (x \u2227 y)\\n  | nucleus-<= {x y : E {L}} (x <= y) : nucleus x <= nucleus y\\n  | nucleus-unit {x : E {L}} : x <= nucleus x\\n  | nucleus-join>= {x : E {L}} : nucleus (nucleus x) <= nucleus x\\n  | nucleus-join {x : E {L}} : nucleus (nucleus x) = nucleus x\\n}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Meet {J : \\\\Set} (J -> E) : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| Dom : BaseSet', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} x) \u2227 Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} y) <= Meet {Dom}\n  {\\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\n  (\\lam (j : \\Sigma (j : Nucleus {Dom}) (\\Pi {P : \\Prop} -> \\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\n    nucleus {j.1} (x \u2227 y))", "completion": "Meet-univ (\\lam j => meet-monotone (Meet-cond j) (Meet-cond j) <=\u2218 nucleus-meet>=)"}
{"prompt": "['x<=x0b+1 : x <= fromRat (x0b + fromInt (pos 1))', \"x' : E\", 'x0b : Rat', \"xx'<gamma : \\\\Sigma (a : Rat) (a < gamma \u2227 fromInt (pos 1)) (zro <= a) (x <= x' + fromRat a) (x' <= x + fromRat a)\", 'x : E', 'gamma : Rat']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', 'pos Nat', '\\\\lemma +-rat \\\\plevels  \\\\hlevels  {x y : Rat} : fromRat x ExUpperReal.+ fromRat y = fromRat (x RatField.+ y) ', '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| meet-right {x y : E} : x \u2227 y <= y', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>x' <= fromRat (x0b + fromInt (pos 1) + fromInt (pos 1))", "completion": "transport ((<=) _) +-rat (xx'<gamma.5 <=\u2218 <=_+ x<=x0b+1 (<=-rat.1 $ <=-less xx'<gamma.2 <=\u2218 meet-right))"}
{"prompt": "['f : RingHom K S', 'l : Array S.E', 'a : S.E', 'S : CRing', 'p : E', 'K : DiscreteField', \"subring : SubRing (Cod {mPolyEval {Fin l'.len} {S1} l'.at \u2218 mPoly-mapHom {Fin l'.len} {K} {S1} f}) (\\\\lam (y : E {S {\\\\this}}) =>\\n  TruncP (\\\\Sigma (x : E {Dom {mPolyEval {Fin l'.len} {S1} l'.at \u2218 mPoly-mapHom {Fin l'.len} {K} {S1} f}})\\n    (func {mPolyEval {Fin l'.len} {S1} l'.at \u2218 mPoly-mapHom {Fin l'.len} {K} {S1} f} x = y)))\"]<<<break>>>['\\\\func cStruct \\\\hlevels  {R : CRing} (S1 : SubRing R) : CRing (\\\\Sigma (x : E {S.S}) (S.contains x)) {\\n  | zro => (zro {S.S}, contains_zro {\\\\new S1 {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new S1 {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S.S} x.1, contains_negative {\\\\new S1 {}} {x.1} x.2)\\n  | ide => (ide {S.S}, S.contains_ide)\\n  | natCoef => natCoefImpl {ISemiring {S1}}\\n} => \\\\new CRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', 'suc Nat', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\instance MonoidRing \\\\hlevels  (M : Monoid) (R : Ring) : Ring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | negative => negative {M.E} {R}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '| Cod : BaseSet', '\\\\func mPolyImage {R E1 : CRing} (f : RingHom R E1) (l : Array E.E) :\\nSubRing (Cod {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f}) (\\\\lam (y : E {S {\\\\this}}) =>\\n  TruncP (\\\\Sigma (x : E {Dom {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f}})\\n    (func {mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f} x = y))) \\n  => ringHomImage (mPolyEval {Fin l.len} {E1} l.at \u2218 mPoly-mapHom {Fin l.len} {R} {E1} f)', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\func mdegree \\\\hlevels  {J : DecSet} {R : Dec} (p : E) : Nat => decMdegree {J} {R} (ret {monoidSetDec-equiv {PermSetDec J} {R} {\\\\new R {}}} p)', '| at (j : Fin len) : A j', '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\func embed \\\\hlevels  {this2 : SubRing} : RingHom IRing S {\\n  | func => \\\\lam (p0 : E {Dom {\\\\this}}) => p0.1\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '| E : \\\\Set', '\\\\func mPolyEval \\\\hlevels  {J : \\\\Set} {R : CRing} (f : J -> R.E) : RingHom (MonoidRing (PermSetMonoid J) R) R {\\n  | func => \\\\lam (p0 : E {Dom {evalMSMonoidHom {E} {R} (func {permSet-univ {J} {R} f})}}) =>\\n    evalMS {E} {R} p0 (func {permSet-univ {J} {R} f})\\n} => evalMSRingHom {PermSetMonoid J} {R} (permSet-univ {J} {R} f)', '\\\\func mPoly-mapHom \\\\hlevels  {J : \\\\Set} {R S : CRing} (f : RingHom R S) :\\nRingHom (MonoidRing (Dom {id {PermSetMonoid J}}) f.Dom) (MonoidRing (Cod {id {PermSetMonoid J}}) f.Cod) {\\n  | func => monoidSet-map {E {Dom {id {PermSetMonoid J}}}} {E {Cod {id {PermSetMonoid J}}}} (func {id {PermSetMonoid J}}) f\\n} => monoidSet-ringHom (id {PermSetMonoid J}) f', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray', '\\\\instance RingCat : Cat Ring {\\n  | Hom => RingHom\\n  | id => RingHom.id\\n  | o => \\\\lam {X : Ob {\\\\this}} {Y : Ob {\\\\this}} {Z : Ob {\\\\this}} => (\u2218)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| contains (E {S}) : \\\\Prop', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| func (E {Dom}) : E {Cod}', '| S : BaseSet', '| Dom : BaseSet', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>\\Pi {a a' : E} -> func {embed {subring}} a = func {embed {subring}} a' -> a = a'", "completion": "\\lam q => ext q"}
{"prompt": "['this : Dec', 'g|c1 : LDiv {M {\\\\this}} g (val2 {\\\\this})', 'c : \\\\Sigma (a b : E) (b#0 : #0 b) (GCD {\\\\new this {}} a b ide) (x = inl~ {\\\\new this {}} {subMonoid} (a, b, b#0))', 'g|c2 : LDiv {M {\\\\this}} g (val1 {\\\\this})', 'c1#0 : #0 c.1', 'g : E {M {\\\\this}}']<<<break>>>['\\\\lemma ldiv_nonZero \\\\hlevels  {this : Domain} {a b : E} (_ : LDiv a.1 b.1) : LDiv {nonZeroMonoid} a b ', '| res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res', '\\\\func nonZeroMonoid \\\\hlevels  {this2 : Domain} : CancelMonoid (\\\\Sigma (x : E) (#0 x)) {\\n  | ide => (ide, zro#ide)\\n  | * => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (x.1 * y.1, #0-* {x.1} {y.1} x.2 y.2)\\n} => \\\\new CancelMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | cancel_*-left => {?hidden}\\n  | cancel_*-right => {?hidden}\\n}', '\\\\func nonZero_ldiv \\\\hlevels  {this : Domain} {a b : E} (a|b : LDiv {nonZeroMonoid} a b) : LDiv a.1 b.1 a|b.inv.1 => \\\\new LDiv {\\n  | inv-right => {?hidden}\\n}', '| \\\\infix 8 #0 E : \\\\Prop', '\\\\func nonZeroGCDMonoid \\\\hlevels  {this5 : GCDDomain} : CancelGCDMonoid (\\\\Sigma (x : E) (#0 x)) {\\n  | ide => (ide, zro#ide)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, #0-* {x.1} {y.1} x.2 y.2)\\n} => \\\\new CancelGCDMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n  | isGCD => {?hidden}\\n  | cancel_*-left => {?hidden}\\n}', '| ide : E', '| E : \\\\Set', '\\\\class LDiv \\\\extends DivBase \\\\hlevels  {\\n  | inv-right : val * inv = elem\\n}']<<<break>>>LDiv {nonZeroMonoid} g ide", "completion": "ldiv_nonZero {this} (res-univ {c.4} g.1 (nonZero_ldiv {this} g|c1) (nonZero_ldiv {this} g|c2))"}
{"prompt": "['x<q : x.U q', 'x : ExUpperReal', 'q : Rat']<<<break>>>['| ide-left {x : E} : ide * x = x', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", 'inP A', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func * (_ _ : Rat) : Rat \\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n    makeRat (xNom IntRing.* yNom) (xDenom Nat.* yDenom) (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', 'pos Nat', '| \\\\infixl 7 * E E : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| U Rat : \\\\Prop', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ']<<<break>>>TruncP (\\Sigma (r : Rat) (x.U r) (fromInt (pos 1) * r <= q))", "completion": "inP (q, x<q, =_<= ide-left)"}
{"prompt": "['y : Real', \"y' : Real\", \"null : y' = y\"]<<<break>>>['\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>y' <= y", "completion": "=_<= p"}
{"prompt": "['x : R.E', 'y : R.E', 'x+y>0 : R.isPos (x R.+ y)', 'R : OrderedCRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '| isPos E : \\\\Prop', '\\\\func positiveSubset \\\\hlevels  (R : OrderedCRing) : SubMonoid R R.isPos => \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| contains (E {S}) : \\\\Prop', '| ide-right {x : E} : x * ide = x']<<<break>>>contains ((x R.+ y) R.* ide {R})", "completion": "simplify x+y>0"}
{"prompt": "[]<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| norm_ide_<= : norm ide <= fromRat ide', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\instance RealStoneC*Algebra : StoneC*Algebra Real {\\n  | isOpen => isOpen {RealNormedAbGroup}\\n  | isCauchy => Closure {E} PreuniformSpace.isUniform\\n  | isUniform => ExPseudoMetricSpace.isUniform {RealNormedAbGroup}\\n  | dist => dist {RealNormedAbGroup}\\n  | zro => Real.fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => RealAbGroup.negative\\n  | norm => abs {RealAbGroup}\\n  | * => (RealField.*)\\n  | ide => Real.fromRat ide\\n  | natCoef => \\\\lam (n : Nat) => Real.fromRat (natCoef n)\\n} => \\\\new StoneC*Algebra {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | norm-bounded => {?hidden}\\n  | isDivisible => {?hidden}\\n  | norm_*n => {?hidden}\\n  | norm-double => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n  | isComplete => {?hidden}\\n  | isCompleteMetric => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | norm_*_<= => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n  | c*-sum => {?hidden}\\n  | c*-square => {?hidden}\\n  | norm_ide_<= => {?hidden}\\n}', '| norm E : ExUpperReal']<<<break>>>norm ide <= fromRat ide", "completion": "norm_ide_<= {RealStoneC*Algebra}"}
{"prompt": "['Dc : isUniform {Cod {\\\\this}} E', 'Z : StronglyCompleteUniformSpace', 'E : Set (Set (E {Cod {\\\\this}}))']<<<break>>>['\\\\type \\\\infix 4 s<=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => (W = Compl {X.E} V) || (W = U))', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| isUniform (Set (Set E)) : \\\\Prop', '| E : \\\\Set', '\\\\lemma s<=<-regular \\\\hlevels  {this : StronglyRegularUniformSpace} {C : Set (Set E)} (_ : isUniform C) :\\n  isUniform (\\\\lam (V : Set E) => TruncP (\\\\Sigma (U : Set E) (C U) (V s<=< U))) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Z.isUniform (\\lam (V : Set Z.E) => TruncP (\\Sigma (U : Set Z.E) (E1 U) (V s<=< U)))", "completion": "s<=<-regular {Z} Dc"}
{"prompt": "['x/=0 : Not (signum x = pos 0)', 'x : E {\\\\this}']<<<break>>>['\\\\func iabs \\\\plevels  \\\\hlevels  (_ : Int) : Nat \\n  | pos n => n\\n  | neg n => n', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func signum \\\\plevels  \\\\hlevels  (_ : Int) : Int \\n  | pos 0 => pos 0\\n  | pos (suc n) => pos 1\\n  | neg (suc n) => neg 1', '\\\\lemma signum_/=0 \\\\plevels  \\\\hlevels  {x : Int} (_ : Not (x = pos 0)) : iabs (signum x) = 1 ', 'pos Nat']<<<break>>>iabs (signum x) = 1", "completion": "signum_/=0 (\\lam p0 => x/=0 $ pmap signum p0)"}
