{"prompt": "['context-b : List env.Sort', 'fin : Index {env.Sort} context-a', 'context-c : List env.Sort', 'sublist : SubList {env.Sort} context-a context-b', 'context-a : List env.Sort', 'env : FSignature']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func length {A1 : \\\\Type} (_ : List A1) : Nat \\n  | {A}, nil => 0\\n  | {A}, a :: l => suc (length {A} l)', '\\\\func right-both-after-expand-left \\\\hlevels  {A3 : \\\\Set} {a3 b3 c3 : List A3} (sublist2 : SubList {A3} a3 b3) (index2 : Index {A3} a3) :\\nshift-index {A3} {a3 ++ c3} {b3 ++ c3} (extend-right-both {A3} {a3} {b3} sublist2 {c3}) (expand-fin-left {A3} {a3} {c3} index2) = shift-index {A3} {b3} {b3 ++ c3} (extend-right-single {A3} {b3} {b3} (identity {A3} {b3}) {c3})\\n  (shift-index {A3} {a3} {b3} sublist2 index2) \\n  | {A}, {x :: a}, {y :: b}, {c}, sublist-match p sublist, zero => idp {Fin (length {A} ((y :: b) ++ c))} {0}\\n  | {A}, {x :: a}, {y :: b}, {c}, sublist-match p sublist, suc index =>\\n  pmap {Fin (length {A} (b ++ c))} {Fin (suc (length {A} (b ++ c)))} (fsuc {length {A} (b ++ c)})\\n    {shift-index {A} {a ++ c} {b ++ c} (extend-right-both {A} {a} {b} sublist {c}) (expand-fin-left {A} {a} {c} index)}\\n    {shift-index {A} {b} {b ++ c} (extend-right-single {A} {b} {b} (identity {A} {b}) {c}) (shift-index {A} {a} {b} sublist index)}\\n    (right-both-after-expand-left {A} {a} {b} {c} sublist index)\\n  | {A}, {a :: a1}, {y :: b}, {c}, sublist-skip sublist, index =>\\n  pmap {Fin (length {A} (b ++ c))} {Fin (suc (length {A} (b ++ c)))} (fsuc {length {A} (b ++ c)})\\n    {shift-index {A} {a :: a1 ++ c} {b ++ c} (extend-right-both {A} {a :: a1} {b} sublist {c}) (expand-fin-left {A} {a :: a1} {c} index)}\\n    {shift-index {A} {b} {b ++ c} (extend-right-single {A} {b} {b} (identity {A} {b}) {c}) (shift-index {A} {a :: a1} {b} sublist index)}\\n    (right-both-after-expand-left {A} {a :: a1} {b} {c} sublist index)', '| Sort : \\\\Set', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func shift-index \\\\hlevels  {A2 : \\\\Set} {a b : List A2} (_ : SubList {A2} a b) (_ : Index {A2} a) : Fin (length {A2} b) \\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, zero => 0\\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, suc ind => suc (shift-index {A} {xs} {ys} sublist ind)\\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, ind => suc (shift-index {A} {l} {ys} sublist ind)', '\\\\func extend-right-both {A3 : \\\\Type} {l2 r2 : List A3} (_ : SubList {A3} l2 r2) {add3 : List A3} : SubList {A3} (l2 ++ add3) (r2 ++ add3) \\n  | {A}, {nil}, {nil}, sublist-nil, {add} => identity {A} {nil {A} ++ add}\\n  | {A}, {x :: l}, {y :: r}, sublist-match p sublist, {add} =>\\n    sublist-match {A} {x} {l ++ add} {y} {r ++ add} p (extend-right-both {A} {l} {r} sublist {add})\\n  | {A}, {l}, {y :: r}, sublist-skip sublist, {add} =>\\n    sublist-skip {A} {l ++ add} {y} {r ++ add} (extend-right-both {A} {l} {r} sublist {add})', '\\\\func identity {A2 : \\\\Type} {list1 : List A2} : SubList {A2} list1 list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})', '\\\\func extend-right-single {A3 : \\\\Type} {l1 r : List A3} (_ : SubList {A3} l1 r) {add3 : List A3} : SubList {A3} l1 (r ++ add3) \\n  | {A}, {nil}, {nil}, sublist-nil, {add} => sublist-nil-free {A} {nil {A} ++ add}\\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, {add} =>\\n    sublist-match {A} {x} {xs} {y} {ys ++ add} p (extend-right-single {A} {xs} {ys} sublist {add})\\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, {add} =>\\n    sublist-skip {A} {l} {y} {ys ++ add} (extend-right-single {A} {l} {ys} sublist {add})', '\\\\func expand-fin-left {A1 : \\\\Type} {a b1 : List A1} (_ : Index {A1} a) : Index {A1} (a ++ b1) \\n  | {A}, {a :: l}, {b}, zero => 0\\n  | {A}, {a :: l}, {b}, suc i => suc (expand-fin-left {A} {l} {b} i)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys']<<<break>>>shift-index {env.Sort} {context-a ++ context-c} {context-b ++ context-c}\n  (extend-right-both {env.Sort} {context-a} {context-b} sublist {context-c})\n  (expand-fin-left {env.Sort} {context-a} {context-c} fin) = shift-index {env.Sort} {context-b} {context-b ++ context-c}\n  (extend-right-single {env.Sort} {context-b} {context-b} (identity {env.Sort} {context-b}) {context-c})\n  (shift-index {env.Sort} {context-a} {context-b} sublist fin)", "completion": "right-both-after-expand-left _ _"}
{"prompt": "[\"r' : PFunc {V} {B}\", 'B : BooleanRing', 'r : PFunc {V} {B}', 'k : Fin r.len', 'V : PosetQModule']<<<break>>>['\\\\func index-left {A1 : \\\\Type} {l1 m1 : Array A1} (_ : Fin l.len) : Fin (len {l1 ++ m1}) \\n  | {A}, {:: {n} a l}, {m}, zero => 0\\n  | {A}, {:: {n} a l}, {m}, suc i => suc (index-left {A} {l} {m} i)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '| at (j : Fin len) : A j', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func ++_index-left {A2 : \\\\Type} {l2 m2 : Array A2} (i1 : Fin l.len) : at {l2 ++ m2} (index-left {A2} {l2} {m2} i1) = l.at i1 \\n  | {A}, {:: {n} a l}, {m}, zero => idp {A} {at {(a :: l) ++ m} (index-left {A} {a :: l} {m} 0)}\\n  | {A}, {:: {n} a l}, {m}, suc i => ++_index-left {A} {l} {m} i', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', '\\\\type \\\\infix 4 <= \\\\hlevels  {R : Semigroup} (x y : R.E) : \\\\Prop => x R.* y = x']<<<break>>>(r.at k).2 <= (at {r ++ r'} (index-left {\\Sigma V.E B.E} {r} {r'} k)).2", "completion": "=_<= (pmap (\\lam p0 => p0.2) $ inv $ ++_index-left k)"}
{"prompt": "['b : \\\\Sigma (_ y : M.E) (S.contains y)', 'e : E {S.S}', 'd : E {S.S}', 'M : PosetAbMonoid', 'a : \\\\Sigma (_ y : M.E) (S.contains y)', 'p : a.1 M.+ b.2 M.+ d M.<= a.2 M.+ b.1 M.+ d']<<<break>>>['| \\\\infixl 6 + E E : E', '| <=-refl {x : E} : x <= x', '| \\\\infix 4 <= E E : \\\\Prop', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>a.1 M.+ b.2 M.+ d M.+ e M.<= a.2 M.+ b.1 M.+ d M.+ e", "completion": "<=_+ p (<=-refl {M} {e})"}
{"prompt": "['p0 : \\\\Sigma (e : E) ((\u2227) (single {E} F) (mkSet {X} W) e)', 'W : Set X.E', 'X : CoverSpace', 'U : Set X.E', 'g : \\\\Sigma (e : E {F.S}) ((\u2227) V W e) -> W \u2286 U', 'V : Set (E {F.S})', 'FV : F.F V']<<<break>>>['| F (E {A}) : \\\\Prop', '| X : \\\\Set', '\\\\func mkSet \\\\hlevels  {X : CoverSpace} (U : Set X.E) : Set (RegularCauchyFilter X) => \\\\lam (F1 : RegularCauchyFilter X) => F.F U', '\\\\lemma mkSet_<= \\\\hlevels  {X : CoverSpace} {U V : Set X.E} (_ : U \u2286 V) : mkSet {X} U \u2286 mkSet {X} V ', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| isProper {U : Set X} (F U) : TruncP (\\\\Sigma (x : X) (U x))', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\instance Completion \\\\hlevels  (X : CoverSpace) : CompleteCoverSpace (RegularCauchyFilter X) {\\n  | isOpen => PrecoverSpace.isOpen {coverSpace {X}}\\n  | isCauchy => isCCauchy {X}\\n} => \\\\new CompleteCoverSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | cauchy-cover => {?hidden}\\n  | cauchy-top => {?hidden}\\n  | cauchy-refine => {?hidden}\\n  | cauchy-glue => {?hidden}\\n  | cauchy-open => {?hidden}\\n  | isRegular => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | isComplete => {?hidden}\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}']<<<break>>>mkSet {X} W \u2286 (\\lam (F1 : RegularCauchyFilter X) => F.F U)", "completion": "\\case \\elim p0 \\with {\n  | (_, (idp, FW)) => mkSet_<= {X} (\\case isProper (filter-meet FV FW) \\with {\n    | inP s => g s\n  })\n}"}
{"prompt": "['J : \\\\Set', 'R : CRing', 'g : J -> R.E']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", 'inP A', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', \"\\\\lemma BigSum_++ \\\\hlevels  {this : AddMonoid} {l l' : Array E} : BigSum (l ++ l') = BigSum l + BigSum l' \", '| \\\\infixl 7 * E E : E', \"\\\\func map_++ {A2 B2 : \\\\Type} (f2 : A2 -> B2) {l1 l'2 : Array A2} :\\n  map {A2} {B2} f2 (l1 ++ l'2) = map {A2} {B2} f2 l1 ++ map {A2} {B2} f2 l'2 \\n  | {A}, {B}, f, {nil}, {l'} =>\\n    idp {Array B (len {nil ++ l'}) (\\\\lam (i : Fin (len {nil ++ l'})) => f (at {nil ++ l'} i))} {map {A} {B} f (nil ++ l')}\\n  | {A}, {B}, f, {:: {n} a l}, {l'} =>\\n  pmap {Array B} {Array B} ((::) (f a)) {map {A} {B} f (l ++ l')} {map {A} {B} f l ++ map {A} {B} f l'}\\n    (map_++ {A} {B} f {l} {l'})\", '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '| E : \\\\Set', '\\\\lemma BigSum-ldistr \\\\hlevels  {this : Semiring} {x : E} {l : Array E} : x * BigSum l = BigSum (map {E} {E} ((*) x) l) ', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', '| contains (E {S}) : \\\\Prop', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\class Ideal \\\\extends TIdeal \\\\hlevels  {\\n  | ideal-right => \\\\lam {r a : E {S}} (s : contains a) => transport {E {S}} contains {r * a} {a * r} (*-comm {S} {r} {a}) (ideal-left {r} {a} s)\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| S : BaseSet']<<<break>>>Ideal R (\\lam (e : E {S {\\this}}) =>\n  TruncP (\\Sigma (l : Array (\\Sigma R.E J)) (e = BigSum {R} (map {\\Sigma R.E J} {R.E} (\\lam (p : \\Sigma R.E J) => p.1 R.* g p.2) l)))) {\n  | contains_zro => {?hidden}\n  | contains_+ => {?hidden}\n  | ideal-left => {?hidden}\n}", "completion": "\\new Ideal {\n  | S => R\n  | contains => \\lam e => \u2203 (\\Sigma (l : Array (\\Sigma R J)) (e = BigSum (map (\\lam p => p.1 * g p.2) l)))\n  | contains_zro => inP (nil, idp)\n  | contains_+ => \\lam p0 p1 => (\\scase \\elim p0, \\elim p1 \\with {\n    | inP (l, p), inP (l', p') => inP (l ++ l', pmap2 (+) p p' *> inv (pmap BigSum (map_++ (later (\\lam p0 => (\n      \\let (c, j) => p0\n      \\in c * g j)))) *> BigSum_++))\n  })\n  | ideal-left => \\lam {r} p0 => (\\scase \\elim p0 \\with {\n    | inP (l, p) => inP (map (\\lam p0 => (\n      \\let (c, j) => p0\n      \\in (r * c, j))) l,\n      pmap ((*) r) p *> BigSum-ldistr {R} *> path (\\lam i => BigSum (map (\\lam p0 => (\n        \\let (c, j) => p0\n        \\in inv (*-assoc {R} {r} {c} {g j}) @ i)) l)))\n  })\n}"}
{"prompt": "['R : CRing', 'M : CMonoid']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '| ide : E', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func + {M3 : \\\\Set} {R3 : AddMonoid} (_ _ : MonoidSet M3 R3) : MonoidSet M3 R3 \\n  | {M}, {R}, in~ l, in~ l' => in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l')\\n  | {M}, {R}, in~ l, ~-equiv l1 l2 r i =>\\n  monoidSet-ext {M} {R} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l1)} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l ++ l2)}\\n    (~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l ++ l1} {l1 ++ l}\\n      (~-perm {M} {R} {l ++ l1} {l1 ++ l} (eperm-++-comm {\\\\Sigma R.E M} {l} {l1})) *> ~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l1 ++ l} {l2 ++ l} (~_++-left {M} {R} {l1} {l2} {l} r) *> ~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l2 ++ l} {l ++ l2}\\n      (~-perm {M} {R} {l2 ++ l} {l ++ l2} (eperm-++-comm {\\\\Sigma R.E M} {l2} {l}))) @ i\\n  | {M}, {R}, ~-equiv l1 l2 r i, in~ l' =>\\n  monoidSet-ext {M} {R} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l1 ++ l')} {in~ {Array (\\\\Sigma R.E M)} {(~)} (l2 ++ l')}\\n    (~-pequiv {Array (\\\\Sigma R.E M)} {(~)} {l1 ++ l'} {l2 ++ l'} (~_++-left {M} {R} {l1} {l2} {l'} r)) @ i\", '\\\\class CSemiring \\\\extends Semiring, PseudoCSemiring, CMonoid \\\\hlevels ', '\\\\instance MonoidSemiring \\\\hlevels  (M : Monoid) (R : Semiring) : Semiring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl\\n} => \\\\new Semiring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\func natCoefImpl \\\\hlevels  {this2 : Semiring} (_ : Nat) : E \\n  | {this}, 0 => zro\\n  | {this}, suc n => natCoefImpl n + ide', '\\\\type MonoidSet \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : \\\\Set => Quotient {Array (\\\\Sigma R.E M)} (~)', \"\\\\func * {M3 : Monoid} {R3 : Semiring} (_ _ : MonoidSet M.E R3) : MonoidSet M.E R3 \\n  | {M}, {R}, in~ l, in~ l' =>\\n    in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l')\\n  | {M}, {R}, in~ l, ~-equiv l1 l2 r i => monoidSet-ext {M.E} {R}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l1)}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l2)}\\n    (toEquality {Array (\\\\Sigma R.E M.E)} {Quotient {Array (\\\\Sigma R.E M.E)} (~)} (inMS~ {M.E} {R}) {(~)}\\n      (~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)}) {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l1}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l l2} (*-coh-right {M} {R} {l} {l1} {l2} r)) @ i\\n  | {M}, {R}, ~-equiv l1 l2 r i, in~ l => monoidSet-ext {M.E} {R}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l1 l)}\\n    {in~ {Array (\\\\Sigma R.E M.E)} {(~)} (pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l2 l)}\\n    (~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)} {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l1 l}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (\\\\lam (b : \\\\Sigma R.E M.E) (a : \\\\Sigma R.E M.E) => func {M} {R} a b) l\\n        l1}\\n      (~-perm {M.E} {R} {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l1 l}\\n        {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (\\\\lam (b : \\\\Sigma R.E M.E) (a : \\\\Sigma R.E M.E) => func {M} {R} a b) l\\n          l1} (pairs-flip {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {func {M} {R}} {l1} {l})) *> toEquality {Array (\\\\Sigma R.E M.E)} {Quotient {Array (\\\\Sigma R.E M.E)} (~)} (inMS~ {M.E} {R}) {(~)}\\n      (~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)})\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l1}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l2}\\n      (*-coh-right {Monoid.op {M}} {Semiring.op {R}} {l} {l1} {l2} r) *> ~-pequiv {Array (\\\\Sigma R.E M.E)} {(~)}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l2}\\n      {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l2 l}\\n      (~-perm {M.E} {R} {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {Monoid.op {M}} {Semiring.op {R}}) l l2}\\n        {pairs {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} (func {M} {R}) l2 l}\\n        (pairs-flip {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {\\\\Sigma R.E M.E} {func {Monoid.op {M}} {Semiring.op {R}}} {l} {l2}))) @ i\", '| E : \\\\Set', '\\\\instance MonoidCSemiring \\\\hlevels  (M : CMonoid) (R : CSemiring) : CSemiring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R}\\n} => \\\\new CSemiring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | *-comm => {?hidden}\\n}', 'in~ A']<<<break>>>CSemiring (MonoidSet (E {M}) R) {\n  | zro => in~ {Array (\\Sigma (E {R}) (E {M}))} {(~)} nil\n  | + => (+)\n  | * => (*)\n  | ide => in~ {Array (\\Sigma (E {R}) (E {M}))} {(~)} ((ide {R}, ide {M}) :: nil)\n  | natCoef => natCoefImpl {MonoidSemiring M R}\n}", "completion": "MonoidCSemiring _ _"}
{"prompt": "['x : Real', 'h1 : U {x RealAbGroup.+ y} = U {x ExUpperReal.+ y}', 'y : Real']<<<break>>>['| U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\infixl 6 + \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (c : Rat) (y.U c) (b + c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\infixl 6 + \\\\hlevels  (x y : Real) : Real => \\\\new Real (L {x InfRealAbMonoid.+ y}) (U {x InfRealAbMonoid.+ y}) {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| \\\\infix 4 < E E : \\\\Prop']<<<break>>>Path (\\lam (i : I) => \\Pi {q : Rat} -> (@) h1 i q -> TruncP (\\Sigma (r : Rat) ((@) h1 i r) (r < q)))\n  (U-rounded {x RealAbGroup.+ y}) (U-rounded {x ExUpperReal.+ y})", "completion": "prop-dpi (\\lam i => ext_coe) (U-rounded {x + y}) (U-rounded {x + y})"}
{"prompt": "['f : RingHom', 'a : E {f.Cod}']<<<break>>>['| zro : E', '| \\\\infixl 7 * E E : E', '| Cod : BaseSet', '| E : \\\\Set', '| zro_*-left {x : E} : zro * x = zro']<<<break>>>zro {f.Cod} * a = zro {f.Cod}", "completion": "zro_*-left {_} {a}"}
{"prompt": "['x : A.E', 'A : LModule R']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| zro-right {x : E} : x + zro = x', '| negative E : E', '| E : \\\\Set']<<<break>>>x + negative {A} (zro {A}) A.+ A.zro = x + negative {A} (zro {A})", "completion": "zro-right {_} {x A.+ A.negative A.zro}"}
{"prompt": "[\"r' : E {R {\\\\this}}\", 'this : LModule R1 (Image {E {f.Dom}} {E {f.Cod}} f.func) {\\n  | zro => (zro {f.Cod}, inP {\\\\Sigma (a : E {f.Dom}) (f.func a = zro {f.Cod})} (zro {f.Dom}, f.func-zro))\\n  | + => \\\\lam (a : E) (b : E) => (a.1 + b.1, \\\\case a.2, b.2 \\\\with {\\n    | inP t, inP s => inP {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1 + b.1)} (t.1 + s.1,\\n      f.func-+ {t.1} {s.1} *> pmap2 {E {f.Cod}} {E {f.Cod}} {E {f.Cod}} ((+) {f.Cod}) {f.func t.1} {a.1} t.2 {f.func s.1} {b.1} s.2)\\n  })\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => \\\\lam (a : E) => (negative {f.Cod} a.1,\\n    map {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)} {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = negative {f.Cod} a.1)} a.2\\n      (\\\\lam (s : \\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)) =>\\n        (negative {f.Dom} s.1, func-negative {f} {s.1} *> pmap {E {f.Cod}} {E {f.Cod}} (negative {f.Cod}) {f.func s.1} {a.1} s.2)))\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c => \\\\lam (r : E {R {\\\\this}}) (a : E {\\\\this}) =>\\n  (r B.*c a.1, map {\\\\Sigma (a1 : A.E) (f.func a1 = a.1)} {\\\\Sigma (a1 : A.E) (f.func a1 = r B.*c a.1)} a.2\\n    (\\\\lam (s : \\\\Sigma (a1 : A.E) (f.func a1 = a.1)) =>\\n      (r A.*c s.1, f.func-*c {r} {s.1} *> pmap {B.E} {B.E} ((B.*c) r) {f.func s.1} {a.1} s.2)))\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', 'f : LinearMap {R} A B', 'r : E {R {\\\\this}}', 'a : E {\\\\this}']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (a1 : E {f.Dom}) (f.func a1 = (r *c (r' *c a)).1))", "completion": "(r B.*c (r' B.*c a.1),\n  map {\\Sigma (a1 : A.E) (f.func a1 = r' B.*c a.1)} {\\Sigma (a1 : A.E) (f.func a1 = r B.*c (r' B.*c a.1))}\n    (map {\\Sigma (a1 : A.E) (f.func a1 = a.1)} {\\Sigma (a1 : A.E) (f.func a1 = r' B.*c a.1)} a.2\n      (\\lam (s : \\Sigma (a1 : A.E) (f.func a1 = a.1)) =>\n        (r' A.*c s.1, f.func-*c {r'} {s.1} *> pmap {B.E} {B.E} ((B.*c) r') {f.func s.1} {a.1} s.2)))\n    (\\lam (s : \\Sigma (a1 : A.E) (f.func a1 = r' B.*c a.1)) =>\n      (r A.*c s.1, f.func-*c {r} {s.1} *> pmap {B.E} {B.E} ((B.*c) r) {f.func s.1} {r' B.*c a.1} s.2))).2"}
{"prompt": "['s : Hom b d', 'd : Ob {C {\\\\this}}', 'c : Ob {C {\\\\this}}', 'h1 : (\\\\lam (e : d.E) => s.func (direct {g} (g.func e))) = s.func', 'g : Hom {C {\\\\this}} c d', 'lem : \\\\Pi (x : d.E) -> s.func (direct {g} (g.func x)) = s.func x', 'Rg : R {\\\\this} {c} {d} g', 'b : Ob {C {\\\\this}}']<<<break>>>['\\\\lemma meet_<= \\\\hlevels  {this : MeetSemilattice} {x y : E} (_ : x <= y) : x \u2227 y = x ', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '\\\\class FrameHom \\\\extends SetHom \\\\hlevels  {\\n  | func-<= {x y : E {Dom}} (x <= y) : func x <= func y\\n  | func-top : func (top {Dom}) = top {Cod}\\n  | func-top>= : top {Cod} <= func (top {Dom})\\n  | func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y\\n  | func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)\\n  | func-Join {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\\\lam (j : J) => func (f j))\\n  | func-Join>= {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\\\lam (j : J) => func (f j))\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| \\\\infix 4 <= E E : \\\\Prop', '| Cod : BaseSet', '| func-Join {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\\\lam (j : J) => func (f j))', '\\\\func Total {B : \\\\Type} (F : B -> \\\\Type) : \\\\Type => \\\\Sigma (b : B) (F b)', '| top : E', '| E : \\\\Set', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| func-Join>= {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\\\lam (j : J) => func (f j))', '\\\\lemma direct-meet \\\\hlevels  {this : FrameHom} {y z : E {Cod}} : direct (y \u2227 z) = direct y \u2227 direct z ', '\\\\lemma surjective-split \\\\hlevels  {this : FrameHom} (_ : IsSurj {E {Dom}} {E {Cod}} func) (x : E {Cod}) : func (direct x) = x ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| <=-refl {x : E} : x <= x', '| func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y', '| func-top : func (top {Dom}) = top {Cod}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| Join {J : \\\\Set} (J -> E) : E', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '\\\\instance LocaleCat : BicompleteCat Locale {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob} (g : Hom Y Z) (f : Hom X Y) => f \u2218 g\\n  | pullback => \\\\lam {x y z : Ob {\\\\this}} (f : Hom {\\\\this} x z) (g : Hom {\\\\this} y z) =>\\n    Pullback.fromLimit {x} {y} {z} {f} {g} (limit {\\\\this} {FreeCat {Shape}} (Diagram.functor {diagram {x} {y} {z} f g}))\\n  | terminal => \\\\new Product {Empty} (absurd {Ob {\\\\this}}) (discrete (\\\\Sigma)) {\\n    | proj => \\\\lam (p0 : J {\\\\this}) => (\\\\case p0 \\\\with {})\\n    | tupleMap => \\\\lam {Z : Ob {D {\\\\this}}} (_ : \\\\Pi (j : J {\\\\this}) -> Hom {D {\\\\this}} Z (G {\\\\this} j)) => \\\\new FrameHom (apex {\\\\this}) Z {\\n      | func => \\\\lam (P : E {Dom {\\\\this}}) => pHat {Z} (P ())\\n      | func-<= => {?hidden}\\n      | func-top => {?hidden}\\n      | func-top>= => {?hidden}\\n      | func-meet => {?hidden}\\n      | func-meet>= => {?hidden}\\n      | func-Join => {?hidden}\\n      | func-Join>= => {?hidden}\\n    }\\n    | tupleBeta => {?hidden}\\n    | tupleEq => {?hidden}\\n  }\\n  | Bprod => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) =>\\n    Product.fromLimit {Fin 2} (limit {\\\\this} {DiscretePrecat (Fin 2)} (Product.functor {Fin 2} (at {x :: y :: nil})))\\n  | limit => \\\\lam {J : Precat} (G : Functor J this2) => colimit {Precat.op {J}} (Functor.op {G})\\n  | colimit => \\\\lam {J : Precat} (G : Functor J this2) => limit {Precat.op {J}} (Functor.op {G})\\n} => \\\\new BicompleteCat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '\\\\func direct \\\\hlevels  {this : FrameHom} (y : E {Cod}) : E {Dom} => SJoin {Dom} (\\\\lam (p0 : E {Dom}) => func p0 <= y)', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '| meet-right {x y : E} : x \u2227 y <= y', '\\\\lemma direct-top \\\\hlevels  {this : FrameHom} : direct (top {Cod}) = top {Dom} ']<<<break>>>Path (\\lam (i : I) => \\Pi {J : \\Set} -> \\Pi {f : J -> d.E} -> (@) h1 i (d.Join {J} f) b.<= b.Join {J} (\\lam (j : J) => (@) h1 i (f j)))\n  (func-Join>= {g \u2218 \\new FrameHom c b {\n    | func => \\lam (x : E {Dom {\\this}}) => s.func (direct {g} x)\n    | func-<= => {?hidden}\n    | func-top => {?hidden}\n    | func-top>= => {?hidden}\n    | func-meet => {?hidden}\n    | func-meet>= => {?hidden}\n    | func-Join => {?hidden}\n    | func-Join>= => {?hidden}\n  }}) s.func-Join>=", "completion": "prop-dpi (\\lam i => ext_coe) (func-Join>= {g \u2218 \\new FrameHom c b {\n  | func => \\lam (x : c.E) => s.func (direct {g} x)\n  | func-<= => {?hidden}\n  | func-top => {?hidden}\n  | func-top>= => {?hidden}\n  | func-meet => {?hidden}\n  | func-meet>= => {?hidden}\n  | func-Join => {?hidden}\n  | func-Join>= => {?hidden}\n}}) (func-Join>= {s})"}
{"prompt": "['R : Ring', 'U : LModule R', 'f : LinearMap {R} U U']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '| E : \\\\Set', '\\\\lemma *c-ldistr {R : Ring} {U : LModule R} {f : LinearMap {R} U U} {p : Poly R} {a b : U.E} :\\n  poly_func {R} {U} p f (a U.+ b) = poly_func {R} {U} p f a U.+ poly_func {R} {U} p f b ', '\\\\func poly_func \\\\hlevels  {R2 : Ring} {U3 : LModule R2} (_ : Poly R2) (_ : AddPointedHom U3 U3) (_ : U.E) : U.E \\n  | {R}, {U}, pzero, f, u => U.zro\\n  | {R}, {U}, padd p e, f, u => f.func (poly_func {R} {U} p f u) U.+ e U.*c u\\n  | {R}, {U}, peq i, f, u =>\\n    (pmap2 {U.E} {U.E} {U.E} (U.+) {f.func U.zro} {U.zro} f.func-zro {R.zro U.*c u} {U.zro} (*c_zro-left {U} {u}) *> U.zro-left {U.zro}) @ i']<<<break>>>\\Pi {p : Poly R} ->\n  \\Pi {a b : U.E} -> poly_func {R} {U} p f (a U.+ b) = poly_func {R} {U} p f a U.+ poly_func {R} {U} p f b", "completion": "*c-ldistr {R} {U} {f}"}
{"prompt": "['a2 : List (Fin (len {env}))', 'this : Data', 'a : \\\\Sigma (List (Fin (len {env}))) (E {C})', 'l : List (\\\\Sigma (List (Fin (len {env}))) (E {C}))', 'a3 : List (Fin (len {env}))', 'a1 : E {C}']<<<break>>>['| \\\\infixl 6 + E E : E', 'suc Nat', '| C : Semiring', 'nil', '\\\\func map {A1 B2 : \\\\Type} (_ : A1 -> B2) (_ : List A1) : List B2 \\n  | {A}, {B}, f, nil => nil {B}\\n  | {A}, {B}, f, a :: l => f a :: map {A} {B} f l', '| Cod : BaseSet', \"\\\\lemma interpretNF_map \\\\hlevels  {this : Data} {a1 : E {C}} {a2 a3 : List (Fin (len {env}))} {l : NF} :\\ninterpretNF' (map {\\\\Sigma (List (Fin (len {env}))) (E {C})} {\\\\Sigma (List (Fin (len {env}))) (E {C})}\\n  (\\\\lam (b : \\\\Sigma (List (Fin (len {env}))) (E {C})) => (a2 ++ b.1 ++ a3, a1 * b.2)) l) = func {alg} a1 * interpretNF {R} {Fin (len {env})} (at {env}) a2 * interpretNF' l * interpretNF {R} {Fin (len {env})} (at {env}) a3 \", '\\\\infixl 7 :* (_ _ : Term n)', '| \\\\infixl 7 * E E : E', '\\\\lemma interpretNF_++ \\\\hlevels  {M : Monoid} {V : \\\\Set} {env : V -> M.E} {t s : List V} :\\n  interpretNF {M} {V} env (t ++ s) = interpretNF {M} {V} env t M.* interpretNF {M} {V} env s ', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '\\\\lemma terms-equality \\\\hlevels  {this : SolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpretNF {env.len} env.at (normalize {env.len} t) = interpretNF {env.len} env.at (normalize {env.len} s)) :\\n  interpret {env.len} env.at t = interpret {env.len} env.at s ', '| E : \\\\Set', \"\\\\func interpretNF' \\\\hlevels  {this3 : Data} (_ : NF) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => mulCoef x.2 x.1\\n  | {this}, x :: l => mulCoef x.2 x.1 + interpretNF' l\", \"\\\\lemma interpretNF_:: \\\\hlevels  {this : Data} {x : \\\\Sigma (List (Fin (len {env}))) (E {C})} {l : NF} :\\n  interpretNF' (x :: l) = func {alg} x.2 * interpretNF {R} {Fin (len {env})} (at {env}) x.1 + interpretNF' l \", 'var (Fin n)', '| alg : SemiringHom C R', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func MonoidSolverModel \\\\hlevels  (M1 : Monoid) : SubstSolverModel M.E {\\n  | Term => MonoidSolverModel.Term\\n  | NF => \\\\lam (n : Nat) => List (Fin n)\\n  | normalize => \\\\lam {n : Nat} (t : SolverModel.Term {\\\\this} n) => normalize-aux {n} t (nil {Fin n})\\n  | interpret => MonoidSolverModel.interpret {M1}\\n  | interpretNF => \\\\lam {n : Nat} => MonoidSolverModel.interpretNF {M1} {Fin n}\\n  | nfVar => \\\\lam {n : Nat} (v : Fin n) => v :: nil {Fin n}\\n  | >>= => \\\\lam {m : Nat} {n : Nat} => (>>=)\\n} => \\\\new SubstSolverModel {\\n  | interpretNF-consistent => {?hidden}\\n  | >>=-consistent => {?hidden}\\n}', '| len : Nat', '| env : Array (E {R})', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| alg-comm (x : E {C}) (y : E {R}) : func {alg} x * y = y * func {alg} x', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| ldistr {x y z : E} : x * (y + z) = x * y + x * z', '\\\\func interpretNF \\\\hlevels  {M2 : Monoid} {V1 : \\\\Set} (_ : V1 -> M.E) (_ : List V1) : M.E \\n  | {M}, {V}, env, nil => M.ide\\n  | {M}, {V}, env, x :: nil => env x\\n  | {M}, {V}, env, x :: l => env x M.* interpretNF {M} {V} env l', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| R : Semiring', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| rdistr {x y z : E} : (x + y) * z = x * z + y * z', '\\\\lemma apply-axiom \\\\hlevels  {this : SubstSolverModel} (env : Array M) (t s : Term env.len)\\n  (_ : interpret {env.len} env.at t = interpret {env.len} env.at s) (pattern : NF (suc env.len)) :\\n  interpretNF {env.len} env.at (pattern >>= fcase {NF env.len} {env.len} (normalize {env.len} t) (nfVar {env.len})) = interpretNF {env.len} env.at (pattern >>= fcase {NF env.len} {env.len} (normalize {env.len} s) (nfVar {env.len})) ', '| func (E {Dom}) : E {Cod}', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)']<<<break>>>func {alg} (a1 * a.2) * interpretNF {R} {Fin (len {env})} ((!!) env) (a2 ++ a.1 ++ a3) + interpretNF' (map {\\Sigma (List (Fin (len {env}))) (E {C})} {\\Sigma (List (Fin (len {env}))) (E {C})}\n  (\\lam (b : \\Sigma (List (Fin (len {env}))) (E {C})) => (a2 ++ b.1 ++ a3, a1 * b.2)) l) = func {alg} a1 * interpretNF {R} {Fin (len {env})} ((!!) env) a2 * interpretNF' (a :: l) * interpretNF {R} {Fin (len {env})} ((!!) env) a3", "completion": "rewrite (interpretNF_:: {this}) (rewrite interpretNF_++ (rewrite interpretNF_++ (rewrite (func-* {alg {this}})\n  (rewrite ldistr (rewrite rdistr (pmap2 (+) (monoid {alg-comm {this} a.2 (interpretNF (env {this}) a2)}) interpretNF_map))))))"}
{"prompt": "[\"C' : Set (Set X.E)\", \"C'u : X.isUniform C'\", \"f : \\\\Pi {U : Set X.E} -> C' U -> TruncP (\\\\Sigma (V : Set (E {\\\\this})) (C V) (mkSet {X} U \u2286 V))\", 'X : UniformSpace', 'C : Set (Set (RegularCauchyFilter X))']<<<break>>>['\\\\lemma makeCauchy \\\\hlevels  {this : PreuniformSpace} {C : Set (Set E)} (_ : isUniform C) : isCauchy C ', '\\\\class RegularCauchyFilter \\\\extends CauchyFilter \\\\hlevels  {\\n  | isRegularFilter {U : Set (E {S})} (F U) : TruncP (\\\\Sigma (V : Set (E {S})) (V <=< U) (F V))\\n}', '\\\\func mkSet \\\\hlevels  {X : CoverSpace} (U : Set X.E) : Set (RegularCauchyFilter X) => \\\\lam (F1 : RegularCauchyFilter X) => F.F U', '| isCauchy (Set (Set E)) : \\\\Prop', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (C1 : Set (Set X.E)) (X.isCauchy C1)\n  (\\Pi {U : Set X.E} -> C1 U -> TruncP (\\Sigma (V : Set (RegularCauchyFilter X)) (C V) (mkSet {X} U \u2286 V))))", "completion": "inP (C', makeCauchy {X} C'u, f)"}
{"prompt": "['X : CoverSpace', \"x' : Total {X.E} S\", 'a : E {A {\\\\this}}', 'q : F {\\\\this} b', 'p : F {\\\\this} a', 'S : Set X.E', 'b : E {A {\\\\this}}']<<<break>>>[\"\\\\lemma <=<_meet-same \\\\hlevels  {this : RatherBelow} {U V V' : E {A}} (_ : R U V) (_ : R U V') : R U (V \u2227 V') \", '| E : \\\\Set', '\\\\func single \\\\hlevels  {X : \\\\Set} (a : X) : Set X => (=) a', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance RegularRatherBelow \\\\hlevels  {X : PrecoverSpace} : RatherBelow {SetLattice X.E} (<=<) => \\\\new RatherBelow {\\n  | <=<-left => {?hidden}\\n  | <=<-right => {?hidden}\\n  | <=<_top => {?hidden}\\n  | <=<_meet => {?hidden}\\n}', '\\\\func extend {X : \\\\Type} {U : Set X} (V : Set (Total {X} U)) : Set X => \\\\lam (x : X) => \\\\Sigma (Ux : U x) (V (x, Ux))', '| A : TopMeetSemilattice']<<<break>>>single {X.E} x'.1 <=< extend {X.E} {S} a \u2227 extend {X.E} {S} b", "completion": "<=<_meet-same p q"}
{"prompt": "['l : Array Real', 'Al : \\\\Pi (j : Fin l.len) -> A (l !! j)', 'A : Set Real']<<<break>>>['| len : Nat', '\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma negative-isInv \\\\hlevels  {this : AddGroup} {x : E} : negative (negative x) = x ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| E : \\\\Set', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '| negative E : E', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>\\Pi (j : Fin (len {map {E} {Real} negative l})) -> A (negative (negative (l !! j)))", "completion": "\\lam j => transportInv A negative-isInv (Al j)"}
{"prompt": "['this : GCDMonoid', 'g : GCD a b', 'c : E']<<<break>>>['| res|val1 : LDiv {M} res val1', '\\\\class GCD \\\\hlevels  {\\n  | M : CMonoid\\n  | val1 : E {M}\\n  | val2 : E {M}\\n  | res : E {M}\\n  | res|val1 : LDiv {M} res val1\\n  | res|val2 : LDiv {M} res val2\\n  | res-univ (g : E {M}) (LDiv {M} g val1) (LDiv {M} g val2) : LDiv {M} g res\\n}', '| inv : E {M}', '| isGCD (x y : E) : TruncP (GCD x y)', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (GCD (inv {g.res|val1}) c)", "completion": "isGCD {this} (inv {res|val1 {g}}) c"}
{"prompt": "['x : E {\\\\this}', 'U : Set X.E', 'CU : C U', 'y : E {\\\\this}', 'C : Set (Set X.E)', 'r : \\\\Sigma (mkSet {X} U x) (mkSet {X} U y)', 'X : StronglyRegularCoverSpace']<<<break>>>['| F (E {A}) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (U : Set X.E) (C U) (\\Sigma (x.F U) (y.F U)))", "completion": "inP (U, CU, r)"}
{"prompt": "['y : SType {R} (positiveSubset R)', 'R : OrderedCRing', 's : SType {R} (positiveSubset R)', 'x : SType {R} (positiveSubset R)']<<<break>>>['| len : Nat', '\\\\field mData : MonoidData {R} vars', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| C : Semiring', '| M : Monoid', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '| E : \\\\Set', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', '| vars : Array (E {M})', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>CRingData {R} (x.1 :: s.2 :: y.2 :: y.1 :: x.2 :: nil) {\n  | interpretNF_negate => {?hidden}\n}", "completion": "\\new CRingData {\n  | R => R\n  | vars => x.1 :: s.2 :: y.2 :: y.1 :: x.2 :: nil\n}"}
{"prompt": "['y|x : LDiv {M} y x']<<<break>>>['| \\\\infixl 7 * E E : E', '| val : E {M}', '| elem : E {M}', '| E : \\\\Set', '| M : Monoid', '| inv-right : val * inv = elem', '| inv : E {M}']<<<break>>>y|x.val * y|x.inv = y|x.elem", "completion": "inv-right {y|x}"}
{"prompt": "['f : symbol {tc.envs color} s', \"s : tc.Sort'\", 'color : E {tc.Color}', 'arguments : DArray {arity {tc.envs color} {s} f} (\\\\lam (index : Fin (arity {tc.envs color} {s} f)) =>\\n  GenericLinearTerm (tc.envs color) (context ++ f !!domain index) (f !!sort index) allow-variables)', 'allow-variables : \\\\Prop', 'tc : TheoremContext', \"context : List tc.Sort'\"]<<<break>>>['\\\\func \\\\infix 7 !!sort \\\\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\\\Sigma (List Sort) Sort} (domain {s} m)) : Sort \\n  => (domain {s} m !! index).2', '\\\\func arity \\\\hlevels  {this : FSignature} {s : Sort} (f : symbol s) : Nat => length {\\\\Sigma (List Sort) Sort} (domain {s} f)', \"| Sort' : \\\\Set\", \"\\\\lemma swap \\\\hlevels  {tc : TheoremContext} (color : E {tc.Color}) {context : List tc.Sort'} {s : tc.Sort'} {n : Nat} {j : Fin n}\\n  (msigs : Fin n -> MetaContext tc.Sort') (t : Term (tc.envs color) context s (msigs j)) :\\ninject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {ModularMetaContext {tc.envs color} {n} msigs} {color}\\n  (upgrade-metavariables {tc.envs color} {context} {s} {n} {j} msigs t) = upgrade-metavariables\\n  {env {tc}} {context} {s} {n} {j} msigs (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {msigs j} {color} t) \", '| domain {s : Sort} (symbol s) : List (\\\\Sigma (List Sort) Sort)', \"\\\\func convert-to-injected-term \\\\hlevels  {tc3 : TheoremContext} {allow-variables3 : \\\\Prop} (color3 : E {tc.Color}) {context3 : List tc.Sort'} {s3 : tc.Sort'}\\n  (term : GenericLinearTerm (tc.envs color3) context3 s3 allow-variables3) :\\n  Term (env {tc3}) context3 s3 (LinearMetaContext {tc.envs color3} {context3} {s3} {allow-variables3} term) \\n  | {tc}, {allow-variables}, color, {context}, {s}, l-func f arguments => func {env {tc}} {context} {s} {LinearMetaContext\\n    {tc.envs color} {context} {s} {allow-variables} (l-func {tc.envs color} {context} {s} {allow-variables} f arguments)}\\n    (color, f)\\n    (\\\\new DArray {FSignature.arity {env {tc}} {s} (color, f)} (\\\\lam (index : Fin (FSignature.arity {env {tc}} {s} (color, f))) =>\\n      Term (env {tc}) (context ++ (color, f) !!domain index) ((color, f) !!sort index) (LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-func {tc.envs color} {context} {s} {allow-variables} f arguments)))\\n        (\\\\lam (i : Fin (FSignature.arity {env {tc}} {s} (color, f))) =>\\n        upgrade-metavariables {env {tc}} {context ++ (color, f) !!domain i} {(color, f) !!sort i}\\n          {length {\\\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f)} {i}\\n          (\\\\lam (i : Fin (length {\\\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f))) =>\\n            LinearMetaContext {tc.envs color} {context ++ f !!domain i} {f !!sort i} {allow-variables} (arguments.at i))\\n          (convert-to-injected-term {tc} {allow-variables} color {context ++ f !!domain i} {f !!sort i} (arguments.at i))))\\n  | {tc}, {allow-variables}, color, {context}, {s}, l-full-metavar => metavar {env {tc}} {context} {s} {LinearMetaContext\\n    {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})}\\n    (idp {tc.Sort'} {s}) (\\\\new DArray {MetaContext.arity {LinearMetaContext\\n      {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n      (idp {tc.Sort'} {s})}\\n      (\\\\lam (index : Fin (MetaContext.arity {LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n        (idp {tc.Sort'} {s}))) => Term (env {tc}) context (m-domain {LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n        (idp {tc.Sort'} {s}) !! index)\\n        (LinearMetaContext\\n          {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})))\\n      (\\\\lam (i : Fin (MetaContext.arity {LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n        (idp {tc.Sort'} {s}))) => var {env {tc}} {context} {m-domain {LinearMetaContext\\n        {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n        (idp {tc.Sort'} {s}) !! i}\\n        {LinearMetaContext\\n          {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} i\\n        (idp {tc.Sort'} {m-domain {LinearMetaContext\\n          {tc.envs color} {context} {s} {allow-variables} (l-full-metavar {tc.envs color} {context} {s} {allow-variables})} {s}\\n          (idp {tc.Sort'} {s}) !! i})))\\n  | {tc}, {allow-variables}, color, {context}, {s}, l-var index p a => var {env {tc}} {context} {s} {LinearMetaContext\\n    {tc.envs color} {context} {s} {allow-variables} (l-var {tc.envs color} {context} {s} {allow-variables} index p a)} index\\n    p\", '\\\\func length {A1 : \\\\Type} (_ : List A1) : Nat \\n  | {A}, nil => 0\\n  | {A}, a :: l => suc (length {A} l)', '\\\\func \\\\infix 7 !!domain \\\\hlevels  {this : FSignature} {s : Sort} (m : symbol s) (index : Index {\\\\Sigma (List Sort) Sort} (domain {s} m)) : List Sort \\n  => (domain {s} m !! index).1', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set', '| symbol Sort : \\\\Set', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func SumFSignature \\\\hlevels  {J Sort1 : \\\\Set} (S : J -> FSignature {\\n  | Sort => Sort1\\n}) : FSignature {\\n  | Sort => Sort1\\n  | symbol => \\\\lam (s : Sort {\\\\this}) => \\\\Sigma (j : J) (symbol {S j} s)\\n  | domain => \\\\lam {s : Sort {\\\\this}} (symb : symbol {\\\\this} s) => domain {S symb.1} {s} symb.2\\n} => \\\\new FSignature', '\\\\func upgrade-metavariables \\\\hlevels  {env3 : FSignature} {context3 : List env.Sort} {s3 : env.Sort} {n3 : Nat} {index3 : Fin n3}\\n  (meta-contexts3 : Fin n3 -> MetaContext env.Sort) (_ : Term env3 context3 s3 (meta-contexts3 index3)) :\\n  Term env3 context3 s3 (ModularMetaContext {env3} {n3} meta-contexts3) \\n  | {env}, {context}, {s}, {n}, {index}, meta-contexts, var index p =>\\n    var {env} {context} {s} {ModularMetaContext {env} {n} meta-contexts} index p\\n  | {env}, {context}, {s}, {n}, {index}, meta-contexts, metavar m arguments =>\\n  metavar {env} {context} {s} {ModularMetaContext {env} {n} meta-contexts} (index, m)\\n    (\\\\new DArray {MetaContext.arity {ModularMetaContext {env} {n} meta-contexts} {s} (index, m)}\\n      (\\\\lam (index1 : Fin (MetaContext.arity {ModularMetaContext {env} {n} meta-contexts} {s} (index, m))) =>\\n      Term env context (m-domain {ModularMetaContext {env} {n} meta-contexts} {s} (index, m) !! index1)\\n        (ModularMetaContext {env} {n} meta-contexts))\\n      (\\\\lam (i : Fin (MetaContext.arity {ModularMetaContext {env} {n} meta-contexts} {s} (index, m))) => upgrade-metavariables\\n        {env} {context} {m-domain {ModularMetaContext {env} {n} meta-contexts} {s} (index, m) !! i} {n} {index} meta-contexts\\n          (arguments.at i)))\\n  | {env}, {context}, {s}, {n}, {index}, meta-contexts, func f arguments =>\\n  func {env} {context} {s} {ModularMetaContext {env} {n} meta-contexts} f\\n    (\\\\new DArray {FSignature.arity {env} {s} f} (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) =>\\n      Term env (context ++ f !!domain index) (f !!sort index) (ModularMetaContext {env} {n} meta-contexts))\\n      (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) =>\\n        upgrade-metavariables {env} {context ++ f !!domain i} {f !!sort i} {n} {index} meta-contexts (arguments.at i)))', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| Sort : \\\\Set', '\\\\func inject-term \\\\hlevels  {J3 Sort4 : \\\\Set} (S3 : J3 -> FSignature {\\n  | Sort => Sort4\\n}) {s3 : Sort4} {c3 : List Sort4} {mc3 : MetaContext Sort4} {j2 : J3} (_ : Term (S3 j2) c3 s3 mc3) :\\n  Term (SumFSignature {J3} {Sort4} S3) c3 s3 mc3 \\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, var index p => var {SumFSignature {J} {Sort1} S} {c} {s} {mc} index p\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, metavar m args =>\\n  metavar {SumFSignature {J} {Sort1} S} {c} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term (SumFSignature {J} {Sort1} S) c (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => inject-term {J} {Sort1} S {mc.m-domain {s} m !! i} {c} {mc} {j} (args.at i)))\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, func f args => func {SumFSignature {J} {Sort1} S} {c} {s} {mc} (j, f)\\n    (\\\\new DArray {FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f)}\\n      (\\\\lam (index : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        Term (SumFSignature {J} {Sort1} S) (c ++ (j, f) !!domain index) ((j, f) !!sort index) mc)\\n      (\\\\lam (i : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        inject-term {J} {Sort1} S {(j, f) !!sort i} {c ++ (j, f) !!domain i} {mc} {j} (args.at i)))', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '\\\\func convert-to-term \\\\hlevels  {env3 : FSignature} {context3 : List env.Sort} {s3 : env.Sort} {allowVariables3 : \\\\Prop}\\n  (term : GenericLinearTerm env3 context3 s3 allowVariables3) :\\n  Term env3 context3 s3 (LinearMetaContext {env3} {context3} {s3} {allowVariables3} term) \\n  | {env}, {context}, {s}, {allowVariables}, l-func f arguments => func {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-func {env} {context} {s} {allowVariables} f arguments)} f\\n    (\\\\new DArray {FSignature.arity {env} {s} f}\\n      (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index)\\n        (LinearMetaContext {env} {context} {s} {allowVariables} (l-func {env} {context} {s} {allowVariables} f arguments)))\\n      (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => upgrade-metavariables\\n        {env} {context ++ f !!domain i} {f !!sort i} {length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f)} {i}\\n          (\\\\lam (i : Fin (length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f))) =>\\n            LinearMetaContext {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))\\n          (convert-to-term {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))))\\n  | {env}, {context}, {s}, {allowVariables}, l-var index p a => var {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-var {env} {context} {s} {allowVariables} index p a)} index p\\n  | {env}, {context}, {s}, {allowVariables}, l-full-metavar => metavar {env} {context} {s}\\n    {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})}\\n    (idp {env.Sort} {s}) (\\\\new DArray {MetaContext.arity\\n      {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n        (idp {env.Sort} {s})}\\n        (\\\\lam (index : Fin (MetaContext.arity\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}))) => Term env context\\n          (m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}) !! index)\\n          (LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})))\\n        (\\\\lam (i : Fin (MetaContext.arity\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}))) => var {env} {context}\\n          {m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n            (idp {env.Sort} {s}) !! i}\\n          {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} i\\n          (idp {env.Sort}\\n            {m-domain {LinearMetaContext {env} {context} {s} {allowVariables} (l-full-metavar {env} {context} {s} {allowVariables})} {s}\\n              (idp {env.Sort} {s}) !! i})))', '| Color : DecSet', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", '\\\\func LinearMetaContext \\\\hlevels  {env3 : FSignature} {context2 : List env.Sort} {s2 : env.Sort} {allowVariables1 : \\\\Prop}\\n  (_ : GenericLinearTerm env3 context2 s2 allowVariables1) : MetaContext env.Sort \\n  | {env}, {context}, {s}, {allowVariables}, l-func f arguments =>\\n  ModularMetaContext {env} {length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f)}\\n    (\\\\lam (i : Fin (length {\\\\Sigma (List env.Sort) env.Sort} (env.domain {s} f))) =>\\n      LinearMetaContext {env} {context ++ f !!domain i} {f !!sort i} {allowVariables} (arguments.at i))\\n  | {env}, {context}, {s}, {allowVariables}, l-var index p a => EmptyMetaContext {env}\\n  | {env}, {context}, {s}, {allowVariables}, l-full-metavar => SingularMetaContext {env} s context', \"\\\\instance env \\\\hlevels  {this1 : TheoremContext} : FSignature {\\n  | Sort => Sort'\\n  | symbol => \\\\lam (s : Sort {\\\\this}) => \\\\Sigma (j : E {Color}) (symbol {envs j} s)\\n  | domain => \\\\lam {s : Sort {\\\\this}} (symb : symbol {\\\\this} s) => domain {envs symb.1} {s} symb.2\\n} => SumFSignature {E {Color}} {Sort'} envs\", '\\\\func ModularMetaContext \\\\hlevels  {env : FSignature} {n : Nat} (meta-contexts : Fin n -> MetaContext env.Sort) : MetaContext env.Sort {\\n  | metaname => \\\\lam (s : MetaContext.Sort {\\\\this}) => \\\\Sigma (i : Fin n) (metaname {meta-contexts i} s)\\n  | m-domain => \\\\lam {s : MetaContext.Sort {\\\\this}} (m : metaname {\\\\this} s) => m-domain {meta-contexts m.1} {s} m.2\\n} => \\\\new MetaContext', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', \"\\\\lemma unwrap-injection \\\\hlevels  {tc : TheoremContext} {color : E {tc.Color}} {context : List tc.Sort'} {s : tc.Sort'} {allow-variables : \\\\Prop}\\n  (t : GenericLinearTerm (tc.envs color) context s allow-variables) :\\ninject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {context} {LinearMetaContext {tc.envs color} {context} {s} {allow-variables} t}\\n  {color} (convert-to-term {tc.envs color} {context} {s} {allow-variables} t) = convert-to-injected-term {tc} {allow-variables} color {context} {s} t \"]<<<break>>>\\Pi (index : Fin (arity {env {tc}} {s} (color, f))) ->\ninject-term {E {tc.Color}} {tc.Sort'} tc.envs {(color, f) !!sort index} {context ++ (color, f) !!domain index} {ModularMetaContext\n  {tc.envs color} {length {\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f)}\n    (\\lam (i : Fin (length {\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f))) =>\n      LinearMetaContext {tc.envs color} {context ++ f !!domain i} {f !!sort i} {allow-variables} (arguments !! i))} {color}\n    (upgrade-metavariables {tc.envs color} {context ++ f !!domain index} {f !!sort index}\n      {length {\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f)} {index}\n      (\\lam (i : Fin (length {\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f))) =>\n        LinearMetaContext {tc.envs color} {context ++ f !!domain i} {f !!sort i} {allow-variables} (arguments !! i))\n      (convert-to-term {tc.envs color} {context ++ f !!domain index} {f !!sort index} {allow-variables} (arguments !! index))) = upgrade-metavariables {env {tc}} {context ++ (color, f) !!domain index} {(color, f) !!sort index}\n  {length {\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f)} {index}\n  (\\lam (i : Fin (length {\\Sigma (List (Sort {tc.envs color})) (Sort {tc.envs color})} (domain {tc.envs color} {s} f))) =>\n    LinearMetaContext {tc.envs color} {context ++ f !!domain i} {f !!sort i} {allow-variables} (arguments !! i))\n  (convert-to-injected-term\n    {tc} {allow-variables} color {context ++ f !!domain index} {f !!sort index} (arguments.at index))", "completion": "\\lam index => rewriteI (unwrap-injection (arguments index))\n  (swap color (\\lam i => LinearMetaContext {envs color} (arguments i)) (convert-to-term {envs color} (arguments index)))"}
{"prompt": "['b : Ob {C {\\\\this}}', 'a^n=u12 : pow {R} a.1 n = u.1.2', 'm : Nat', 'n : Nat', 'a : Ob {C {\\\\this}}', 't : \\\\Sigma (n : Nat) (c : R.E) (cd : Nat) (R.isHomogen c cd) (pow {R} b.1 n = a.1 R.* c) (suc b.2 * n = suc a.2 + cd)', 's : \\\\Sigma (y : R.E) (k : Nat) (yh : R.isHomogen y (suc a.2 * k)) ((x,\\n  inP {\\\\Sigma (y : SType {R} (powers {R} a.1)) (x = inl~ {R} {powers {R} a.1} y) (n : Nat) (R.isHomogen y.1 n) (R.isHomogen y.2 n)}\\n    u) = fromSType {R} {powers {R} a.1}\\n    (y, pow {R} a.1 k, inP {\\\\Sigma (n : Nat) (pow {R} a.1 n = pow {R} a.1 k)} (k, idp {R.E} {pow {R} a.1 k})) {suc a.2 * k}\\n    {?hidden} {?hidden})', 'u : \\\\Sigma (y : SType {R} (powers {R} a.1)) (x = inl~ {R} {powers {R} a.1} y) (n : Nat) (R.isHomogen y.1 n) (R.isHomogen y.2 n)', 'd : u.1.1 R.* pow {R} a.1 s.2 R.* pow {R} a.1 m = s.1 R.* u.1.2 R.* pow {R} a.1 m', 'R : GradedCRing']<<<break>>>['| \\\\infixl 6 + E E : E', '| C : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', 'coef C', 'nil', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', '\\\\lemma gensZeroToIdealZero \\\\hlevels  {R : CRing} (gensCoeffs : List (\\\\Sigma R.E (gen : R.E) (gen = R.zro))) : idealElem {R}\\n  (map {\\\\Sigma R.E (gen : R.E) (gen = R.zro)} {\\\\Sigma R.E R.E} (\\\\lam (x : \\\\Sigma R.E (gen : R.E) (gen = R.zro)) => (x.1, x.2))\\n    gensCoeffs) = R.zro ', ':zro', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '| negative E : E', '\\\\lemma pow_*-comm \\\\hlevels  {this : CMonoid} {a b : E} {n : Nat} : pow (a * b) n = pow a n * pow b n ', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\lemma pow_* \\\\hlevels  {this : Monoid} {a : E} {n m : Nat} : pow a (n * m) = pow (pow a n) m ', '\\\\lemma toZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x = y) : x - y = zro ', 'pos Nat', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '| zro : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", 'var V', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\infixr 5 :: A (List A)', '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>s.1 R.* pow {R} t.2 s.2 R.* pow {R} (pow {R} b.1 t.1) n R.* pow {R} (pow {R} b.1 t.1) m = u.1.1 R.* pow {R} t.2 n R.* pow {R} b.1 (t.1 Nat.* s.2) R.* pow {R} (pow {R} b.1 t.1) m", "completion": "rewrite pow_* (rewrite t.5 (rewrite pow_*-comm (rewrite pow_*-comm (rewrite pow_*-comm equation))))"}
{"prompt": "['mc : MetaContext env.Sort', 'm : mc.metaname s', 'context : List env.Sort', 'arguments : DArray {arity {mc} {s} m} (\\\\lam (index : Fin (arity {mc} {s} m)) => Term env context (mc.m-domain {s} m !! index) mc)', 'env : FSignature', 's : env.Sort']<<<break>>>['\\\\lemma plain-identity-effect \\\\hlevels  {env : FSignature} {context : List env.Sort} {s : env.Sort} {mc : MetaContext env.Sort} (t : Term env context s mc) :\\n  apply {env} {s} {context} {mc} t {context} (plain-identity {env} {context} {mc}) = t ', '\\\\func apply \\\\hlevels  {env2 : FSignature} {s2 : env.Sort} {old-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\\n  (_ : Term env2 old-context2 s2 mc2) {new-context2 : List env.Sort}\\n  (_ : Substitution {env2} old-context2 new-context2 mc2) : Term env2 new-context2 s2 mc2 \\n  | {env}, {s}, {old-context}, {mc}, var index idp, {new-context}, map => map index\\n  | {env}, {s}, {old-context}, {mc}, metavar m arguments, {new-context}, map =>\\n  metavar {env} {new-context} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term env new-context (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) =>\\n      apply {env} {mc.m-domain {s} m !! i} {old-context} {mc} (arguments.at i) {new-context} map))\\n  | {env}, {s}, {old-context}, {mc}, func f arguments, {new-context}, map =>\\n  func {env} {new-context} {s} {mc} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (new-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) =>\\n    apply {env} {f !!sort i} {old-context ++ f !!domain i} {mc} (arguments.at i) {new-context ++ f !!domain i}\\n      (append-context-right {env} {old-context} {new-context} {mc} map {f !!domain i})))', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', '| Sort : \\\\Set', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '\\\\func plain-identity \\\\hlevels  {env : FSignature} {context : List env.Sort} {mc : MetaContext env.Sort} : Substitution {env} context context mc \\n  => \\\\lam (i : Index {env.Sort} context) => var {env} {context} {context !! i} {mc} i (idp {env.Sort} {context !! i})', '| m-domain {s : Sort} (metaname s) : List Sort', '\\\\func arity \\\\hlevels  {this : MetaContext} {s : Sort} (m : metaname s) : Nat => length {Sort} (m-domain {s} m)', '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))']<<<break>>>\\Pi (index : Fin (arity {mc} {s} m)) ->\n  apply {env} {mc.m-domain {s} m !! index} {context} {mc} (arguments.at index) {context} (plain-identity {env} {context} {mc}) = arguments.at index", "completion": "\\lam index => plain-identity-effect (arguments index)"}
{"prompt": "['D : DiscreteField (E {f.Cod}) {\\n  | zro => zro {f.Cod}\\n  | + => (+) {f.Cod}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => (*) {f.Cod}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => negative {f.Cod}\\n  | negative-left => {?hidden}\\n  | ide => ide {f.Cod}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoef {f.Cod}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', 'f : RingHom', 'e : Equiv {E {f.Dom}} {E {f.Cod}} f.func']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| \\\\infixl 6 + E E : E', '| #0-* {x y : E} (#0 x) (#0 y) : #0 (x * y)', '\\\\lemma id_finvImpl {this : DiscreteField} {x : E} (x/=0 : x /= zro) : x * finv-impl x = ide \\n=> \\\\case aux zro/=ide x (eitherZeroOrInv x) \\\\with {\\n  | inl x=0 => absurd {x * (\\\\case inl {x = zro} {Inv x} x=0 \\\\with {\\n    | inl p => zro\\n    | inr j => j.inv\\n  }) = ide} (x/=0 x=0)\\n  | inr j => j.inv-right\\n}', '| \\\\infix 8 #0 E : \\\\Prop', '\\\\field eitherZeroOrInv (x : E) : (x = zro) || Inv x', '| +-assoc {x y z : E} : x + y + z = x + (y + z)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '| inv-left : inv * val = elem', '| \\\\infixl 7 * E E : E', 'yes E', 'no (Not E)', '\\\\class DiscreteField \\\\extends Field, EuclideanDomain {\\n  | finv E : E\\n  | finv_zro : finv zro = zro\\n  | finv-right {x : E} (x /= zro) : x * finv x = ide\\n  \\\\field eitherZeroOrInv (x : E) : (x = zro) || Inv x\\n  | nonZeroApart => \\\\lam {x : E} (x/=0 : x /= zro) => (\\\\scase eitherZeroOrInv x \\\\with {\\n    | byLeft x=0 => absurd {Inv x} (x/=0 x=0)\\n    | byRight x#0 => x#0\\n  })\\n  | locality => \\\\lam (x : E) => (\\\\scase eitherZeroOrInv x \\\\with {\\n    | byLeft x=0 => byRight {Inv x} {Inv (x + ide)} (lmake {x + ide} ide (\\n      \\\\let env => x :: nil\\n      \\\\in SolverModel.terms-equality\\n          {SemiringSolverModel this6} env (:ide {Nat} {1} :* (var {Nat} {env.len} 0 :+ :ide {Nat} {1})) (:ide {Nat} {1})\\n            (SemiringSolverModel.apply-axiom\\n            env (var {Nat} {env.len} 0) (:zro {Nat} {1}) x=0 ((nil {Fin 1}, 1) :: nil {\\\\Sigma (List (Fin 1)) Nat})\\n              ((nil {Fin 1}, 1) :: nil {\\\\Sigma (List (Fin 1)) Nat}) ((nil {Fin 1}, 1) :: nil {\\\\Sigma (List (Fin 1)) Nat}))))\\n    | byRight xInv => byLeft {Inv x} {Inv (x + ide)} xInv\\n  })\\n  | isEuclidean => inP {EuclideanRingData E {\\n    | zro => zro\\n    | + => (+)\\n    | zro-left => {?hidden}\\n    | zro-right => {?hidden}\\n    | +-assoc => {?hidden}\\n    | +-comm => {?hidden}\\n    | * => (*)\\n    | *-assoc => {?hidden}\\n    | ldistr => {?hidden}\\n    | rdistr => {?hidden}\\n    | ide => ide\\n    | ide-left => {?hidden}\\n    | ide-right => {?hidden}\\n    | natCoef => natCoef\\n    | natCoefZero => {?hidden}\\n    | natCoefSuc => {?hidden}\\n    | *-comm => {?hidden}\\n    | decideEq => decideEq\\n    | negative => negative\\n    | negative-left => {?hidden}\\n  }}\\n    (\\\\new EuclideanRingData E {\\n      | zro => zro\\n      | + => (+)\\n      | zro-left => {?hidden}\\n      | zro-right => {?hidden}\\n      | +-assoc => {?hidden}\\n      | +-comm => {?hidden}\\n      | * => (*)\\n      | *-assoc => {?hidden}\\n      | ldistr => {?hidden}\\n      | rdistr => {?hidden}\\n      | ide => ide\\n      | ide-left => {?hidden}\\n      | ide-right => {?hidden}\\n      | natCoef => natCoef\\n      | natCoefZero => {?hidden}\\n      | natCoefSuc => {?hidden}\\n      | *-comm => {?hidden}\\n      | # => (DecSet.#)\\n      | #-irreflexive => {?hidden}\\n      | #-symmetric => {?hidden}\\n      | #-comparison => {?hidden}\\n      | tightness => {?hidden}\\n      | decideEq => decideEq\\n      | nonEqualApart => {?hidden}\\n      | euclideanMap => \\\\lam (_ : E {\\\\this}) => 0\\n      | divMod => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq y zro \\\\with {\\n        | yes p => (zro, x)\\n        | no n => (finv y * x, zro)\\n      })\\n      | isDivMod => {?hidden}\\n      | isEuclideanMap => {?hidden}\\n      | negative => negative\\n      | negative-left => {?hidden}\\n    })\\n}', '| ret B : A', '| func-zro : func (zro {Dom}) = zro {Cod}', '| E : \\\\Set', '| negative E : E', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', '| ide-right {x : E} : x * ide = x', '| ide-left {x : E} : ide * x = x', \"\\\\func isInj {this : Equiv} {a a' : A} (p : f a = f a') : a = a' \\n  => inv {A} {ret (f a)} {a} (ret_f a) *> pmap {B} {A} ret {f a} {f a'} p *> ret_f a'\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func f_ret {this : Equiv} (y : B) : f (ret y) = y \\n  => pmap {B} {B} (\\\\lam (y : B) => f (ret y)) {y} {f (sec y)} (inv {B} {f (sec y)} {y} (f_sec y)) *> pmap {A} {B} f {ret (f (sec y))} {sec y} (ret_f (sec y)) *> f_sec y', '| zro-right {x : E} : x + zro = x', '| func-ide : func (ide {Dom}) = ide {Cod}', '| zro/=ide : zro /= ide', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| zro-left {x : E} : zro + x = x', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\func finv-impl {this : DiscreteField} (x : E) : E => \\\\case aux zro/=ide x (eitherZeroOrInv x) \\\\with {\\n  | inl p => zro\\n  | inr j => j.inv\\n}', '| negative-left {x : E} : negative x + x = zro', '| func (E {Dom}) : E {Cod}', '\\\\field decideEq (x y : E) : Dec (x = y)', '| Dom : BaseSet', '| #-irreflexive {x : E} : Not (x # x)', '| #0-zro : Not (#0 zro)', '| Cod : BaseSet', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '| nonZeroApart {x : E} (x /= zro) : #0 x', '| inv-right : val * inv = elem', '| *-comm {x y : E} : x * y = y * x', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| natCoef Nat : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func map {A B C2 D2 : \\\\Type} (_ : A -> C2) (_ : B -> D2) (_ : A || B) : C2 || D2 \\n  | {A}, {B}, {C}, {D}, f, g, byLeft a => byLeft {C} {D} (f a)\\n  | {A}, {B}, {C}, {D}, f, g, byRight b => byRight {C} {D} (g b)', 'byLeft A', '| ide : E', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| inv : E {M}', '| natCoefZero : natCoef 0 = zro', 'byRight B', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '| zro : E', '| func-* {x y : E {Dom}} : func (x * y) = func x * func y', '| ldistr {x y z : E} : x * (y + z) = x * y + x * z', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '| natCoefSuc (n : Nat) : natCoef (suc n) = natCoef n + ide', '\\\\lemma finv_zroImpl {this : DiscreteField} : finv-impl zro = zro => \\\\case aux zro/=ide zro (eitherZeroOrInv zro) \\\\with {\\n  | inl p => idp {E} {\\\\case inl {zro = zro} {Inv zro} p \\\\with {\\n    | inl p => zro\\n    | inr j => j.inv\\n  }}\\n  | inr j => absurd {(\\\\case inr {zro = zro} {Inv zro} j \\\\with {\\n    | inl p => zro\\n    | inr j => j.inv\\n  }) = zro} (zro/=ide (Paths.inv {E} {zro * j.inv} {zro} (zro_*-left {j.inv}) *> j.inv-right))\\n}', '| rdistr {x y z : E} : (x + y) * z = x * z + y * z', '| +-comm {x y : E} : x + y = y + x', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ']<<<break>>>DiscreteField (E {f.Dom}) {\n  | zro => zro {f.Dom}\n  | + => (+) {f.Dom}\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n  | +-comm => {?hidden}\n  | * => (*) {f.Dom}\n  | *-assoc => {?hidden}\n  | ldistr => {?hidden}\n  | rdistr => {?hidden}\n  | negative => negative {f.Dom}\n  | negative-left => {?hidden}\n  | ide => ide {f.Dom}\n  | ide-left => {?hidden}\n  | ide-right => {?hidden}\n  | natCoef => natCoef {f.Dom}\n  | natCoefZero => {?hidden}\n  | natCoefSuc => {?hidden}\n  | zro/=ide => {?hidden}\n  | *-comm => {?hidden}\n  | decideEq => \\lam (x : E {\\this}) (y : E {\\this}) => (\\case eitherZeroOrInv {\\this} (x - y) \\with {\n    | byLeft x-y=0 => yes {x = y} (fromZero {x} {y} x-y=0)\n    | byRight x-y-isInv => no {x = y} (\\lam (x=y : x = y) =>\n      #-irreflexive {\\this} {y} (transport {E {\\this}} (\\lam (x : E {\\this}) => Inv (x - y)) {x} {y} x=y x-y-isInv))\n  })\n  | zeroProduct => {?hidden}\n  | finv => finv-impl\n  | finv_zro => {?hidden}\n  | finv-right => {?hidden}\n  | eitherZeroOrInv => \\lam (a : E {\\this}) =>\n  map {f.func a = D.zro} {Inv {D} (f.func a)} {a = zro {\\this}} {Inv {f.Dom} a} (\\lam (q : f.func a = D.zro) =>\n    isInj {e} {a} {zro {\\this}} (q *> Paths.inv {E {f.Cod}} {f.func (zro {\\this})} {D.zro} f.func-zro))\n    (\\lam (fai : Inv {D} (f.func a)) => \\new Inv {f.Dom} a (e.ret fai.inv) {\n      | inv-left => {?hidden}\n      | inv-right => {?hidden}\n    }) (D.eitherZeroOrInv (f.func a))\n}", "completion": "\\new DiscreteField {\n  | Ring => Dom {f}\n  | *-comm => isInj {e} $ func-* {f} *> *-comm *> inv (func-* {f})\n  | zro/=ide => \\lam q => zro/=ide {D} $ inv (func-zro {f}) *> pmap f q *> func-ide {f}\n  | eitherZeroOrInv => \\lam a => map (\\lam q => isInj {e} $ q *> inv (func-zro {f})) (\\lam (fai : Inv (f a)) => \\new Inv a {\n    | inv => ret {e} (inv {fai})\n    | inv-left => isInj {e} $ func-* {f} *> pmap (\\lam _x => _x * _) (f_ret {e} _) *> inv-left {fai} *> inv (func-ide {f})\n    | inv-right => isInj {e} $ func-* {f} *> pmap ((*) _) (f_ret {e} _) *> inv-right {fai} *> inv (func-ide {f})\n  }) (eitherZeroOrInv {D} (f a))\n}"}
{"prompt": "['a : E', 'this : JoinSemilatticeAbMonoid', 'c : E', 'b : E']<<<break>>>['| \\\\infixl 6 + E E : E', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| E : \\\\Set', '| +-comm {x y : E} : x + y = y + x']<<<break>>>a \u2228 b + c = c + (a \u2228 b)", "completion": "+-comm {this}"}
{"prompt": "[\"new-context : List tc.Sort'\", 'msubst : MetaSubstitution (env {tc}) context (rule-linear-mc {tc} {s} {color} idx) mc', \"context : List tc.Sort'\", 'color : E {tc.Color}', 'tc : TheoremContext', 'subst : Substitution {env {tc}} context new-context mc', \"mc : MetaContext tc.Sort'\", \"s : tc.Sort'\", 'idx : rule-J {tc.rules color} s']<<<break>>>['\\\\func apply \\\\hlevels  {env2 : FSignature} {s2 : env.Sort} {old-context2 : List env.Sort} {mc2 : MetaContext env.Sort}\\n  (_ : Term env2 old-context2 s2 mc2) {new-context2 : List env.Sort}\\n  (_ : Substitution {env2} old-context2 new-context2 mc2) : Term env2 new-context2 s2 mc2 \\n  | {env}, {s}, {old-context}, {mc}, var index idp, {new-context}, map => map index\\n  | {env}, {s}, {old-context}, {mc}, metavar m arguments, {new-context}, map =>\\n  metavar {env} {new-context} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term env new-context (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) =>\\n      apply {env} {mc.m-domain {s} m !! i} {old-context} {mc} (arguments.at i) {new-context} map))\\n  | {env}, {s}, {old-context}, {mc}, func f arguments, {new-context}, map =>\\n  func {env} {new-context} {s} {mc} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (new-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) =>\\n    apply {env} {f !!sort i} {old-context ++ f !!domain i} {mc} (arguments.at i) {new-context ++ f !!domain i}\\n      (append-context-right {env} {old-context} {new-context} {mc} map {f !!domain i})))', '\\\\func apply \\\\hlevels  {env3 : FSignature} {context3 core-context2 : List env.Sort} {s3 : env.Sort}\\n  {old-metacontext2 new-metacontext3 : MetaContext env.Sort} (_ : Term env3 context3 s3 old-metacontext2)\\n  (_ : SubList {env.Sort} core-context2 context3)\\n  (_ : MetaSubstitution env3 core-context2 old-metacontext2 new-metacontext3) : Term env3 context3 s3 new-metacontext3 \\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, var index p, sublist, subst =>\\n    var {env} {context} {s} {new-metacontext} index p\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, metavar m arguments, sublist, subst =>\\n  Substitution.apply {env} {s} {core-context ++ old-metacontext.m-domain {s} m} {new-metacontext} (subst {s} m) {context}\\n    (extend-substitution-left {env} {core-context} {old-metacontext.m-domain {s} m} {context} {new-metacontext} sublist\\n      (\\\\lam (i : Index {env.Sort} (old-metacontext.m-domain {s} m)) => MetaSubstitution.apply\\n        {env} {context} {core-context} {old-metacontext.m-domain {s} m !! i} {old-metacontext} {new-metacontext} (arguments.at i)\\n          sublist subst))\\n  | {env}, {context}, {core-context}, {s}, {old-metacontext}, {new-metacontext}, func f arguments, sublist, subst =>\\n  func {env} {context} {s} {new-metacontext} f (\\\\new DArray {FSignature.arity {env} {s} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s} f)) => Term env (context ++ f !!domain index) (f !!sort index) new-metacontext)\\n    (\\\\lam (i : Fin (FSignature.arity {env} {s} f)) => MetaSubstitution.apply\\n      {env} {context ++ f !!domain i} {core-context} {f !!sort i} {old-metacontext} {new-metacontext} (arguments.at i)\\n        (extend-right-single {env.Sort} {core-context} {context} sublist {f !!domain i}) subst))', \"\\\\func rule-right-linear \\\\hlevels  {this : TheoremContext} {s : Sort'} {c : E {Color}} (idx : rule-J {rules c} s) :\\n  Term (envs c) (nil {Sort'}) s (rule-linear-mc {s} {c} idx) => rule-r {rules c} {s} idx\", '\\\\func append-context-right \\\\hlevels  {env3 : FSignature} {old-context2 new-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Substitution {env3} old-context2 new-context3 mc3) {additional-context3 : List env.Sort}\\n  (index2 : Index {env.Sort} (old-context2 ++ additional-context3)) :\\n  Term env3 (new-context3 ++ additional-context3) ((old-context2 ++ additional-context3) !! index2) mc3 \\n  | {env}, {nil}, {new-context}, {mc}, subst, {additional-context}, index =>\\n  weakening {env} {(nil {env.Sort} ++ additional-context) !! index} {additional-context} {new-context ++ additional-context} {mc}\\n    (var {env} {additional-context} {(nil {env.Sort} ++ additional-context) !! index} {mc} index\\n      (idp {env.Sort} {(nil {env.Sort} ++ additional-context) !! index}))\\n    (id+left {env.Sort} {additional-context} {new-context})\\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, zero =>\\n  weakening {env} {((a :: old-context) ++ additional-context) !! 0} {new-context} {new-context ++ additional-context} {mc} (subst 0)\\n    (id+right {env.Sort} {new-context} {additional-context})\\n  | {env}, {a :: old-context}, {new-context}, {mc}, subst, {additional-context}, suc index => append-context-right\\n    {env} {old-context} {new-context} {mc} (\\\\lam (i : Index {env.Sort} old-context) => subst (suc i)) {additional-context}\\n      index', '\\\\func Index {A : \\\\Type} (list : List A) : \\\\Type => Fin (length {A} list)', '| Sort : \\\\Set', \"| Sort' : \\\\Set\", '\\\\func inject-term \\\\hlevels  {J3 Sort4 : \\\\Set} (S3 : J3 -> FSignature {\\n  | Sort => Sort4\\n}) {s3 : Sort4} {c3 : List Sort4} {mc3 : MetaContext Sort4} {j2 : J3} (_ : Term (S3 j2) c3 s3 mc3) :\\n  Term (SumFSignature {J3} {Sort4} S3) c3 s3 mc3 \\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, var index p => var {SumFSignature {J} {Sort1} S} {c} {s} {mc} index p\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, metavar m args =>\\n  metavar {SumFSignature {J} {Sort1} S} {c} {s} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s} m)) => Term (SumFSignature {J} {Sort1} S) c (mc.m-domain {s} m !! index) mc)\\n    (\\\\lam (i : Fin (MetaContext.arity {mc} {s} m)) => inject-term {J} {Sort1} S {mc.m-domain {s} m !! i} {c} {mc} {j} (args.at i)))\\n  | {J}, {Sort1}, S, {s}, {c}, {mc}, {j}, func f args => func {SumFSignature {J} {Sort1} S} {c} {s} {mc} (j, f)\\n    (\\\\new DArray {FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f)}\\n      (\\\\lam (index : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        Term (SumFSignature {J} {Sort1} S) (c ++ (j, f) !!domain index) ((j, f) !!sort index) mc)\\n      (\\\\lam (i : Fin (FSignature.arity {SumFSignature {J} {Sort1} S} {s} (j, f))) =>\\n        inject-term {J} {Sort1} S {(j, f) !!sort i} {c ++ (j, f) !!domain i} {mc} {j} (args.at i)))', 'nil', '\\\\func identity {A2 : \\\\Type} {list1 : List A2} : SubList {A2} list1 list1 \\n  | {A}, {nil} => sublist-nil {A}\\n  | {A}, {a :: list} => sublist-match {A} {a} {list} {a} {list} (idp {A} {a}) (identity {A} {list})', '\\\\func extend-right-single {A3 : \\\\Type} {l1 r : List A3} (_ : SubList {A3} l1 r) {add3 : List A3} : SubList {A3} l1 (r ++ add3) \\n  | {A}, {nil}, {nil}, sublist-nil, {add} => sublist-nil-free {A} {nil {A} ++ add}\\n  | {A}, {x :: xs}, {y :: ys}, sublist-match p sublist, {add} =>\\n    sublist-match {A} {x} {xs} {y} {ys ++ add} p (extend-right-single {A} {xs} {ys} sublist {add})\\n  | {A}, {l}, {y :: ys}, sublist-skip sublist, {add} =>\\n    sublist-skip {A} {l} {y} {ys ++ add} (extend-right-single {A} {l} {ys} sublist {add})', \"\\\\func weakening \\\\hlevels  {env3 : FSignature} {s'3 : env.Sort} {narrow-context3 wide-context3 : List env.Sort} {mc3 : MetaContext env.Sort}\\n  (_ : Term env3 narrow-context3 s'3 mc3) (_ : SubList {env.Sort} narrow-context3 wide-context3) :\\n  Term env3 wide-context3 s'3 mc3 \\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, var index p, sublist =>\\n  var {env} {wide-context} {s'} {mc} (shift-index {env.Sort} {narrow-context} {wide-context} sublist index)\\n    (proof {env.Sort} {narrow-context} {wide-context} {s'} sublist index p)\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, metavar m arguments, sublist =>\\n  metavar {env} {wide-context} {s'} {mc} m (\\\\new DArray {MetaContext.arity {mc} {s'} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {s'} m)) => Term env wide-context (mc.m-domain {s'} m !! index) mc)\\n    (\\\\lam (i1 : Fin (MetaContext.arity {mc} {s'} m)) =>\\n      weakening {env} {mc.m-domain {s'} m !! i1} {narrow-context} {wide-context} {mc} (arguments.at i1) sublist))\\n  | {env}, {s'}, {narrow-context}, {wide-context}, {mc}, func f arguments, sublist =>\\n  func {env} {wide-context} {s'} {mc} f (\\\\new DArray {FSignature.arity {env} {s'} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {s'} f)) => Term env (wide-context ++ f !!domain index) (f !!sort index) mc)\\n    (\\\\lam (i1 : Fin (FSignature.arity {env} {s'} f)) =>\\n    weakening {env} {f !!sort i1} {narrow-context ++ f !!domain i1} {wide-context ++ f !!domain i1} {mc} (arguments.at i1)\\n      (extend-right-both {env.Sort} {narrow-context} {wide-context} sublist {f !!domain i1})))\", '\\\\data Term \\\\hlevels  (env : FSignature) (List env.Sort) env.Sort (MetaContext env.Sort) \\n  | var (index : Index {env.Sort} context) (termSort = context !! index)\\n  | metavar (m : mc.metaname termSort) (DArray {MetaContext.arity {mc} {termSort} m}\\n    (\\\\lam (index : Fin (MetaContext.arity {mc} {termSort} m)) => Term env context (mc.m-domain {termSort} m !! index) mc))\\n  | func (f : env.symbol termSort) (DArray {FSignature.arity {env} {termSort} f}\\n    (\\\\lam (index : Fin (FSignature.arity {env} {termSort} f)) => Term env (context ++ f !!domain index) (f !!sort index) mc))', '| Color : DecSet', '\\\\lemma commutation \\\\hlevels  {env : FSignature} {s : env.Sort} {aux-context core-context new-context : List env.Sort}\\n  {old-ms new-ms : MetaContext env.Sort} (term : Term env aux-context s old-ms)\\n  (subst : Substitution {env} core-context new-context new-ms)\\n  (metasubst : MetaSubstitution env core-context old-ms new-ms) :\\nMetaSubstitution.apply {env} {new-context ++ aux-context} {new-context} {s} {old-ms} {new-ms}\\n  (weakening {env} {s} {aux-context} {new-context ++ aux-context} {old-ms} term\\n    (extend-left-single {env.Sort} {aux-context} {aux-context} (identity {env.Sort} {aux-context}) {new-context}))\\n  (extend-right-single {env.Sort} {new-context} {new-context} (identity {env.Sort} {new-context}) {aux-context})\\n  (\\\\lam {s : env.Sort} (m : old-ms.metaname s) => Substitution.apply\\n    {env} {s} {core-context ++ old-ms.m-domain {s} m} {new-ms} (metasubst {s} m) {new-context ++ old-ms.m-domain {s} m}\\n      (append-context-right {env} {core-context} {new-context} {new-ms} subst {old-ms.m-domain {s} m})) = Substitution.apply {env} {s} {core-context ++ aux-context} {new-ms}\\n  (MetaSubstitution.apply {env} {core-context ++ aux-context} {core-context} {s} {old-ms} {new-ms}\\n    (weakening {env} {s} {aux-context} {core-context ++ aux-context} {old-ms} term\\n      (extend-left-single {env.Sort} {aux-context} {aux-context} (identity {env.Sort} {aux-context}) {core-context}))\\n    (extend-right-single {env.Sort} {core-context} {core-context} (identity {env.Sort} {core-context}) {aux-context})\\n    metasubst) {new-context ++ aux-context}\\n  (append-context-right {env} {core-context} {new-context} {new-ms} subst {aux-context}) ', '| metaname Sort : \\\\Set', \"| envs (E {Color}) : FSignature {\\n  | Sort => Sort'\\n}\", \"\\\\instance env \\\\hlevels  {this1 : TheoremContext} : FSignature {\\n  | Sort => Sort'\\n  | symbol => \\\\lam (s : Sort {\\\\this}) => \\\\Sigma (j : E {Color}) (symbol {envs j} s)\\n  | domain => \\\\lam {s : Sort {\\\\this}} (symb : symbol {\\\\this} s) => domain {envs symb.1} {s} symb.2\\n} => SumFSignature {E {Color}} {Sort'} envs\", \"\\\\func rule-linear-mc \\\\hlevels  {this : TheoremContext} {s : Sort'} {c : E {Color}} (idx : rule-J {rules c} s) : MetaContext (Sort {envs c}) \\n  => LinearMetaContext {envs c} {nil {Sort'}} {s} {Empty} (get-rule-pattern {s} {c} idx)\", '| E : \\\\Set', '| m-domain {s : Sort} (metaname s) : List Sort', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\func extend-left-single {A1 : \\\\Type} {l1 r1 : List A1} (_ : SubList {A1} l1 r1) {add1 : List A1} : SubList {A1} l1 (add1 ++ r1) \\n  | {A}, {l}, {r}, sublist, {nil} => sublist\\n  | {A}, {l}, {r}, sublist, {a :: add} => sublist-skip {A} {l} {a} {add ++ r} (extend-left-single {A} {l} {r} sublist {add})']<<<break>>>MetaSubstitution.apply\n{env {tc}} {new-context ++ nil {tc.Sort'}} {new-context} {s} {rule-linear-mc {tc} {s} {color} idx} {mc}\n  (weakening {env {tc}} {s} {nil {tc.Sort'}} {new-context ++ nil {tc.Sort'}} {rule-linear-mc {tc} {s} {color} idx}\n    (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {nil {tc.Sort'}} {rule-linear-mc {tc} {s} {color} idx} {color}\n      (rule-right-linear {tc} {s} {color} idx))\n    (extend-left-single {Sort} {nil {tc.Sort'}} {nil {tc.Sort'}} (identity {Sort} {nil {tc.Sort'}}) {new-context}))\n  (extend-right-single {Sort} {new-context} {new-context} (identity {Sort} {new-context}) {nil {tc.Sort'}})\n  (\\lam {s1 : Sort} (m : metaname {rule-linear-mc {tc} {s} {color} idx} s1) => Substitution.apply\n    {env {tc}} {s1} {context ++ m-domain {rule-linear-mc {tc} {s} {color} idx} {s1} m} {mc} (msubst {s1} m)\n      {new-context ++ m-domain {rule-linear-mc {tc} {s} {color} idx} {s1} m} (append-context-right\n        {env {tc}} {context} {new-context} {mc} subst {m-domain {rule-linear-mc {tc} {s} {color} idx} {s1} m})) = Substitution.apply {env {tc}} {s} {context ++ nil {tc.Sort'}} {mc}\n  (MetaSubstitution.apply {env {tc}} {context ++ nil {tc.Sort'}} {context} {s} {rule-linear-mc {tc} {s} {color} idx} {mc}\n    (weakening {env {tc}} {s} {nil {tc.Sort'}} {context ++ nil {tc.Sort'}} {rule-linear-mc {tc} {s} {color} idx}\n      (inject-term {E {tc.Color}} {tc.Sort'} tc.envs {s} {nil {tc.Sort'}} {rule-linear-mc {tc} {s} {color} idx} {color}\n        (rule-right-linear {tc} {s} {color} idx))\n      (extend-left-single {Sort} {nil {tc.Sort'}} {nil {tc.Sort'}} (identity {Sort} {nil {tc.Sort'}}) {context}))\n    (extend-right-single {Sort} {context} {context} (identity {Sort} {context}) {nil {tc.Sort'}}) msubst)\n  {new-context ++ nil {tc.Sort'}} (append-context-right {env {tc}} {context} {new-context} {mc} subst {nil {tc.Sort'}})", "completion": "commutation (inject-term envs (rule-right-linear idx)) subst msubst"}
{"prompt": "['g : CoverMap X RealNormed', \"W<=<a'b' : W <=< open-rat-int a' b'\", 'W : Set E', \"a' : Rat\", \"b' : Rat\"]<<<break>>>['\\\\func open-rat-int \\\\plevels  \\\\hlevels  (a b : Rat) : Set Real => \\\\lam (x : Real) => \\\\Sigma (x.L a) (x.U b)', '\\\\lemma <=<_^-1 \\\\hlevels  {X Y : PrecoverSpace} {f : PrecoverMap X Y} {U V : Set Y.E} (_ : U <=< V) : f.func ^-1 U <=< f.func ^-1 V ', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| Cod : BaseSet', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => \\\\Sigma (e : X.E) ((\u2227) V W e) -> W \u2286 U)', '| Dom : BaseSet']<<<break>>>func {g} ^-1 W <=< func {g} ^-1 open-rat-int a' b'", "completion": "<=<_^-1 W<=<a'b'"}
{"prompt": "['l : Array \\\\Prop (suc (suc n))', 'q : l.at (fromNat {suc n} (suc n)) -> l.at 0', 'i : Fin (suc n)', 'p : DArray {suc n} (\\\\lam (i : Fin (suc n)) => l.at i -> l.at (suc i))', 'n : Nat']<<<break>>>['\\\\lemma <_suc_<= \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < suc m) : n <= m ', 'suc Nat', '\\\\lemma id<suc \\\\plevels  \\\\hlevels  {n : Nat} : n < suc n ', '\\\\lemma aux \\\\plevels  \\\\hlevels  {n : Nat} {l : Array \\\\Prop (suc n)} (_ : DArray {n} (\\\\lam (i : Fin n) => l.at i -> l.at (suc i))) {i j : Fin (suc n)}\\n  {k : Nat} (_ : i + k = j) (_ : l.at i) : l.at j ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '\\\\func divMod \\\\plevels  \\\\hlevels  (_ _ : Nat) : \\\\Sigma Nat Nat ', \"\\\\lemma <=_exists \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n <= m) : n + (m -' n) = m \", '| at (j : Fin len) : A j', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma mod_< \\\\plevels  \\\\hlevels  {n m : Nat} (_ : n < m) : n mod m = n ', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>l.at (suc i) -> l.at 0", "completion": "\\lam a => q $ aux p (later $ pmap suc (<=_exists $ <_suc_<= $ fin_< i) *> inv (mod_< id<suc)) a"}
{"prompt": "['this : StoneC*Algebra', 'q>0 : zro < q', 'q : Rat', 'x>=0 : zro <= x', 'x : E', 'x<=q : x <= q *q ide']<<<break>>>['\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '\\\\lemma finv>0 {this : DiscreteOrderedField} {x : E} (_ : zro < x) : zro < finv x ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '\\\\lemma ide_*q \\\\hlevels  {this : QModule} {a : E} : fromInt (pos 1) *q a = a ', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\type \\\\infix 4 <= \\\\hlevels  {R : Ring} (x y : R.E) : \\\\Prop => IsSquare {R} (y - x)', '| E : \\\\Set', '\\\\lemma >_/= \\\\hlevels  {this : StrictPoset} {x y : E} (_ : x > y) : x /= y ', '\\\\func toRatModule \\\\hlevels  {this1 : QModule} : LModule RatField E {\\n  | zro => zro\\n  | + => (AddMonoid.+)\\n  | negative => negative\\n  | *c => (*q)\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\lemma square-lem \\\\hlevels  {this : StoneC*Algebra} {x : E} (_ : zro StoneC*Algebra.<= x) (_ : x StoneC*Algebra.<= ide) :\\n  norm (ide - x) ExUpperReal.<= ide ', '\\\\lemma *c_zro-right \\\\hlevels  {this : LModule} {r : E {R}} : r *c zro = zro ', '\\\\instance ExUpperRealPointed \\\\hlevels  : Pointed ExUpperReal {\\n  | ide => fromRat ide\\n} => \\\\new Pointed', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| ide : E', '\\\\lemma finv-left {this : DiscreteField} {x : E} (_ : x /= zro) : finv x * x = ide ', '| norm E : ExUpperReal', '| zro : E', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '\\\\lemma *q-assoc \\\\hlevels  {this : QModule} {q r : Rat} {a : E} : q * r *q a = q *q (r *q a) ', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| finv E : E', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infixl 7 *c (E {R}) E : E', '\\\\lemma <=_*q-right \\\\hlevels  {this : PosetQModule} {q : Rat} (_ : zro <= q) {a b : E} (_ : a <= b) : q *q a <= q *q b ']<<<break>>>norm (ide - finv q *q x) <= ide", "completion": "square-lem {this}\n  (transport (\\lam _x => _x <= _) (*c_zro-right {toRatModule {this}}) $ <=_*q-right {this} (<=-less $ finv>0 {RatField} q>0) x>=0)\n  (transport ((<=) _)\n    (inv (*q-assoc {this}) *> pmap (\\lam _x => _x *q {this} _) (finv-left {RatField} $ >_/= {RatField} q>0) *> ide_*q {this}) $ <=_*q-right {this} (<=-less $ finv>0 {RatField} q>0) x<=q)"}
{"prompt": "['f : FrameHom', 'o : IsOvert {f.Cod}', 'd : isStronglyDense {f}', 'a : E {f.Dom}']<<<break>>>['\\\\func pHat \\\\hlevels  {this : Locale} (P : \\\\Prop) : E => Join {P} (\\\\lam (_ : P) => top)', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| top : E', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '| \\\\infix 4 <= E E : \\\\Prop', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func IsPositive \\\\hlevels  {this : Locale} (a : E) : \\\\Prop => \\\\Pi (P : \\\\Prop) -> a <= pHat P -> P', '\\\\lemma func_positive \\\\hlevels  {f : FrameHom} {x : E {f.Dom}} (_ : IsPositive {f.Cod} (f.func x)) : IsPositive {f.Dom} x ', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>a <= pHat {f.Dom} (\\Pi (P : \\Prop) -> a <= pHat {f.Dom} P -> P)", "completion": "d (o _ <=\u2218 Join-univ (\\lam h => Join-cond $ func_positive h))"}
{"prompt": "['this : TopAbGroup (\\\\Sigma X.E Y.E) {\\n  | isOpen => \\\\lam (W : Set E) => \\\\Pi {s : E} -> W s -> TruncP (\\\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\\n    (\\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)))\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n  | zro => (X.zro, Y.zro)\\n  | + => \\\\lam (s : E {\\\\this}) (t : E {\\\\this}) => (s.1 X.+ t.1, s.2 Y.+ t.2)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => \\\\lam (s : E {\\\\this}) => (X.negative s.1, Y.negative s.2)\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | isCauchy => Closure {\\\\Sigma X.E Y.E} (\\\\lam (C : Set (Set (\\\\Sigma X.E Y.E))) => TruncP (\\\\Sigma (j : Bool) (isCauchy C)))\\n  | cauchy-open => {?hidden}\\n  | isUniform => \\\\lam (E1 : Set (Set E)) =>\\n  TruncP (\\\\Sigma (C : Set (Set X.E)) (X.isUniform C) (D : Set (Set Y.E)) (Y.isUniform D) (Refines {\\\\Sigma X.E Y.E}\\n    (\\\\lam (W : Set (\\\\Sigma X.E Y.E)) => TruncP (\\\\Sigma (U : Set X.E) (C U) (V : Set Y.E) (D V) (W = Prod {X.E} {Y.E} U V)))\\n    E1))\\n  | uniform-cauchy => {?hidden}\\n  | +-cont => {?hidden}\\n  | negative-cont => {?hidden}\\n  | neighborhood-uniform => {?hidden}\\n}', 'Y : TopAbGroup', 'x : E {\\\\this}', 'X : TopAbGroup']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| zro-left {x : E} : zro + x = x', '| E : \\\\Set']<<<break>>>zro {\\this} + x = x", "completion": "ext (zro-left, zro-left)"}
{"prompt": "['x : List (\\\\Sigma {?error} Bool)', 'r : x ~ y', 'y : List (\\\\Sigma {?error} Bool)']<<<break>>>['\\\\func AreAdjacent \\\\hlevels  {S : \\\\Set} (w_1 w_2 : E) : \\\\Prop => TruncP (\\\\Sigma (u_1 u_2 : E) (x : S) (p : Bool)\\n  (\\\\Sigma (w_1 = u_1 * u_2) (w_2 = u_1 * ((x, p) :: nil {\\\\Sigma S Bool}) * ((x, not p) :: nil {\\\\Sigma S Bool}) * u_2)))', '\\\\func inv \\\\hlevels  {S2 : \\\\Set} (_ : E) : E \\n  | {S}, nil => nil {\\\\Sigma S Bool}\\n  | {S}, (x, deg) :: l => inv {S} l ++ (x, not deg) :: nil {\\\\Sigma S Bool}', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| E : \\\\Set', '\\\\func W \\\\hlevels  {S : \\\\Set} : Monoid (List (\\\\Sigma S Bool)) {\\n  | ide => nil {\\\\Sigma S Bool}\\n  | * => (++)\\n} => ListMonoid {\\\\Sigma S Bool}', '\\\\lemma equiv_inv \\\\hlevels  {S : \\\\Set} {a b : E} (_ : a ~ b) : inv {S} a ~ inv {S} b ', '\\\\data Closure {A : \\\\Type} (A -> A -> \\\\Type) (_ _ : A) : \\\\Prop \\n  | cin (R x y)\\n  | crefl (x = y)\\n  | csym (Closure {A} R y x)\\n  | ctrans {z : A} (Closure {A} R x z) (Closure {A} R z y)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>Closure {List (\\Sigma {?error} Bool)} (AreAdjacent {{?error}}) (inv {{?error}} x) (inv {{?error}} y)", "completion": "equiv_inv r"}
{"prompt": "['Y : Ob', 'm : Mono {X} {Y}', 'X : Ob', 'this : ToposPrecat']<<<break>>>['| Hom Ob Ob : \\\\Set', '| y : Ob {D}', '| pbBeta2 {w : Ob {D}} {p1 : Hom {D} w x} {p2 : Hom {D} w y} {c : f \u2218 p1 = g \u2218 p2} : pbProj2 \u2218 pbMap {w} p1 p2 c = p2', '| pbProj2 : Hom {D} apex y', '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| apex : Ob {D}', '| char-pullback {S B : Ob} (m : Mono {S} {B}) : Pullback {B} {apex {terminal}} {omega} (char-map {S} {B} m) true-map S {\\n  | pbProj1 => m.f\\n  | pbProj2 => terminalMap {S}\\n}', '| g : Hom {D} y z', '| f : Hom {D} x z', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| pbMap {w : Ob {D}} (p1 : Hom {D} w x) (p2 : Hom {D} w y) (f \u2218 p1 = g \u2218 p2) : Hom {D} w apex', '| x : Ob {D}', '| Ob : \\\\hType', '| z : Ob {D}', '| D : Precat']<<<break>>>\\Pi {w : Ob {D {char-pullback {X} {Y} m}}} ->\n\\Pi {p1 : Hom {D {char-pullback {X} {Y} m}} w (x {char-pullback {X} {Y} m})} ->\n  \\Pi {p2 : Hom {D {char-pullback {X} {Y} m}} w (y {char-pullback {X} {Y} m})} ->\n  \\Pi {c : f {char-pullback {X} {Y} m} \u2218 p1 = g {char-pullback {X} {Y} m} \u2218 p2} ->\n    pbProj2 {char-pullback {X} {Y} m} \u2218 pbMap {char-pullback {X} {Y} m} {w} p1 p2 c = p2", "completion": "pbBeta2 {char-pullback {this} m}"}
{"prompt": "['X : StronglyRegularCoverSpace']<<<break>>>['\\\\class Locale \\\\extends CompleteLattice, BoundedDistributiveLattice, SiteWithBasis \\\\hlevels  {\\n  | Join-ldistr>= {J : \\\\Set} {f : J -> E} {e : E} : e \u2227 Join {J} f <= Join {J} (\\\\lam (j : J) => e \u2227 f j)\\n  | basicCover-stable => \\\\lam {x : Ob} {y : Ob} (x<=y : Hom x y) {J : \\\\Set} {g : J -> Ob} (c : isBasicCover y {J} g) =>\\n    meet-univ {x} {Join {J} (\\\\lam (j : J) => (g j).1)} {x} (<=-refl {x}) (x<=y <=\u2218 c) <=\u2218 Join-ldistr>= {J} {\\\\lam (j : J) => (g j).1} {x}\\n  | ldistr>= => \\\\lam {x : E} {y : E} {z : E} => (\\n    \\\\have t => path (\\\\lam (i : I) (b : Bool) => (\\\\case b \\\\with {\\n            | false => idp {E} {if {E} false (x \u2227 y) (x \u2227 z)}\\n            | true => idp {E} {if {E} true (x \u2227 y) (x \u2227 z)}\\n          }) @ i)\\n    \\\\in transportInv\\n        {Bool -> E} (\\\\lam (x1 : Bool -> E) => x \u2227 Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 y z) <= Join {Bool} x1)\\n          {\\\\lam (b : Bool) => if {E} b (x \u2227 y) (x \u2227 z)} {\\\\lam (b : Bool) => x \u2227 if {E} b y z} t\\n          (Join-ldistr>= {Bool} {\\\\lam (p0 : Bool) => if {E} p0 y z} {x}))\\n  | Meet-cond => \\\\lam {J : \\\\Set} (j : J) {f : J -> E} =>\\n  Join-univ {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n    {f j} (\\\\lam (p0 : \\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)) => p0.2 j)\\n  | join-left => \\\\lam {x : E} {y : E} => Join-cond {Bool} true {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | join-right => \\\\lam {x : E} {y : E} => Join-cond {Bool} false {\\\\lam (p0 : Bool) => if {E} p0 x y}\\n  | Meet-univ => \\\\lam {J : \\\\Set} {f : J -> E} {e : E} (p : \\\\Pi (j : J) -> e <= f j) =>\\n  Join-cond {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= f j)} (e, p)\\n    {\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= f j)) => t.1}\\n  | join-univ => \\\\lam {x y z : E} (x<=z : x <= z) (y<=z : y <= z) =>\\n  Join-univ {Bool} {\\\\lam (p0 : Bool) => if {E} p0 x y} {z} (\\\\lam (p0 : Bool) => (\\\\case p0 \\\\with {\\n    | true => x<=z\\n    | false => y<=z\\n  }))\\n  | join => \\\\lam (x : E) (y : E) => Join {Bool} (\\\\lam (p0 : Bool) => if {E} p0 x y)\\n  | Meet => \\\\lam {J : \\\\Set} (g : J -> E) =>\\n    Join {\\\\Sigma (b : E) (\\\\Pi (j : J) -> b <= g j)} (\\\\lam (t : Total {E} (\\\\lam (p0 : E) => \\\\Pi (j : J) -> p0 <= g j)) => t.1)\\n  | isBasicCover => \\\\lam (x : Ob) {J : \\\\Set} (g : J -> Ob) => x <= Join {J} (\\\\lam (j : J) => (g j).1)\\n}', '\\\\type Subset \\\\alias \\\\infix 4 \u2286 \\\\hlevels  {X : \\\\hType} (U V : Set X) : \\\\Prop => \\\\Pi {x : X} -> U x -> V x', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>Locale (Set (X.E -> \\Prop)) {\n  | <= => (\u2286)\n  | meet => \\lam (U : E {\\this}) (V : E {\\this}) (a : X.E -> \\Prop) => \\Sigma (U a) (V a)\n  | top => \\lam (_ : X.E -> \\Prop) => \\Sigma\n  | Join => \\lam {J : \\Set} (f : J -> E {\\this}) (a : X.E -> \\Prop) => TruncP (\\Sigma (j : J) (f j a))\n}", "completion": "SetLattice _"}
{"prompt": "['X : ExPseudoNormedRing', 'p : X.norm X.ide /= zro']<<<break>>>['\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| norm_ide_<= : norm ide <= fromRat ide', '| ide : E', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '| \\\\infix 4 < E E : \\\\Prop', '\\\\lemma norm_ide<1 \\\\hlevels  {X : ExPseudoNormedRing} (_ : U {X.norm X.ide} ide) : X.norm X.ide = zro ', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '\\\\lemma U_<= \\\\plevels  \\\\hlevels  {this : ExUpperReal} {q r : Rat} (_ : U q) (_ : q <= r) : U r ', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| U Rat : \\\\Prop', \"\\\\func dec<_<= \\\\hlevels  {A : Dec} (a a' : A.E) : Or (a A.< a') (a' <= a) => \\\\case A.trichotomy a a' \\\\with {\\n  | less a<a' => inl {a A.< a'} {a' <= a} a<a'\\n  | equals a=a' => inr {a A.< a'} {a' <= a} (transportInv {A.E} ((<=) a') {a} {a'} a=a' (A.<-irreflexive {a'}))\\n  | greater a'<a => inr {a A.< a'} {a' <= a} (A.<=-less {a'} {a} a'<a)\\n}\", '| E : \\\\Set', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)', \"\\\\type \\\\infix 4 <= \\\\hlevels  {A : StrictPoset} (a a' : A.E) : \\\\Prop => Not (a' A.< a)\"]<<<break>>>X.norm X.ide = fromRat ide", "completion": "<=-antisymmetric norm_ide_<= (\\lam {b} |1|<b => (\\case dec<_<= (1 : Rat) b \\with {\n  | inl r => r\n  | inr b<=1 => absurd $ p $ norm_ide<1 $ U_<= |1|<b b<=1\n}))"}
{"prompt": "['q : Poly (MPoly (Fin n) R)', 'R : CRing', 'n : Nat', 'a : E', 'b : E', 'p : Poly (MPoly (Fin n) R)']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| C : Semiring', \"\\\\func normalize \\\\hlevels  {this : AlgData} (t : RingTerm (E {C}) (Fin (len {vars {mData}}))) :\\n  List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n  => remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) S} (normalize' t)))\", 'suc Nat', \"\\\\data \\\\infix 5 ~ {M : \\\\Set} {R : AddMonoid} (_ _ : Array (\\\\Sigma R.E M)) \\n  | ~-perm (EPerm {\\\\Sigma R.E M} l l')\\n  | ~-sym (l' ~ l)\\n  | ~-zro {m : M} (l = (R.zro, m) :: l')\\n  | ~-+ {l'' : Array (\\\\Sigma R.E M)} (m : M) {a b : R.E} (l = (a R.+ b, m) :: l'') (l' = (a, m) :: (b, m) :: l'')\", '\\\\func permSet-map \\\\hlevels  {A2 B2 : \\\\Set} (_ : A2 -> B2) (_ : PermSet A2) : PermSet B2 \\n  | {A}, {B}, f, in~ l => in~ {Array B} {EPerm {B}} (map {A} {B} f l)\\n  | {A}, {B}, f, ~-equiv x y r i => ~-psequiv {B} {map {A} {B} f x} {map {A} {B} f y} (EPerm_map {A} {B} f {x} {y} r) @ i', '| R : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\func id \\\\hlevels  {R : Ring} : RingHom R R {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new RingHom {\\n  | func-+ => {?hidden}\\n  | func-ide => {?hidden}\\n  | func-* => {?hidden}\\n}', '\\\\instance MonoidRing \\\\hlevels  (M : Monoid) (R : Ring) : Ring (MonoidSet M.E R) {\\n  | zro => in~ {Array (\\\\Sigma R.E M.E)} {(~)} nil\\n  | + => (+)\\n  | * => (*)\\n  | negative => negative {M.E} {R}\\n  | ide => in~ {Array (\\\\Sigma R.E M.E)} {(~)} ((R.ide, M.ide) :: nil)\\n  | natCoef => natCoefImpl {MonoidSemiring M R}\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\type PermSet \\\\hlevels  (A : \\\\Set) : \\\\Set => Quotient {Array A} (EPerm {A})', '\\\\lemma terms-equality \\\\hlevels  {this : AlgData} (t s : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', '\\\\func fzero \\\\plevels  \\\\hlevels  {n : Nat} : Fin (suc n) => 0', '\\\\instance PermSetMonoid \\\\hlevels  (A : \\\\Set) : CMonoid (PermSet A) {\\n  | ide => in~ {Array A} {EPerm {A}} nil\\n  | * => (PermSetMonoid.*)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| E : \\\\Set', '\\\\func inPS \\\\hlevels  {A : \\\\Set} (l : Array A) : PermSet A => in~ {Array A} {EPerm {A}} l', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', 'in~ A', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '\\\\func ret {n3 : Nat} {R3 : CRing} (_ : Poly (MPoly (Fin n3) R3)) : E \\n  | {n}, {R}, pzero => zro\\n  | {n}, {R}, padd p e =>\\n    ret {n} {R} p * mVar {Fin (suc n)} {R} (fzero {n}) + monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R}) e\\n  | {n}, {R}, peq i =>\\n    (zro-right {zro * mVar {Fin (suc n)} {R} (fzero {n})} *> zro_*-left {mVar {Fin (suc n)} {R} (fzero {n})}) @ i', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', \"\\\\func monoidSet-map \\\\hlevels  {M2 N2 : \\\\Set} (_ : M2 -> N2) (g2 : AddMonoidHom) (_ : MonoidSet M2 g.Dom) : MonoidSet N2 g.Cod \\n  | {M}, {N}, f, g, in~ l => inMS~ {N} {g.Cod}\\n    (map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l)\\n  | {M}, {N}, f, g, ~-equiv l l' r i => monoidSet-ext {N} {g.Cod} {inMS~ {N} {g.Cod}\\n    (map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l)}\\n    {inMS~ {N} {g.Cod}\\n      (map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l')}\\n    (~-pequiv {Array (\\\\Sigma (E {g.Cod}) N)} {(~)}\\n      {map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l}\\n      {map {\\\\Sigma (E {g.Dom}) M} {\\\\Sigma (E {g.Cod}) N} (\\\\lam (s : \\\\Sigma (E {g.Dom}) M) => (g.func s.1, f s.2)) l'}\\n      (~_map {M} {N} g f {l} {l'} r)) @ i\", '| vars : Array (E {M})', '\\\\func fsuc \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : Fin (suc n) => suc x', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', '\\\\type MonoidSet \\\\hlevels  (M : \\\\Set) (R : AddMonoid) : \\\\Set => Quotient {Array (\\\\Sigma R.E M)} (~)', '\\\\class RingData \\\\extends BaseRingData \\\\hlevels  {\\n  | C => IntRing\\n  | S => IntRing\\n  | alg-comm => intComm {R}\\n  | alg => intMap {R}\\n}', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new RingData {MonoidRing (PermSetMonoid (Fin (suc n))) R1}\n  (ret {n} {R1} p :: ret {n} {R1} q :: in~ {Array (\\Sigma R.E (PermSet (Fin (suc n))))} {(~)} ((R.ide, inPS {Fin (suc n)} (fzero {n} :: nil)) :: nil) :: monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R1}) a :: monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R1}) b :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} ((var {E} {Fin 5} 0 :+ var {E} {Fin 5} 1) :* var {E} {Fin 5} 2 :+ (var {E} {Fin 5} 3 :+ var {E} {Fin 5} 4)) = interpret {\\new RingData {MonoidRing (PermSetMonoid (Fin (suc n))) R1}\n  (ret {n} {R1} p :: ret {n} {R1} q :: in~ {Array (\\Sigma R.E (PermSet (Fin (suc n))))} {(~)} ((R.ide, inPS {Fin (suc n)} (fzero {n} :: nil)) :: nil) :: monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R1}) a :: monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R1}) b :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}}\n  (var {E} {Fin 5} 0 :* var {E} {Fin 5} 2 :+ var {E} {Fin 5} 3 :+ (var {E} {Fin 5} 1 :* var {E} {Fin 5} 2 :+ var {E} {Fin 5} 4))", "completion": "\n  \\let d => \\new RingData {\n         | R => MonoidRing (PermSetMonoid (Fin (suc n))) R\n         | vars => ret {n} {R} p :: ret {n} {R} q :: in~ {Array (\\Sigma R.E (PermSet (Fin (suc n))))} {(~)} ((R.ide, inPS {Fin (suc n)} (fzero {n} :: nil)) :: nil) :: monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R}) a :: monoidSet-map {PermSet (Fin n)} {PermSet (Fin (suc n))} (permSet-map {Fin n} {Fin (suc n)} (fsuc {n})) (id {R}) b :: nil\n       }\n  \\in terms-equality\n        {d} ((var 0 :+ var 1) :* var 2 :+ (var 3 :+ var 4)) (var 0 :* var 2 :+ var 3 :+ (var 1 :* var 2 :+ var 4)) idp"}
{"prompt": "['p0 : \\\\Sigma (s t u v : E) (a * u = b * v) (s * u + t * v = ide)', 's_t_u_v_p_q : \\\\Sigma (s t u v : E) (a * u = b * v) (s * u + t * v = ide)', 'this : LDiv (p0.2 * a + p0.1 * b) b p0.3 {\\n  | inv-right => {?hidden}\\n}', 'a : E', 'b : E', 'this : StrictBezoutRing']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\data Term \\\\hlevels  \\\\Set Nat \\n  | var (Fin n)\\n  | coef C\\n  | :zro\\n  | :ide\\n  | :negative (Term C n)\\n  | \\\\infixl 6 :+ (_ _ : Term C n)\\n  | \\\\infixl 7 :* (_ _ : Term C n)', '\\\\lemma terms-equality \\\\hlevels  {R : CRing} (env : Array R.E) (t s : Term Int env.len)\\n  (_ : ringInterpretNF {R} env (sortMonomials {env.len} {Int} (normalize {env.len} {IntRing} (t :+ :negative {E} {env.len} s))) = R.zro) :\\n  interpret {R} env t = interpret {R} env s ', 'nil', 'pos Nat', '\\\\func NF \\\\hlevels  (C : \\\\Set) (n : Nat) : \\\\Set => List (\\\\Sigma (List (Fin n)) C)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func interpret \\\\hlevels  {R6 : Ring} (env4 : Array R.E) (_ : Term Int env.len) : R.E \\n  | {R}, env, coef c => intCoef {R} c\\n  | {R}, env, var c => env.at c\\n  | {R}, env, :zro => R.zro\\n  | {R}, env, :ide => R.ide\\n  | {R}, env, :negative t => R.negative (interpret {R} env t)\\n  | {R}, env, t :+ s => interpret {R} env t R.+ interpret {R} env s\\n  | {R}, env, t :* s => interpret {R} env t R.* interpret {R} env s', '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', \"\\\\lemma apply-axioms \\\\hlevels  {R : CRing} (env : Array R.E)\\n  (l : Array (\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)))\\n  (add : NF Int env.len) : ringInterpretNF {R} env (sortMonomials\\n  {env.len} {Int} (Big {List (\\\\Sigma (List (Fin env.len)) Int)} {List (\\\\Sigma (List (Fin env.len)) Int)} (++) add\\n    (map {\\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)}\\n      {List (\\\\Sigma (List (Fin env.len)) Int)}\\n      (\\\\lam (s : \\\\Sigma (NF Int env.len) (t s : Term Int env.len) (interpret {R} env t = interpret {R} env s)) =>\\n        multiply {env.len} {IntRing} s.1 (normalize {env.len} {IntRing} (s.2 :+ :negative {E} {env.len} s.3))) l))) = ringInterpretNF' {R} {env} add \", '| E : \\\\Set', '| M : Monoid', '\\\\infixl 6 :+ (_ _ : Term C n)', ':ide', '\\\\infixl 7 :* (_ _ : Term C n)', '\\\\infixr 5 :: A (List A)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', 'var (Fin n)']<<<break>>>interpret (p0.2 :: a :: p0.1 :: b :: p0.3 :: p0.4 :: nil)\n  ((var {Int} {6} 0 :* var {Int} {6} 1 :+ var {Int} {6} 2 :* var {Int} {6} 3) :* var {Int} {6} 4) = interpret (p0.2 :: a :: p0.1 :: b :: p0.3 :: p0.4 :: nil) (var {Int} {6} 3)", "completion": "\n  \\let env : DArray {6} (\\lam _ => E) => p0.2 :: a :: p0.1 :: b :: p0.3 :: p0.4 :: nil\n  \\in terms-equality env ((var 0 :* var 1 :+ var 2 :* var 3) :* var 4) (var 3) (apply-axioms env\n        (((0 :: nil, 1) :: nil, var 1 :* var 4, var 3 :* var 5, p) :: ((3 :: nil, 1) :: nil, var 2 :* var 4 :+ var 0 :* var 5, :ide, q) :: nil)\n        nil)"}
{"prompt": "['this : Dec', 'x : E', 'p : x /= y', 'y : E']<<<break>>>['| zro : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '\\\\data Empty \\\\plevels  \\\\hlevels  ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\lemma fromZero \\\\hlevels  {this : AddGroup} {x y : E} (_ : x - y = zro) : x = y ']<<<break>>>x - y = zro -> Empty", "completion": "\\lam x-y=0 => p (fromZero {this} x-y=0)"}
{"prompt": "['c : Limit {Precat.op {J}} {Precat.op {I.D}} (Functor.op {Comp {J} {I.C} {I.D} (\\\\new I {}) F})', 'I : ReflectiveSubPrecat', 'J : Precat', 'j : Ob {J {\\\\this}}', \"h : Hom {J {\\\\this}} j j'\", 'F : Functor J I.C', \"j' : Ob {J {\\\\this}}\", \"this : Limit {Precat.op {J1}} {Precat.op {I.C}} (Functor.op {F1}) (I.reflector c.apex) {\\n  | coneMap => \\\\lam (j : Ob {J {\\\\this}}) => inverse {I1} {F.F j} {I.reflector c.apex} (I.reflectorMap c.apex \u2218 c.coneMap j)\\n  | coneCoh => {?hidden}\\n  | isLimit => {?hidden}\\n  | limMap => \\\\lam {z : Ob {Cone.D {\\\\this}}} (c' : Cone {J {\\\\this}} {Cone.D {\\\\this}} (G {\\\\this}) z) => ret {I.isReflective {c.apex} {z}}\\n    (c.limMap {I.F z} (map {Precat.op {I.C}} {Precat.op {I.D}} (FullyFaithfulFunctor.op {I1}) {Precat.op {J1}} {Functor.op {F1}} c'))\\n  | limBeta => {?hidden}\\n  | limUnique => {?hidden}\\n}\"]<<<break>>>['| reflectorMap (X : Ob {D}) : Hom {D} X (F (reflector X))', '| Hom Ob Ob : \\\\Set', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\lemma inverse-right \\\\plevels obj >= hom \\\\hlevels  {this : FullyFaithfulFunctor} {X Y : Ob {C}} {f : Hom {D} (F X) (F Y)} : Func {X} {Y} (inverse {X} {Y} f) = f ', \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', '| F (Ob {C}) : Ob {D}', '\\\\func inverse \\\\plevels obj >= hom \\\\hlevels  {this : FullyFaithfulFunctor} {X Y : Ob {C}} (f : Hom {D} (F X) (F Y)) : Hom {C} X Y => ret {isFullyFaithful {X} {Y}} f', '| Func-o {X Y Z : Ob {C}} {g : Hom {C} Y Z} {f : Hom {C} X Y} : Func {X} {Z} (g \u2218 f) = Func {Y} {Z} g \u2218 Func {X} {Y} f', '| isFaithful {X Y : Ob {C}} {f g : Hom {C} X Y} (Func {X} {Y} f = Func {X} {Y} g) : f = g', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| o-assoc {X Y Z W : Ob} {h : Hom Z W} {g : Hom Y Z} {f : Hom X Y} : h \u2218 g \u2218 f = h \u2218 (g \u2218 f)', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| D : Precat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\class ReflectiveSubPrecat \\\\extends FullyFaithfulFunctor, RightAdjointUnit \\\\plevels obj >= hom \\\\hlevels  {\\n  | reflector (Ob {D}) : Ob {Functor.C}\\n  | reflectorMap (X : Ob {D}) : Hom {D} X (F (reflector X))\\n  \\\\field isReflective {X : Ob {D}} {Y : Ob {Functor.C}} : Equiv {Hom {Functor.C} (reflector X) Y} {Hom {D} X (F Y)} (\\\\lam (p0 : A {\\\\this}) => Func {reflector X} {Y} p0 \u2218 reflectorMap X)\\n  | eta => \\\\new NatTrans {D} {D} (Id {D}) (Comp {D} {Functor.C} {D} (\\\\new this9 {}) LAdj) {\\n    | trans => reflectorMap\\n    | natural => {?hidden}\\n  }\\n  | LAdj => \\\\new Functor D Functor.C reflector {\\n    | Func => \\\\lam {X : Ob {Functor.C {\\\\this}}} {Y : Ob {Functor.C {\\\\this}}} (h : Hom {Functor.C {\\\\this}} X Y) =>\\n      ret {isReflective {X} {reflector Y}} (reflectorMap Y \u2218 h)\\n    | Func-id => {?hidden}\\n    | Func-o => {?hidden}\\n  }\\n  | eta-adjoint => isReflective\\n}', '| reflector (Ob {D}) : Ob {C}', '| C : Precat', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>Func {j} {j'} h \u2218 coneMap {\\this} j = coneMap {\\this} j'", "completion": "isFaithful {I} (rewrite (Func-o {I}) (repeat {2} (rewrite (inverse-right {I})) (rewrite o-assoc (pmap ((\u2218) _) (coneCoh {c} h)))))"}
{"prompt": "['h : Hom {C {\\\\this}} L M']<<<break>>>['\\\\instance locale \\\\hlevels  {this2 : Nucleus} : Locale Subtype {\\n  | <= => \\\\lam (p0 : E {\\\\this}) (p1 : E {\\\\this}) => p0.1 <= p1.1\\n  | meet => \\\\lam (p0 : E {\\\\this}) (p1 : E {\\\\this}) => (p0.1 \u2227 p1.1,\\n    transportInv {E {L}} (\\\\lam (x : E {L}) => x <= p0.1 \u2227 p1.1) {nucleus (p0.1 \u2227 p1.1)} {nucleus p0.1 \u2227 nucleus p1.1}\\n      (nucleus-meet {p0.1} {p1.1}) (meet-monotone {L} {nucleus p0.1} {nucleus p1.1} {p0.1} {p1.1} p0.2 p1.2))\\n  | top => (top {L}, top-univ {L} {nucleus (top {L})})\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) =>\\n    (nucleus (Join {L} {J} (\\\\lam (p0 : J) => (f p0).1)), nucleus-join>= {Join {L} {J} (\\\\lam (p0 : J) => (f p0).1)})\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func wclosed-image \\\\hlevels  {this2 : FrameHom} : Nucleus {Dom} (\\\\lam (x : E {L {\\\\this}}) => Meet {Dom}\\n  {\\\\Sigma (j : Nucleus {Dom}) (\\\\Pi {P : \\\\Prop} -> \\\\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))}\\n  (\\\\lam (j : \\\\Sigma (j : Nucleus {Dom}) (\\\\Pi {P : \\\\Prop} -> \\\\Pi {x : E {Dom}} -> func x <= pHat {Cod} P -> x <= j.nucleus (pHat {Dom} P))) =>\\n    nucleus {j.1} x)) => \\\\new Nucleus {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}', '\\\\class FrameHom \\\\extends SetHom \\\\hlevels  {\\n  | func-<= {x y : E {Dom}} (x <= y) : func x <= func y\\n  | func-top : func (top {Dom}) = top {Cod}\\n  | func-top>= : top {Cod} <= func (top {Dom})\\n  | func-meet {x y : E {Dom}} : func (x \u2227 y) = func x \u2227 func y\\n  | func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)\\n  | func-Join {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) = Join {Cod} {J} (\\\\lam (j : J) => func (f j))\\n  | func-Join>= {J : \\\\Set} {f : J -> E {Dom}} : func (Join {Dom} {J} f) <= Join {Cod} {J} (\\\\lam (j : J) => func (f j))\\n}', '| Cod : BaseSet', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\func wclosed-factor \\\\hlevels  {this2 : FrameHom} : FrameHom (locale {wclosed-image}) Cod {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => func x.1\\n} => \\\\new FrameHom {\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}', '| Dom : BaseSet']<<<break>>>FrameHom (locale {wclosed-image {h}}) h.Cod {\n  | func => \\lam (x : E {Dom {\\this}}) => h.func x.1\n}", "completion": "wclosed-factor {h}"}
{"prompt": "['this : LatticeAbGroup', 'y : E']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| zro-left {x : E} : zro + x = x', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ']<<<break>>>zro + y <= y", "completion": "=_<= (zro-left {this})"}
{"prompt": "[\"r : Not (Index {M.E} x.1 l')\", 'p : MonoidSet M.E R', 'j : Fin (len {map {MonoidSet M.E R} {R.E} (monoidSet-coefs {M.E} {R} {(=) x.1} (M.decideEq x.1))\\n  (map {M.E} {MonoidSet M.E R} (\\\\lam (m : M.E) => msMonomial {M.E} {R} (msCoef {M} {R} p m) m) l)})', 'R : AbMonoid', 'l : Array M.E', 'Rd : DecSet R.E', 'x : E {\\\\this}', 'M : DecSet', \"l' : Array M.E\"]<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma decideEq/=_reduce \\\\hlevels  {A : DecSet} {x y : A.E} (p : x /= y) : A.decideEq x y = no {x = y} p ', '\\\\func Index {A : \\\\Type} (x : A) (l : Array A) : \\\\Type => \\\\Sigma (i : Fin l.len) (l.at i = x)', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', '\\\\func msCoef \\\\hlevels  {M : DecSet} {R : AbMonoid} (p : MonoidSet M.E R) (m : M.E) : R.E => monoidSet-coefs {M.E} {R} {(=) m} (M.decideEq m) p', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '| zro : E', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', 'no (Not E)', '\\\\lemma BigSum_zro \\\\hlevels  {this : AddMonoid} {l : Array E} (_ : \\\\Pi (j : Fin l.len) -> l.at j = zro) : BigSum l = zro ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func element {A1 : \\\\Type} {P1 : A1 -> \\\\Prop} {D1 : \\\\Pi (a : A1) -> Dec (P1 a)} {l1 : Array A1} {j1 : Fin l.len}\\n  (_ : Not (P1 (l.at j1))) : Index {A1} (l.at j1) (remove {A1} {P1} D1 l1) \\n  | {A}, {P}, {D}, {:: {n} a l}, {j}, p => \\\\case j, p \\\\with {\\n    | zero, p => \\\\case D a \\\\with {\\n      | yes e => absurd {\\\\Sigma (i : Fin (len {\\\\case yes {P a} e \\\\with {\\n        | yes p => remove {A} {P} D l\\n        | no n => a :: remove {A} {P} D l\\n      }}))\\n        (at {\\\\case yes {P a} e \\\\with {\\n          | yes p => remove {A} {P} D l\\n          | no n => a :: remove {A} {P} D l\\n        }} i = a)} (p e)\\n      | no q => (0, idp {A} {at {\\\\case no {P a} q \\\\with {\\n        | yes p => remove {A} {P} D l\\n        | no n => a :: remove {A} {P} D l\\n      }} 0})\\n    }\\n    | suc j, p => \\\\case D a \\\\with {\\n      | yes e => element {A} {P} {D} {l} {j} p\\n      | no q => \\n        \\\\let t => element {A} {P} {D} {l} {j} p\\n        \\\\in (suc t.1, t.2)\\n    }\\n  }', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\func keep {A2 : \\\\Type} {P1 : A2 -> \\\\Prop} (_ : \\\\Pi (a : A2) -> Dec (P1 a)) (_ : Array A2) : Array A2 \\n  | {A}, {P}, D, nil => nil\\n  | {A}, {P}, D, :: {n} a l => \\\\case D a \\\\with {\\n    | yes p => a :: keep {A} {P} D l\\n    | no n => keep {A} {P} D l\\n  }']<<<break>>>BigSum {R} (map {\\Sigma R.E M.E} {R.E} (\\lam (p0 : \\Sigma R.E M.E) => p0.1)\n  (keep {\\Sigma R.E M.E} {\\lam (s : \\Sigma R.E M.E) => x.1 = s.2} (\\lam (s : \\Sigma R.E M.E) => M.decideEq x.1 s.2)\n    ((msCoef {M} {R} p (l.at j), l.at j) :: nil))) = zro {R}", "completion": "BigSum_zro (later $ rewrite (decideEq/=_reduce (\\lam p' => r $ rewrite p' $ element $ later $ rewriteI p' x.2)) (\\lam p0 => (\\case p0 \\with {})))"}
{"prompt": "['S : SubLModule R N', 'N : LModule R', 'R : Ring']<<<break>>>['\\\\func in \\\\hlevels  {R1 : Ring} {N : LModule R1} (S : SubLModule R1 N) : LinearMap {R1} (IModule {S}) N {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x.1\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| contains (E {S}) : \\\\Prop']<<<break>>>\\Pi {a a' : \\Sigma (x : N.E) (S.contains x)} -> func {in {R} {N} S} a = func {in {R} {N} S} a' -> a = a'", "completion": "\\lam p => exts p"}
{"prompt": "['x : E', 'this : LatticeAbGroup', 'y : E']<<<break>>>['\\\\lemma negative_<= \\\\hlevels  {this : PosetAddGroup} {x y : E} (_ : x <= y) : negative y <= negative x ', '| \\\\infix 4 <= E E : \\\\Prop', '| negative E : E', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>negative y <= negative (x \u2227 y)", "completion": "negative_<= {this} (meet-right {this})"}
{"prompt": "['y : E', 'x : E', 'this : CompleteLattice']<<<break>>>['true', 'false', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func if {A : \\\\Type} (_ : Bool) (_ _ : A) : A \\n  | {A}, true, then, else => then\\n  | {A}, false, then, else => else', '| E : \\\\Set', '| join \\\\alias \\\\infixl 6 \u2228 E E : E', '| join-right {x y : E} : y <= x \u2228 y', '| join-left {x y : E} : x <= x \u2228 y']<<<break>>>\\Pi (p0 : Bool) -> if {E} p0 x y <= x \u2228 y", "completion": "\\lam p0 => (\\case \\elim p0 \\with {\n  | true => join-left {this}\n  | false => join-right {this}\n})"}
{"prompt": "['x : E', '-x<=1 : negative x <= ide', 'this : OrderedC*Algebra']<<<break>>>['\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| ide : E', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| negative E : E', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\lemma ide_*q \\\\hlevels  {this : QModule} {a : E} : fromInt (pos 1) *q a = a ', 'pos Nat']<<<break>>>negative x <= fromInt (pos 1) *q ide", "completion": "rewrite (ide_*q {this}) -x<=1"}
{"prompt": "['A : BaseSet', 'B : AddMonoid']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func index-left {A1 : \\\\Type} {l1 m1 : Array A1} (_ : Fin l.len) : Fin (len {l1 ++ m1}) \\n  | {A}, {:: {n} a l}, {m}, zero => 0\\n  | {A}, {:: {n} a l}, {m}, suc i => suc (index-left {A} {l} {m} i)', '\\\\class FinSuppFunc \\\\extends SetHom \\\\hlevels  {\\n  | fSupp : TruncP (\\\\Sigma (s : Array (E {Dom})) (\\\\Pi (i : E {Dom}) -> (\\\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))\\n}', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| +-assoc {x y z : E} : x + y + z = x + (y + z)', '\\\\func ++_index-left {A2 : \\\\Type} {l2 m2 : Array A2} (i1 : Fin l.len) : at {l2 ++ m2} (index-left {A2} {l2} {m2} i1) = l.at i1 \\n  | {A}, {:: {n} a l}, {m}, zero => idp {A} {at {(a :: l) ++ m} (index-left {A} {a :: l} {m} 0)}\\n  | {A}, {:: {n} a l}, {m}, suc i => ++_index-left {A} {l} {m} i', 'inP A', '| Cod : BaseSet', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '| at (j : Fin len) : A j', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\class AddMonoid \\\\extends AddPointed \\\\hlevels  {\\n  | \\\\infixl 6 + E E : E\\n  | zro-left {x : E} : zro + x = x\\n  | zro-right {x : E} : x + zro = x\\n  | +-assoc {x y z : E} : x + y + z = x + (y + z)\\n}', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func index-right {A1 : \\\\Type} {l1 m1 : Array A1} (_ : Fin m.len) : Fin (len {l1 ++ m1}) \\n  | {A}, {nil}, {m}, i => i\\n  | {A}, {:: {n} a l}, {m}, i => suc (index-right {A} {l} {m} i)', '| fSupp : TruncP (\\\\Sigma (s : Array (E {Dom})) (\\\\Pi (i : E {Dom}) -> (\\\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))', \"\\\\func pmap2 {A B C : \\\\Type} (f : A -> B -> C) {a a' : A} (p : a = a') {b b' : B} (q : b = b') : f a b = f a' b' \\n  => path (\\\\lam (i : I) => f (p @ i) (q @ i))\", '| zro-right {x : E} : x + zro = x', '\\\\func ++_index-right {A2 : \\\\Type} {l1 m2 : Array A2} {i2 : Fin m.len} : at {l1 ++ m2} (index-right {A2} {l1} {m2} i2) = m.at i2 \\n  | {A}, {nil}, {m}, {i} => idp {A} {at {nil ++ m} (index-right {A} {nil} {m} i)}\\n  | {A}, {:: {n} a l}, {m}, {i} => ++_index-right {A} {l} {m} {i}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| zro-left {x : E} : zro + x = x', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>AddMonoid (FinSuppFunc A B) {\n  | zro => \\new FinSuppFunc A B {\n    | func => \\lam (_ : E {Dom {\\this}}) => B.zro\n    | fSupp => {?hidden}\n  }\n  | + => \\lam (f : E {\\this}) (g : E {\\this}) => \\new FinSuppFunc A B {\n    | func => \\lam (a : E {Dom {\\this}}) => f.func a B.+ g.func a\n    | fSupp => {?hidden}\n  }\n  | zro-left => {?hidden}\n  | zro-right => {?hidden}\n  | +-assoc => {?hidden}\n}", "completion": "\\new AddMonoid {\n  | E => FinSuppFunc A B\n  | AddPointed => FinSuppFuncAddPointed\n  | + => \\lam f g => \\new FinSuppFunc {\n    | func => \\lam a => f a + g a\n    | fSupp => \\scase fSupp {f}, fSupp {g} \\with {\n      | inP (s, c), inP (s', c') =>\n      inP (s ++ s', \\lam a d => pmap2 (+) (c a (\\lam j => rewrite ++_index-left in d (index-left j)))\n        (c' a (\\lam j => rewrite ++_index-right in d (index-right j))) *> zro-left)\n    }\n  }\n  | zro-left => exts (\\lam a => zro-left)\n  | zro-right => exts (\\lam a => zro-right)\n  | +-assoc => exts (\\lam a => +-assoc)\n}"}
{"prompt": "['J : \\\\Set', 'this : CompleteLattice', 'f : I -> J -> E', 'I : \\\\Set']<<<break>>>['| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '| \\\\infix 4 <= E E : \\\\Prop', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z']<<<break>>>\\Pi (p : \\Sigma I J) -> f p.1 p.2 <= Join {I} (\\lam (i : I) => Join {J} (f i))", "completion": "\\lam p => Join-cond {this} p.2 <=\u2218 {this} Join-cond {this} p.1"}
{"prompt": "['l : Array E', 'this : AbGroup']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| at (j : Fin len) : A j', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| negative E : E', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray']<<<break>>>Array E l.len (\\lam (i : Fin l.len) => negative (l.at i))", "completion": "map (negative {this}) l"}
{"prompt": "['b : PFunc {V} {B}']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\instance FinOrder \\\\hlevels  (n : Nat) : LinearOrder.Dec (Fin n) {\\n  | < => (StrictPoset.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (i : E {\\\\this}) (j : E {\\\\this}) => (\\\\case trichotomy i j \\\\with {\\n    | less r => less {i} {j} r\\n    | equals r => equals {i} {j} (fin_nat-inj {n} {i} {j} r)\\n    | greater r => greater {i} {j} r\\n  })\\n} => \\\\new LinearOrder.Dec {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', '\\\\class FinSet \\\\extends KFinSet, Choice, DecSet {\\n  | finEq : TruncP (Equiv {Fin finCard} {E})\\n  | #-comparison => \\\\lam (x : E) (y : E) (z : E) (x/=z : x # z) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => byRight {x # y} {y # z} (\\\\lam (y=z : y = z) => x/=z (x=y *> y=z))\\n    | no x/=y => byLeft {x # y} {y # z} x/=y\\n  })\\n  | #-symmetric => /=-sym {E}\\n  | # => (/=)\\n  | nonEqualApart => \\\\lam {x y : E} (p : x /= y) => p\\n  | tightness => \\\\lam {x : E} {y : E} (x//=y : Not (x # y)) => (\\\\scase decideEq x y \\\\with {\\n    | yes x=y => x=y\\n    | no x/=y => absurd {x = y} (x//=y x/=y)\\n  })\\n  | finSurj => map {Equiv {Fin finCard} {E}} {\\\\Sigma (f : Fin finCard -> E) (IsSurj {Fin finCard} {E} f)} finEq\\n    (\\\\lam (e : Equiv {Fin finCard} {E}) => (e.f, isSurjMap {ESEquiv.fromEquiv e}))\\n  | #-irreflexive => \\\\lam {x : E} (p : x # x) => p (idp {E} {x})\\n  | choice => \\\\lam {B : E -> \\\\Set} => (\\\\scase finEq \\\\with {\\n    | inP e => transport {\\\\Type} (\\\\lam (x : \\\\Type) => \\\\Pi {A : x -> \\\\Set} -> (\\\\Pi (i : x) -> TruncP (A i)) -> TruncP (\\\\Pi (i : x) -> A i))\\n      {Fin finCard} {E} (Equiv-to-= {Fin finCard} {E} e) (finiteAC {finCard}) {B}\\n  })\\n}', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>FinSet (Fin b.len) {\n  | finCard => b.len\n  | decideEq => decideEq\n}", "completion": "FinFin (len {b})"}
{"prompt": "['x : A.E', 'A : StoneC*Algebra', 'w : A.E', 'x<=w : x A.<= w']<<<break>>>['| zro : E', '\\\\func \\\\infixl 6 - \\\\hlevels  {G : AddGroup} (x y : G.E) : G.E => x G.+ G.negative y', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma to>=0 \\\\hlevels  {this : PosetAddGroup} {x y : E} (_ : x <= y) : zro <= y - x ']<<<break>>>A.zro A.<= w - x", "completion": "to>=0 {A} x<=w"}
{"prompt": "['this : AddGroup (FinSuppFunc A B) {\\n  | zro => \\\\new FinSuppFunc A B {\\n    | func => \\\\lam (_ : E {Dom {\\\\this}}) => B.zro\\n    | fSupp => {?hidden}\\n  }\\n  | + => \\\\lam (f : E) (g : E) => \\\\new FinSuppFunc A B {\\n    | func => \\\\lam (a : E {Dom {\\\\this}}) => f.func a B.+ g.func a\\n    | fSupp => {?hidden}\\n  }\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative => \\\\lam (f : E {\\\\this}) => \\\\new FinSuppFunc A B {\\n    | func => \\\\lam (a : E {Dom {\\\\this}}) => B.negative (f.func a)\\n    | fSupp => {?hidden}\\n  }\\n  | negative-left => {?hidden}\\n  | negative-right => {?hidden}\\n}', 'x : E {\\\\this}']<<<break>>>['| len : Nat', '| \\\\infixl 6 + E E : E', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| fSupp : TruncP (\\\\Sigma (s : Array (E {Dom})) (\\\\Pi (i : E {Dom}) -> (\\\\Pi (j : Fin s.len) -> s.at j /= i) -> func i = zro {Cod}))', '| Cod : BaseSet', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '\\\\func Array (A : \\\\Type) : \\\\Type => Array A', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| at (j : Fin len) : A j', '| negative E : E', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>TruncP (\\Sigma (s : Array (E {Dom {negative {\\this} x + x}})) (\\Pi (i : E {Dom {negative {\\this} x + x}}) ->\n  (\\Pi (j : Fin s.len) -> s.at j /= i) -> func {negative {\\this} x + x} i = zro {Cod {negative {\\this} x + x}}))", "completion": "fSupp {\\new FinSuppFunc A B {\n  | func => \\lam (a : A.E) => B.negative (x.func a) B.+ x.func a\n  | fSupp => {?hidden}\n}}"}
{"prompt": "['this : Field Complex {\\n  | zro => \\\\new Complex zro zro\\n  | + => \\\\lam (x y : E {\\\\this}) => \\\\new Complex (x.re + y.re) (x.im + y.im)\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | * => \\\\lam (x y : E) => \\\\new Complex (x.re * y.re - x.im * y.im) (x.re * y.im + x.im * y.re)\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative => \\\\lam (x : E {\\\\this}) => \\\\new Complex (negative x.re) (negative x.im)\\n  | negative-left => {?hidden}\\n  | ide => \\\\new Complex ide zro\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoef => natCoefImpl\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | locality => {?hidden}\\n  | *-comm => {?hidden}\\n  | #0-tight => {?hidden}\\n}', 'x : E {\\\\this}', 'r : Inv {RealField} (x.re + ide)']<<<break>>>['| \\\\infixl 6 + E E : E', 'byLeft A', '| ide : E', '| im : Real', '| re : Real', '\\\\instance ComplexMonoid : CMonoid Complex {\\n  | ide => \\\\new Complex ide zro\\n  | * => \\\\lam (x y : E {\\\\this}) => \\\\new Complex (x.re * y.re - x.im * y.im) (x.re * y.im + x.im * y.re)\\n} => \\\\new CMonoid {\\n  | *-assoc => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | *-comm => {?hidden}\\n}', \"\\\\instance RealField : OrderedFieldAlgebra RatField Real {\\n  | zro => fromRat zro\\n  | + => (RealAbGroup.+)\\n  | negative => negative\\n  | *c => \\\\lam (a : E {LModule.R {\\\\this}}) => (RealField.*) (fromRat a)\\n  | * => (RealField.*)\\n  | ide => ide\\n  | natCoef => \\\\lam (n : Nat) => fromRat (natCoef n)\\n  | coefMap => fromRat\\n  | meet => meet\\n  | join => RealAbGroup.join\\n  | isPos => \\\\lam (x : E) => x.L zro\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xi : #0 {\\\\this} x) => (\\\\case U-inh {x RealField.* xi.inv} \\\\with {\\n    | inP (u, xy<u) => \\\\case (real-lift2-char {rat_real \u2218 *-rat-locally-uniform} {x} {xi.inv} zro u).1\\n      (transport {Real} (\\\\lam (x : Real) => x.L zro) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n        (transportInv {Real} (\\\\lam (x : E {xi.M}) => x.L zro) {x Semigroup.* xi.inv} {ide {\\\\this}} xi.inv-right\\n          (idp {Int} {signum (ratNom (ide - zro))})),\\n        transport {Real} (\\\\lam (x : Real) => x.U u) {x RealField.* xi.inv} {func {*-cover-def} (x, xi.inv)} (\\\\peval x RealField.* xi.inv)\\n          xy<u) \\\\with {\\n        | inP (a', b', c1, d1, c2, d2, a'>0, _x, c1<x, x<d1, c2<y, y<d2, h) => \\n          \\\\have | c1<d1 => LU-less {x} {c1} {d1} c1<x x<d1\\n                | c2<d2 => LU-less {xi.inv} {c2} {d2} c2<y y<d2\\n          \\\\in \\\\case dec<_<= {RatField} c1 zro, dec<_<= {RatField} zro d1 \\\\with {\\n                | inl c1<0, inl d1>0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro}\\n                  (a'>0 <\u2218 transport {Rat} ((StrictPoset.<) a') {zro Semigroup.* ((c2 RatField.+ d2) RatField.* ratio (pos 1) 2)} {zro}\\n                    (zro_*-left {(c2 RatField.+ d2) RatField.* ratio (pos 1) 2})\\n                    (h {zro} {mid c2 d2} (c1<0, d1>0) (mid-between {c2} {d2} c2<d2)).1))\\n                | inl c1<0, inr d1<=0 =>\\n                  byRight {isPos {\\\\this} x} {isNeg {\\\\this} x} ((negative_L {x} {zro}).2 (U_<= {x} {d1} {zro} x<d1 d1<=0))\\n                | inr c1>=0, inl d1>0 => byLeft {isPos {\\\\this} x} {isNeg {\\\\this} x} (L_<= {x} {c1} {zro} c1<x c1>=0)\\n                | inr c1>=0, inr d1<=0 => absurd {isPos {\\\\this} x || isNeg {\\\\this} x} (<-irreflexive {zro} (c1>=0 <\u2218r c1<d1 <\u2218l d1<=0))\\n              }\\n      }\\n  })\\n} => \\\\new OrderedFieldAlgebra {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | *c-comm-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | coefMap_*c => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | <_+-comparison => {?hidden}\\n  | <_+-connectedness => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | coef_< => {?hidden}\\n  | coef_<-inv => {?hidden}\\n  | *-comm => {?hidden}\\n}\", '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\lemma inv-char {x : Complex} : Inv {ComplexMonoid} x <-> Inv {RealField} x.re || Inv {RealField} x.im ']<<<break>>>Inv {ComplexMonoid} (x + ide {\\this})", "completion": "inv-char.2 (byLeft r)"}
{"prompt": "['X : \\\\Set']<<<break>>>['| top : E', '| top-univ {x : E} : x <= top', '| E : \\\\Set', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-antisymmetric {x y : E} (x <= y) (y <= x) : x = y']<<<break>>>top = top \u2227 top", "completion": "<=-antisymmetric (\\lam _ => ((), ())) top-univ"}
{"prompt": "['X : StronglyRegularCoverSpace', 'F : WeaklyCauchyFilter X', 'W : Set (E {F.S})', 'U : Set X.E', 'V : Set X.E', 'FW : F.F W', 'V<=<U : V s<=< U', 'W<=<V : W s<=< V']<<<break>>>['| F (E {A}) : \\\\Prop', '\\\\type \\\\infix 4 s<=< \\\\hlevels  {X : PrecoverSpace} (V U : Set X.E) : \\\\Prop => X.isCauchy (\\\\lam (W : Set X.E) => (W = Compl {X.E} V) || (W = U))', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', 'inP A', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TruncP (\\Sigma (V W : Set X.E) (W s<=< V) (V s<=< U) (F.F W))", "completion": "inP (V, W, W<=<V, V<=<U, FW)"}
{"prompt": "['S : SubRing R', 'R : CRing']<<<break>>>['\\\\class PseudoCRing \\\\extends PseudoRing, PseudoCSemiring \\\\hlevels ', '| \\\\infixl 6 + E E : E', '\\\\func IAddMonoid \\\\hlevels  {this2 : SubAddMonoid} : AddMonoid (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro)\\n  | + => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\\n} => \\\\new AddMonoid {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n}', '| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)', '| contains_negative {x : E {S}} (contains x) : contains (negative {S} x)', '| contains_zro : contains (zro {S})', '\\\\class SubPseudoSemiring \\\\extends SubAddMonoid, SubSemigroup \\\\hlevels ', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func IAddGroup \\\\hlevels  {this2 : SubAddGroup} : AddGroup (\\\\Sigma (x : E {S}) (contains x)) {\\n  | zro => (zro {S}, contains_zro)\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E {\\\\this}) => (negative {S} x.1, contains_negative {x.1} x.2)\\n} => \\\\new AddGroup {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | negative-right => {?hidden}\\n}', '\\\\func ISemigroup \\\\hlevels  {this2 : SubSemigroup} : Semigroup (\\\\Sigma (x : E {S}) (contains x)) {\\n  | * => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (x.1 * y.1, contains_* {x.1} {y.1} x.2 y.2)\\n} => \\\\new Semigroup {\\n  | *-assoc => {?hidden}\\n}', '| contains_+ {x y : E {S}} (contains x) (contains y) : contains (x + y)', '| E : \\\\Set', '| negative E : E', '| S : BaseSet', '\\\\func cStruct \\\\hlevels  {R : PseudoCRing} (S1 : SubPseudoRing R) : PseudoCRing (\\\\Sigma (x : E {S.S}) (S.contains x)) {\\n  | zro => (zro {S.S}, contains_zro {\\\\new S1 {}})\\n  | + => \\\\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\\\new S1 {}} {x.1} {y.1} x.2 y.2)\\n  | * => \\\\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\\n  | negative => \\\\lam (x : E) => (negative {S.S} x.1, contains_negative {\\\\new S1 {}} {x.1} x.2)\\n} => \\\\new PseudoCRing {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n}', '\\\\class SubPseudoRing \\\\extends SubPseudoSemiring, SubAddGroup \\\\hlevels ', '| contains (E {S}) : \\\\Prop']<<<break>>>PseudoCRing (\\Sigma (x : E {S.S}) (S.contains x)) {\n  | zro => (zro {S.S}, contains_zro {\\new S1 {}})\n  | + => \\lam (x : E) (y : E) => (x.1 + y.1, contains_+ {\\new S1 {}} {x.1} {y.1} x.2 y.2)\n  | * => \\lam (x : E) (y : E) => (x.1 * y.1, S.contains_* {x.1} {y.1} x.2 y.2)\n  | negative => \\lam (x : E) => (negative {S.S} x.1, contains_negative {\\new S1 {}} {x.1} x.2)\n}", "completion": "cStruct S"}
{"prompt": "['x : E {Dom {\\\\this}}', 'this : ReflectiveSubPrecat FrameCat FramePresCat FrameUnitalSubcat.F {\\n  | Func => FrameUnitalSubcat.Func\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n  | isFullyFaithful => {?hidden}\\n  | reflector => PresentedFrame\\n  | reflectorMap => FrameReflectiveSubcat.reflectorMap\\n  | isReflective => \\\\lam {X : Ob {D {\\\\this}}} {Y : Ob {C {\\\\this}}} =>\\n  \\\\new QEquiv {Hom {C {\\\\this}} (reflector {\\\\this} X) Y} {Hom {D {\\\\this}} X (Functor.F {\\\\this} Y)}\\n    (\\\\lam (p0 : A {\\\\this}) => Functor.Func {\\\\this} {reflector {\\\\this} X} {Y} p0 \u2218 ReflectiveSubPrecat.reflectorMap {\\\\this} X) {\\n    | ret => adjointMap {X} {Y}\\n    | ret_f => \\\\lam (f1 : A {\\\\this}) => path (\\\\lam (i : I) => (\\n      \\\\have arg => \\\\lam (U : Opens X) => (\\n              \\\\let | g => \\\\lam (q : \\\\Sigma (x : X.E) (U.1 x)) => func {FrameReflectiveSubcat.reflectorMap X} q.1\\n                   | t => path (\\\\lam (i : I) => (\\n                     \\\\have arg => \\\\lam (x : X.E) => propExt {U.1 x}\\n                             {Cover {X} x {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                               (\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2)}\\n                             (\\\\lam (u : U.1 x) =>\\n                             cover-inj {X} {x} {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                               {\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2}\\n                               ((x, u), x, cover-inj {X} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x} () (idp {X.E} {x})) (idp {X.E} {x}))\\n                             (closure<= {X} {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                               {\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2}\\n                               {U}\\n                               (\\\\lam (t : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) =>\\n                               cover-trans {X} {t.2} {\\\\Sigma (x : X.E) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : X.E) (U.1 x)) => t.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => t.1.1} t.3 (\\\\lam (_ : \\\\Sigma) =>\\n                                 cover-inj {X} {t.1.1} {\\\\Sigma (x : X.E) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : X.E) (U.1 x)) => t.1} t.1 (idp {X.E} {t.1.1})))\\n                               {x})\\n                     \\\\in \\n                           \\\\let h1 => path (\\\\lam (i : I) (e : X.E) => arg e @ i)\\n                           \\\\in (\\\\lam (e : X.E) => arg e @ i,\\n                                 prop-dpi (\\\\lam (i : I) => \\\\Pi (x : X.E) -> SCover {X} x (h1 @ i) -> (@) h1 i x) U.2 (Join {\\\\Sigma (x : X.E) (U.1 x)} g).2 @ i)))\\n              \\\\in transportInv {Opens X} (\\\\lam (x : Opens X) =>\\n                    func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} x = f.func x)\\n                    {U} {Join {\\\\Sigma (x : X.E) (U.1 x)} g} t\\n                    (func-Join {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)}\\n                      {\\\\Sigma (x : X.E) (U.1 x)} {g} *> inv {Y.E} {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j))}\\n                      {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                        func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} (g j))}\\n                      (pmap {\\\\Sigma (x : X.E) (U.1 x) -> Y.E} {Y.E} (Y.Join {\\\\Sigma (x : X.E) (U.1 x)})\\n                        {\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j)} {\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                          func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} (g j)}\\n                        (path (\\\\lam (i : I) (_x : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                          (pmap {Opens X} {Y.E} f.func {func {FrameReflectiveSubcat.reflectorMap X} _x.1}\\n                            {Join {\\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)}\\n                              (\\\\lam (q : \\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)) => embed {X} q.1)}\\n                            (element_join {X} {func {FrameReflectiveSubcat.reflectorMap X} _x.1}) *> f.func-Join {\\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)}\\n                            {\\\\lam (j : \\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)) =>\\n                            (\\\\lam (p0 : X.E) => Cover {X} p0 {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1),\\n                              \\\\lam (x : X.E) (c : SCover {X} x (\\\\lam (p0 : X.E) => Cover {X} p0 {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) =>\\n                                cover-trans {X} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))} {\\\\lam (t : \\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) => t.1} c (\\\\lam (p0 : \\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) => p0.2))}) @ i))) *> inv {Y.E} {f.func (Join {\\\\Sigma (x : X.E) (U.1 x)} g)}\\n                      {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j))}\\n                      (f.func-Join {\\\\Sigma (x : X.E) (U.1 x)} {g})))\\n      \\\\in \\n            \\\\let h1 => path (\\\\lam (i : I) (e : Opens X) => arg e @ i)\\n            \\\\in \\\\new FrameHom (reflector {\\\\this} X) Y {\\n                  | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                  | func-<= => {?hidden}\\n                  | func-top => {?hidden}\\n                  | func-top>= => {?hidden}\\n                  | func-meet => {?hidden}\\n                  | func-meet>= => {?hidden}\\n                  | func-Join => {?hidden}\\n                  | func-Join>= => {?hidden}\\n                }))\\n    | f_sec => \\\\lam (f1 : B {\\\\this}) => path (\\\\lam (i : I) => (\\n      \\\\have arg => adjointMap_embed {X} {Y} f1\\n      \\\\in \\n            \\\\let h1 => path (\\\\lam (i : I) (e : X.E) => arg e @ i)\\n            \\\\in \\\\new FramePresHom X (Functor.F {\\\\this} Y) {\\n                  | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                  | func-conj => {?hidden}\\n                  | func-basicCover => {?hidden}\\n                  | func-image => {?hidden}\\n                }))\\n  }\\n}', 'X : Ob {D {\\\\this}}', 'Y : Ob {C {\\\\this}}', 'h1 : func {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f \u2218 reflectorMap X)} = f.func', 'i : I', 'this : QEquiv {Hom {C {\\\\this}} (reflector {\\\\this} X) Y} {Hom {D {\\\\this}} X (Functor.F {\\\\this} Y)}\\n  (\\\\lam (p0 : A {\\\\this}) => Functor.Func {\\\\this} {reflector {\\\\this} X} {Y} p0 \u2218 ReflectiveSubPrecat.reflectorMap {\\\\this} X) {\\n  | ret => adjointMap {X} {Y}\\n  | ret_f => \\\\lam (f1 : A {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => \\\\lam (U : Opens X) => (\\n            \\\\let | g => \\\\lam (q : \\\\Sigma (x : X.E) (U.1 x)) => func {FrameReflectiveSubcat.reflectorMap X} q.1\\n                 | t => path (\\\\lam (i : I) => (\\n                   \\\\have arg => \\\\lam (x : X.E) => propExt {U.1 x}\\n                           {Cover {X} x {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                             (\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2)}\\n                           (\\\\lam (u : U.1 x) =>\\n                           cover-inj {X} {x} {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                             {\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2}\\n                             ((x, u), x, cover-inj {X} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => x} () (idp {X.E} {x})) (idp {X.E} {x}))\\n                           (closure<= {X} {\\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)}\\n                             {\\\\lam (p0 : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) => p0.2}\\n                             {U}\\n                             (\\\\lam (t : \\\\Sigma (j : \\\\Sigma (x : X.E) (U.1 x)) (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} j.1).1 x)) =>\\n                             cover-trans {X} {t.2} {\\\\Sigma (x : X.E) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : X.E) (U.1 x)) => t.1} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => t.1.1} t.3 (\\\\lam (_ : \\\\Sigma) =>\\n                               cover-inj {X} {t.1.1} {\\\\Sigma (x : X.E) (U.1 x)} {\\\\lam (t : \\\\Sigma (x : X.E) (U.1 x)) => t.1} t.1 (idp {X.E} {t.1.1})))\\n                             {x})\\n                   \\\\in \\n                         \\\\let h1 => path (\\\\lam (i : I) (e : X.E) => arg e @ i)\\n                         \\\\in (\\\\lam (e : X.E) => arg e @ i,\\n                               prop-dpi (\\\\lam (i : I) => \\\\Pi (x : X.E) -> SCover {X} x (h1 @ i) -> (@) h1 i x) U.2 (Join {\\\\Sigma (x : X.E) (U.1 x)} g).2 @ i)))\\n            \\\\in transportInv {Opens X} (\\\\lam (x : Opens X) =>\\n                  func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} x = f.func x)\\n                  {U} {Join {\\\\Sigma (x : X.E) (U.1 x)} g} t\\n                  (func-Join {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)}\\n                    {\\\\Sigma (x : X.E) (U.1 x)} {g} *> inv {Y.E} {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j))}\\n                    {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                      func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} (g j))}\\n                    (pmap {\\\\Sigma (x : X.E) (U.1 x) -> Y.E} {Y.E} (Y.Join {\\\\Sigma (x : X.E) (U.1 x)})\\n                      {\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j)} {\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                        func {adjointMap {X} {Y} (FrameUnitalSubcat.Func {PresentedFrame X} {Y} f1 \u2218 FrameReflectiveSubcat.reflectorMap X)} (g j)}\\n                      (path (\\\\lam (i : I) (_x : \\\\Sigma (x : X.E) (U.1 x)) =>\\n                        (pmap {Opens X} {Y.E} f.func {func {FrameReflectiveSubcat.reflectorMap X} _x.1}\\n                          {Join {\\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)}\\n                            (\\\\lam (q : \\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)) => embed {X} q.1)}\\n                          (element_join {X} {func {FrameReflectiveSubcat.reflectorMap X} _x.1}) *> f.func-Join {\\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)}\\n                          {\\\\lam (j : \\\\Sigma (x : X.E) ((func {FrameReflectiveSubcat.reflectorMap X} _x.1).1 x)) =>\\n                          (\\\\lam (p0 : X.E) => Cover {X} p0 {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1),\\n                            \\\\lam (x : X.E) (c : SCover {X} x (\\\\lam (p0 : X.E) => Cover {X} p0 {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) =>\\n                              cover-trans {X} {x} {\\\\Sigma} {\\\\lam (_ : \\\\Sigma) => j.1} {\\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))} {\\\\lam (t : \\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) => t.1} c (\\\\lam (p0 : \\\\Sigma (x : X.E) (Cover {X} x {\\\\Sigma} (\\\\lam (_ : \\\\Sigma) => j.1))) => p0.2))}) @ i))) *> inv {Y.E} {f.func (Join {\\\\Sigma (x : X.E) (U.1 x)} g)}\\n                    {Y.Join {\\\\Sigma (x : X.E) (U.1 x)} (\\\\lam (j : \\\\Sigma (x : X.E) (U.1 x)) => f.func (g j))}\\n                    (f.func-Join {\\\\Sigma (x : X.E) (U.1 x)} {g})))\\n    \\\\in \\n          \\\\let h1 => path (\\\\lam (i : I) (e : Opens X) => arg e @ i)\\n          \\\\in \\\\new FrameHom (reflector {\\\\this} X) Y {\\n                | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                | func-<= => {?hidden}\\n                | func-top => {?hidden}\\n                | func-top>= => {?hidden}\\n                | func-meet => {?hidden}\\n                | func-meet>= => {?hidden}\\n                | func-Join => {?hidden}\\n                | func-Join>= => {?hidden}\\n              }))\\n  | f_sec => \\\\lam (f1 : B {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => adjointMap_embed {X} {Y} f1\\n    \\\\in \\n          \\\\let h1 => path (\\\\lam (i : I) (e : X.E) => arg e @ i)\\n          \\\\in \\\\new FramePresHom X (Functor.F {\\\\this} Y) {\\n                | func => \\\\lam (e : E {Dom {\\\\this}}) => arg e @ i\\n                | func-conj => {?hidden}\\n                | func-basicCover => {?hidden}\\n                | func-image => {?hidden}\\n              }))\\n}', 'f : A {\\\\this}']<<<break>>>['| ret B : A', '| f A : B', \"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", '| reflector (Ob {D}) : Ob {C}', '| func-meet>= {x y : E {Dom}} : func x \u2227 func y <= func (x \u2227 y)', '\\\\type Opens \\\\hlevels  (P : FramePres) : \\\\Set => \\\\Sigma (U : P.E -> \\\\Prop) (\\\\Pi (x : P.E) -> SCover {P} x U -> U x)', '| \\\\infix 4 <= E E : \\\\Prop', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>\\Pi {y : Opens X} -> (@) h1 i x Y.\u2227 (@) h1 i y Y.<= (@) h1 i (x \u2227 y)", "completion": "(@) (prop-dpi (\\lam i => ext_coe) (func-meet>= {adjointMap {X} {Y} (Func {PresentedFrame X} {Y} f \u2218 reflectorMap X)}) (func-meet>= {f}))\n  i {x}"}
{"prompt": "['lr : IsReduced {V} {B} l', 'l : PFunc {V} {B}', 'V : RieszSpace', 'B : BooleanRing', 'bs : Array B.E', 'bsr : IsReducedB {B} bs', 'vsp : inSF {V} {B} l = inSF {V} {B} (mkArray {\\\\Sigma V.E B.E} {bs.len} (\\\\lam (i : Fin bs.len) => (vs.at i, bs.at i)))', 'vs : Array V.E bs.len']<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| A (Fin len) : \\\\Type', '| A : \\\\Set', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '\\\\func inSF \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} (l : Array (\\\\Sigma V.E B.E)) : SFunc V B \\n  => in~ {Array (\\\\Sigma V.E B.E)} {(~)} l', '\\\\type SFunc \\\\hlevels  (V : AddMonoid) (B : BottomDistributiveLattice) : \\\\Set => Quotient {Array (\\\\Sigma V.E B.E)} (~)', '| at (j : Fin len) : A j', '\\\\instance ~_Equivalence \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} : Equivalence (Array (\\\\Sigma V.E B.E)) {\\n  | ~ => (~)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', \"\\\\lemma ~-sfequiv \\\\hlevels  {V : AddMonoid} {B : BottomDistributiveLattice} {l l' : Array (\\\\Sigma V.E B.E)} (_ : l ~ l') :\\n  inSF {V} {B} l = inSF {V} {B} l' \", '| E : \\\\Set', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| \\\\infix 4 ~ A A : \\\\Prop', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray', '\\\\lemma equalityEquiv \\\\hlevels  (E : Equivalence) {x y : E.A} (_ : in~ {E.A} {(E.~)} x = in~ {E.A} {(E.~)} y) : x E.~ y ', \"\\\\lemma apply-left \\\\hlevels  {V : PosetQModule} {B : BooleanRing} {l l' : PFunc {V} {B}} (_ : IsReduced {V} {B} l) (_ : IsReduced {V} {B} l')\\n  (_ : l ~ l') (f : V.E -> V.E) (_ : f V.zro = V.zro) :\\n  map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (f s.1, s.2)) l ~ map {\\\\Sigma V.E B.E} {\\\\Sigma V.E B.E} (\\\\lam (s : \\\\Sigma V.E B.E) => (f s.1, s.2)) l' \", '\\\\lemma abs_zro \\\\hlevels  {this : LatticeAbGroup} : abs zro = zro ', 'in~ A']<<<break>>>inSF {V} {B} (map {\\Sigma V.E (E {B})} {\\Sigma V.E (E {B})} (\\lam (s : \\Sigma V.E (E {B})) => (abs {V} s.1, s.2)) l) = inSF {V} {B} (map {\\Sigma V.E (E {B})} {\\Sigma V.E (E {B})} (\\lam (s : \\Sigma V.E (E {B})) => (abs {V} s.1, s.2))\n  (mkArray {\\Sigma V.E (E {B})} {bs.len} (\\lam (i : Fin bs.len) => (vs.at i, bs.at i))))", "completion": "~-sfequiv (apply-left {_} {_} {_} {mkArray (\\lam i => (vs i, bs i))} lr bsr (equalityEquiv ~_Equivalence (path (\\lam i => vsp i))) (abs {V})\n  (abs_zro {V}))"}
{"prompt": "['X : TopLModule R', 'x : Total {X.E} S', 'a : X.E', 'So : X.isOpen S', 'R : NearSkewField', 'S : Set X.E']<<<break>>>['\\\\lemma limit-id \\\\hlevels  {R : NearSkewField} {X : TopLModule R} {S : Set X.E} {x : Total {X.E} S} {a : X.E} (So : X.isOpen S) :\\nIsLimit {R} {InvDirectedSet {R} {\\\\lam (x1 : R.E) =>\\n  S (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1)}\\n  (aux1 {R} {X} {S} {x} {a} So) (aux2 {R} {X} {S} {x} {a})} (\\\\lam (h : E) => h.4) R.zro ', '| +-cont : ContMap (ProductTopSpace \\\\this \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 + s.2\\n}', '\\\\func tuple \\\\hlevels  {X Y Z : TopSpace} (f : ContMap X Y) (g : ContMap X Z) : ContMap X (Y \u2a2f Z) {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (f.func x, g.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\instance TopSpaceHasProduct \\\\hlevels  : HasProduct TopSpace {\\n  | Product => ProductTopSpace\\n} => \\\\new HasProduct', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func InvDirectedSet \\\\hlevels  {R : NearSkewField} {S : Set R.E} (So : R.isOpen S) (S0 : S R.zro) :\\nDirectedSet (\\\\Sigma (V : Set R.E) (R.isOpen V) (V R.zro) (x : R.E) (V x) ((\u2227) (\\\\lam (h : R.E) => Inv {R} h) S x)) {\\n  | <= => \\\\lam (S : E {\\\\this}) (T : E {\\\\this}) => T.1 \u2286 S.1\\n} => SubPointDirectedSet {R} {(\\\\lam (h : R.E) => Inv {R} h) \u2227 S} R.zro (aux {R} {S} So S0)', '\\\\lemma cont-limit \\\\hlevels  {I : DirectedSet} {X Y : TopSpace} {f : I.E -> X.E} {l : X.E} (_ : IsLimit {X} {I} f l) (g : ContMap X Y) :\\n  IsLimit {Y} {I} (\\\\lam (n : I.E) => g.func (f n)) (g.func l) ', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\lemma aux2 \\\\hlevels  {R : NearSkewField} {X : TopLModule R} {S : Set X.E} {x : Total {X.E} S} {a : X.E} : S (x.1 X.+ R.zro X.*c a) ', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func compose \\\\alias \\\\infixl 8 \u2218 \\\\hlevels  {X Y Z : TopSpace} (g : ContMap Y Z) (f : ContMap X Y) : ContMap X Z {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => g.func (f.func x)\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '| zro : E', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\func id \\\\hlevels  {X : TopSpace} : ContMap X X {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}', '\\\\lemma aux1 \\\\hlevels  {R : NearSkewField} {X : TopLModule R} {S : Set X.E} {x : Total {X.E} S} {a : X.E} (_ : X.isOpen S) :\\nisOpen {Dom {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))}}\\n  (\\\\lam (x1 : E {Dom {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))}}) =>\\n    S (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} x1)) ', '| isOpen (Set E) : \\\\Prop', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| *c-cont : ContMap (ProductTopSpace R \\\\this) \\\\this {\\n  | func => \\\\lam (s : E {Dom {\\\\this}}) => s.1 *c s.2\\n}', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\func const \\\\hlevels  {Y X : TopSpace} (x : X.E) : ContMap Y X {\\n  | func => \\\\lam (_ : E {Dom {\\\\this}}) => x\\n} => \\\\new ContMap {\\n  | func-cont => {?hidden}\\n}']<<<break>>>\\Pi {U : Set X.E} -> X.isOpen U ->\n  U (func {+-cont {X} \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (*c-cont {X} \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} R.zro) ->\n  TruncP (\\Sigma (N : E) (\\Pi {n : E} ->\n    N <= n -> U (func {X.+-cont \u2218 tuple {R} {X} {X} (const {R} {X} x.1) (X.*c-cont \u2218 tuple {R} {R} {X} (id {R}) (const {R} {X} a))} n.4)))", "completion": "cont-limit (limit-id So) (+-cont \u2218 tuple (const x.1) (*c-cont \u2218 tuple id (const a)))"}
{"prompt": "['this : StrictBezoutRing']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| \\\\infixl 7 * E E : E', '| ide-left {x : E} : ide * x = x', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| zro-right {x : E} : x + zro = x', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>ide * ide + zro = ide", "completion": "transport (\\lam x0 => substitution_meta) (inv (path (\\lam (i : I) => ide-left {ide} @ i + zro) *> path ((@) (zro-right {ide}))))\n  idp"}
{"prompt": "['E : Set (Set Y.E)', 'Eu : Y.isUniform E', 'X : CoverSpace', 'Y : UniformSpace', 'f : I.E -> CoverMap X Y', 'I : DirectedSet', 'fc : IsUniFuncConvergent {I} {X.E} {Y} (\\\\lam (n : I.E) => func {f n})']<<<break>>>['| top : E', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '| \\\\infix 4 <= E E : \\\\Prop', 'inP A', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>(\\lam (U : Set X.E) =>\n  TruncP (\\Sigma (N : I.E) (\\Pi {x : X.E} -> U x -> TruncP (\\Sigma (W : Set Y.E) (E1 W) (\\Pi {n : I.E} -> N I.<= n -> W (func {f n} x)))))) top", "completion": "\\case fc Eu \\with {\n  | inP (N, h) => inP $ later (N, \\lam {x} _ => h x)\n}"}
{"prompt": "['j : Inv', 'this : Ring']<<<break>>>['| \\\\infixl 7 * E E : E', '| val : E {M}', '| E : \\\\Set', '| negative E : E', '| inv : E {M}', '\\\\lemma negative_* \\\\hlevels  {this : PseudoRing} {x y : E} : negative x * negative y = x * y ']<<<break>>>negative j.val * negative j.inv = j.val * j.inv", "completion": "negative_* {this}"}
{"prompt": "['l : List A.E', 'x : A.E', 'A : DecSet', 'e : x = a', 'a : A.E', 'p : a /= x']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\func count \\\\hlevels  {A1 : DecSet} (_ : List A.E) (_ : A.E) : Nat \\n  | {A}, nil, a => 0\\n  | {A}, x :: l, a => \\\\case A.decideEq x a \\\\with {\\n    | yes p => suc (count {A} l a)\\n    | no n => count {A} l a\\n  }', 'yes E', '\\\\data Empty \\\\plevels  \\\\hlevels  ', 'suc Nat', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '| E : \\\\Set']<<<break>>>(\\case yes {x = a} e \\with {\n  | yes p => suc (count {A} l a)\n  | no n => count {A} l a\n}) = 0", "completion": "\\case p (inv e) \\with {}"}
{"prompt": "['E : CRing', 'R : CRing', 'f : RingHom R E', 'a : E {S {\\\\this}}']<<<break>>>['| \\\\infixl 6 + E E : E', '| ide-left {x : E} : ide * x = x', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '| ide : E', '| Cod : BaseSet', '| zro-right {x : E} : x + zro = x', '| zro : E', '| \\\\infixl 7 * E E : E', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro-left {x : E} : zro + x = x', '| func-zro : func (zro {Dom}) = zro {Cod}', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| zro_*-left {x : E} : zro * x = zro', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\"]<<<break>>>(E.zro E.* a E.+ E.ide) E.* a E.+ f.func R.zro = a", "completion": "rewrite (func-zro {f}) simplify"}
{"prompt": "['a : E', 'this : OrderedC*Algebra', 'q : Rat']<<<break>>>[\"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| \\\\infix 4 <= E E : \\\\Prop', '\\\\lemma *q-comm-left \\\\hlevels  {this : QPseudoAlgebra} {r : Rat} {a b : E} : r *q (a * b) = r *q a * b ', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '| \\\\infixl 7 * E E : E', '\\\\lemma *q-assoc \\\\hlevels  {this : QModule} {q r : Rat} {a : E} : q * r *q a = q *q (r *q a) ', '\\\\lemma *q-comm-right \\\\hlevels  {this : QPseudoAlgebra} {r : Rat} {a b : E} : r *q (a * b) = a * (r *q b) ', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| finv E : E', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma =_<= \\\\hlevels  {P : Preorder} {x y : P.E} (_ : x = y) : x P.<= y ', '| E : \\\\Set', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\lemma finv_* {this : DiscreteField} {x y : E} : finv (x * y) = finv y * finv x ']<<<break>>>RatField.finv q *q a * (DiscreteField.finv q *q a) <= DiscreteField.finv (q * q) *q (a * a)", "completion": "=_<= (inv (pmap (\\lam _x => _x *q {this} _) (finv_* {RatField}) *> *q-assoc {this} *> pmap ((*q) {this} _) (*q-comm-right {this}) *> *q-comm-left {this}))"}
{"prompt": "['this : OrderedSemiring']<<<break>>>['| zro : E', '| \\\\infixl 6 + E E : E', '| natCoef Nat : E', '| zro-right {x : E} : x + zro = x', '| E : \\\\Set']<<<break>>>natCoef 0 + zro = natCoef 0", "completion": "zro-right {this}"}
{"prompt": "['S : SubMonoid M', 'a : \\\\Sigma (_ y : M.E) (S.contains y)', 'b : \\\\Sigma (_ y : M.E) (S.contains y)']<<<break>>>['| \\\\infixl 7 * E E : E', '| contains_* {x y : E {S}} (contains x) (contains y) : contains (x * y)', '| S : BaseSet', '| contains (E {S}) : \\\\Prop']<<<break>>>S.contains (a.2 * b.2)", "completion": "contains_* {S} a.3 b.3"}
{"prompt": "['a : Array Bool n', 'n : Nat', 'p0 : Fin (length {Array Bool n}\\n  (map {Array Bool n} {Array Bool n} (\\\\lam (b : Array Bool n) => \\\\new Array Bool n (\\\\lam (j : Fin n) => a.at j or b.at j))\\n    (nil {Array Bool n})))']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func length {A1 : \\\\Type} (_ : List A1) : Nat \\n  | {A}, nil => 0\\n  | {A}, a :: l => suc (length {A} l)', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', '\\\\func \\\\infixl 9 !! {A1 : \\\\Type} (l1 : List A1) (_ : Fin (length {A1} l1)) : A1 \\n  | {A}, a :: l, zero => a\\n  | {A}, a :: l, suc i => l !! i', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', '\\\\func NonEmpty \\\\plevels  \\\\hlevels  (l : Array Bool) : \\\\Prop => TruncP (\\\\Sigma (j : Fin l.len) (l.at j = true))', '| at (j : Fin len) : A j', 'nil', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '\\\\func map {A1 B2 : \\\\Type} (_ : A1 -> B2) (_ : List A1) : List B2 \\n  | {A}, {B}, f, nil => nil {B}\\n  | {A}, {B}, f, a :: l => f a :: map {A} {B} f l']<<<break>>>NonEmpty (map {Array Bool n} {Array Bool n} (\\lam (b : Array Bool n) => \\new Array Bool n (\\lam (j : Fin n) => a.at j or b.at j))\n  (nil {Array Bool n}) !! p0)", "completion": "\\case p0 \\with {}"}
{"prompt": "['this : QModule', 'n : Nat', 'a : E']<<<break>>>['\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '\\\\func \\\\infixl 7 *i \\\\hlevels  {this2 : AddGroup} (_ : Int) (_ : E) : E \\n  | {this}, pos n, a => n *n a\\n  | {this}, neg n, a => n *n negative a', '\\\\lemma *q_*i \\\\hlevels  {this : QModule} {x : Int} {a : E} : fromInt x *q a = x *i a ', '| E : \\\\Set', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', 'pos Nat']<<<break>>>fromInt (pos n) *q a = pos n *i a", "completion": "*q_*i {this}"}
{"prompt": "['b : Rat', 'x : Real', 'x<b : x.U b']<<<break>>>['\\\\lemma finv_finv {this : DiscreteField} {x : E} : finv (finv x) = x ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| finv E : E', '| U Rat : \\\\Prop', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\"]<<<break>>>x.U (finv (finv b))", "completion": "transportInv (U {x}) (finv_finv {RatField}) x<b"}
{"prompt": "['e|x : LDiv {M} e x']<<<break>>>['| \\\\infixl 7 * E E : E', '| val : E {M}', '| elem : E {M}', '| E : \\\\Set', '| M : Monoid', '| inv-right : val * inv = elem', '| inv : E {M}']<<<break>>>e|x.val * e|x.inv = e|x.elem", "completion": "inv-right {e|x}"}
{"prompt": "['L : Locale', 'a<=<gj : a <=< g j', 'f : PrecoverMap (LocalePrecoverSpace L) (LocalePrecoverSpace M)', 'a : M.E', 'M : Locale', 'J : \\\\Set', 'g : J -> E {Dom {\\\\this}}']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '\\\\type \\\\infix 4 <=< \\\\hlevels  {this : Locale} (x y : E) : \\\\Prop => top <= neg x \u2228 y', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '| Join {J : \\\\Set} (J -> E) : E', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| \\\\infix 4 <= E E : \\\\Prop', '| func (E {Dom}) : E {Cod}', '| E : \\\\Set', '\\\\func points^* \\\\hlevels  {L : Locale} (a : L.E) : Set (CompleteFilter L) => \\\\lam (x : CompleteFilter L) => x.F a', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)']<<<break>>>points_* {L} (\\lam (a1 : CompleteFilter L) => points^* {M} a (f.func a1)) L.<= L.Join {J}\n  (\\lam (j : J) => L.Join {\\Sigma (b : M.E) (b <=< g j)} (\\lam (s : \\Sigma (b : M.E) (b <=< g j)) => points_* {L} (f.func ^-1 points^* {M} s.1)))", "completion": "Join-cond {L} (later (a, a<=<gj)) {\\lam s => points_* (f ^-1 points^* s.1)} <=\u2218 Join-cond j"}
{"prompt": "['r : Inv {R} (a R.+ R.ide)', 'a : R.E', 'R : CRing']<<<break>>>['\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', '| \\\\infixl 6 + E E : E', '| ide : E', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', 'byRight B']<<<break>>>Inv {R} a || Inv {R} (a R.+ R.ide)", "completion": "byRight r"}
{"prompt": "['p : Poly R', 'c : R.E', 'p/=0 : p /= zro', 'R : Dec', 'c/=0 : c /= R.zro']<<<break>>>['\\\\instance PolyRing \\\\hlevels  (R : Ring) : Ring (Poly R) {\\n  | zro => pzero {R}\\n  | + => (PolyRing.+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", 'padd (Poly R) R.E', '\\\\func \\\\infixl 7 *c \\\\hlevels  {R3 : Ring} (_ : R.E) (_ : Poly R3) : Poly R3 \\n  | {R}, r, pzero => pzero {R}\\n  | {R}, r, padd p e => padd {R} (r *c p) (r R.* e)\\n  | {R}, r, peq i =>\\n    (pmap {R.E} {Poly R} (padd {R} (pzero {R})) {r R.* R.zro} {R.zro} (R.zro_*-right {r}) *> path (peq {R})) @ i', '| zro : E', 'pzero', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\lemma nonZero_* \\\\hlevels  {this : Domain} {x y : E} (_ : x /= zro) (_ : y /= zro) : x * y /= zro ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func * {R3 : Ring} (_ _ : Poly R3) : Poly R3 \\n  | {R}, pzero, q => pzero {R}\\n  | {R}, padd p e, q => padd {R} (p * q) R.zro + e *c q\\n  | {R}, peq i, q =>\\n    (pmap {Poly R} {Poly R} ((+) (padd {R} (pzero {R}) R.zro)) {R.zro *c q} {pzero {R}} (zro_*c {R} {q}) *> path (peq {R})) @ i', '\\\\lemma *c_* \\\\hlevels  {R : Ring} {c : R.E} {p : Poly R} : c *c p = padd {R} (pzero {R}) c * p ', '\\\\instance PolyDomain \\\\hlevels  (R : Domain) : Domain (Poly R) {\\n  | zro => pzero {R}\\n  | + => (+)\\n  | * => (*)\\n  | negative => negative {R}\\n  | ide => padd {R} (pzero {R}) R.ide\\n  | natCoef => \\\\lam (n : Nat) => padd {R} (pzero {R}) (R.natCoef n)\\n  | #0 => PolyRingWith#.#0 {R}\\n} => \\\\new Domain {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | #0-zro => {?hidden}\\n  | #0-+ => {?hidden}\\n  | #0-tight => {?hidden}\\n  | #0-*-left => {?hidden}\\n  | #0-*-right => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zro#ide => {?hidden}\\n  | #0-* => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Poly \\\\hlevels  AddPointed \\n  | pzero\\n  | padd (Poly R) R.E\\n  | peq I', '| E : \\\\Set', '\\\\func lastCoef \\\\hlevels  {R : AddPointed} (p : Poly R) : R.E => polyCoef {R} p 0']<<<break>>>c *c p /= zro", "completion": "transportInv (\\lam _x => _x /= 0) *c_* (nonZero_* {_} {padd pzero c} (\\lam e => c/=0 $ pmap lastCoef e) p/=0)"}
{"prompt": "[\"yfx'<eps/2 : (^-1) func (OBall {Cod} (half eps) y) x'\", 'this : IsometricMap', 'x : E {Dom}', 'eps : Rat', 'y : E {Cod}', 'yfx<eps/2 : OBall {Cod} (half eps) y (func x)', \"x' : E {Dom}\"]<<<break>>>['| func-isometry {x y : E {Dom}} : dist {Cod} (func x) (func y) = dist {Dom} x y', '\\\\lemma halving1/2 \\\\hlevels  {this : ExPseudoMetricSpace} {x y z : E} {c : Rat} (_ : U {dist y x} (c * ratio (pos 1) 2))\\n  (_ : U {dist y z} (c * ratio (pos 1) 2)) : U {dist x z} c ', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '| U Rat : \\\\Prop', '| dist E E : ExUpperReal', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>U {dist {Dom} x x'} eps", "completion": "rewriteI (func-isometry {this}) (halving1/2 yfx<eps/2 yfx'<eps/2)"}
{"prompt": "['R : GradedCRing', 'm0 : Nat', 'n : Nat', \"e0' : R.E\", 'l1 : Nat', 'g1^l1=0 : pow {R} g1.1 l1 = R.zro', 'm1 : Nat', 'k0 : Nat', 'd : R.E', 'g1 : Carrier R', 'g0^l0=0 : pow {R} g0.1 l0 = R.zro', 'l0 : Nat', \"e1' : R.E\", 'k1 : Nat', 'g0 : Carrier R', 'u : Nat', 'a : Carrier R']<<<break>>>['| \\\\infixl 6 + E E : E', 'suc Nat', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma pow_+ \\\\hlevels  {this : Monoid} {a : E} {n m : Nat} : pow a (n + m) = pow a n * pow a m ', '| isHomogen E Nat : \\\\Prop', '| homogen-zro {n : Nat} : isHomogen zro n', '| zro : E', '| \\\\infixl 7 * E E : E', '\\\\func \\\\infixl 7 * \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => 0\\n  | x, suc y => x * y + x', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| zro_*-right {x : E} : x * zro = zro', '| zro-left {x : E} : zro + x = x', '| E : \\\\Set', '| zro_*-left {x : E} : zro * x = zro', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a']<<<break>>>R.isHomogen (d R.* (pow {R} g0.1 (k0 Nat.* n) R.* pow {R} g0.1 l0 R.* pow {R} g0.1 m0 R.* e0' R.+ pow {R} g1.1 (k1 Nat.* n + l1) R.* pow {R} g1.1 m1 R.* e1'))\n  (suc a.2 Semigroup.* (u + n))", "completion": "rewrite pow_+ (rewrite g0^l0=0 (rewrite g1^l1=0 (simplify homogen-zro)))"}
{"prompt": "['a : E {\\\\this}', 'f : AddGroupHom']<<<break>>>['\\\\lemma func-negative \\\\hlevels  {this : AddGroupHom} {x : E {Dom}} : func (negative {Dom} x) = negative {Cod} (func x) ', '| E : \\\\Set', '| Cod : BaseSet', '| func (E {Dom}) : E {Cod}', '| negative E : E', '| Dom : BaseSet']<<<break>>>f.func (negative {f.Dom} a.1) = negative {f.Cod} (f.func a.1)", "completion": "func-negative {f}"}
{"prompt": "[\"d0 : \\\\Pi (j : Fin lu'.len) -> d.at j = R.zro <-> rank {R} {lu'.len} {lv'.len} (toMatrix {R} {U} {V} {lv} lu bv f) <= j\", 'R : SmithDomain', 'bv : IsBasis {V} lv', 'v : E', \"g : \\\\Pi (j : Fin lu'.len) -> f.func (lu.at j) = d.at j V.*c at {fit {V.E} V.zro {lu'.len} lv} j\", 'fu=v : f.func u = v.1', 'f : LinearMap {R} U V', \"lv : Array V.E lv'.len\", 'c : Array (E {U.R}) lu.len', 'U : LModule R', \"lv' : Array V.E\", 's : u = BigSum {U} (\\\\new Array U.E lu.len (\\\\lam (i : Fin lu.len) => c.at i U.*c lu.at i))', 'r : Nat', \"d : Array R.E lu'.len\", \"lic : Fin (rank {R} {lu'.len} {lv'.len} (toMatrix {R} {U} {V} {lv} lu bv f)) -> Image {U.E} {V.E} f.func\", \"lu : Array U.E lu'.len\", 'V : LModule R', \"lu' : Array U.E\", 'u : E {f.Dom}']<<<break>>>[\"\\\\lemma prop-dpi \\\\plevels  \\\\hlevels  (A : I -> \\\\Prop) (a : A left) (a' : A right) : Path A a a' \", \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\func take {A3 : \\\\Type} (n3 : Nat) (l1 : Array A3) (_ : n3 <= l.len) : Array A3 n3 \\n  | {A}, 0, l, p => nil\\n  | {A}, suc n, nil, p => absurd {Array A (suc n)} (p (zero<suc {n}))\\n  | {A}, suc n, :: {n1} a l, p => a :: take {A} n l (conv {n} {n1} p)', '| \\\\infix 4 <= E E : \\\\Prop', '| R : Ring', '\\\\func ImageLModuleRightHom \\\\hlevels  {R1 : Ring} {A B : LModule R1} (f : LinearMap {R1} A B) : LinearMap {R1} (ImageLModule {R1} {A} {B} f) B {\\n  | func => \\\\lam (p0 : E {Dom {ImageAddPointedRightHom f}}) => p0.1\\n} => \\\\new LinearMap {\\n  | func-+ => {?hidden}\\n  | func-*c => {?hidden}\\n}', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '\\\\instance ImageLModule \\\\hlevels  {R1 : Ring} {A B : LModule R1} (f : LinearMap {R1} A B) : LModule R1 (Image {E {f.Dom}} {E {f.Cod}} f.func) {\\n  | zro => (zro {f.Cod}, inP {\\\\Sigma (a : E {f.Dom}) (f.func a = zro {f.Cod})} (zro {f.Dom}, f.func-zro))\\n  | + => \\\\lam (a : E) (b : E) => (a.1 + b.1, \\\\case a.2, b.2 \\\\with {\\n    | inP t, inP s => inP {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1 + b.1)} (t.1 + s.1,\\n      f.func-+ {t.1} {s.1} *> pmap2 {E {f.Cod}} {E {f.Cod}} {E {f.Cod}} ((+) {f.Cod}) {f.func t.1} {a.1} t.2 {f.func s.1} {b.1} s.2)\\n  })\\n  | negative => \\\\lam (a : E) => (negative {f.Cod} a.1,\\n    map {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)} {\\\\Sigma (a1 : E {f.Dom}) (f.func a1 = negative {f.Cod} a.1)} a.2\\n      (\\\\lam (s : \\\\Sigma (a1 : E {f.Dom}) (f.func a1 = a.1)) =>\\n        (negative {f.Dom} s.1, func-negative {f} {s.1} *> pmap {E {f.Cod}} {E {f.Cod}} (negative {f.Cod}) {f.func s.1} {a.1} s.2)))\\n  | *c => \\\\lam (r : E {R {\\\\this}}) (a : E {\\\\this}) =>\\n  (r B.*c a.1, map {\\\\Sigma (a1 : A.E) (f.func a1 = a.1)} {\\\\Sigma (a1 : A.E) (f.func a1 = r B.*c a.1)} a.2\\n    (\\\\lam (s : \\\\Sigma (a1 : A.E) (f.func a1 = a.1)) =>\\n      (r A.*c s.1, f.func-*c {r} {s.1} *> pmap {B.E} {B.E} ((B.*c) r) {f.func s.1} {a.1} s.2)))\\n} => \\\\new LModule {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | *c-assoc => {?hidden}\\n  | *c-ldistr => {?hidden}\\n  | *c-rdistr => {?hidden}\\n  | ide_*c => {?hidden}\\n}', '\\\\func fin-inc_<= \\\\plevels  \\\\hlevels  {n m : Nat} (p : n <= m) (i : Fin n) : Fin m => toFin i {m} {?hidden}', '| at (j : Fin len) : A j', '\\\\lemma divQuotient_dec0 \\\\hlevels  {this : CRing.Dec} (a : DivQuotient this) : Set.Dec (a = in~ {E} {(~)} zro) ', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\func mkArray {A : \\\\Type} {n : Nat} (f : Fin n -> A) : Array A n f => \\\\new DArray', 'in~ A', '| len : Nat', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\func fit {A3 : \\\\Type} (_ : A3) {n2 : Nat} (_ : Array A3) : Array A3 n2 \\n  | {A}, a, {0}, l => nil\\n  | {A}, a, {suc n}, nil => replicate {A} (suc n) a\\n  | {A}, a, {suc n}, :: {n} b l => b :: fit {A} a {n} l', '\\\\func BigSum \\\\hlevels  {this : AddMonoid} (l : Array E) : E => Big {E} {E} (+) zro l', \"\\\\lemma BigSum-subset \\\\hlevels  {this : AddMonoid} {l l' : Array E} (p : l.len <= l'.len)\\n  (_ : \\\\Pi (j : Fin l.len) -> l.at j = l'.at (toFin j {l'.len} {?hidden}))\\n  (_ : \\\\Pi (j : Fin l'.len) -> l.len <= j -> l'.at j = zro) : BigSum l = BigSum l' \", '\\\\lemma *c_zro-left \\\\hlevels  {this : LModule} {a : E} : zro {R} *c a = zro ', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\lemma dec_decide \\\\plevels  \\\\hlevels  {E : \\\\Prop} (_ : Dec E) : Decide E ', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| \\\\infixl 7 *c (E {R}) E : E', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet', '\\\\func find {A2 : \\\\Type} (P2 : A2 -> Decide) (l1 : Array A2) :\\nOr (\\\\Sigma (j : Fin l.len) (E {P2 (l.at j)}) (\\\\Pi {i : Fin l.len} -> i < j -> E {P2 (l.at i)} -> Empty))\\n  (\\\\Pi {j : Fin l.len} -> E {P2 (l.at j)} -> Empty) \\n  | {A}, P, nil => inr {\\\\Sigma (j : Fin 0) (E {P (at {nil} j)}) (\\\\Pi {i : Fin 0} -> i < j -> E {P (at {nil} i)} -> Empty)}\\n    {\\\\Pi {j : Fin 0} -> E {P (at {nil} j)} -> Empty} (\\\\lam {j : Fin 0} => (\\\\case j \\\\with {}))\\n  | {A}, P, :: {n} a l => \\\\case decide {P a} \\\\with {\\n    | yes e => inl {\\\\Sigma (j : Fin (suc l.len)) (E {P (at {a :: l} j)}) (\\\\Pi {i : Fin (suc l.len)} -> i < j -> E {P (at {a :: l} i)} -> Empty)}\\n      {\\\\Pi {j : Fin (suc l.len)} -> E {P (at {a :: l} j)} -> Empty}\\n      (0, e, \\\\lam {i : Fin (suc l.len)} (p0 : i < 0) => (\\\\case p0 \\\\with {}))\\n    | no q => \\\\case find {A} P l \\\\with {\\n      | inl e => inl {\\\\Sigma (j : Fin (suc l.len)) (E {P (at {a :: l} j)}) (\\\\Pi {i : Fin (suc l.len)} -> i < j -> E {P (at {a :: l} i)} -> Empty)}\\n        {\\\\Pi {j : Fin (suc l.len)} -> E {P (at {a :: l} j)} -> Empty}\\n        (suc e.1, e.2, \\\\lam {i : Fin (suc l.len)} => (\\\\case i \\\\with {\\n          | zero => \\\\lam (_ : 0 < suc e.1) => q\\n          | suc i => \\\\lam (p0 : suc i < suc e.1) => (\\\\case p0 \\\\with {\\n            | suc<suc p => e.3 {i} p\\n          })\\n        }))\\n      | inr p => inr {\\\\Sigma (j : Fin (suc l.len)) (E {P (at {a :: l} j)}) (\\\\Pi {i : Fin (suc l.len)} -> i < j -> E {P (at {a :: l} i)} -> Empty)}\\n        {\\\\Pi {j : Fin (suc l.len)} -> E {P (at {a :: l} j)} -> Empty} (\\\\lam {j : Fin (suc l.len)} => (\\\\case j \\\\with {\\n          | zero => q\\n          | suc j => p {j}\\n        }))\\n    }\\n  }', '\\\\data \\\\infixr 2 Or (_ _ : \\\\Type) \\n  | inl A\\n  | inr B', '\\\\func DivPreoder \\\\hlevels  (M : CMonoid) : Preorder M.E {\\n  | <= => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => TruncP (LDiv {M} y x)\\n} => \\\\new Preorder {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n}', '\\\\lemma rank<=rows \\\\hlevels  {R : SmithDomain} {n m : Nat} {A : Matrix R.E n m} : rank {R} {n} {m} A <= n ', 'inP A', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| Cod : BaseSet', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| func-*c {r : E {R}} {x : E {Dom}} : func (r *c x) = r *c func x', '| \\\\infix 4 ~ A A : \\\\Prop', '\\\\func EquivRel \\\\hlevels  {this2 : Preorder} : Equivalence E {\\n  | ~ => \\\\lam (x : A {\\\\this}) (y : A {\\\\this}) => \\\\Sigma (x <= y) (y <= x)\\n} => \\\\new Equivalence {\\n  | ~-transitive => {?hidden}\\n  | ~-reflexive => {?hidden}\\n  | ~-symmetric => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma *c_zro-right \\\\hlevels  {this : LModule} {r : E {R}} : r *c zro = zro ', '\\\\func toFin \\\\plevels  \\\\hlevels  (k1 : Nat) {n1 : Nat} (\\\\property _ : k1 < n1) : Fin n1 \\n  | 0, {suc n}, p => 0\\n  | suc k, {suc n}, p => suc (toFin k {n} {?hidden})', '\\\\func rank \\\\hlevels  {R : SmithDomain} {n m : Nat} (A : Matrix R.E n m) : Nat => firstNonZero {R} (rank-array {R} {n} {m} A).1', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', \"\\\\lemma rank-array {R : SmithDomain} {n m : Nat} (A : Matrix R.E n m) :\\n\\\\level (\\\\Sigma (d : Array (DivQuotient R) (n \u2227 m)) (TruncP (\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n  (\\\\Pi (j : Fin (n \u2227 m)) -> d.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n    | less _x => n\\n    | equals p => n\\n    | greater _x => m\\n  }} {n} (meet-left {n} {m}) j)}\\n    (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n      | less _x => n\\n      | equals p => n\\n      | greater _x => m\\n    }} {m} (meet-right {n} {m}) j)))))) (\\\\lam (p0 : \\\\Sigma (d : Array (DivQuotient R) (n \u2227 m)) (TruncP (\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n  (\\\\Pi (j : Fin (n \u2227 m)) -> d.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n    | less _x => n\\n    | equals p => n\\n    | greater _x => m\\n  }} {n} (meet-left {n} {m}) j)}\\n    (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n      | less _x => n\\n      | equals p => n\\n      | greater _x => m\\n    }} {m} (meet-right {n} {m}) j))))))\\n  (p1 : \\\\Sigma (d : Array (DivQuotient R) (n \u2227 m)) (TruncP (\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n    (\\\\Pi (j : Fin (n \u2227 m)) -> d.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n      | less _x => n\\n      | equals p => n\\n      | greater _x => m\\n    }} {n} (meet-left {n} {m}) j)}\\n      (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n        | less _x => n\\n        | equals p => n\\n        | greater _x => m\\n      }} {m} (meet-right {n} {m}) j)))))) => (\\\\case p0, p1 \\\\with {\\n  | (d, inP (B, A~B, Bs, q)), (d', inP (B', A~B', B's, q')) => path (\\\\lam (i : I) => (\\n    \\\\have arg => path (\\\\lam (i : I) => (\\n            \\\\have arg => \\\\lam (j : Fin (n \u2227 m)) =>\\n                  q j *> ~-pequiv {R.E} {\\\\lam (x : R.E) (y : R.E) => \\\\Sigma (x <= y) (y <= x)} {at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n                    | less _x => n\\n                    | equals p => n\\n                    | greater _x => m\\n                  }} {n} (meet-left {n} {m}) j)}\\n                    (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n                      | less _x => n\\n                      | equals p => n\\n                      | greater _x => m\\n                    }} {m} (meet-right {n} {m}) j)} {at {at {B'} (toFin j {n} {?hidden})} (toFin j {m} {?hidden})} (smith-div-equiv\\n                  {R} {n} {m} {B'} {B} B's Bs (~-transitive {B'} {A} {B} (~-symmetric {A} {B'} A~B') A~B) (toFin j {n} {?hidden})\\n                    (toFin j {m} {?hidden})) *> inv {Quotient {R.E} (~)} {d'.at j} {in~ {R.E} {\\\\lam (x : R.E) (y : R.E) => \\\\Sigma (x <= y) (y <= x)}\\n                    (at {at {B'} (toFin j {n} {?hidden})} (toFin j {m} {?hidden}))} (q' j)\\n            \\\\in \\\\new Array (DivQuotient R) (n \u2227 m) (\\\\lam (j : Fin (n \u2227 m)) => arg j @ i)))\\n    \\\\in (arg @ i, prop-dpi (\\\\lam (i : I) => TruncP (\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n          (\\\\Pi (j : Fin (n \u2227 m)) -> at {arg @ i} j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n            | less _x => n\\n            | equals p => n\\n            | greater _x => m\\n          }} {n} (meet-left {n} {m}) j)}\\n            (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n              | less _x => n\\n              | equals p => n\\n              | greater _x => m\\n            }} {m} (meet-right {n} {m}) j)))))\\n          (inP {\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n            (\\\\Pi (j : Fin (n \u2227 m)) -> d.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n              | less _x => n\\n              | equals p => n\\n              | greater _x => m\\n            }} {n} (meet-left {n} {m}) j)}\\n              (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n                | less _x => n\\n                | equals p => n\\n                | greater _x => m\\n              }} {m} (meet-right {n} {m}) j)))} (B, A~B, Bs, q))\\n          (inP {\\\\Sigma (B : Matrix R.E n m) (A M~ B) (IsSmith {R} {n} {m} B)\\n            (\\\\Pi (j : Fin (n \u2227 m)) -> d'.at j = in~ {R.E} {(~)} (at {at {B} (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n              | less _x => n\\n              | equals p => n\\n              | greater _x => m\\n            }} {n} (meet-left {n} {m}) j)}\\n              (fin-inc_<= {\\\\case trichotomy n m \\\\with {\\n                | less _x => n\\n                | equals p => n\\n                | greater _x => m\\n              }} {m} (meet-right {n} {m}) j)))} (B', A~B', B's, q')) @ i)))\\n})) \", '\\\\type Image {A B : \\\\Type} (f : A -> B) : \\\\Type => \\\\Sigma (b : B) (TruncP (\\\\Sigma (a : A) (f a = b)))', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '| zro : E', '\\\\func toMatrix \\\\hlevels  {R : Ring} {U V : LModule R} {lv : Array V.E} (lu : Array U.E) (bv : IsBasis {V} lv) (f : LinearMap {R} U V) :\\n  Matrix R.E lu.len lv.len \\n  => mkMatrix {R.E} {lu.len} {lv.len} (\\\\lam (i : Fin lu.len) => at {basis-split {V} {lv} bv (f.func (lu.at i))})', '\\\\lemma func-BigSum \\\\hlevels  {this : AddMonoidHom} {l : Array (E {Dom})} :\\n  func (BigSum {Dom} l) = BigSum {Cod} (\\\\new Array (E {Cod}) l.len (\\\\lam (j : Fin l.len) => func (l.at j))) ', '\\\\func take-index {A3 : \\\\Type} {n5 : Nat} {l2 : Array A3} {p3 : n5 <= l.len} {j2 : Fin n5} :\\n  at {take {A3} n5 l2 p3} j2 = l.at (fin-inc_<= {n5} {l.len} p3 j2) \\n  | {A}, {suc n}, {nil}, {p}, {j} =>\\n    absurd {at {take {A} (suc n) nil p} j = at {nil} (fin-inc_<= {suc n} {0} p j)} (p (zero<suc {n}))\\n  | {A}, {suc n}, {:: {n1} a l}, {p}, {zero} => idp {A} {at {take {A} (suc n) (a :: l) p} 0}\\n  | {A}, {suc n}, {:: {n1} a l}, {p}, {suc j} => take-index {A} {n} {l} {conv {n} {n1} p} {j}']<<<break>>>TruncP (\\Sigma (c : Array (E {R}) r) (v = BigSum {ImageLModule {R1} {U} {V} f} (\\new Array E r (\\lam (i : Fin r) => c.at i *c lic i))))", "completion": "inP (mkArray (\\lam j => c (fin-inc_<= rank<=rows j)), ext $ inv fu=v *> pmap f s *> func-BigSum {f} *> inv (BigSum-subset\n  {V} {_} {\\lam j => f (c j *c lu j)} rank<=rows (\\lam j => pmap (\\lam p0 => _ *c f p0) take-index *> inv func-*c)\n    (\\lam j r<=j => func-*c *> pmap ((*c) _) (g j *> pmap (\\lam _x => _x *c _) ((d0 j).2 r<=j) *> *c_zro-left) *> *c_zro-right)) *> inv (func-BigSum {ImageLModuleRightHom f}))"}
{"prompt": "['r : E', 'this : QPseudoAlgebra', 'b : E']<<<break>>>['| \\\\infixl 7 * E E : E', '\\\\lemma *q-comm-right \\\\hlevels  {this : QPseudoAlgebra} {r : Rat} {a b : E} : r *q (a * b) = a * (r *q b) ', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', '| E : \\\\Set']<<<break>>>r *q (b * b) = b * (r *q b)", "completion": "*q-comm-right {this}"}
{"prompt": "['this : TopLModule']<<<break>>>['| ide : E', '| \\\\infixl 7 *c (E {R}) E : E', '| E : \\\\Set', '| negative E : E', '\\\\lemma neg_ide_*c \\\\hlevels  {this : LModule} {a : E} : negative {R} (ide {R}) *c a = negative a ', '| R : Ring']<<<break>>>\\Pi (a : E) -> negative {R} (ide {R}) *c a = negative a", "completion": "\\lam a => neg_ide_*c {this}"}
{"prompt": "['j : Fin (len {p0.1})', 'R : CRing', 'p0 : \\\\Sigma (l : Array R.E) (IsGeneratedBy {I.1} l)', 'c : Countable R.E', 'n : Nat']<<<break>>>['\\\\instance IntRing \\\\hlevels  : OrderedCRing.Dec Int {\\n  | zro => pos 0\\n  | + => (IntRing.+)\\n  | * => (IntRing.*)\\n  | negative => negative\\n  | ide => pos 1\\n  | natCoef => pos\\n  | #0 => AddGroup.Dec.#0\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y}\\n      (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x < y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) => <-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => signum x = pos 1\\n  | #0=>eitherPosOrNeg => #0=>eitherPosOrNeg\\n  | +_trichotomy => \\\\lam (x : E {\\\\this}) => (\\\\case x \\\\with {\\n    | pos 0 => equals {pos 0} {pos 0} (idp {Int} {pos 0})\\n    | pos (suc n) => greater {pos (suc n)} {pos 0} (idp {Int} {signum (pos (suc n) - pos 0)})\\n    | neg (suc n) => less {neg (suc n)} {pos 0} (idp {Int} {signum (pos 0 - neg (suc n))})\\n  })\\n} => \\\\new OrderedCRing.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zro/=ide => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | positive=>#0 => {?hidden}\\n  | negative=>#0 => {?hidden}\\n  | *-comm => {?hidden}\\n}', '| C : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\func maybe {A B : \\\\Type} (_ : B) (_ : A -> B) (_ : Maybe A) : B \\n  | {A}, {B}, b, f, nothing => b\\n  | {A}, {B}, b, f, just a => f a', '\\\\func \\\\infixl 9 !! (a : DArray) (i : Fin a.len) : a.A i ', ':zro', '| E : \\\\Set', '\\\\func interpretRingNF \\\\hlevels  {this3 : BaseData} (_ : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) : E {R} \\n  | {this}, nil => zro {R}\\n  | {this}, x :: nil => func {alg} x.2 * interpretNF {mData} x.1\\n  | {this}, x :: l => func {alg} x.2 * interpretNF {mData} x.1 + interpretRingNF l', '\\\\class CRingData \\\\extends CAlgData, RingData \\\\hlevels ', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\lemma terms-equality \\\\hlevels  {this : CRingData} (t s : RingTerm (E {C}) (Fin (len {vars})))\\n  (_ : interpretRingNF (normalize t) = interpretRingNF (normalize s)) : interpret t = interpret s ', \"\\\\func normalize \\\\hlevels  {this : CRingData} (t : RingTerm (E {C}) (Fin (len {vars}))) : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C})) \\n=> remove0 (collapse (sort {LexicographicalProduct (LexicographicalList (FinOrder (len {vars}))) IntRing}\\n  (map {\\\\Sigma (List (Fin (len {vars}))) Int} {\\\\Sigma (List (Fin (len {vars}))) Int}\\n    (\\\\lam (p : \\\\Sigma (List (Fin (len {vars}))) Int) => (sort {FinOrder (len {vars})} p.1, p.2)) (normalize' t))))\", '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\infixl 7 :* (_ _ : RingTerm C V)', '| vars : Array (E {M})', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\data Int \\\\plevels  \\\\hlevels  \\n  | pos Nat\\n  | neg Nat  {\\n    | 0 => pos 0\\n  }', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new CRingData {R} (p0.1 !! j :: maybe {R.E} {R.E} R.zro (\\lam (a : R.E) => a) (c.1 n) :: nil) {\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 2} 0) = interpret {\\new CRingData {R} (p0.1 !! j :: maybe {R.E} {R.E} R.zro (\\lam (a : R.E) => a) (c.1 n) :: nil) {\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 2} 0 :+ :zro {Int} {Fin 2} :* var {E} {Fin 2} 1)", "completion": "\n  \\let d => \\new CRingData {\n         | R => R\n         | vars => p0.1 !! j :: maybe {R.E} {R.E} R.zro (\\lam (a : R.E) => a) (c.1 n) :: nil\n       }\n  \\in terms-equality {d} (var 0) (var 0 :+ :zro :* var 1) idp"}
{"prompt": "['X : TopLModule R', 'R : NearSkewField']<<<break>>>['\\\\class TopSpace \\\\extends BaseSet \\\\hlevels  {\\n  | isOpen (Set E) : \\\\Prop\\n  | open-top : isOpen top\\n  | open-inter {U V : Set E} (isOpen U) (isOpen V) : isOpen (U \u2227 V)\\n  | open-Union {S : Set (Set E)} (\\\\Pi {U : Set E} -> S U -> isOpen U) : isOpen (Union {E} S)\\n}', '| isOpen (Set E) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\instance ProductTopSpace \\\\hlevels  (X Y : TopSpace) : TopSpace (\\\\Sigma X.E Y.E) {\\n  | isOpen => \\\\lam (W : Set (E {\\\\this})) =>\\n  \\\\Pi {s : E {\\\\this}} -> W s -> TruncP (\\\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set Y.E) (Y.isOpen V) (V s.2)\\n    (\\\\Pi {x : X.E} -> U x -> \\\\Pi {y : Y.E} -> V y -> W (x, y)))\\n} => \\\\new TopSpace {\\n  | open-top => {?hidden}\\n  | open-inter => {?hidden}\\n  | open-Union => {?hidden}\\n}', '| E : \\\\Set', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>TopSpace (\\Sigma X.E E) {\n  | isOpen => \\lam (W : Set (E {\\this})) =>\n  \\Pi {s : E {\\this}} -> W s -> TruncP (\\Sigma (U : Set X.E) (X.isOpen U) (U s.1) (V : Set E) (isOpen V) (V s.2)\n    (\\Pi {x : X.E} -> U x -> \\Pi {y : E} -> V y -> W (x, y)))\n}", "completion": "ProductTopSpace X (ProductTopSpace R X)"}
{"prompt": "['l2 : List A.E', 'a : A.E', 'A : Dec', 'a1 : A.E', 's : Sorted {A} (l1 ++ a1 :: l2)', 'a<=a1 : a <= a1', 'l1 : List A.E']<<<break>>>['\\\\func insert \\\\hlevels  {A2 : Dec} (_ : A.E) (_ : List A.E) : List A.E \\n  | {A}, a, nil => a :: nil {A.E}\\n  | {A}, a, x :: xs => \\\\case dec<_<= {A} x a \\\\with {\\n    | inl x<a => x :: insert {A} a xs\\n    | inr a<=x => a :: x :: xs\\n  }', '\\\\lemma insert_++-left \\\\hlevels  {A : Dec} {a a1 : A.E} (_ : a <= a1) {l1 l2 : List A.E} (_ : Sorted {A} (l1 ++ a1 :: l2)) :\\n  insert {A} a (l1 ++ a1 :: l2) = insert {A} a l1 ++ a1 :: l2 ', '| E : \\\\Set', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : List A1) : List A1 \\n  | {A}, nil, ys => ys\\n  | {A}, a :: xs, ys => a :: xs ++ ys', '\\\\infixr 5 :: A (List A)']<<<break>>>insert {A} a (l1 ++ a1 :: l2) = insert {A} a l1 ++ a1 :: l2", "completion": "insert_++-left a<=a1 s"}
{"prompt": "['null : Nat', 'n : Nat', 'c : Nat']<<<break>>>['\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', 'suc Nat', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', \"\\\\func \\\\infixl 6 -' \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | 0, m => 0\\n  | suc n, 0 => suc n\\n  | suc n, suc m => n -' m\", '\\\\lemma conv \\\\plevels  \\\\hlevels  {x y : Nat} (_ : suc x <= suc y) : x <= y ', '| \\\\infix 4 <= E E : \\\\Prop', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', \"\\\\lemma -'<=id \\\\plevels  \\\\hlevels  {n m : Nat} : n -' m <= n \"]<<<break>>>n -' suc n1 <= c", "completion": "\\case \\elim n, \\elim q \\with {\n  | 0, _ => zero<=_\n  | suc n, q => -'<=id <=\u2218 conv q\n}"}
{"prompt": "['this : Limit {Precat.op {Precategory-of-elements {C1} P}} {Precat.op {PresheafCat C1}}\\n  (Functor.op {Comp {Precategory-of-elements {C1} P} {C1} {PresheafCat C1} (functor {C1}) (projection {C1} {P})}) P {\\n  | coneMap => \\\\lam (p0 : Ob {J {\\\\this}}) =>\\n  \\\\new NatTrans {Precat.op {C1}} {SetCat} (VPresheaf.F {Functor.F {Cone.G {\\\\this}} p0}) (VPresheaf.F {apex {\\\\this}}) {\\n    | trans => \\\\lam (o : Ob {C {\\\\this}}) (h : Functor.F {NatTrans.F {\\\\this}} o) => Func {P.F} {p0.1} {o} h p0.2\\n    | natural => {?hidden}\\n  }\\n  | coneCoh => {?hidden}\\n  | isLimit => {?hidden}\\n  | limMap => \\\\lam {G : Ob {Cone.D {\\\\this}}} (cone : Cone {J {\\\\this}} {Cone.D {\\\\this}} (Cone.G {\\\\this}) G) =>\\n  \\\\new NatTrans {Precat.op {C1}} {SetCat} (VPresheaf.F {apex {\\\\this}}) G.F {\\n    | trans => \\\\lam (X : Ob {C {\\\\this}}) (p : Functor.F {NatTrans.F {\\\\this}} X) => f {yoneda-lemma {C1} X G} (cone.coneMap (X, p))\\n    | natural => {?hidden}\\n  }\\n  | limBeta => {?hidden}\\n  | limUnique => {?hidden}\\n}', 'C : Precat', 'P : Ob']<<<break>>>['\\\\instance Precategory-of-elements \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (P : Ob) : Precat (\\\\Sigma (c : C.Ob) (Functor.F {P.F} c)) {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => \\\\Sigma (u : C.Hom x.1 y.1) (x.2 = Func {P.F} {y.1} {x.1} u y.2)\\n  | id => \\\\lam (p0 : Ob {\\\\this}) => (C.id p0.1, transportInv\\n    {Functor.F {P.F} p0.1 -> Functor.F {P.F} p0.1} (\\\\lam (x : Functor.F {P.F} p0.1 -> Functor.F {P.F} p0.1) => p0.2 = x p0.2)\\n      {Func {P.F} {p0.1} {p0.1} (id p0.1)} {id (Functor.F {P.F} p0.1)} (Func-id {P.F} {p0.1})\\n      (idp {Functor.F {P.F} p0.1} {p0.2}))\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (p0 : Hom {\\\\this} Y Z) (p1 : Hom {\\\\this} X Y) =>\\n  (p0.1 C.\u2218 p1.1, p1.2 *> transportInv {Functor.F {P.F} Y.1}\\n    (\\\\lam (x : Functor.F {P.F} Y.1) => Func {P.F} {Y.1} {X.1} p1.1 x = Func {P.F} {Z.1} {X.1} (p0.1 C.\u2218 p1.1) Z.2) {Y.2}\\n    {Func {P.F} {Z.1} {Y.1} p0.1 Z.2} p0.2 (transportInv {Functor.F {P.F} Z.1 -> Functor.F {P.F} X.1}\\n      (\\\\lam (x : Functor.F {P.F} Z.1 -> Functor.F {P.F} X.1) => Func {P.F} {Y.1} {X.1} p1.1 (Func {P.F} {Z.1} {Y.1} p0.1 Z.2) = x Z.2)\\n      {Func {P.F} {Z.1} {X.1} (p1.1 \u2218 p0.1)} {Func {P.F} {Y.1} {X.1} p1.1 \u2218 Func {P.F} {Z.1} {Y.1} p0.1}\\n      (Func-o {P.F} {Z.1} {Y.1} {X.1} {p1.1} {p0.1})\\n      (idp {Functor.F {P.F} X.1} {Func {P.F} {Y.1} {X.1} p1.1 (Func {P.F} {Z.1} {Y.1} p0.1 Z.2)})))\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| D : Precat', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Functor} : Functor (op {C}) (op {D}) F {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} => Func {Y} {X}\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| G : Functor J D', '\\\\class NatTrans \\\\plevels obj >= hom >= iobj >= ihom \\\\hlevels  {\\n  | C : Precat\\n  | D : Precat\\n  | F : Functor C D\\n  | G : Functor C D\\n  | trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)\\n  | natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X\\n}', '| J : Precat', '| C : Precat', '| F : Functor C D', '\\\\func yoneda-lemma \\\\plevels obj >= hom \\\\hlevels  {C1 : Precat} (A1 : C.Ob) (F : Ob) :\\nQEquiv {Hom (Functor.F A1) F} {Functor.F {F.F} A1} (\\\\lam (nat : A {\\\\this}) => nat.trans A1 (C.id A1)) {\\n  | ret => \\\\lam (p : B {\\\\this}) => \\\\new NatTrans {op {C1}} {SetCat} (VPresheaf.F {Functor.F A1}) F.F {\\n    | trans => \\\\lam (o : Ob {C {\\\\this}}) (f : Functor.F {NatTrans.F {\\\\this}} o) => Func {F.F} {A1} {o} f p\\n    | natural => {?hidden}\\n  }\\n  | ret_f => \\\\lam (nf : A {\\\\this}) => path (\\\\lam (i : I) => (\\n    \\\\have arg => \\\\lam (o : C.Ob) => path (\\\\lam (i : I) (h : C.Hom o A1) => (\\n            \\\\let | nat-nf => nf.natural {A1} {o} h\\n                 | nat-nf-app => path (\\\\lam (i : I) => (@) nat-nf i (C.id A1))\\n            \\\\in inv {Functor.F {F.F} o} {nf.trans o (C.id A1 C.\u2218 h)} {trans {ret {\\\\this} (nf.trans A1 (C.id A1))} o h} nat-nf-app *> transportInv\\n                {C.Hom o A1} (\\\\lam (x : C.Hom o A1) => nf.trans o x = nf.trans o h) {C.id A1 C.\u2218 h} {h} (C.id-left {o} {A1} {h})\\n                  (idp {Functor.F {F.F} o} {nf.trans o h})) @ i)\\n    \\\\in \\n          \\\\let h1 => path (\\\\lam (i : I) (X : C.Ob) => arg X @ i)\\n          \\\\in \\\\new NatTrans {op {C1}} {SetCat} (VPresheaf.F {Functor.F A1}) F.F {\\n                | trans => \\\\lam (X : Ob {C {\\\\this}}) => arg X @ i\\n                | natural => {?hidden}\\n              }))\\n  | f_sec => \\\\lam (b : B {\\\\this}) =>\\n  transportInv {Functor.F {F.F} A1 -> Functor.F {F.F} A1} (\\\\lam (x : Functor.F {F.F} A1 -> Functor.F {F.F} A1) => x b = b)\\n    {Func {F.F} {A1} {A1} (id A1)} {id (Functor.F {F.F} A1)} (Func-id {F.F} {A1})\\n    (idp {Functor.F {F.F} A1} {id (Functor.F {F.F} A1) b})\\n} => \\\\new QEquiv', '\\\\func functor \\\\plevels obj >= hom \\\\hlevels  {C : Precat} : Functor C (PresheafCat C) (hom-presheaf {C}) {\\n  | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) =>\\n  \\\\new NatTrans {op {C}} {SetCat} (VPresheaf.F {Functor.F {\\\\this} X}) (VPresheaf.F {Functor.F {\\\\this} Y}) {\\n    | trans => \\\\lam (o : Ob {NatTrans.C {\\\\this}}) => (C.\u2218) f\\n    | natural => {?hidden}\\n  }\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', '| trans (X : Ob {C}) : Hom {D} (Functor.F {NatTrans.F} X) (Functor.F {G} X)', '\\\\instance PresheafCat \\\\plevels obj >= hom \\\\hlevels  (C : Precat) : Cat (VPresheaf SetCat C) {\\n  | Hom => \\\\lam (x : Ob) (y : Ob) => Hom x.F y.F\\n  | id => \\\\lam (x : Ob) => id x.F\\n  | o => \\\\lam {X Y Z : Ob} => (\u2218)\\n} => VPresheafCat SetCat C', '| natural {X Y : Ob {C}} (f : Hom {C} X Y) : trans Y \u2218 Func {NatTrans.F} {X} {Y} f = Func {G} {X} {Y} f \u2218 trans X', '\\\\func hom-presheaf \\\\plevels obj >= hom \\\\hlevels  {C : Precat} (c : C.Ob) : VPresheaf SetCat C\\n  (\\\\new Functor (op {VPresheaf.C {\\\\this}}) (VPresheaf.D {\\\\this}) (\\\\lam (x : Ob {Functor.C {\\\\this}}) => C.Hom x c) {\\n    | Func => \\\\lam {X Y : Ob {Functor.C {\\\\this}}} (f : Hom {Functor.C {\\\\this}} X Y) (g : F {\\\\this} X) => g C.\u2218 f\\n    | Func-id => {?hidden}\\n    | Func-o => {?hidden}\\n  }) => \\\\new VPresheaf', '| Hom Ob Ob : \\\\Set', '| F : Functor (op {C}) D', '| coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", \"| coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\", '| \\\\infixl 8 o \\\\alias \\\\infixl 8 \u2218 {X Y Z : Ob} (Hom Y Z) (Hom X Y) : Hom X Z', \"\\\\class Cone \\\\plevels obj >= hom \\\\hlevels  {\\n  | J : Precat\\n  | D : Precat\\n  | G : Functor J D\\n  | apex : Ob {D}\\n  | coneMap (j : Ob {J}) : Hom {D} apex (F {G} j)\\n  | coneCoh {j j' : Ob {J}} (h : Hom {J} j j') : Func {G} {j} {j'} h \u2218 coneMap j = coneMap j'\\n}\", '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| F (Ob {C}) : Ob {D}', '| id-right {X Y : Ob} {f : Hom X Y} : f \u2218 id X = f', '| apex : Ob {D}', '| Func {X Y : Ob {C}} (Hom {C} X Y) : Hom {D} (F X) (F Y)', '| id-left {X Y : Ob} {f : Hom X Y} : id Y \u2218 f = f', '| D : Precat', '| id (X : Ob) : Hom X X', '| f A : B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func projection \\\\plevels obj >= hom \\\\hlevels  {C1 : Precat} {P : Ob} : Functor (Precategory-of-elements {C1} P) C1 (\\\\lam (p0 : Ob {C {\\\\this}}) => p0.1) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (p0 : Hom {C {\\\\this}} X Y) => p0.1\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| Ob : \\\\hType', '\\\\func op \\\\plevels obj >= hom \\\\hlevels  {this2 : Precat} : Precat Ob {\\n  | Hom => \\\\lam (x : Ob {\\\\this}) (y : Ob {\\\\this}) => Hom y x\\n  | id => id\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) => f \u2218 g\\n} => \\\\new Precat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n}', '| G : Functor C D', '\\\\func Comp \\\\plevels obj >= hom \\\\hlevels  {C1 D E : Precat} (G : Functor D E) (F1 : Functor C1 D) : Functor C1 E (\\\\lam (X : Ob {C {\\\\this}}) => G.F (F.F X)) {\\n  | Func => \\\\lam {X Y : Ob {C {\\\\this}}} (f : Hom {C {\\\\this}} X Y) => G.Func {F.F X} {F.F Y} (F.Func {X} {Y} f)\\n} => \\\\new Functor {\\n  | Func-id => {?hidden}\\n  | Func-o => {?hidden}\\n}']<<<break>>>\\Pi {G : Ob {Cone.D {\\this}}} -> \\Pi (cone : Cone {J {\\this}} {Cone.D {\\this}} (Cone.G {\\this}) G) ->\n  NatTrans {Precat.op {C1}} {SetCat} (VPresheaf.F {apex {\\this}}) G.F {\n    | trans => \\lam (X : Ob {C {\\this}}) (p : Functor.F {NatTrans.F {\\this}} X) => f {yoneda-lemma {C1} X G} (cone.coneMap (X, p))\n    | natural => {?hidden}\n  }", "completion": "\\lam {G} cone => \\new NatTrans {\n  | trans => \\lam X p => f {yoneda-lemma _ G} (coneMap {cone} (X, p))\n  | natural => \\lam {X} {Y} f => exts (\\lam g => (\n    \\let | ch => coneCoh {cone} {(X, g)} {(Y, Func {P} f g)} (f, idp)\n         | nat => natural {coneMap {cone} (X, g)} f\n         | nat-applied => path (\\lam i => nat i (id X))\n    \\in repeat {3} unfold\n          (rewriteI ch (repeat {3} unfold (rewrite id-right (unfold (unfold (rewriteI nat-applied (unfold (rewrite id-left idp))))))))))\n}"}
{"prompt": "['this : AbMonoid', 'e : Equiv {Fin A.finCard} {A.E}', 'A : FinSet', 'x : A.E -> E']<<<break>>>['\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| f A : B', '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', '| E : \\\\Set', '| finCard : Nat']<<<break>>>Array E A.finCard (\\lam (j : Fin A.finCard) => x (e.f j))", "completion": "\\lam j => x (e j)"}
{"prompt": "['R : GradedCRing', 'n : Nat', 'd : R.E', 'u : Nat', 'a : Carrier R']<<<break>>>['| \\\\infixl 6 + E E : E', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma pow_+ \\\\hlevels  {this : Monoid} {a : E} {n m : Nat} : pow a (n + m) = pow a n * pow a m ', '\\\\func powers \\\\hlevels  {M : Monoid} (a : M.E) : SubMonoid M (\\\\lam (x : E {S {\\\\this}}) => TruncP (\\\\Sigma (n : Nat) (pow {M} a n = x))) \\n=> \\\\new SubMonoid {\\n  | contains_ide => {?hidden}\\n  | contains_* => {?hidden}\\n}', 'inP A', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\data Quotient {A : \\\\Type} (A -> A -> \\\\Type) : \\\\Set \\n  | in~ A\\n  | ~-equiv (x y : A) (R x y) I', '| \\\\infixl 7 * E E : E', '\\\\func ~-pequiv {A : \\\\Type} {R : A -> A -> \\\\Type} {x y : A} (r : R x y) : in~ {A} {R} x = in~ {A} {R} y => path (~-equiv {A} {R} x y r)', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '| E : \\\\Set', '| *-assoc {x y z : E} : x * y * z = x * (y * z)', '| contains (E {S}) : \\\\Prop', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\func pow \\\\hlevels  {this2 : Monoid} (_ : E) (_ : Nat) : E \\n  | {this}, a, 0 => ide\\n  | {this}, a, suc n => pow a n * a', 'in~ A']<<<break>>>in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (d, pow {R} a.1 n, inP {\\Sigma (n1 : Nat) (pow {R} a.1 n1 = pow {R} a.1 n)} (n, idp {R.E} {pow {R} a.1 n})) = in~ {\\Sigma (_ y : R.E) (contains y)}\n  {\\lam (x : \\Sigma (_ y : R.E) (contains y)) (y : \\Sigma (_ y : R.E) (contains y)) => x.1 R.* y.2 = y.1 R.* x.2}\n  (d R.* pow {R} a.1 u, pow {R} a.1 (u + n),\n    inP {\\Sigma (n1 : Nat) (pow {R} a.1 n1 = pow {R} a.1 (u + n))} (u + n, idp {R.E} {pow {R} a.1 (u + n)}))", "completion": "~-pequiv (pmap ((*) d) pow_+ *> inv *-assoc)"}
{"prompt": "['this : GradedCRing', 'a : E', 'n : Nat', 'l : Array E (suc n + suc m) (\\\\lam (j : Fin (suc n + suc m)) => (\\\\case decideEq n j, decideEq m j \\\\with {\\n  | yes p, d => a\\n  | no n, yes p => negative a\\n  | no n, no n => zro\\n}))', 'm : Nat']<<<break>>>['\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', 'suc Nat', '\\\\lemma fin_< \\\\plevels  \\\\hlevels  {n : Nat} (x : Fin n) : x < n ', '\\\\lemma char_nat \\\\plevels  \\\\hlevels  {n : Nat} (i : Nat) : fin-inc {suc i} {n} (fromNat {i} i) = i ', 'no (Not E)', '\\\\lemma zero<=_ \\\\plevels  \\\\hlevels  {x : Nat} : 0 <= x ', '| E : \\\\Set', '| negative E : E', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func toFin \\\\plevels  \\\\hlevels  (k1 : Nat) {n1 : Nat} (\\\\property _ : k1 < n1) : Fin n1 \\n  | 0, {suc n}, p => 0\\n  | suc k, {suc n}, p => suc (toFin k {n} {?hidden})', '| <=-refl {x : E} : x <= x', '\\\\lemma decideEq/=_reduce \\\\hlevels  {A : DecSet} {x y : A.E} (p : x /= y) : A.decideEq x y = no {x = y} p ', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\func fromNat \\\\plevels  \\\\hlevels  {m : Nat} (n : Nat) : Fin (suc m) => n mod suc m', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '| <-transitive-left \\\\alias \\\\infixl 8 <\u2218l {a1 a2 a3 : E} (a1 < a2) (a2 <= a3) : a1 < a3', '\\\\func Not (A : \\\\Type) : \\\\Prop => A -> Empty', '\\\\data \\\\infix 4 < \\\\plevels  \\\\hlevels  (_ _ : Nat) \\\\with\\n  | 0, suc n => zero<suc\\n  | suc n, suc m => suc<suc (n < m)', '\\\\func \\\\infixl 6 + \\\\plevels  \\\\hlevels  (_ _ : Nat) : Nat \\n  | x, 0 => x\\n  | x, suc y => suc (x + y)', '\\\\lemma fin_nat-inj \\\\plevels  \\\\hlevels  {n : Nat} {x y : Fin n} (_ : x = y) : x = y ', '| zro : E', \"\\\\func \\\\infix 1 /= {A : \\\\Type} (a a' : A) : \\\\Prop => Not (a = a')\", '\\\\func fin-inc-right \\\\plevels  \\\\hlevels  {n m : Nat} (i : Fin m) : Fin (n AddMonoid.+ m) \\n  => fin-inc_<= {m} {n Nat.+ m} (<=_+ {0} {n} {m} {m} (zero<=_ {n}) (<=-refl {m})) i', '\\\\func divMod \\\\plevels  \\\\hlevels  (_ _ : Nat) : \\\\Sigma Nat Nat ', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', \"\\\\func inv {A1 : \\\\Type} {a1 a' : A1} (_ : a1 = a') : a' = a1 \\n  | {A}, {a}, {a'}, idp => idp {A} {a}\", '\\\\lemma char_nat \\\\plevels  \\\\hlevels  {n : Nat} (i : Nat) : fin-inc-right {n} {suc i} (fromNat {i} i) = i ', '\\\\field decideEq (x y : E) : Dec (x = y)', '\\\\func fin-inc \\\\plevels  \\\\hlevels  {n1 m1 : Nat} (_ : Fin n1) : Fin (n1 + m1) \\n  | {suc n}, {m}, zero => 0\\n  | {suc n}, {m}, suc i => suc (fin-inc {n} {m} i)', '| <=_+ {a b c d : E} (a <= b) (c <= d) : a + c <= b + d']<<<break>>>\\Pi (k : Fin l.len) -> k /= fin-inc {suc n} {suc m} (fromNat {n} n) ->\n  k /= fin-inc-right {suc n} {suc m} (fromNat {m} m) -> (\\case decideEq n k, decideEq m k \\with {\n    | yes p, d => a\n    | no n, yes p => negative a\n    | no n, no n => zro\n  }) = zro", "completion": "\\lam k p1 p2 => rewrite (decideEq/=_reduce (\\lam p => p1 $ fin_nat-inj $ inv $ char_nat {suc m} n *> p),\n  decideEq/=_reduce (\\lam p => p2 $ fin_nat-inj $ inv $ char_nat {suc n} m *> p)) idp"}
{"prompt": "['fd : IsDenseTopEmbedding {f}', 'f : ContMap X Y', \"g : ContMap X' Y'\", 'gd : IsDenseTopEmbedding {g}']<<<break>>>[\"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| isOpen (Set E) : \\\\Prop', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '| Cod : BaseSet', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', \"\\\\lemma isEmbedding \\\\hlevels  {X X' Y Y' : TopSpace} {f : ContMap X Y} {g : ContMap X' Y'} (_ : IsTopEmbedding {f}) (_ : IsTopEmbedding {g}) :\\n  IsTopEmbedding {prod {X} {X'} {Y} {Y'} f g} \", '| Dom : BaseSet', \"\\\\func prod \\\\hlevels  {X X' Y Y' : TopSpace} (f : ContMap X Y) (f' : ContMap X' Y') : ContMap (X \u2a2f X') (Y \u2a2f Y') {\\n  | func => \\\\lam (x : E {Dom {\\\\this}}) => (func {f \u2218 proj1 {X} {X'}} x, func {f' \u2218 proj2 {X} {X'}} x)\\n} => tuple {X \u2a2f X'} {Y} {Y'} (f \u2218 proj1 {X} {X'}) (f' \u2218 proj2 {X} {X'})\", '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I']<<<break>>>\\Pi {U : Set (E {Dom {prod {f.Dom} {g.Dom} {f.Cod} {g.Cod} f g}})} ->\n  isOpen {Dom {prod {f.Dom} {g.Dom} {f.Cod} {g.Cod} f g}} U ->\n  TruncP (\\Sigma (V : Set (E {Cod {prod {f.Dom} {g.Dom} {f.Cod} {g.Cod} f g}}))\n    (isOpen {Cod {prod {f.Dom} {g.Dom} {f.Cod} {g.Cod} f g}} V) (U = func {prod {f.Dom} {g.Dom} {f.Cod} {g.Cod} f g} ^-1 V))", "completion": "isEmbedding fd.2 gd.2"}
{"prompt": "[\"k : Fin l'.len\", \"l' : PFunc {V} {B}\", \"j : Fin l'.len\"]<<<break>>>['| len : Nat', '\\\\data Dec \\\\plevels  \\\\hlevels  \\\\Prop \\n  | yes E\\n  | no (Not E)', '\\\\instance FinFin (n : Nat) : FinSet (Fin n) {\\n  | finCard => n\\n  | decideEq => decideEq\\n} => \\\\new FinSet {\\n  | finEq => {?hidden}\\n}', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| E : \\\\Set', '\\\\field decideEq (x y : E) : Dec (x = y)']<<<break>>>Dec (j = k)", "completion": "decideEq j k"}
{"prompt": "['L : Locale', 'b_p : \\\\Sigma (b : M.E) (b <=< M.Join {J} g)', 'f : PrecoverMap (LocalePrecoverSpace L) (LocalePrecoverSpace M)', 'M : Locale', 'J : \\\\Set', 'g : J -> E {Dom {\\\\this}}', 'Ld : HasDensePoints L', 'p0 : \\\\Sigma (b : M.E) (b <=< M.Join {J} g)', 'this : FrameHom M L {\\n  | func => \\\\lam (a : E {Dom {\\\\this}}) =>\\n    L.Join {\\\\Sigma (b : M.E) (b <=< a)} (\\\\lam (s : \\\\Sigma (b : M.E) (b <=< a)) => points_* {L} (f.func ^-1 points^* {M} s.1))\\n  | func-<= => {?hidden}\\n  | func-top => {?hidden}\\n  | func-top>= => {?hidden}\\n  | func-meet => {?hidden}\\n  | func-meet>= => {?hidden}\\n  | func-Join => {?hidden}\\n  | func-Join>= => {?hidden}\\n}']<<<break>>>['\\\\class CompleteFilter \\\\extends Filter \\\\hlevels  {\\n  | filter-Join {J : \\\\Set} {f : J -> E {A}} (F (Join {A} {J} f)) : TruncP (\\\\Sigma (j : J) (F (f j)))\\n}', '| Join-cond {J : \\\\Set} (j : J) {f : J -> E} : f j <= Join {J} f', '\\\\lemma points_*_meet>= \\\\hlevels  {L : Locale} {U V : Set (CompleteFilter L)} : points_* {L} U L.\u2227 points_* {L} V L.<= points_* {L} (U \u2227 V) ', '| \\\\infix 4 <= E E : \\\\Prop', '\\\\func neg \\\\hlevels  {this : Locale} (x : E) : E => x --> bottom', '\\\\type \\\\infix 4 <=< \\\\hlevels  {this : Locale} (x y : E) : \\\\Prop => top <= neg x \u2228 y', '\\\\data Empty \\\\plevels  \\\\hlevels  ', '| bottom : E', '| filter-meet {a b : E {A}} (F a) (F b) : F (a \u2227 b)', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '\\\\instance SetLattice \\\\hlevels  (A : \\\\hType) : Locale (Set A) {\\n  | <= => (\u2286)\\n  | meet => \\\\lam (U : E {\\\\this}) (V : E {\\\\this}) (a : A) => \\\\Sigma (U a) (V a)\\n  | top => \\\\lam (_ : A) => \\\\Sigma\\n  | Join => \\\\lam {J : \\\\Set} (f : J -> E {\\\\this}) (a : A) => TruncP (\\\\Sigma (j : J) (f j a))\\n} => \\\\new Locale {\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | top-univ => {?hidden}\\n  | Join-cond => {?hidden}\\n  | Join-univ => {?hidden}\\n  | Join-ldistr>= => {?hidden}\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '\\\\lemma isProper \\\\hlevels  {this : CompleteFilter} (_ : F (bottom {A})) : Empty ', '\\\\lemma points_*-mono \\\\hlevels  {L : Locale} {U V : Set (CompleteFilter L)} (_ : U \u2286 V) : points_* {L} U L.<= points_* {L} V ', '| filter-mono {a b : E {A}} (F a) (a <= b) : F b', '| Join {J : \\\\Set} (J -> E) : E', '| Join-univ {J : \\\\Set} {f : J -> E} {e : E} (\\\\Pi (j : J) -> f j <= e) : Join {J} f <= e', '\\\\func Set \\\\hlevels  (X : \\\\hType) : \\\\Set => X -> \\\\Prop', '\\\\func \\\\infix 8 ^-1 \\\\hlevels  {X Y : \\\\hType} (f : X -> Y) (S : Set Y) : Set X => \\\\lam (a : X) => S (f a)', '\\\\lemma eval \\\\hlevels  {this : Locale} {x y : E} : (x --> y) \u2227 x <= y ', '\\\\func points^* \\\\hlevels  {L : Locale} (a : L.E) : Set (CompleteFilter L) => \\\\lam (x : CompleteFilter L) => x.F a', '\\\\data TruncP \\\\Type \\n  | inP A\\n  | truncP (_ _ : TruncP A) I', '\\\\func absurd {A : \\\\Type} (_ : Empty) : A ', '\\\\data \\\\infixr 2 || (_ _ : \\\\Type) : \\\\Prop \\n  | byLeft A\\n  | byRight B', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '| func (E {Dom}) : E {Cod}', '\\\\func points_* \\\\hlevels  {L : Locale} (U : Set (CompleteFilter L)) : L.E => SJoin {L} (\\\\lam (a : L.E) => points^* {L} a \u2286 U)', '| bottom-univ {x : E} : bottom <= x', '| meet-right {x y : E} : x \u2227 y <= y']<<<break>>>L.Join {\\Sigma (s : Set (CompleteFilter L)) (TruncP (\\Sigma (V : Set (CompleteFilter M))\n  (TruncP (\\Sigma (a : M.E) ((a = neg {M} b) || (\\Sigma (j : J) (a <=< g j))) (points^* {M} a = V))) (s = f.func ^-1 V)))}\n  (\\lam (j : \\Sigma (s : Set (CompleteFilter L)) (TruncP (\\Sigma (V : Set (CompleteFilter M))\n    (TruncP (\\Sigma (a : M.E) ((a = neg {M} b) || (\\Sigma (j : J) (a <=< g j))) (points^* {M} a = V))) (s = f.func ^-1 V)))) =>\n    points_* {L} (f.func ^-1 points^* {M} b) L.\u2227 points_* {L} j.1) L.<= L.Join {J} (\\lam (j : J) => func {\\this} (g j))", "completion": "Join-univ (\\lam p0 => (\\case \\elim p0 \\with {\n  | (_, inP (_, inP (_, byLeft idp, idp), idp)) => points_*_meet>= <=\u2218 points_*-mono (later (\\lam p0 => (\n    \\let (fxb, fxnb) => p0\n    \\in absurd $ isProper $ filter-mono (filter-meet fxnb fxb) (eval {M})))) <=\u2218 Ld <=\u2218 bottom-univ\n  | (_, inP (_, inP (a, byRight (j, a<=<gj), idp), idp)) =>\n    meet-right <=\u2218 Join-cond {L} (later (a, a<=<gj)) {\\lam s => points_* (f ^-1 points^* s.1)} <=\u2218 Join-cond j\n}))"}
{"prompt": "['a : L.E', 'L : Locale', 'x : L.E', 'c : a --> x L.<= a --> pHat {L} P', 'P : \\\\Prop']<<<break>>>['\\\\func pHat \\\\hlevels  {this : Locale} (P : \\\\Prop) : E => Join {P} (\\\\lam (_ : P) => top)', '\\\\func \\\\infixr 5 --> \\\\hlevels  {this : Locale} (x y : E) : E => SJoin (\\\\lam (p0 : E) => p0 \u2227 x <= y)', '| \\\\infix 4 <= E E : \\\\Prop', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| nucleus-unit {x : E {L}} : x <= nucleus x', '\\\\func open \\\\hlevels  {this2 : Locale} (a : E) : Nucleus ((-->) a) => \\\\new Nucleus {\\n  | nucleus-meet => {?hidden}\\n  | nucleus-meet>= => {?hidden}\\n  | nucleus-<= => {?hidden}\\n  | nucleus-unit => {?hidden}\\n  | nucleus-join>= => {?hidden}\\n  | nucleus-join => {?hidden}\\n}', '\\\\lemma exponent \\\\hlevels  {this : Locale} {x y z : E} : x \u2227 y <= z <-> x <= y --> z ']<<<break>>>x L.\u2227 a L.<= pHat {L} P", "completion": "exponent.2 (nucleus-unit {open a} <=\u2218 c)"}
{"prompt": "['f : CoverMap Z X', 'X : CoverSpace', 'g : CoverMap Z Y', 'Z : CoverSpace', 'Y : CoverSpace']<<<break>>>['\\\\func precover \\\\hlevels  {Z : PrecoverSpace} {X Y : CoverSpace} (f : PrecoverMap Z X) (g : PrecoverMap Z Y) : PrecoverMap Z (X \u2a2f Y) {\\n  | func => \\\\lam (z : E {Dom {\\\\this}}) => (f.func z, g.func z)\\n} => \\\\new PrecoverMap {\\n  | func-cont => {?hidden}\\n  | func-cover => {?hidden}\\n}', '\\\\class PrecoverMap \\\\extends ContMap \\\\hlevels  {\\n  | func-cover {D : Set (Set (E {Cod}))} (isCauchy {Cod} D) : isCauchy {Dom} (\\\\lam (U : Set (E {Dom})) => TruncP (\\\\Sigma (V : Set (E {Cod})) (D V) (U = func ^-1 V)))\\n}', '| Product \\\\alias \\\\infixl 7 \u2a2f E E : E', '\\\\instance CoverSpaceHasProduct \\\\hlevels  : HasProduct CoverSpace {\\n  | Product => ProductCoverSpace\\n} => \\\\new HasProduct', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '| Dom : BaseSet']<<<break>>>PrecoverMap Z (X \u2a2f Y) {\n  | func => \\lam (z : E {Dom {\\this}}) => (f.func z, g.func z)\n}", "completion": "precover f g"}
{"prompt": "['y<=y0b+1 : y <= fromRat (y0b + fromInt (pos 1))', 'y0b : Rat', 'y : E']<<<break>>>['true', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '\\\\type \\\\infix 4 <= \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : \\\\Prop => \\\\Pi {b : Rat} -> y.U b -> x.U b', '| \\\\infixl 6 + E E : E', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func toContr \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '| E : \\\\Set', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\instance RatNormed \\\\hlevels  : NormedAbGroup Rat {\\n  | isOpen => PrecoverSpace.isOpen\\n  | isCauchy => PreuniformSpace.isCauchy\\n  | isUniform => isUniform\\n  | dist => PseudoNormedAbGroup.dist\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | negative => RatField.negative\\n  | norm => \\\\lam (a : E {\\\\this}) => Real.fromRat (abs {RatField} a)\\n} => \\\\new NormedAbGroup {\\n  | cauchy-open => {?hidden}\\n  | uniform-cauchy => {?hidden}\\n  | dist-refl => {?hidden}\\n  | dist-symm => {?hidden}\\n  | dist-triang => {?hidden}\\n  | dist-uniform => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | negative-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | norm_zro => {?hidden}\\n  | norm_negative => {?hidden}\\n  | norm_+ => {?hidden}\\n  | norm-dist => {?hidden}\\n  | isHausdorff => {?hidden}\\n  | isSeparatedCoverSpace => {?hidden}\\n  | dist-ext => {?hidden}\\n  | norm-ext => {?hidden}\\n}', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '| <=-transitive \\\\alias \\\\infixr 9 <=\u2218 {x y z : E} (x <= y) (y <= z) : x <= z', '| len : Nat', '\\\\lemma <=-rat \\\\plevels  \\\\hlevels  {a b : Rat} : a Preorder.<= b <-> fromRat a ExUpperReal.<= fromRat b ', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| vars : Array (E {M})', 'pos Nat', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '| zro : E', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\lemma solve<=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr p t1 t2)) (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) :\\n  interpret t1 <= interpret t2 ', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\func + (_ _ : Rat) : Rat \\n  | rat xNom (suc 0) xDenom/=0 reduced, rat yNom (suc 0) yDenom/=0 reduced =>\\n    makeRat (xNom + yNom) 1 (\\\\lam (p0 : 1 = 0) => (\\\\case p0 \\\\with {}))\\n  | rat xNom xDenom xDenom/=0 reduced, rat yNom yDenom yDenom/=0 reduced =>\\n  makeRat (xNom IntRing.* pos yDenom + yNom IntRing.* pos xDenom) (xDenom Nat.* yDenom)\\n    (productNonZero {xDenom} {yDenom} xDenom/=0 yDenom/=0)', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>y <= fromRat (y0b + fromInt (pos 1) + fromInt (pos 1))", "completion": "y<=y0b+1 <=\u2218 <=-rat.1 linarith"}
{"prompt": "['R : CRing', 'A : Matrix R.E n n', 'n : Nat', 'B : Matrix R.E m m', 'm : Nat']<<<break>>>['| \\\\infixl 6 + E E : E', \"\\\\func blockMatrix {R : AddPointed} {n m n' m' : Nat} (A : Matrix R.E n m) (B : Matrix R.E n' m') :\\n  Matrix R.E (n AddMonoid.+ n') (m AddMonoid.+ m') \\n=> makeMatrix {R.E} {n Nat.+ n'} {m AddMonoid.+ m'} ((++') {Array R.E (m Nat.+ m')}\\n  (map {Array R.E m} {Array R.E (m Nat.+ m')} (\\\\lam (_x : Array R.E m) => (++') {R.E} _x {m'} (replicate {R.E} m' R.zro)) A)\\n  {n'} (map {Array R.E m'} {Array R.E (m Nat.+ m')} ((++') {R.E} (replicate {R.E} m R.zro) {m'}) B))\", \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma determinant_block {R : CRing} {n m : Nat} (A : Matrix R.E n n) (B : Matrix R.E m m) :\\n  determinant {R} {n + m} (blockMatrix {R} {n} {n} {m} {m} A B) = determinant {R} {n} A R.* determinant {R} {m} B ', '\\\\lemma cfactor-right \\\\hlevels  {M : CMonoid} {x y : M.E} (_ : Inv {M} (x M.* y)) : Inv {M} y ', '\\\\class Inv \\\\extends LInv, RInv \\\\hlevels ', '\\\\instance MatrixRing \\\\hlevels  (R : Ring) (n : Nat) : Ring (Matrix R.E n n) {\\n  | zro => \\\\new Array (Array R.E n) n (\\\\lam (_ : Fin n) => \\\\new Array R.E n (\\\\lam (_ : Fin n) => R.zro))\\n  | + => \\\\lam (M : E) (N : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => at {at {M} i} j R.+ at {at {N} i} j)\\n  | * => (product)\\n  | negative => \\\\lam (M : E) => mkMatrix {R.E} {n} {n} (\\\\lam (i : Fin n) (j : Fin n) => R.negative (at {at {M} i} j))\\n  | ide => ide {R} {n}\\n  | natCoef => natCoefImpl\\n} => \\\\new Ring {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n}', '\\\\lemma cfactor-left \\\\hlevels  {M : CMonoid} {x y : M.E} (_ : Inv {M} (x M.* y)) : Inv {M} x ', '| \\\\infixl 7 * E E : E', '\\\\func determinant {R : CRing} {n : Nat} (M : Matrix R.E n n) : R.E => FinSum {R} {SymFin n}\\n  (\\\\lam (e : Sym n) => sign {R} {n} e R.* BigProd {R} (\\\\new Array R.E n (\\\\lam (j : Fin n) => at {at {M} (f {e} j)} j)))', \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '\\\\func \\\\infix 0 <-> \\\\plevels  \\\\hlevels  (P Q : \\\\Prop) : \\\\Prop => \\\\Sigma (P -> Q) (Q -> P)', '\\\\instance NatSemiring \\\\hlevels  : LinearlyOrderedCSemiring.Dec Nat {\\n  | zro => 0\\n  | + => (Nat.+)\\n  | * => (Nat.*)\\n  | ide => 1\\n  | natCoef => \\\\lam (n : Nat) => n\\n  | < => (NatOrder.<)\\n  | meet => meet\\n  | join => join\\n  | # => (#)\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case trichotomy {\\\\this} x y \\\\with {\\n    | less x<y => no {x = y} (\\\\lam (x=y : x = y) => StrictPoset.<-irreflexive\\n      {\\\\this} {y} (transport {E {\\\\this}} (\\\\lam (_x : E {\\\\this}) => _x StrictPoset.< y) {x} {y} x=y x<y))\\n    | equals x=y => yes {x = y} x=y\\n    | greater y<x => no {x = y} (\\\\lam (x=y : x = y) =>\\n      StrictPoset.<-irreflexive {\\\\this} {y} (transport {E {\\\\this}} ((StrictPoset.<) {\\\\this} y) {x} {y} x=y y<x))\\n  })\\n  | trichotomy => \\\\lam (n : E {\\\\this}) (m : E {\\\\this}) => (\\\\case n - m, idp {Int} {n - m} \\\\with {\\n    | pos 0, p => equals {n} {m} (triEquals {n} {m} p)\\n    | pos (suc d), p => greater {n} {m} (triGreater {n} {m} {d} p)\\n    | neg (suc d), p => less {n} {m} (triLess {n} {m} {d} p)\\n  })\\n} => \\\\new LinearlyOrderedCSemiring.Dec {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | zro_*-left => {?hidden}\\n  | zro_*-right => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <_+-left => {?hidden}\\n  | zro<ide => {?hidden}\\n  | <_*_positive-left => {?hidden}\\n  | <_*_negative-left => {?hidden}\\n  | *-comm => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | #-irreflexive => {?hidden}\\n  | #-symmetric => {?hidden}\\n  | #-comparison => {?hidden}\\n  | tightness => {?hidden}\\n  | nonEqualApart => {?hidden}\\n}', '| E : \\\\Set', '\\\\lemma product \\\\hlevels  {M : Monoid} (i j : Inv {M}) : Inv {M} (i.val M.* j.val) ', '\\\\lemma determinant-inv {R : CRing} {n : Nat} {M : Matrix R.E n n} : Inv {MatrixRing R n} M <-> Inv {R} (determinant {R} {n} M) ']<<<break>>>Inv {MatrixRing R (n + m)} (blockMatrix {R} {n} {n} {m} {m} A B) <-> (\\Sigma (Inv {MatrixRing R n} A) (Inv {MatrixRing R m} B))", "completion": "(\\lam s => (determinant-inv.2 $ cfactor-left $ transport Inv (determinant_block A B) $ determinant-inv.1 s,\n  determinant-inv.2 $ cfactor-right $ transport Inv (determinant_block A B) $ determinant-inv.1 s),\n  \\lam s => determinant-inv.2 $ transportInv Inv (determinant_block A B) $ product (determinant-inv.1 s.1) (determinant-inv.1 s.2))"}
{"prompt": "['a : \\\\Sigma V.E B.E', \"bs' : Array B.E\", 'B : BooleanRing', \"bs'r : IsReducedB {B} bs'\"]<<<break>>>['| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', 'suc Nat', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\class DArray {\\n  | len : Nat\\n  | A (Fin len) : \\\\Type\\n  | at (j : Fin len) : A j\\n}', \"\\\\func ++_++' {A2 : \\\\Type} {l1 : Array A2} {n : Nat} {l'2 : Array A2 n} : l1 ++ l'2 = (++') {A2} l1 {n} l'2 \\n  | {A}, {nil}, {n}, {l'} => idp {Array A} {nil ++ l'}\\n  | {A}, {:: {n} a l}, {n}, {l'} =>\\n    pmap {Array A} {Array A} ((::) a) {l ++ l'} {(++') {A} l {l'.len} l'} (++_++' {A} {l} {l'.len} {l'})\", \"\\\\func \\\\infixr 5 ++' {A1 : \\\\Type} (xs1 : Array A1) {n1 : Nat} (_ : Array A1 n1) : Array A1 (xs.len + n1) \\n  | {A}, nil, {n}, ys => ys\\n  | {A}, :: {n} a xs, {n}, ys => a :: (++') {A} xs {n} ys\", '\\\\func IsReducedB \\\\hlevels  {B : BooleanRing} (l : Array B.E) : \\\\Prop => \\\\Pi {i j : Fin l.len} -> i /= j -> l.at i B.* l.at j = B.zro', '\\\\func BigJoin \\\\hlevels  {this : BottomJoinSemilattice} (l : Array E) : E => Big {E} {E} (\u2228) bottom l', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func diff \\\\hlevels  {this : BooleanRing} (x y : E) : E => x + x * y', '\\\\func \\\\infixr 5 ++ {A1 : \\\\Type} (_ _ : Array A1) : Array A1 \\n  | {A}, nil, ys => ys\\n  | {A}, :: {n} a xs, ys => a :: xs ++ ys', '\\\\lemma add_IsReducedB \\\\hlevels  {B : BooleanRing} {b : B.E} {l : Array B.E} (_ : IsReducedB {B} l) :\\n  IsReducedB {B} (diff {B} b (BigJoin {B} l) :: map {B.E} {B.E} ((B.\u2227) b) l ++ map {B.E} {B.E} (\\\\lam (p0 : B.E) => diff {B} p0 b) l) ', '| E : \\\\Set', '| meet \\\\alias \\\\infixl 7 \u2227 E E : E']<<<break>>>IsReducedB {B}\n  (diff {B} a.2 (BigJoin {B} bs') :: (++') {B.E} (map {B.E} {B.E} ((B.\u2227) a.2) bs') {bs'.len} (map {B.E} {B.E} (\\lam (p0 : B.E) => diff {B} p0 a.2) bs'))", "completion": "transport (\\lam x => IsReducedB {B} (_ :: x)) (++_++' {_} {map ((\u2227) a.2) bs'} {_} {map (\\lam p0 => diff {B} p0 a.2) bs'})\n  (add_IsReducedB {B} bs'r)"}
{"prompt": "[]<<<break>>>['\\\\class Real \\\\extends InfReal, UpperReal \\\\hlevels  {\\n  | LU-focus (eps : Rat) (eps > zro) : TruncP (\\\\Sigma (a : Rat) (L a) (U (a AddMonoid.+ eps)))\\n}', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func fromRat \\\\hlevels  (x : Rat) : Real (\\\\lam (_x : Rat) => _x StrictPoset.< x) ((OrderedAddGroup.<) x) => \\\\new Real {\\n  | L-closed => {?hidden}\\n  | L-rounded => {?hidden}\\n  | L-inh => {?hidden}\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n  | LU-disjoint => {?hidden}\\n  | LU-located => {?hidden}\\n  | LU-focus-bound => {?hidden}\\n  | U-inh => {?hidden}\\n  | LU-focus => {?hidden}\\n}', '| E : \\\\Set', '\\\\func fromInt \\\\plevels  \\\\hlevels  (x : Int) : Rat => rat x 1 {?hidden} {?hidden}', '| \\\\infix 4 < E E : \\\\Prop', '\\\\type \\\\infix 4 < \\\\hlevels  {A : PreorderedAddGroup} (x y : A.E) : \\\\Prop => A.isPos (y - x)', 'pos Nat']<<<break>>>Real (\\lam (_x : Rat) => _x StrictPoset.< fromInt (pos 2)) ((OrderedAddGroup.<) (fromInt (pos 2)))", "completion": "fromRat (fromInt (pos 2))"}
{"prompt": "['x : E {Dom}', 'q : Rat', 'p : U {fromRat (finv delta) * norm {Dom} x} q', 'delta>0 : zro < delta', 'this : BoundedLinearMap', 'delta : Rat', 'q>0 : U {zro} q']<<<break>>>['\\\\lemma finv>0 {this : DiscreteOrderedField} {x : E} (_ : zro < x) : zro < finv x ', \"\\\\func pmap {A B : \\\\Type} (f : A -> B) {a a' : A} (p : a = a') : f a = f a' => path (\\\\lam (i : I) => f (p @ i))\", \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '| A : RatValue', '| <=-less {a1 a2 : E} (a1 < a2) : a1 <= a2', '| \\\\infixl 7 * E E : E', '| *-comm {x y : E} : x * y = y * x', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '\\\\lemma abs-ofPos \\\\hlevels  {this : LatticeAbGroup} {x : E} (_ : zro <= x) : abs x = x ', '\\\\instance ExUpperRealSemigroup \\\\hlevels  : CSemigroup ExUpperReal {\\n  | * => (ExUpperReal.*)\\n} => \\\\new CSemigroup {\\n  | *-assoc => {?hidden}\\n  | *-comm => {?hidden}\\n}', \"\\\\func \\\\infixr 9 *> {A : \\\\Type} {a a' a'' : A} (_ : a = a') (_ : a' = a'') : a = a'' \\n  | {A}, {a}, {a'}, {a''}, p, idp => p\", '\\\\infixl 7 * \\\\plevels  \\\\hlevels  (x y : ExUpperReal) : ExUpperReal \\n=> \\\\new ExUpperReal (\\\\lam (a : Rat) => TruncP (\\\\Sigma (b : Rat) (x.U b) (zro < b) (c : Rat) (y.U c) (zro < c) (b * c < a))) {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', '\\\\func fromRat \\\\plevels  \\\\hlevels  (x : Rat) : ExUpperReal ((<) x) => \\\\new ExUpperReal {\\n  | U-closed => {?hidden}\\n  | U-rounded => {?hidden}\\n}', \"\\\\func transport {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (p : a = a') (b : B a) : B a' => coe (\\\\lam (i : I) => B (p @ i)) b right\", '\\\\lemma <-rat \\\\plevels  \\\\hlevels  {x : ExUpperReal} {y : Rat} : x < fromRat y <-> x.U y ', '\\\\lemma finv_<-rotate-right \\\\plevels  \\\\hlevels  {a : Rat} (_ : zro StrictPoset.< a) {b c : ExUpperReal} (_ : fromRat (finv a) * b ExUpperRealAbMonoid.< c) :\\n  b ExUpperRealAbMonoid.< fromRat a * c ', '\\\\instance ExUpperRealAbMonoid \\\\hlevels  : BiorderedLatticeAbMonoid ExUpperReal {\\n  | < => (ExUpperRealAbMonoid.<)\\n  | <= => (ExUpperReal.<=)\\n  | meet => ExUpperReal.meet\\n  | join => ExUpperReal.join\\n  | zro => fromRat zro\\n  | + => (ExUpperReal.+)\\n} => \\\\new BiorderedLatticeAbMonoid {\\n  | <-irreflexive => {?hidden}\\n  | <-transitive => {?hidden}\\n  | <=-refl => {?hidden}\\n  | <=-transitive => {?hidden}\\n  | <=-antisymmetric => {?hidden}\\n  | <-transitive-right => {?hidden}\\n  | <-transitive-left => {?hidden}\\n  | <=-less => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | <_meet-univ => {?hidden}\\n  | <_join-univ => {?hidden}\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | <=_+ => {?hidden}\\n  | join_+-left => {?hidden}\\n  | +-comm => {?hidden}\\n  | meet_+-left => {?hidden}\\n}', '| norm E : ExUpperReal', '| \\\\infix 4 < E E : \\\\Prop', '\\\\func finv (_ : Rat) : Rat \\n  | rat (pos 0) denom denom/=0 reduced => rat (pos 0) 1 {?hidden} {?hidden}\\n  | rat (pos (suc n)) b b/=0 r => rat (pos b) (suc n) {?hidden} {?hidden}\\n  | rat (neg (suc n)) b b/=0 r => rat (neg b) (suc n) {?hidden} {?hidden}', '| zro : E', '\\\\lemma finv_<-rotate-left \\\\plevels  \\\\hlevels  {a : Rat} (_ : zro StrictPoset.< a) {b c : ExUpperReal} (_ : zro ExUpperRealAbMonoid.< c)\\n  (_ : b ExUpperRealAbMonoid.< fromRat a * c) : fromRat (finv a) * b ExUpperRealAbMonoid.< c ', '\\\\infixl 7 *q \\\\hlevels  {this : QModule} (q : Rat) (a : E) : E => ratNom q *i center.1', \"\\\\class ExUpperReal \\\\plevels  \\\\hlevels  {\\n  | U Rat : \\\\Prop\\n  | U-closed {q q' : Rat} (U q) (q < q') : U q'\\n  | U-rounded {q : Rat} (U q) : TruncP (\\\\Sigma (r : Rat) (U r) (r < q))\\n}\", \"\\\\func transportInv {A : \\\\Type} (B : A -> \\\\Type) {a a' : A} (_ : a = a') (_ : B a') : B a \\n  | {A}, B, {a}, {a'}, idp, b => b\", '| finv E : E', '\\\\lemma norm_*q \\\\hlevels  {this : SeparatedPreBanachSpace} {q : Rat} {x : E} : norm (q *q x) = norm {A} q * norm x ', '| U Rat : \\\\Prop', '\\\\func abs \\\\hlevels  {this : LatticeAbGroup} (x : E) : E => x \u2228 negative x', '| Dom : BaseSet']<<<break>>>U {norm {Dom} (finv q *q x)} delta", "completion": "<-rat.1 (transportInv (\\lam _x => _x < _)\n  (norm_*q *> pmap (\\lam _x => _x * _) (pmap fromRat $ abs-ofPos {RatField} $ <=-less $ finv>0 {RatField} q>0)) $ finv_<-rotate-left q>0 (<-rat.2 delta>0) $ transport ((<) _) *-comm $ finv_<-rotate-right delta>0 (<-rat.2 p))"}
{"prompt": "['f : GroupHom G H', 'p : IsIsomorphism {f}']<<<break>>>['\\\\func this_iso \\\\hlevels  {G H : Group} {f : GroupHom G H} (p : IsIsomorphism {f}) : Iso {SetCat} {G.E} {H.E} f.func \\n  => Inj+Surj->SetIso {G.E} {H.E} f.func p.1 p.2', '\\\\class Iso \\\\extends SplitMono \\\\plevels obj >= hom \\\\hlevels  {\\n  | f_hinv : f \u2218 hinv = id {C} cod\\n}', '| Cod : BaseSet', '| E : \\\\Set', '| func (E {Dom}) : E {Cod}', '\\\\instance SetCat \\\\hlevels  : Cat \\\\Set {\\n  | Hom => \\\\lam (X : Ob {\\\\this}) (Y : Ob {\\\\this}) => X -> Y\\n  | id => \\\\lam (o : Ob {\\\\this}) (x : o) => x\\n  | o => \\\\lam {X Y Z : Ob {\\\\this}} (g : Hom {\\\\this} Y Z) (f : Hom {\\\\this} X Y) (x : X) => g (f x)\\n} => \\\\new Cat {\\n  | id-left => {?hidden}\\n  | id-right => {?hidden}\\n  | o-assoc => {?hidden}\\n  | univalence => {?hidden}\\n}', '| Dom : BaseSet']<<<break>>>Iso {SetCat} {E {f.Dom}} {E {f.Cod}} f.func", "completion": "this_iso p"}
{"prompt": "[\"b' : Rat\", 'b : Rat']<<<break>>>['true', '\\\\func isSuc \\\\hlevels  {this : LinearData} (_ : Nat) : Bool \\n  | {this}, suc n => true\\n  | {this}, 0 => false', '| C : Semiring', '\\\\func \\\\infixl 2 or \\\\plevels  \\\\hlevels  (_ _ : Bool) : Bool \\n  | true, y => true\\n  | false, y => y', 'suc Nat', '| R : Semiring', '\\\\infixl 6 :+ (_ _ : RingTerm C V)', '\\\\data Bool \\\\plevels  \\\\hlevels  \\n  | false\\n  | true', \"\\\\instance RatField : DiscreteOrderedField Rat {\\n  | zro => rat (pos 0) 1 {?hidden} {?hidden}\\n  | + => (RatField.+)\\n  | * => (RatField.*)\\n  | negative => RatField.negative\\n  | ide => rat (pos 1) 1 {?hidden} {?hidden}\\n  | natCoef => \\\\lam (n : Nat) => rat (pos n) 1 {?hidden} {?hidden}\\n  | decideEq => \\\\lam (x : E {\\\\this}) (y : E {\\\\this}) => (\\\\case decideEq (ratNom x) (ratNom y), decideEq (ratDenom x) (ratDenom y) \\\\with {\\n    | yes p, yes q => yes {x = y} (ext {x} {y} p q)\\n    | no p, d => no {x = y} (\\\\lam (x=y : x = y) => p (pmap {Rat} {Int} ratNom {x} {y} x=y))\\n    | d, no q => no {x = y} (\\\\lam (x=y : x = y) => q (pmap {Rat} {Nat} ratDenom {x} {y} x=y))\\n  })\\n  | meet => meet\\n  | join => join\\n  | isPos => \\\\lam (x : E {\\\\this}) => isPos (ratNom x)\\n  | #0=>eitherPosOrNeg => \\\\lam {x : E {\\\\this}} (xInv : #0 {\\\\this} x) => (\\\\case x, xInv \\\\with {\\n    | rat n1 d1 d1/=0 r1, (rat n2 d2 d2/=0 r2, il, p) => #0=>eitherPosOrNeg {n1}\\n      (\\\\lam (n1=0 : n1 = zro) => (\\\\case inv {Rat} {makeRat zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        {makeRat' zro (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden})}\\n        (simp {zro} {d2 Nat.* d1} {productNonZero {d2} {d1} {?hidden} {?hidden}}) *> transport {Int}\\n        (\\\\lam (x : E) => makeRat x (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n        {n2 Semigroup.* zro} {zro} (zro_*-right {n2}) (transport {Int}\\n          (\\\\lam (x : E) => makeRat (n2 IntRing.* x) (d2 Nat.* d1) (productNonZero {d2} {d1} {?hidden} {?hidden}) = rat (pos 1) 1 {?hidden} {?hidden})\\n          {n1} {zro} n1=0 il) \\\\with {}))\\n  })\\n  | finv => RatField.finv\\n  | eitherZeroOrInv => \\\\lam (x : E {\\\\this}) => (\\\\case decideEq {\\\\this} x (zro {\\\\this}) \\\\with {\\n    | yes x=0 => byLeft {x = zro {\\\\this}} {Inv x} x=0\\n    | no x/=0 => byRight {x = zro {\\\\this}} {Inv x} (rmake {x} (DiscreteField.finv {\\\\this} x) (finv-right {\\\\this} {x} x/=0))\\n  })\\n} => \\\\new DiscreteOrderedField {\\n  | zro-left => {?hidden}\\n  | zro-right => {?hidden}\\n  | +-assoc => {?hidden}\\n  | +-comm => {?hidden}\\n  | *-assoc => {?hidden}\\n  | ldistr => {?hidden}\\n  | rdistr => {?hidden}\\n  | negative-left => {?hidden}\\n  | ide-left => {?hidden}\\n  | ide-right => {?hidden}\\n  | natCoefZero => {?hidden}\\n  | natCoefSuc => {?hidden}\\n  | zeroProduct => {?hidden}\\n  | meet-left => {?hidden}\\n  | meet-right => {?hidden}\\n  | meet-univ => {?hidden}\\n  | join-left => {?hidden}\\n  | join-right => {?hidden}\\n  | join-univ => {?hidden}\\n  | zro/>0 => {?hidden}\\n  | positive_+ => {?hidden}\\n  | ide>zro => {?hidden}\\n  | positive_* => {?hidden}\\n  | *-comm => {?hidden}\\n  | finv_zro => {?hidden}\\n  | finv-right => {?hidden}\\n}\", '\\\\func Cert \\\\hlevels  {this : LinearData} (n : Nat) : \\\\Set0 => Array Nat n', '\\\\func map {A B : \\\\Type} (f : A -> B) (as : Array A) : Array B as.len (\\\\lam (i : Fin as.len) => f (as.at i)) => \\\\new DArray', '\\\\func interpretEq \\\\hlevels  {this3 : LinearData} (_ : Equation) : \\\\Prop \\n  | {this}, (t1, Less, t2) => interpret t1 < interpret t2\\n  | {this}, (t1, LessOrEquals, t2) => interpret t1 <= interpret t2\\n  | {this}, (t1, Equals, t2) => interpret t1 = interpret t2', ':ide', '\\\\data Rat \\\\plevels  \\\\hlevels  \\n  | rat (nom : Int) (denom : Nat) (\\\\property (denom /= 0)) (\\\\property (gcd {NatEuclidean} (iabs nom) denom = 1))', '| at (j : Fin len) : A j', '\\\\lemma solve=Problem \\\\hlevels  {this : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}})))\\n  (_ : CorrectCert (toContr1 p t1 t2)) (_ : CorrectCert (toContr2 p t1 t2))\\n  (_ : DArray {p.len} (\\\\lam (j : Fin p.len) => interpretEq (p.at j))) : interpret t1 = interpret t2 ', '| E : \\\\Set', '\\\\data RingTerm (_ _ : \\\\Type) \\n  | coef C\\n  | var V\\n  | :zro\\n  | :ide\\n  | :negative (RingTerm C V)\\n  | \\\\infixl 6 :+ (_ _ : RingTerm C V)\\n  | \\\\infixl 7 :* (_ _ : RingTerm C V)', '\\\\class MonoidData \\\\hlevels  {\\n  | M : Monoid\\n  | vars : Array (E {M})\\n}', '| len : Nat', '\\\\data Fin \\\\plevels  \\\\hlevels  Nat \\\\with\\n  | suc n => zero\\n  | suc n => suc (Fin n)', '| M : Monoid', '\\\\func idp {A : \\\\Type} {a : A} : a = a => path (\\\\lam (_ : I) => a)', '\\\\data Nat \\\\plevels  \\\\hlevels  \\n  | zero\\n  | suc Nat', '\\\\lemma interpretNF_negate \\\\hlevels  {this : BaseRingData} (l : List (\\\\Sigma (List (Fin (len {vars {mData}}))) (E {C}))) :\\n  negative {R} (interpretRingNF l) = interpretRingNF (negate {C} {Fin (len {vars})} l) ', ':negative (RingTerm C V)', '| vars : Array (E {M})', '\\\\class LinearRatData \\\\extends LinearData, RatData \\\\hlevels ', '\\\\func hasNegative \\\\hlevels  {this1 : LinearData} (p1 : Problem) (_ : Cert p.len) : Bool \\n  | {this}, nil, nil => false\\n  | {this}, :: {n} e p, k :: c => isLess e.2 and isSuc k or hasNegative p c', '\\\\field mData : MonoidData {R} vars', '\\\\func Equation \\\\hlevels  {this : LinearData} : \\\\Set \\n  => \\\\Sigma (RingTerm (E {C}) (Fin (len {vars {mData}}))) Operation (RingTerm (E {C}) (Fin (len {vars {mData}})))', '\\\\func interpret \\\\hlevels  {this7 : AlgData} (_ : RingTerm (E {C}) (Fin (len {vars {mData}}))) : E {R} \\n  | {this}, coef c => func {alg} c\\n  | {this}, var x => at {vars} x\\n  | {this}, :zro => zro {R}\\n  | {this}, :ide => ide {R}\\n  | {this}, :negative t => pnegative (interpret t)\\n  | {this}, t :+ s => interpret t + interpret s\\n  | {this}, t :* s => interpret t * interpret s', '\\\\data Operation \\\\plevels  \\\\hlevels  \\n  | Less\\n  | LessOrEquals\\n  | Equals', 'var V', \"\\\\func \\\\infix 1 = {A : \\\\Type} (a a' : A) : \\\\Type => a = a'\", '\\\\func toContr2 \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t2, Less, t1) :: p', '\\\\func toContr1 \\\\hlevels  {this1 : LinearData} (p : Problem) (t1 t2 : RingTerm (E {C}) (Fin (len {vars {mData}}))) : Array Equation \\n  => (t1, Less, t2) :: p', '\\\\func interpretCert \\\\hlevels  {this : LinearData} (l : Array (RingTerm (E {C}) (Fin (len {vars {mData}})))) (c : Cert l.len) : E {R} \\n  => interpretRingNF (normalize (cert-toTerm l c))', '\\\\data List \\\\Type \\n  | nil\\n  | \\\\infixr 5 :: A (List A)']<<<break>>>interpret {\\new LinearRatData (b' :: b :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 2} 0 :+ (var {E} {Fin 2} 1 :+ :negative {E} {Fin 2} (var {E} {Fin 2} 0))) = interpret {\\new LinearRatData (b' :: b :: nil) {\n  | mData => \\new MonoidData {R {\\this}} (vars {\\this})\n  | interpretNF_negate => {?hidden}\n}} (var {E} {Fin 2} 1)", "completion": "solve=Problem {\\new LinearRatData {\n  | R => RatField\n  | vars => b' :: b :: nil\n}} nil (var 0 :+ (var 1 :+ :negative (var 0))) (var 1) (1 :: nil, 0, idp, idp {Bool} {true})\n  (1 :: nil, 0, idp, idp {Bool} {true}) nil"}
